{"version":3,"sources":["node_modules/swiper/swiper-bundle.min.js","node_modules/echarts/dist/echarts.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,yLAAyL,kBAAkB,aAAa,gBAAgB,YAAY,WAAW,KAAK,WAAW,+GAA+G,aAAa,oCAAoC,YAAY,mBAAmB,KAAK,mBAAmB,sEAAsE,SAAS,wBAAwB,cAAc,+EAA+E,gBAAgB,iBAAiB,mBAAmB,sCAAsC,mFAAmF,GAAG,OAAO,OAAO,8BAA8B,iCAAiC,gBAAgB,iBAAiB,aAAa,0BAA0B,YAAY,6BAA6B,SAAS,2BAA2B,YAAY,wBAAwB,OAAO,wBAAwB,0BAA0B,OAAO,kCAAkC,0BAA0B,iCAAiC,WAAW,4BAA4B,SAAS,uBAAuB,YAAY,WAAW,kFAAkF,aAAa,+CAA+C,gBAAgB,OAAO,sBAAsB,aAAa,WAAW,gFAAgF,UAAU,yBAAyB,uBAAuB,gBAAgB,mBAAmB,wBAAwB,YAAY,8BAA8B,iCAAiC,6BAA6B,OAAO,4BAA4B,WAAW,mBAAmB,kBAAkB,UAAU,wBAAwB,0BAA0B,uBAAuB,SAAS,mCAAmC,gEAAgE,kCAAkC,kDAAkD,aAAa,2CAA2C,gBAAgB,cAAc,iEAAiE,6CAA6C,KAAK,gBAAgB,8CAA8C,uBAAuB,OAAO,aAAa,4DAA4D,mCAAmC,qCAAqC,IAAI,2EAA2E,OAAO,SAAS,UAAU,kBAAkB,+CAA+C,aAAa,kBAAkB,oCAAoC,6BAA6B,wBAAwB,cAAc,4CAA4C,qBAAqB,oFAAoF,MAAM,kGAAkG,eAAe,4BAA4B,WAAW,aAAa,0CAA0C,8CAA8C,aAAa,mDAAmD,SAAS,KAAK,kBAAkB,QAAQ,cAAc,UAAU,8DAA8D,oGAAoG,SAAS,uDAAuD,eAAe,SAAS,iBAAiB,eAAe,IAAI,gGAAgG,WAAW,cAAc,mBAAmB,SAAS,8BAA8B,gDAAgD,KAAK,gBAAgB,wCAAwC,gBAAgB,qBAAqB,+BAA+B,sBAAsB,uBAAuB,eAAe,yCAAyC,YAAY,kMAAkM,yBAAyB,cAAc,YAAY,sBAAsB,6BAA6B,qBAAqB,gCAAgC,yCAAyC,WAAW,kBAAkB,SAAS,gBAAgB,2CAA2C,0BAA0B,2BAA2B,IAAI,yBAAyB,iBAAiB,WAAW,wCAAwC,SAAS,KAAK,iBAAiB,aAAa,oBAAoB,8CAA8C,IAAI,sBAAsB,2BAA2B,oBAAoB,IAAI,iCAAiC,MAAM,+BAA+B,QAAQ,wBAAwB,8CAA8C,IAAI,sBAAsB,2BAA2B,oBAAoB,IAAI,iCAAiC,MAAM,kCAAkC,QAAQ,qBAAqB,8CAA8C,IAAI,sBAAsB,2BAA2B,oBAAoB,IAAI,2BAA2B,6BAA6B,+BAA+B,YAAY,YAAY,wBAAwB,8CAA8C,IAAI,sBAAsB,2BAA2B,oBAAoB,IAAI,0BAA0B,uBAAuB,sBAAsB,GAAG,GAAG,oBAAoB,0FAA0F,YAAY,cAAc,uDAAuD,iEAAiE,YAAY,wBAAwB,YAAY,cAAc,gCAAgC,YAAY,uBAAuB,YAAY,cAAc,+BAA+B,YAAY,wBAAwB,YAAY,cAAc,kEAAkE,YAAY,eAAe,8CAA8C,IAAI,sBAAsB,gCAAgC,cAAc,eAAe,MAAM,iCAAiC,wDAAwD,kCAAkC,WAAW,qCAAqC,cAAc,8CAA8C,6CAA6C,mEAAmE,6BAA6B,cAAc,MAAM,cAAc,aAAa,WAAW,MAAM,WAAW,4CAA4C,mFAAmF,2BAA2B,4BAA4B,aAAa,WAAW,MAAM,WAAW,oCAAoC,uEAAuE,2BAA2B,6BAA6B,YAAY,gBAAgB,8CAA8C,IAAI,sBAAsB,gCAAgC,mEAAmE,2BAA2B,WAAW,wBAAwB,cAAc,MAAM,uBAAuB,gIAAgI,KAAK,MAAM,WAAW,2MAA2M,YAAY,oBAAoB,oDAAoD,IAAI,sBAAsB,qCAAqC,WAAW,wBAAwB,cAAc,MAAM,cAAc,kBAAkB,2BAA2B,kCAAkC,EAAE,wCAAwC,WAAW,iEAAiE,YAAY,2BAA2B,WAAW,8CAA8C,2DAA2D,QAAQ,wBAAwB,kBAAkB,MAAM,oBAAoB,wHAAwH,2BAA2B,YAAY,yBAAyB,kBAAkB,MAAM,oBAAoB,yHAAyH,4BAA4B,YAAY,mBAAmB,UAAU,mDAAmD,mBAAmB,kBAAkB,0LAA0L,OAAO,+BAA+B,YAAY,mBAAmB,YAAY,yBAAyB,uBAAuB,QAAQ,cAAc,0CAA0C,YAAY,uEAAuE,6CAA6C,QAAQ,cAAc,wBAAwB,YAAY,YAAY,kBAAkB,sCAAsC,iBAAiB,cAAc,kBAAkB,oDAAoD,YAAY,cAAc,yBAAyB,YAAY,kBAAkB,6DAA6D,YAAY,cAAc,2BAA2B,YAAY,gBAAgB,8BAA8B,2BAA2B,uBAAuB,iCAAiC,6DAA6D,qDAAqD,eAAe,WAAW,0BAA0B,SAAS,sBAAsB,sBAAsB,+BAA+B,2BAA2B,WAAW,0BAA0B,SAAS,SAAS,kBAAkB,gBAAgB,MAAM,QAAQ,6BAA6B,wBAAwB,UAAU,gBAAgB,0BAA0B,kBAAkB,sBAAsB,QAAQ,UAAU,2BAA2B,oBAAoB,mBAAmB,oBAAoB,mBAAmB,MAAM,+CAA+C,YAAY,cAAc,4BAA4B,6BAA6B,kBAAkB,aAAa,mCAAmC,mCAAmC,WAAW,+BAA+B,4BAA4B,YAAY,qBAAqB,cAAc,QAAQ,cAAc,4BAA4B,6BAA6B,0CAA0C,KAAK,iEAAiE,+BAA+B,WAAW,sDAAsD,mDAAmD,YAAY,kBAAkB,oMAAoM,qBAAqB,mBAAmB,mBAAmB,KAAK,qBAAqB,EAAE,2BAA2B,sCAAsC,YAAY,kBAAkB,kBAAkB,cAAc,sKAAsK,aAAa,qBAAqB,mBAAmB,mBAAmB,KAAK,yBAAyB,EAAE,+BAA+B,sCAAsC,YAAY,oBAAoB,iBAAiB,cAAc,uHAAuH,YAAY,qBAAqB,iBAAiB,cAAc,kCAAkC,EAAE,kDAAkD,YAAY,qBAAqB,WAAW,4DAA4D,kBAAkB,iBAAiB,cAAc,+CAA+C,WAAW,kBAAkB,YAAY,sBAAsB,iBAAiB,cAAc,oCAAoC,WAAW,qCAAqC,YAAY,oBAAoB,oBAAoB,mBAAmB,YAAY,cAAc,iEAAiE,cAAc,gBAAgB,yCAAyC,aAAa,kBAAkB,gBAAgB,oBAAoB,6CAA6C,oHAAoH,0BAA0B,0ZAA0Z,cAAc,0EAA0E,aAAa,8DAA8D,mBAAmB,MAAM,mDAAmD,2DAA2D,IAAI,MAAM,kDAAkD,mFAAmF,2BAA2B,SAAS,gBAAgB,oCAAoC,gDAAgD,sDAAsD,aAAa,GAAG,aAAa,wBAAwB,gBAAgB,OAAO,mQAAmQ,SAAS,IAAI,8BAA8B,YAAY,eAAe,MAAM,EAAE,iDAAiD,UAAU,SAAS,kCAAkC,MAAM,cAAc,wBAAwB,oBAAoB,oBAAoB,+EAA+E,kBAAkB,yDAAyD,sKAAsK,yTAAyT,OAAO,aAAa,wBAAwB,YAAY,OAAO,2PAA2P,MAAM,oCAAoC,aAAa,GAAG,OAAO,gCAAgC,WAAW,KAAK,QAAQ,yBAAyB,0EAA0E,qCAAqC,8DAA8D,EAAE,KAAK,iBAAiB,UAAU,8HAA8H,qBAAqB,UAAU,sIAAsI,IAAI,qBAAqB,iBAAiB,EAAE,kFAAkF,iBAAiB,iBAAiB,+BAA+B,qEAAqE,mCAAmC,GAAG,aAAa,mJAAmJ,+BAA+B,iBAAiB,WAAW,0CAA0C,yDAAyD,WAAW,6BAA6B,4BAA4B,wCAAwC,qCAAqC,cAAc,GAAG,oBAAoB,6CAA6C,eAAe,+BAA+B,IAAI,wBAAwB,sDAAsD,mBAAmB,QAAQ,aAAa,IAAI,aAAa,EAAE,EAAE,KAAK,iBAAiB,kBAAkB,qBAAqB,wBAAwB,cAAc,kEAAkE,oDAAoD,QAAQ,qCAAqC,kBAAkB,2bAA2b,uDAAuD,oIAAoI,8HAA8H,mCAAmC,QAAQ,qFAAqF,oKAAoK,SAAS,oIAAoI,sDAAsD,iFAAiF,0BAA0B,cAAc,iFAAiF,qDAAqD,0CAA0C,qKAAqK,gEAAgE,oEAAoE,wCAAwC,yBAAyB,qEAAqE,iIAAiI,oGAAoG,yIAAyI,8FAA8F,0BAA0B,gDAAgD,qFAAqF,MAAM,2PAA2P,wKAAwK,uBAAuB,+bAA+b,2BAA2B,4GAA4G,6BAA6B,inBAAinB,qGAAqG,0MAA0M,oMAAoM,qEAAqE,qBAAqB,4DAA4D,gFAAgF,iEAAiE,cAAc,sHAAsH,kNAAkN,0GAA0G,iCAAiC,mKAAmK,+BAA+B,4JAA4J,0IAA0I,4DAA4D,gHAAgH,uBAAuB,0BAA0B,sFAAsF,oIAAoI,kBAAkB,kEAAkE,iEAAiE,UAAU,qEAAqE,oMAAoM,wMAAwM,0BAA0B,cAAc,WAAW,iBAAiB,IAAI,MAAM,kFAAkF,yCAAyC,YAAY,mBAAmB,oGAAoG,wEAAwE,6CAA6C,wDAAwD,wKAAwK,kHAAkH,8CAA8C,mCAAmC,GAAG,MAAM,yKAAyK,mCAAmC,uEAAuE,wDAAwD,6GAA6G,KAAK,uCAAuC,WAAW,8CAA8C,kDAAkD,oGAAoG,+DAA+D,qBAAqB,sDAAsD,6JAA6J,KAAK,uDAAuD,gOAAgO,aAAa,6BAA6B,0BAA0B,iCAAiC,uDAAuD,4aAA4a,cAAc,WAAW,8JAA8J,aAAa,0CAA0C,+NAA+N,wCAAwC,4IAA4I,SAAS,cAAc,OAAO,6iEAA6iE,IAAI,SAAS,sBAAsB,WAAW,uDAAuD,mBAAmB,wBAAwB,GAAG,wBAAwB,iBAAiB,EAAE,WAAW,uDAAuD,8BAA8B,mDAAmD,gBAAgB,iCAAiC,IAAI,gBAAgB,mBAAmB,WAAW,iCAAiC,yBAAyB,yCAAyC,2EAA2E,KAAK,sBAAsB,WAAW,iCAAiC,aAAa,qDAAqD,8CAA8C,IAAI,sBAAsB,aAAa,sCAAsC,qBAAqB,WAAW,iCAAiC,yBAAyB,uEAAuE,oBAAoB,WAAW,kCAAkC,sCAAsC,gDAAgD,mBAAmB,WAAW,4DAA4D,qGAAqG,kFAAkF,GAAG,QAAQ,iBAAiB,iBAAiB,+BAA+B,8CAA8C,IAAI,sBAAsB,yIAAyI,sCAAsC,8BAA8B,6FAA6F,yBAAyB,sFAAsF,aAAa,GAAG,MAAM,SAAS,sBAAsB,uBAAuB,4aAA4a,2CAA2C,GAAG,yBAAyB,uPAAuP,gBAAgB,iCAAiC,2BAA2B,uDAAuD,0BAA0B,sDAAsD,4EAA4E,eAAe,QAAQ,yGAAyG,2BAA2B,SAAS,+BAA+B,sPAAsP,0EAA0E,IAAI,MAAM,IAAI,cAAc,wBAAwB,+BAA+B,sDAAsD,4LAA4L,8DAA8D,sGAAsG,EAAE,wIAAwI,4FAA4F,8BAA8B,6BAA6B,wFAAwF,gJAAgJ,0BAA0B,oSAAoS,+BAA+B,KAAK,2BAA2B,+BAA+B,KAAK,uSAAuS,kCAAkC,KAAK,+BAA+B,mCAAmC,gGAAgG,6JAA6J,iYAAiY,wGAAwG,wCAAwC,6CAA6C,wCAAwC,SAAS,yCAAyC,4JAA4J,wCAAwC,SAAS,yCAAyC,qBAAqB,KAAK,aAAa,YAAY,OAAO,aAAa,yEAAyE,IAAI,sBAAsB,KAAK,aAAa,YAAY,OAAO,aAAa,uEAAuE,qFAAqF,kFAAkF,kBAAkB,mBAAmB,mBAAmB,mBAAmB,oBAAoB,6CAA6C,SAAS,uBAAuB,wCAAwC,GAAG,8BAA8B,qBAAqB,0BAA0B,GAAG,+BAA+B,SAAS,0BAA0B,wCAAwC,2BAA2B,gBAAgB,yBAAyB,UAAU,4BAA4B,UAAU,IAAI,KAAK,mDAAmD,wPAAwP,8BAA8B,sBAAsB,wMAAwM,UAAU,GAAG,aAAa,oCAAoC,MAAM,sBAAsB,2BAA2B,0BAA0B,2CAA2C,QAAQ,WAAW,uBAAuB,wBAAwB,UAAU,qCAAqC,+BAA+B,0BAA0B,WAAW,+EAA+E,kCAAkC,wCAAwC,kDAAkD,iBAAiB,wDAAwD,SAAS,yFAAyF,YAAY,WAAW,MAAM,8GAA8G,4DAA4D,wDAAwD,oJAAoJ,kBAAkB,oCAAoC,4BAA4B,WAAW,eAAe,0BAA0B,mCAAmC,kGAAkG,oEAAoE,iCAAiC,8OAA8O,gCAAgC,+GAA+G,+kBAA+kB,mEAAmE,6DAA6D,mEAAmE,0yBAA0yB,+BAA+B,8IAA8I,eAAe,YAAY,WAAW,qGAAqG,gDAAgD,kCAAkC,KAAK,uCAAuC,uCAAuC,sCAAsC,qEAAqE,KAAK,sDAAsD,6JAA6J,sDAAsD,gCAAgC,sEAAsE,iBAAiB,kBAAkB,6BAA6B,mEAAmE,2PAA2P,YAAY,yBAAyB,4CAA4C,oEAAoE,oCAAoC,sBAAsB,gBAAgB,sBAAsB,4BAA4B,yFAAyF,qSAAqS,wCAAwC,+FAA+F,yBAAyB,wBAAwB,yBAAyB,6CAA6C,iCAAiC,0FAA0F,oCAAoC,0DAA0D,4CAA4C,wDAAwD,yBAAyB,0CAA0C,oCAAoC,6CAA6C,sCAAsC,SAAS,iVAAiV,2UAA2U,0LAA0L,aAAa,4BAA4B,WAAW,yEAAyE,+BAA+B,mBAAmB,wDAAwD,eAAe,mCAAmC,QAAQ,4EAA4E,+DAA+D,wHAAwH,6BAA6B,mBAAmB,wDAAwD,8BAA8B,mBAAmB,QAAQ,0EAA0E,6DAA6D,mHAAmH,QAAQ,0BAA0B,iOAAiO,uBAAuB,qBAAqB,oHAAoH,IAAI,eAAe,WAAW,4GAA4G,0DAA0D,4FAA4F,iGAAiG,cAAc,yDAAyD,WAAW,qDAAqD,yBAAyB,iEAAiE,6EAA6E,yQAAyQ,cAAc,8BAA8B,8EAA8E,oCAAoC,4CAA4C,qCAAqC,SAAS,8aAA8a,qTAAqT,iLAAiL,+BAA+B,uEAAuE,eAAe,6DAA6D,2BAA2B,qDAAqD,4FAA4F,WAAW,mCAAmC,qDAAqD,wCAAwC,2BAA2B,qDAAqD,iFAAiF,WAAW,mCAAmC,qDAAqD,cAAc,kDAAkD,2DAA2D,YAAY,yCAAyC,qDAAqD,gBAAgB,0EAA0E,4BAA4B,iGAAiG,kCAAkC,wEAAwE,6JAA6J,qBAAqB,oBAAoB,wDAAwD,KAAK,sBAAsB,uDAAuD,8EAA8E,gCAAgC,4HAA4H,WAAW,sBAAsB,yRAAyR,aAAa,iLAAiL,aAAa,iBAAiB,mBAAmB,OAAO,sBAAsB,2CAA2C,gEAAgE,mCAAmC,6BAA6B,iDAAiD,yBAAyB,YAAY,IAAI,MAAM,6EAA6E,YAAY,gCAAgC,uOAAuO,cAAc,sBAAsB,WAAW,kHAAkH,GAAG,YAAY,WAAW,qEAAqE,qBAAqB,KAAK,sEAAsE,oBAAoB,WAAW,wBAAwB,sHAAsH,wCAAwC,6BAA6B,yGAAyG,uBAAuB,iGAAiG,wDAAwD,wBAAwB,gDAAgD,iJAAiJ,aAAa,0BAA0B,WAAW,sGAAsG,WAAW,yJAAyJ,4BAA4B,WAAW,+FAA+F,eAAe,wBAAwB,qCAAqC,wEAAwE,WAAW,0BAA0B,iBAAiB,kEAAkE,0BAA0B,qDAAqD,wBAAwB,UAAU,qCAAqC,YAAY,WAAW,2BAA2B,aAAa,kBAAkB,oFAAoF,wBAAwB,qDAAqD,kFAAkF,sBAAsB,0BAA0B,8BAA8B,KAAK,+BAA+B,KAAK,MAAM,qBAAqB,wBAAwB,qCAAqC,YAAY,WAAW,0BAA0B,mBAAmB,iBAAiB,YAAY,WAAW,oBAAoB,6HAA6H,yBAAyB,qDAAqD,kFAAkF,UAAU,qCAAqC,YAAY,WAAW,6DAA6D,gBAAgB,0EAA0E,4HAA4H,4BAA4B,iBAAiB,qBAAqB,eAAe,qBAAqB,SAAS,wBAAwB,wFAAwF,8HAA8H,iBAAiB,gKAAgK,KAAK,YAAY,2EAA2E,uBAAuB,wGAAwG,qBAAqB,gJAAgJ,2NAA2N,4RAA4R,yBAAyB,qGAAqG,yKAAyK,KAAK,YAAY,6EAA6E,uBAAuB,mMAAmM,oOAAoO,8OAA8O,cAAc,yBAAyB,gHAAgH,uCAAuC,yBAAyB,+BAA+B,yBAAyB,iHAAiH,WAAW,uHAAuH,GAAG,sEAAsE,2SAA2S,8FAA8F,6CAA6C,qHAAqH,0KAA0K,2BAA2B,UAAU,MAAM,2CAA2C,2CAA2C,8BAA8B,OAAO,+BAA+B,OAAO,iBAAiB,GAAG,sBAAsB,iDAAiD,GAAG,YAAY,WAAW,MAAM,qBAAqB,6BAA6B,kBAAkB,gBAAgB,yBAAyB,wJAAwJ,qRAAqR,UAAU,sBAAsB,qEAAqE,2UAA2U,mCAAmC,oDAAoD,0BAA0B,kCAAkC,qDAAqD,SAAS,gCAAgC,YAAY,aAAa,OAAO,sIAAsI,0BAA0B,WAAW,aAAa,kLAAkL,iCAAiC,YAAY,wBAAwB,MAAM,wBAAwB,+HAA+H,KAAK,cAAc,aAAa,kDAAkD,IAAI,sBAAsB,yFAAyF,QAAQ,uBAAuB,WAAW,0BAA0B,sBAAsB,oCAAoC,0DAA0D,8CAA8C,mBAAmB,aAAa,6CAA6C,uCAAuC,sCAAsC,kBAAkB,WAAW,0EAA0E,WAAW,GAAG,GAAG,UAAU,IAAI,4BAA4B,6BAA6B,8BAA8B,yEAAyE,uBAAuB,2DAA2D,qBAAqB,WAAW,eAAe,SAAS,2BAA2B,UAAU,IAAI,KAAK,EAAE,iBAAiB,KAAK,UAAU,gJAAgJ,qBAAqB,8CAA8C,qIAAqI,wCAAwC,uBAAuB,sCAAsC,wlBAAwlB,0CAA0C,uBAAuB,8BAA8B,oGAAoG,uWAAuW,+DAA+D,+CAA+C,gCAAgC,8DAA8D,wBAAwB,yCAAyC,WAAW,gCAAgC,oDAAoD,yFAAyF,GAAG,yCAAyC,+BAA+B,WAAW,kDAAkD,yEAAyE,aAAa,gCAAgC,WAAW,wDAAwD,2BAA2B,0BAA0B,GAAG,mCAAmC,6EAA6E,qBAAqB,uCAAuC,WAAW,0DAA0D,cAAc,KAAK,0DAA0D,mBAAmB,WAAW,yBAAyB,SAAS,qBAAqB,WAAW,oBAAoB,4BAA4B,8ZAA8Z,aAAa,0GAA0G,iEAAiE,iCAAiC,mBAAmB,gCAAgC,iRAAiR,kDAAkD,8CAA8C,mBAAmB,WAAW,sfAAsf,yBAAyB,sCAAsC,0DAA0D,8aAA8a,SAAS,yEAAyE,IAAI,UAAU,UAAU,IAAI,YAAY,WAAW,yBAAyB,8BAA8B,OAAO,6BAA6B,4CAA4C,EAAE,8DAA8D,yBAAyB,mBAAmB,gDAAgD,0BAA0B,6BAA6B,SAAS,sCAAsC,UAAU,EAAE,8BAA8B,UAAU,yCAAyC,GAAG,oCAAoC,uCAAuC,uBAAuB,GAAG,gBAAgB,OAAO,mBAAmB,yNAAyN,sBAAsB,6BAA6B,2HAA2H,uGAAuG,aAAa,yGAAyG,gBAAgB,6CAA6C,kGAAkG,kFAAkF,uCAAuC,iBAAiB,KAAK,kBAAkB,SAAS,GAAG,mDAAmD,cAAc,yDAAyD,iBAAiB,KAAK,yGAAyG,YAAY,WAAW,2EAA2E,uBAAuB,+BAA+B,yBAAyB,WAAW,wBAAwB,gCAAgC,4DAA4D,2BAA2B,8BAA8B,yDAAyD,uIAAuI,gHAAgH,yBAAyB,WAAW,gDAAgD,WAAW,uCAAuC,8BAA8B,qBAAqB,0BAA0B,qCAAqC,qBAAqB,YAAY,WAAW,0CAA0C,wBAAwB,iCAAiC,2BAA2B,2BAA2B,oCAAoC,+CAA+C,4EAA4E,qBAAqB,oCAAoC,yBAAyB,WAAW,YAAY,oBAAoB,yCAAyC,KAAK,yHAAyH,gHAAgH,qCAAqC,4BAA4B,WAAW,+DAA+D,uCAAuC,IAAI,uBAAuB,SAAS,+HAA+H,mBAAmB,QAAQ,YAAY,IAAI,2CAA2C,EAAE,EAAE,KAAK,uBAAuB,6BAA6B,6DAA6D,OAAO,wBAAwB,+EAA+E,0BAA0B,+CAA+C,IAAI,mBAAmB,4CAA4C,qCAAqC,uHAAuH,2EAA2E,2EAA2E,sMAAsM,yDAAyD,SAAS,mHAAmH,oDAAoD,iCAAiC,8GAA8G,WAAW,MAAM,WAAW,uCAAuC,+BAA+B,MAAM,aAAa,+SAA+S,mBAAmB,iBAAiB,iFAAiF,oBAAoB,iBAAiB,mFAAmF,IAAI,wBAAwB,UAAU,4CAA4C,mBAAmB,QAAQ,YAAY,WAAW,IAAI,EAAE,KAAK,iBAAiB,+CAA+C,qBAAqB,4CAA4C,OAAO,oFAAoF,iFAAiF,+BAA+B,OAAO,6BAA6B,yBAAyB,kCAAkC,0JAA0J,wBAAwB,uBAAuB,oBAAoB,2ZAA2Z,mCAAmC,6BAA6B,qBAAqB,6BAA6B,qBAAqB,oBAAoB,qCAAqC,qCAAqC,YAAY,iKAAiK,qCAAqC,+CAA+C,sCAAsC,qDAAqD,cAAc,KAAK,qDAAqD,YAAY,mEAAmE,kBAAkB,iBAAiB,uCAAuC,iNAAiN,OAAO,kDAAkD,wGAAwG,OAAO,mEAAmE,iEAAiE,gRAAgR,+DAA+D,qCAAqC,wBAAwB,2CAA2C,yEAAyE,yEAAyE,gBAAgB,kFAAkF,6CAA6C,KAAK,0DAA0D,6FAA6F,QAAQ,0JAA0J,KAAK,OAAO,wDAAwD,kCAAkC,uBAAuB,oCAAoC,mLAAmL,+DAA+D,2BAA2B,iBAAiB,weAAwe,2BAA2B,iCAAiC,kBAAkB,sDAAsD,iEAAiE,SAAS,mBAAmB,uBAAuB,qFAAqF,eAAe,iCAAiC,YAAY,uPAAuP,oBAAoB,uBAAuB,kFAAkF,eAAe,kCAAkC,YAAY,uJAAuJ,IAAI,kBAAkB,iCAAiC,mBAAmB,2CAA2C,uUAAuU,yBAAyB,WAAW,gEAAgE,yBAAyB,WAAW,0DAA0D,iBAAiB,qCAAqC,icAAic,kDAAkD,GAAG,oBAAoB,kDAAkD,iNAAiN,IAAI,kBAAkB,yCAAyC,yEAAyE,iMAAiM,oUAAoU,iCAAiC,iyBAAiyB,uBAAuB,+TAA+T,GAAG,KAAK,0BAA0B,qDAAqD,gCAAgC,KAAK,mDAAmD,sDAAsD,+BAA+B,KAAK,4DAA4D,4EAA4E,uMAAuM,wMAAwM,qBAAqB,qJAAqJ,wCAAwC,wKAAwK,MAAM,0GAA0G,sBAAsB,mJAAmJ,iNAAiN,mBAAmB,iCAAiC,yEAAyE,0GAA0G,uBAAuB,sGAAsG,IAAI,yIAAyI,2EAA2E,gaAAga,iBAAiB,iCAAiC,SAAS,cAAc,ihBAAihB,mBAAmB,8CAA8C,gDAAgD,mBAAmB,cAAc,IAAI,oBAAoB,iCAAiC,yEAAyE,uBAAuB,iNAAiN,IAAI,wBAAwB,WAAW,0CAA0C,kIAAkI,6UAA6U,uCAAuC,SAAS,2BAA2B,WAAW,yEAAyE,uBAAuB,WAAW,0CAA0C,sCAAsC,yCAAyC,kGAAkG,6OAA6O,+CAA+C,oGAAoG,gCAAgC,6LAA6L,6BAA6B,gGAAgG,oIAAoI,6DAA6D,oFAAoF,yBAAyB,iFAAiF,2bAA2b,wBAAwB,4DAA4D,iLAAiL,uBAAuB,qEAAqE,mNAAmN,qCAAqC,0EAA0E,4BAA4B,WAAW,0BAA0B,qJAAqJ,sBAAsB,gDAAgD,uBAAuB,qUAAqU,6BAA6B,WAAW,0BAA0B,qJAAqJ,sBAAsB,gDAAgD,uBAAuB,uVAAuV,iBAAiB,WAAW,0BAA0B,yDAAyD,yGAAyG,+CAA+C,6FAA6F,oCAAoC,oCAAoC,oBAAoB,mCAAmC,IAAI,2BAA2B,2NAA2N,yLAAyL,8BAA8B,qBAAqB,yDAAyD,KAAK,8BAA8B,4DAA4D,yBAAyB,wDAAwD,yKAAyK,6BAA6B,yBAAyB,iBAAiB,oSAAoS,6BAA6B,GAAG,GAAG,2BAA2B,kCAAkC,4KAA4K,qEAAqE,6BAA6B,IAAI,KAAK,sCAAsC,qCAAqC,gHAAgH,kDAAkD,4BAA4B,4DAA4D,8DAA8D,iFAAiF,qEAAqE,kcAAkc,6BAA6B,4DAA4D,gBAAgB,+EAA+E,kEAAkE,oYAAoY,0BAA0B,uEAAuE,gBAAgB,qDAAqD,0FAA0F,8CAA8C,+PAA+P,0BAA0B,oDAAoD,+PAA+P,yBAAyB,uDAAuD,iFAAiF,yTAAyT,yCAAyC,uCAAuC,0RAA0R,kNAAkN,mNAAmN,4gCAA4gC,uBAAuB,mDAAmD,sCAAsC,qEAAqE,4BAA4B,8DAA8D,oFAAoF,oBAAoB,0BAA0B,yCAAyC,wTAAwT,4BAA4B,gCAAgC,mQAAmQ,oBAAoB,gBAAgB,qCAAqC,gBAAgB,0FAA0F,mqCAAmqC,gBAAgB,gDAAgD,ijBAAijB,4BAA4B,0DAA0D,6JAA6J,2BAA2B,yFAAyF,4BAA4B,0FAA0F,mBAAmB,gCAAgC,eAAe,aAAa,8FAA8F,sBAAsB,wBAAwB,sBAAsB,2BAA2B,2iBAA2iB,oBAAoB,oBAAoB,cAAc,gBAAgB,kBAAkB,8FAA8F,sBAAsB,wBAAwB,sBAAsB,2BAA2B,mgBAAmgB,KAAK,0BAA0B,mBAAmB,2BAA2B,oCAAoC,6NAA6N,mIAAmI,WAAW,2BAA2B,0HAA0H,yCAAyC,6CAA6C,wOAAwO,WAAW,4FAA4F,gKAAgK,wCAAwC,6CAA6C,wGAAwG,iCAAiC,KAAK,kGAAkG,kCAAkC,8EAA8E,qCAAqC,IAAI,iBAAiB,0HAA0H,cAAc,MAAM,oFAAoF,sBAAsB,SAAS,cAAc,2DAA2D,oKAAoK,0DAA0D,sBAAsB,GAAG,wBAAwB,MAAM,iCAAiC,2BAA2B,wEAAwE,8GAA8G,IAAI,iCAAiC,YAAY,IAAI,iCAAiC,KAAK,uCAAuC,qCAAqC,uCAAuC,sCAAsC,8BAA8B,iBAAiB,oBAAoB,mLAAmL,8CAA8C,8GAA8G,WAAW,MAAM,WAAW,uCAAuC,+BAA+B,MAAM,qKAAqK,KAAK,2BAA2B,8BAA8B,oBAAoB,MAAM,wBAAwB,UAAU,gFAAgF,qGAAqG,MAAM,oCAAoC,WAAW,mJAAmJ,4BAA4B,sDAAsD,cAAc,8CAA8C,2ZAA2Z,gCAAgC,WAAW,yCAAyC,iCAAiC,6BAA6B,oDAAoD,cAAc,oFAAoF,qBAAqB,0CAA0C,oFAAoF,IAAI,4BAA4B,WAAW,yCAAyC,kCAAkC,KAAK,4BAA4B,mBAAmB,6CAA6C,iDAAiD,GAAG,6BAA6B,gCAAgC,gCAAgC,iCAAiC,yBAAyB,0BAA0B,oCAAoC,2CAA2C,6BAA6B,mCAAmC,0BAA0B,gCAAgC,uBAAuB,wBAAwB,yBAAyB,+BAA+B,uBAAuB,oCAAoC,sBAAsB,oCAAoC,wBAAwB,2BAA2B,mBAAmB,kBAAkB,gdAAgd,oBAAoB,2BAA2B,qCAAqC,6BAA6B,WAAW,iCAAiC,2CAA2C,6PAA6P,6BAA6B,2BAA2B,uIAAuI,WAAW,mJAAmJ,EAAE,OAAO,EAAE,iBAAiB,GAAG,iBAAiB,2BAA2B,gCAAgC,YAAY,gKAAgK,sFAAsF,6QAA6Q,WAAW,uDAAuD,8sBAA8sB,oBAAoB,eAAe,ydAAyd,KAAK,gBAAgB,iBAAiB,qBAAqB,gHAAgH,gBAAgB,iPAAiP,oBAAoB,UAAU,oGAAoG,+BAA+B,WAAW,gHAAgH,2BAA2B,uFAAuF,aAAa,cAAc,OAAO,yBAAyB,0BAA0B,iBAAiB,oDAAoD,MAAM,gDAAgD,0DAA0D,oCAAoC,sBAAsB,uEAAuE,QAAQ,8BAA8B,QAAQ,WAAW,qBAAqB,uHAAuH,+BAA+B,WAAW,mCAAmC,IAAI,MAAM,qBAAqB,sFAAsF,gBAAgB,kBAAkB,uBAAuB,KAAK,uBAAuB,iBAAiB,qBAAqB,sCAAsC,qDAAqD,mFAAmF,qBAAqB,cAAc,oBAAoB,uBAAuB,qPAAqP,KAAK,+EAA+E,yCAAyC,iBAAiB,uBAAuB,oFAAoF,gCAAgC,sCAAsC,mCAAmC,IAAI,MAAM,qBAAqB,iGAAiG,gBAAgB,+CAA+C,wFAAwF,oBAAoB,UAAU,+FAA+F,KAAK,eAAe,kEAAkE,8JAA8J,MAAM,4nBAA4nB,KAAK,kBAAkB,WAAW,+HAA+H,iBAAiB,WAAW,8LAA8L,mBAAmB,WAAW,0WAA0W,+BAA+B,iBAAiB,+JAA+J,6BAA6B,WAAW,+SAA+S,KAAK,wBAAwB,8BAA8B,WAAW,MAAM,+CAA+C,4CAA4C,QAAQ,4BAA4B,mHAAmH,OAAO,UAAU,mDAAmD,2BAA2B,qCAAqC,qDAAqD,SAAS,4BAA4B,wBAAwB,oBAAoB,sDAAsD,WAAW,sBAAsB,KAAK,KAAK,wBAAwB,6LAA6L,+HAA+H,cAAc,8GAA8G,YAAY,WAAW,MAAM,kBAAkB,sDAAsD,+BAA+B,+BAA+B,yDAAyD,iIAAiI,gGAAgG,8EAA8E,8JAA8J,gSAAgS,UAAU,iLAAiL,8IAA8I,KAAK,mKAAmK,sGAAsG,qCAAqC,yHAAyH,2BAA2B,mBAAmB,sPAAsP,KAAK,wBAAwB,+CAA+C,WAAW,MAAM,8BAA8B,8EAA8E,+CAA+C,uIAAuI,4LAA4L,6TAA6T,uFAAuF,2BAA2B,qDAAqD,wLAAwL,SAAS,kCAAkC,wBAAwB,oBAAoB,sDAAsD,WAAW,sBAAsB,KAAK,KAAK,wBAAwB,+LAA+L,IAAI,MAAM,oHAAoH,yEAAyE,oDAAoD,gJAAgJ,+FAA+F,8EAA8E,8JAA8J,sRAAsR,2BAA2B,8JAA8J,KAAK,gBAAgB,6BAA6B,iCAAiC,wBAAwB,oBAAoB,yFAAyF,8CAA8C,4BAA4B,8CAA8C,2CAA2C,WAAW,uEAAuE,oJAAoJ,yBAAyB,6BAA6B,MAAM,sCAAsC,wEAAwE,MAAM,mGAAmG,oBAAoB,8HAA8H,4JAA4J,wCAAwC,eAAe,oBAAoB,6BAA6B,MAAM,6IAA6I,iCAAiC,wBAAwB,kBAAkB,8HAA8H,gLAAgL,iGAAiG,qDAAqD,sMAAsM,gDAAgD,4OAA4O,IAAI,0FAA0F,iBAAiB,IAAI,8CAA8C,UAAU,0BAA0B,YAAY,qIAAqI,mBAAmB,QAAQ,YAAY,qQAAqQ,EAAE,KAAK,iBAAiB,0HAA0H,qBAAqB,uFAAuF,EAAE,0BAA0B,YAAY,iJAAiJ,mBAAmB,QAAQ,eAAe,IAAI,EAAE,KAAK,iBAAiB,0CAA0C,oBAAoB,sBAAsB,sBAAsB,sBAAsB,qBAAqB,uBAAuB,qBAAqB,6CAA6C,4UAA4U,EAAE,0BAA0B,YAAY,uPAAuP,SAAS,iCAAiC,SAAS,icAAic,mBAAmB,QAAQ,cAAc,qBAAqB,IAAI,EAAE,KAAK,iBAAiB,gEAAgE,+BAA+B,6DAA6D,6BAA6B,qCAAqC,gCAAgC,6DAA6D,kCAAkC,6DAA6D,qBAAqB,uBAAuB,qBAAqB,gUAAgU,EAAE,yBAAyB,WAAW,mIAAmI,mBAAmB,QAAQ,aAAa,2CAA2C,IAAI,EAAE,KAAK,iBAAiB,uEAAuE,oBAAoB,yBAAyB,oBAAoB,yBAAyB,4BAA4B,yBAAyB,0BAA0B,2BAA2B,6BAA6B,6BAA6B,qBAAqB,wBAAwB,EAAE,wBAAwB,UAAU,YAAY,mBAAmB,QAAQ,aAAa,IAAI,EAAE,KAAK,uBAAuB,qGAAqG,kBAAkB,qDAAqD,0BAA0B,qDAAqD,6BAA6B,yDAAyD,EAAE,oBAAoB,MAAM,0HAA0H,mBAAmB,WAAW,KAAK,QAAQ,wDAAwD,oGAAoG,QAAQ,sLAAsL,mBAAmB,WAAW,6EAA6E,KAAK,EAAE,QAAQ,sCAAsC,eAAe,SAAS,iBAAiB,UAAU,4HAA4H,2BAA2B,KAAK,EAAE,KAAK,iBAAiB,uCAAuC,qBAAqB,iBAAiB,0BAA0B,uCAAuC,wBAAwB,qCAAqC,yBAAyB,8EAA8E,2BAA2B,gEAAgE,yBAAyB,oFAAoF,EAAE,oBAAoB,MAAM,mPAAmP,mBAAmB,QAAQ,QAAQ,sBAAsB,KAAK,EAAE,KAAK,uBAAuB,2EAA2E,kBAAkB,uIAAuI,oBAAoB,2DAA2D,oBAAoB,qCAAqC,+BAA+B,qCAAqC,6BAA6B,8IAA8I,2BAA2B,2EAA2E,yBAAyB,yDAAyD,EAAE,0BAA0B,YAAY,sCAAsC,mBAAmB,QAAQ,cAAc,uCAAuC,KAAK,EAAE,KAAK,mBAAmB,mGAAmG,oBAAoB,mGAAmG,4BAA4B,mGAAmG,8BAA8B,qDAAqD,+BAA+B,wDAAwD,EAAE,oBAAoB,MAAM,gPAAgP,OAAO,8FAA8F,mBAAmB,QAAQ,SAAS,KAAK,sHAAsH,EAAE,EAAE,KAAK,sBAAsB,iEAAiE,oBAAoB,iDAAiD,sBAAsB,iDAAiD,8BAA8B,iDAAiD,qBAAqB,0CAA0C,EAAE,uBAAuB,SAAS,yCAAyC,mBAAmB,QAAQ,YAAY,KAAK,EAAE,KAAK,iBAAiB,2CAA2C,qBAAqB,8CAA8C,2BAA2B,gFAAgF,yBAAyB,oGAAoG,EAAE,+BAA+B,gBAAgB,0CAA0C,mBAAmB,QAAQ,kBAAkB,eAAe,KAAK,EAAE,KAAK,iBAAiB,yDAAyD,qBAAqB,4DAA4D,2BAA2B,yDAAyD,yBAAyB,6EAA6E,EAAE,wBAAwB,UAAU,0GAA0G,mBAAmB,QAAQ,aAAa,KAAK,qBAAqB,EAAE,EAAE,KAAK,iBAAiB,uHAAuH,uCAAuC,uGAAuG,6BAA6B,kGAAkG,sBAAsB,+FAA+F,qBAAqB,kHAAkH,EAAE,2BAA2B,YAAY,cAAc,mBAAmB,QAAQ,eAAe,KAAK,EAAE,KAAK,uBAAuB,6BAA6B,0DAA0D,OAAO,8GAA8G,qCAAqC,0BAA0B,sDAAsD,6BAA6B,0DAA0D,EAAE,2BAA2B,YAAY,2DAA2D,mBAAmB,QAAQ,eAAe,KAAK,EAAE,KAAK,uBAAuB,6BAA6B,kHAAkH,OAAO,kJAAkJ,qCAAqC,0BAA0B,sDAAsD,6BAA6B,0DAA0D,EAAE,2BAA2B,YAAY,kCAAkC,mBAAmB,QAAQ,eAAe,KAAK,EAAE,KAAK,uBAAuB,6BAA6B,kHAAkH,OAAO,8GAA8G,qCAAqC,0BAA0B,sDAAsD,6BAA6B,0DAA0D,EAAE,gCAAgC,iBAAiB,kEAAkE,mBAAmB,QAAQ,oBAAoB,KAAK,EAAE,KAAK,uBAAuB,gOAAgO,0BAA0B,gEAAgE,6BAA6B,oEAAoE,EAAE,sBAAsB,QAAQ,yJAAyJ,mBAAmB,QAAQ,UAAU,2BAA2B,KAAK,EAAE,KAAK,uBAAuB,sBAAsB,mDAAmD,yBAAyB,mCAAmC,oBAAoB,mCAAmC,oBAAoB,mCAAmC,4BAA4B,mCAAmC,6BAA6B,sBAAsB,sBAAsB,2BAA2B,sBAAsB,4CAA4C,EAAE,mBAAmB;AAChwwI,6C;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0GAA0G;AAC1G,CAAC,4BAA4B;;AAE7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,gBAAgB,sCAAsC,iBAAiB,EAAE;AACvF,6BAA6B,8EAA8E;AAC3G;AACA;;AAEA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,QAAQ;AAC7D,4CAA4C,QAAQ;AACpD,4DAA4D,QAAQ;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD,sDAAsD;AACtD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,kCAAkC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8BAA8B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA,2CAA2C,wBAAwB;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAwC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,gBAAgB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2BAA2B;AACpE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,aAAa,IAAI,aAAa,IAAI,YAAY,IAAI,SAAS,IAAI,SAAS,IAAI;AAC1G;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA,iOAAiO,MAAM;AACvO;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,SAAS;AAC1D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,UAAU;AAC9D;;AAEA;AACA;AACA,aAAa;AACb,mDAAmD;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yFAAyF;AACzF;AACA,OAAO;AACP;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH,iCAAiC;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,yDAAyD;AACzD,wDAAwD;AACxD,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B;AAC5B,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B,qCAAqC;AACrC;AACA,WAAW;AACX;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;AACX;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,8DAA8D;AAC9D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,8CAA8C,MAAM;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,WAAW,QAAQ,WAAW;AACjE,sCAAsC,WAAW;AACjD,WAAW;AACX;AACA,uCAAuC,YAAY;AACnD,6BAA6B,SAAS,cAAc,WAAW,eAAe,WAAW;AACzF,gCAAgC,SAAS,cAAc,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,WAAW;AAC9C,mCAAmC,KAAK,KAAK,MAAM;AACnD,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,8BAA8B,MAAM;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA,6BAA6B,WAAW,IAAI,WAAW;AACvD,gCAAgC,WAAW;AAC3C,WAAW;AACX;AACA,wBAAwB,YAAY;AACpC,yBAAyB,SAAS,SAAS,WAAW,EAAE,WAAW;AACnE,4BAA4B,SAAS,OAAO,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,WAAW;AACxC,sBAAsB,KAAK,KAAK,MAAM;AACtC,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB,eAAe,IAAI;AACnB,aAAa,EAAE;AACf,cAAc,GAAG,EAAE,GAAG;AACtB,gBAAgB,GAAG,EAAE,GAAG;AACxB,gBAAgB,GAAG,EAAE,GAAG,EAAE,GAAG;AAC7B,qBAAqB,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI;AACxC,cAAc,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI;AAClD;AACA,6BAA6B,KAAK,EAAE,GAAG,EAAE,GAAG;AAC5C;AACA,cAAc,KAAK;AACnB,eAAe,KAAK,EAAE,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK,sBAAsB,GAAG,4BAA4B,EAAE,sBAAsB,KAAK,4BAA4B,IAAI,gCAAgC,GAAG,yBAAyB,EAAE,sBAAsB,GAAG,yBAAyB,EAAE,sBAAsB,KAAK,4BAA4B,GAAG,gCAAgC,EAAE,sBAAsB,GAAG,yBAAyB,EAAE,sBAAsB,GAAG,8BAA8B,EAAE,sBAAsB,GAAG,yBAAyB,EAAE,sBAAsB,GAAG,yBAAyB,EAAE,sBAAsB,IAAI,yBAAyB,EAAE;AACvnB;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP,kCAAkC;;AAElC;AACA,yBAAyB,6BAA6B;AACtD,gDAAgD,gDAAgD;AAChG;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,IAAI,UAAU,EAAE;AACnD;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,gBAAgB;AAChB,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAuD;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE,sBAAsB,iBAAiB,gBAAgB,uBAAuB,UAAU,WAAW,2CAA2C,4EAA4E,iBAAiB,wBAAwB,WAAW,YAAY,2CAA2C;AAC5Y,OAAO;AACP;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,yBAAyB,kBAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA,oDAAoD,SAAS;AAC7D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB,0CAA0C;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,yCAAyC;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,uBAAuB,0CAA0C;AACjE;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C,+CAA+C;AAC/C;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,WAAW,UAAU,YAAY,EAAE,IAAI;AAClG;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,iEAAiE,WAAW,IAAI,GAAG,IAAI,IAAI;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD,SAAS;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY,wBAAwB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,+BAA+B;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kEAAkE,sBAAsB;AACxF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,aAAa;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,2BAA2B;AACxD;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,yCAAyC;AACzC;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iCAAiC,QAAQ;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP,uBAAuB,iDAAiD;AACxE;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA,OAAO;AACP;;AAEA,0CAA0C,SAAS;AACnD,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,4BAA4B;AACnF,yDAAyD,6BAA6B;AACtF;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,iEAAiE,gCAAgC;AACjG;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,gCAAgC;AAC7E;;AAEA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA,+CAA+C;AAC/C,6CAA6C;AAC7C;AACA,OAAO,cAAc,MAAM;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,iBAAiB,+BAA+B;AAChD;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oFAAoF;;AAEpF,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4CAA4C;AAC5C,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6JAA6J;AAC7J,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA,SAAS;AACT,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,uCAAuC;AAChE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,eAAe;AACf;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,qDAAqD;AACrD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8CAA8C;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0DAA0D,UAAU;AACpE;AACA;;AAEA;;AAEA,oDAAoD,UAAU;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,6BAA6B;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;;AAEX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oCAAoC;AACpC;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,yBAAyB,yBAAyB;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,sBAAsB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,6BAA6B,uBAAuB;AACpD;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,gBAAgB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA,6BAA6B,WAAW;AACxC;;AAEA,8BAA8B,iBAAiB;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA,+BAA+B,WAAW;AAC1C;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,4BAA4B;AACrD;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;;AAEA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,SAAS;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA,6BAA6B,aAAa;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,uBAAuB;AACtD,gCAAgC,oBAAoB;AACpD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA,yBAAyB,eAAe;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA,wCAAwC,oBAAoB;AAC5D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,gBAAgB;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,2BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4EAA4E;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,4BAA4B;AACzD;AACA;;AAEA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA,+CAA+C;AAC/C;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,0DAA0D;AACnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,yBAAyB;AACzD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA,2BAA2B,yBAAyB;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA,uBAAuB,+BAA+B;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,4CAA4C;AACjE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,6BAA6B,gCAAgC;AAC7D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA,qBAAqB,gCAAgC;AACrD;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD,SAAS;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,wCAAwC;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;;AAEA,yBAAyB,wCAAwC;AACjE,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA;;AAEA,yBAAyB,wBAAwB;AACjD;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,wBAAwB;AACjD;;AAEA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,+BAA+B;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,YAAY,+BAA+B;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,oDAAoD,4BAA4B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8BAA8B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,qDAAqD,kBAAkB,OAAO,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,yBAAyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,sBAAsB;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,yCAAyC;AACzC,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,sBAAsB;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,YAAY;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,gBAAgB;AACpE;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6EAA6E,eAAe;AAC5F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG;;AAErG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,sDAAsD;AAC/E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,UAAU;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA;;AAEA,4BAA4B,uBAAuB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP,qBAAqB,6BAA6B;AAClD;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,0EAA0E;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,uBAAuB;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD,yBAAyB,gCAAgC;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,MAAM;AACnE,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA,yBAAyB,wBAAwB;AACjD;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;;AAErB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,2BAA2B,0DAA0D;AACrF;AACA;;AAEA,6BAA6B,qBAAqB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,2BAA2B;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0CAA0C;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wEAAwE,SAAS;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wEAAwE,SAAS;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA,4CAA4C,SAAS;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,SAAS;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,6BAA6B;AACtD;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,iCAAiC,4BAA4B;AAC7D;AACA;;AAEA,2BAA2B,yBAAyB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,yBAAyB,kBAAkB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,UAAU;AACnC;;AAEA,+BAA+B,UAAU;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yBAAyB,UAAU;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,2BAA2B;AACtD;AACA;;AAEA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,sBAAsB;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6EAA6E;AAC7E;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;;AAEA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yBAAyB,kBAAkB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET,2CAA2C,SAAS;AACpD;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,SAAS;AACT,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,MAAM;AACjD,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,4BAA4B;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,mCAAmC,iBAAiB;AACpD;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA,qDAAqD,UAAU;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yBAAyB,4BAA4B;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,WAAW;;AAEX,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA,aAAa;;AAEb,2BAA2B,yBAAyB;AACpD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;;AAEA;;AAEA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B,0BAA0B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAA8D,MAAM;AAC7E;;AAEA,uBAAuB,oBAAoB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;;AAEA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;;AAEb;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;;AAEA;AACA;;AAEA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;;AAEA;AACA;AACA;;AAEA,6BAA6B,WAAW;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,gBAAgB;AAC1D;AACA;;AAEA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA,wCAAwC,gBAAgB;AACxD;;AAEA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,wCAAwC,gBAAgB;AACxD;AACA;AACA;;AAEA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2EAA2E,uBAAuB;AAClG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,2BAA2B,SAAS;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,WAAW;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA,OAAO;;AAEP,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA,uBAAuB,cAAc;AACrC;;AAEA,yBAAyB,kCAAkC;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA,uBAAuB,cAAc;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;;AAEA;;AAEA,qBAAqB,cAAc;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2DAA2D;;AAE3D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qDAAqD;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAA4C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,2BAA2B;AAC3B;AACA,OAAO;AACP,0BAA0B;AAC1B,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,sBAAsB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sFAAsF;AACtF;;AAEA,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF;AACxF;;AAEA,yBAAyB,2BAA2B;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,wFAAwF;AACxF;;AAEA,yBAAyB,8BAA8B;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uFAAuF;AACvF;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,uBAAuB,0BAA0B;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,2BAA2B;AACpD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gFAAgF;;AAEhF,uBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kFAAkF;;AAElF,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,oFAAoF;AACpF;;AAEA,2BAA2B,sBAAsB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8EAA8E;;AAE9E,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,4EAA4E;AAC5E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,4EAA4E;AAC5E;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,yBAAyB;AAChC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,mBAAmB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA,yBAAyB,mBAAmB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA,YAAY,gBAAgB;AAC5B;AACA;;AAEA,uCAAuC,YAAY;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA,SAAS;AACT;;AAEA,+CAA+C,mBAAmB;AAClE;;AAEA;AACA;AACA,SAAS;AACT;;AAEA,+CAA+C,wBAAwB;AACvE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,0CAA0C,qBAAqB;AAC/D;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,qCAAqC,MAAM;AAC3C,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA,6EAA6E;AAC7E;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,qBAAqB,kCAAkC;AACvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD,yBAAyB,+BAA+B;AACxD;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,4BAA4B;AACnD,yBAAyB,+BAA+B;AACxD;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD,yBAAyB,gCAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,8KAA8K;AAC9K;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,qCAAqC,EAAE;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wEAAwE;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qCAAqC;AAC5D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,gCAAgC;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,EAAE;AACrB;AACA;;AAEA,mBAAmB,EAAE,SAAS,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,EAAE,SAAS,IAAI,SAAS,IAAI;AAC/C;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET,0CAA0C,QAAQ;AAClD;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,uBAAuB,wBAAwB;AAC/C;;AAEA;;AAEA,yBAAyB,+BAA+B;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F;AACA;;AAEA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,mDAAmD,oDAAoD;AACvG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,gBAAgB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAsC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA,uBAAuB,uBAAuB;AAC9C;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,gBAAgB;AACzC;AACA;;AAEA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,qBAAqB,qBAAqB;AAC1C;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gDAAgD,SAAS,QAAQ,WAAW,UAAU;AACtF;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,gDAAgD,WAAW,cAAc;AACzE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C,YAAY,sBAAsB,eAAe,mBAAmB;AACnH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,SAAS,OAAO,QAAQ;AACnF,uCAAuC,kBAAkB,YAAY,oBAAoB,gBAAgB,eAAe;AACxH;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,2BAA2B,+BAA+B;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,cAAc,mBAAmB,mBAAmB,gBAAgB;;AAE1G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA,OAAO;AACP,0CAA0C,SAAS;AACnD;AACA;;AAEA;AACA;AACA,OAAO,SAAS;AAChB,yCAAyC,WAAW,YAAY,2CAA2C,iDAAiD,gDAAgD,8CAA8C,uCAAuC;AACjS;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO,SAAS;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,6BAA6B,uCAAuC,2CAA2C;AACzN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,oIAAoI;;AAEpI;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yIAAyI;AACzI;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6GAA6G;AAC7G,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mEAAmE;AACnE,2EAA2E;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,iDAAiD,SAAS;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;AACA;AACA;AACA,OAAO,gBAAgB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,WAAW;;AAEX;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,yFAAyF;AACzF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;;AAEA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,oFAAoF;;AAEpF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qEAAqE;;AAErE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA,0DAA0D;AAC1D,4EAA4E;AAC5E;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,aAAa;AACb;AACA;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,yHAAyH;AACzH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,KAAK;AAC7C,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,EAAE,MAAM;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iHAAiH,QAAQ,kDAAkD,MAAM;AACjL;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kIAAkI,gBAAgB;AAClJ;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kIAAkI,SAAS;AAC3I;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA,uBAAuB,OAAO;AAC9B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,kIAAkI,MAAM;AACxI;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qCAAqC,MAAM,kDAAkD,OAAO;AACpG,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,sDAAsD,wCAAwC;AAC9F,0DAA0D,4CAA4C;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA,cAAc,2DAA2D;AACzE;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa;AACxC;AACA;AACA;;AAEA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,iDAAiD;AACjD,WAAW;AACX,SAAS;;AAET;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;;AAEA,6BAA6B,+BAA+B;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;;AAEA;;AAEA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,sBAAsB;AACvE,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;;AAEA,+CAA+C,SAAS;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C,iCAAiC,SAAS,mCAAmC,mCAAmC;AAC9J;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,+CAA+C,SAAS;AACxD;AACA;;AAEA;AACA,yBAAyB,yBAAyB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,cAAc;;AAEhE,CAAC;AACD","file":"scripts.js","sourcesContent":["/**\n * Swiper 6.4.5\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2020 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: December 18, 2020\n */\n\n!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).Swiper=t()}(this,(function(){\"use strict\";function e(e,t){for(var a=0;a<t.length;a++){var i=t[a];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function t(){return(t=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var i in a)Object.prototype.hasOwnProperty.call(a,i)&&(e[i]=a[i])}return e}).apply(this,arguments)}function a(e){return null!==e&&\"object\"==typeof e&&\"constructor\"in e&&e.constructor===Object}function i(e,t){void 0===e&&(e={}),void 0===t&&(t={}),Object.keys(t).forEach((function(s){void 0===e[s]?e[s]=t[s]:a(t[s])&&a(e[s])&&Object.keys(t[s]).length>0&&i(e[s],t[s])}))}var s={body:{},addEventListener:function(){},removeEventListener:function(){},activeElement:{blur:function(){},nodeName:\"\"},querySelector:function(){return null},querySelectorAll:function(){return[]},getElementById:function(){return null},createEvent:function(){return{initEvent:function(){}}},createElement:function(){return{children:[],childNodes:[],style:{},setAttribute:function(){},getElementsByTagName:function(){return[]}}},createElementNS:function(){return{}},importNode:function(){return null},location:{hash:\"\",host:\"\",hostname:\"\",href:\"\",origin:\"\",pathname:\"\",protocol:\"\",search:\"\"}};function r(){var e=\"undefined\"!=typeof document?document:{};return i(e,s),e}var n={document:s,navigator:{userAgent:\"\"},location:{hash:\"\",host:\"\",hostname:\"\",href:\"\",origin:\"\",pathname:\"\",protocol:\"\",search:\"\"},history:{replaceState:function(){},pushState:function(){},go:function(){},back:function(){}},CustomEvent:function(){return this},addEventListener:function(){},removeEventListener:function(){},getComputedStyle:function(){return{getPropertyValue:function(){return\"\"}}},Image:function(){},Date:function(){},screen:{},setTimeout:function(){},clearTimeout:function(){},matchMedia:function(){return{}},requestAnimationFrame:function(e){return\"undefined\"==typeof setTimeout?(e(),null):setTimeout(e,0)},cancelAnimationFrame:function(e){\"undefined\"!=typeof setTimeout&&clearTimeout(e)}};function l(){var e=\"undefined\"!=typeof window?window:{};return i(e,n),e}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,t){return(d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(){if(\"undefined\"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function u(e,t,a){return(u=p()?Reflect.construct:function(e,t,a){var i=[null];i.push.apply(i,t);var s=new(Function.bind.apply(e,i));return a&&d(s,a.prototype),s}).apply(null,arguments)}function c(e){var t=\"function\"==typeof Map?new Map:void 0;return(c=function(e){if(null===e||(a=e,-1===Function.toString.call(a).indexOf(\"[native code]\")))return e;var a;if(\"function\"!=typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,i)}function i(){return u(e,arguments,o(this).constructor)}return i.prototype=Object.create(e.prototype,{constructor:{value:i,enumerable:!1,writable:!0,configurable:!0}}),d(i,e)})(e)}var h=function(e){var t,a;function i(t){var a,i,s;return a=e.call.apply(e,[this].concat(t))||this,i=function(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}(a),s=i.__proto__,Object.defineProperty(i,\"__proto__\",{get:function(){return s},set:function(e){s.__proto__=e}}),a}return a=e,(t=i).prototype=Object.create(a.prototype),t.prototype.constructor=t,t.__proto__=a,i}(c(Array));function v(e){void 0===e&&(e=[]);var t=[];return e.forEach((function(e){Array.isArray(e)?t.push.apply(t,v(e)):t.push(e)})),t}function f(e,t){return Array.prototype.filter.call(e,t)}function m(e,t){var a=l(),i=r(),s=[];if(!t&&e instanceof h)return e;if(!e)return new h(s);if(\"string\"==typeof e){var n=e.trim();if(n.indexOf(\"<\")>=0&&n.indexOf(\">\")>=0){var o=\"div\";0===n.indexOf(\"<li\")&&(o=\"ul\"),0===n.indexOf(\"<tr\")&&(o=\"tbody\"),0!==n.indexOf(\"<td\")&&0!==n.indexOf(\"<th\")||(o=\"tr\"),0===n.indexOf(\"<tbody\")&&(o=\"table\"),0===n.indexOf(\"<option\")&&(o=\"select\");var d=i.createElement(o);d.innerHTML=n;for(var p=0;p<d.childNodes.length;p+=1)s.push(d.childNodes[p])}else s=function(e,t){if(\"string\"!=typeof e)return[e];for(var a=[],i=t.querySelectorAll(e),s=0;s<i.length;s+=1)a.push(i[s]);return a}(e.trim(),t||i)}else if(e.nodeType||e===a||e===i)s.push(e);else if(Array.isArray(e)){if(e instanceof h)return e;s=e}return new h(function(e){for(var t=[],a=0;a<e.length;a+=1)-1===t.indexOf(e[a])&&t.push(e[a]);return t}(s))}m.fn=h.prototype;var g,y,w,b={addClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(\" \")})));return this.forEach((function(e){var t;(t=e.classList).add.apply(t,i)})),this},removeClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(\" \")})));return this.forEach((function(e){var t;(t=e.classList).remove.apply(t,i)})),this},hasClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(\" \")})));return f(this,(function(e){return i.filter((function(t){return e.classList.contains(t)})).length>0})).length>0},toggleClass:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=v(t.map((function(e){return e.split(\" \")})));this.forEach((function(e){i.forEach((function(t){e.classList.toggle(t)}))}))},attr:function(e,t){if(1===arguments.length&&\"string\"==typeof e)return this[0]?this[0].getAttribute(e):void 0;for(var a=0;a<this.length;a+=1)if(2===arguments.length)this[a].setAttribute(e,t);else for(var i in e)this[a][i]=e[i],this[a].setAttribute(i,e[i]);return this},removeAttr:function(e){for(var t=0;t<this.length;t+=1)this[t].removeAttribute(e);return this},transform:function(e){for(var t=0;t<this.length;t+=1)this[t].style.transform=e;return this},transition:function(e){for(var t=0;t<this.length;t+=1)this[t].style.transitionDuration=\"string\"!=typeof e?e+\"ms\":e;return this},on:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=t[0],s=t[1],r=t[2],n=t[3];function l(e){var t=e.target;if(t){var a=e.target.dom7EventData||[];if(a.indexOf(e)<0&&a.unshift(e),m(t).is(s))r.apply(t,a);else for(var i=m(t).parents(),n=0;n<i.length;n+=1)m(i[n]).is(s)&&r.apply(i[n],a)}}function o(e){var t=e&&e.target&&e.target.dom7EventData||[];t.indexOf(e)<0&&t.unshift(e),r.apply(this,t)}\"function\"==typeof t[1]&&(i=t[0],r=t[1],n=t[2],s=void 0),n||(n=!1);for(var d,p=i.split(\" \"),u=0;u<this.length;u+=1){var c=this[u];if(s)for(d=0;d<p.length;d+=1){var h=p[d];c.dom7LiveListeners||(c.dom7LiveListeners={}),c.dom7LiveListeners[h]||(c.dom7LiveListeners[h]=[]),c.dom7LiveListeners[h].push({listener:r,proxyListener:l}),c.addEventListener(h,l,n)}else for(d=0;d<p.length;d+=1){var v=p[d];c.dom7Listeners||(c.dom7Listeners={}),c.dom7Listeners[v]||(c.dom7Listeners[v]=[]),c.dom7Listeners[v].push({listener:r,proxyListener:o}),c.addEventListener(v,o,n)}}return this},off:function(){for(var e=arguments.length,t=new Array(e),a=0;a<e;a++)t[a]=arguments[a];var i=t[0],s=t[1],r=t[2],n=t[3];\"function\"==typeof t[1]&&(i=t[0],r=t[1],n=t[2],s=void 0),n||(n=!1);for(var l=i.split(\" \"),o=0;o<l.length;o+=1)for(var d=l[o],p=0;p<this.length;p+=1){var u=this[p],c=void 0;if(!s&&u.dom7Listeners?c=u.dom7Listeners[d]:s&&u.dom7LiveListeners&&(c=u.dom7LiveListeners[d]),c&&c.length)for(var h=c.length-1;h>=0;h-=1){var v=c[h];r&&v.listener===r||r&&v.listener&&v.listener.dom7proxy&&v.listener.dom7proxy===r?(u.removeEventListener(d,v.proxyListener,n),c.splice(h,1)):r||(u.removeEventListener(d,v.proxyListener,n),c.splice(h,1))}}return this},trigger:function(){for(var e=l(),t=arguments.length,a=new Array(t),i=0;i<t;i++)a[i]=arguments[i];for(var s=a[0].split(\" \"),r=a[1],n=0;n<s.length;n+=1)for(var o=s[n],d=0;d<this.length;d+=1){var p=this[d];if(e.CustomEvent){var u=new e.CustomEvent(o,{detail:r,bubbles:!0,cancelable:!0});p.dom7EventData=a.filter((function(e,t){return t>0})),p.dispatchEvent(u),p.dom7EventData=[],delete p.dom7EventData}}return this},transitionEnd:function(e){var t=this;return e&&t.on(\"transitionend\",(function a(i){i.target===this&&(e.call(this,i),t.off(\"transitionend\",a))})),this},outerWidth:function(e){if(this.length>0){if(e){var t=this.styles();return this[0].offsetWidth+parseFloat(t.getPropertyValue(\"margin-right\"))+parseFloat(t.getPropertyValue(\"margin-left\"))}return this[0].offsetWidth}return null},outerHeight:function(e){if(this.length>0){if(e){var t=this.styles();return this[0].offsetHeight+parseFloat(t.getPropertyValue(\"margin-top\"))+parseFloat(t.getPropertyValue(\"margin-bottom\"))}return this[0].offsetHeight}return null},styles:function(){var e=l();return this[0]?e.getComputedStyle(this[0],null):{}},offset:function(){if(this.length>0){var e=l(),t=r(),a=this[0],i=a.getBoundingClientRect(),s=t.body,n=a.clientTop||s.clientTop||0,o=a.clientLeft||s.clientLeft||0,d=a===e?e.scrollY:a.scrollTop,p=a===e?e.scrollX:a.scrollLeft;return{top:i.top+d-n,left:i.left+p-o}}return null},css:function(e,t){var a,i=l();if(1===arguments.length){if(\"string\"!=typeof e){for(a=0;a<this.length;a+=1)for(var s in e)this[a].style[s]=e[s];return this}if(this[0])return i.getComputedStyle(this[0],null).getPropertyValue(e)}if(2===arguments.length&&\"string\"==typeof e){for(a=0;a<this.length;a+=1)this[a].style[e]=t;return this}return this},each:function(e){return e?(this.forEach((function(t,a){e.apply(t,[t,a])})),this):this},html:function(e){if(void 0===e)return this[0]?this[0].innerHTML:null;for(var t=0;t<this.length;t+=1)this[t].innerHTML=e;return this},text:function(e){if(void 0===e)return this[0]?this[0].textContent.trim():null;for(var t=0;t<this.length;t+=1)this[t].textContent=e;return this},is:function(e){var t,a,i=l(),s=r(),n=this[0];if(!n||void 0===e)return!1;if(\"string\"==typeof e){if(n.matches)return n.matches(e);if(n.webkitMatchesSelector)return n.webkitMatchesSelector(e);if(n.msMatchesSelector)return n.msMatchesSelector(e);for(t=m(e),a=0;a<t.length;a+=1)if(t[a]===n)return!0;return!1}if(e===s)return n===s;if(e===i)return n===i;if(e.nodeType||e instanceof h){for(t=e.nodeType?[e]:e,a=0;a<t.length;a+=1)if(t[a]===n)return!0;return!1}return!1},index:function(){var e,t=this[0];if(t){for(e=0;null!==(t=t.previousSibling);)1===t.nodeType&&(e+=1);return e}},eq:function(e){if(void 0===e)return this;var t=this.length;if(e>t-1)return m([]);if(e<0){var a=t+e;return m(a<0?[]:[this[a]])}return m([this[e]])},append:function(){for(var e,t=r(),a=0;a<arguments.length;a+=1){e=a<0||arguments.length<=a?void 0:arguments[a];for(var i=0;i<this.length;i+=1)if(\"string\"==typeof e){var s=t.createElement(\"div\");for(s.innerHTML=e;s.firstChild;)this[i].appendChild(s.firstChild)}else if(e instanceof h)for(var n=0;n<e.length;n+=1)this[i].appendChild(e[n]);else this[i].appendChild(e)}return this},prepend:function(e){var t,a,i=r();for(t=0;t<this.length;t+=1)if(\"string\"==typeof e){var s=i.createElement(\"div\");for(s.innerHTML=e,a=s.childNodes.length-1;a>=0;a-=1)this[t].insertBefore(s.childNodes[a],this[t].childNodes[0])}else if(e instanceof h)for(a=0;a<e.length;a+=1)this[t].insertBefore(e[a],this[t].childNodes[0]);else this[t].insertBefore(e,this[t].childNodes[0]);return this},next:function(e){return this.length>0?e?this[0].nextElementSibling&&m(this[0].nextElementSibling).is(e)?m([this[0].nextElementSibling]):m([]):this[0].nextElementSibling?m([this[0].nextElementSibling]):m([]):m([])},nextAll:function(e){var t=[],a=this[0];if(!a)return m([]);for(;a.nextElementSibling;){var i=a.nextElementSibling;e?m(i).is(e)&&t.push(i):t.push(i),a=i}return m(t)},prev:function(e){if(this.length>0){var t=this[0];return e?t.previousElementSibling&&m(t.previousElementSibling).is(e)?m([t.previousElementSibling]):m([]):t.previousElementSibling?m([t.previousElementSibling]):m([])}return m([])},prevAll:function(e){var t=[],a=this[0];if(!a)return m([]);for(;a.previousElementSibling;){var i=a.previousElementSibling;e?m(i).is(e)&&t.push(i):t.push(i),a=i}return m(t)},parent:function(e){for(var t=[],a=0;a<this.length;a+=1)null!==this[a].parentNode&&(e?m(this[a].parentNode).is(e)&&t.push(this[a].parentNode):t.push(this[a].parentNode));return m(t)},parents:function(e){for(var t=[],a=0;a<this.length;a+=1)for(var i=this[a].parentNode;i;)e?m(i).is(e)&&t.push(i):t.push(i),i=i.parentNode;return m(t)},closest:function(e){var t=this;return void 0===e?m([]):(t.is(e)||(t=t.parents(e).eq(0)),t)},find:function(e){for(var t=[],a=0;a<this.length;a+=1)for(var i=this[a].querySelectorAll(e),s=0;s<i.length;s+=1)t.push(i[s]);return m(t)},children:function(e){for(var t=[],a=0;a<this.length;a+=1)for(var i=this[a].children,s=0;s<i.length;s+=1)e&&!m(i[s]).is(e)||t.push(i[s]);return m(t)},filter:function(e){return m(f(this,e))},remove:function(){for(var e=0;e<this.length;e+=1)this[e].parentNode&&this[e].parentNode.removeChild(this[e]);return this}};function E(e,t){return void 0===t&&(t=0),setTimeout(e,t)}function x(){return Date.now()}function T(e,t){void 0===t&&(t=\"x\");var a,i,s,r=l(),n=r.getComputedStyle(e,null);return r.WebKitCSSMatrix?((i=n.transform||n.webkitTransform).split(\",\").length>6&&(i=i.split(\", \").map((function(e){return e.replace(\",\",\".\")})).join(\", \")),s=new r.WebKitCSSMatrix(\"none\"===i?\"\":i)):a=(s=n.MozTransform||n.OTransform||n.MsTransform||n.msTransform||n.transform||n.getPropertyValue(\"transform\").replace(\"translate(\",\"matrix(1, 0, 0, 1,\")).toString().split(\",\"),\"x\"===t&&(i=r.WebKitCSSMatrix?s.m41:16===a.length?parseFloat(a[12]):parseFloat(a[4])),\"y\"===t&&(i=r.WebKitCSSMatrix?s.m42:16===a.length?parseFloat(a[13]):parseFloat(a[5])),i||0}function C(e){return\"object\"==typeof e&&null!==e&&e.constructor&&e.constructor===Object}function S(){for(var e=Object(arguments.length<=0?void 0:arguments[0]),t=1;t<arguments.length;t+=1){var a=t<0||arguments.length<=t?void 0:arguments[t];if(null!=a)for(var i=Object.keys(Object(a)),s=0,r=i.length;s<r;s+=1){var n=i[s],l=Object.getOwnPropertyDescriptor(a,n);void 0!==l&&l.enumerable&&(C(e[n])&&C(a[n])?S(e[n],a[n]):!C(e[n])&&C(a[n])?(e[n]={},S(e[n],a[n])):e[n]=a[n])}}return e}function M(e,t){Object.keys(t).forEach((function(a){C(t[a])&&Object.keys(t[a]).forEach((function(i){\"function\"==typeof t[a][i]&&(t[a][i]=t[a][i].bind(e))})),e[a]=t[a]}))}function z(){return g||(g=function(){var e=l(),t=r();return{touch:!!(\"ontouchstart\"in e||e.DocumentTouch&&t instanceof e.DocumentTouch),pointerEvents:!!e.PointerEvent&&\"maxTouchPoints\"in e.navigator&&e.navigator.maxTouchPoints>=0,observer:\"MutationObserver\"in e||\"WebkitMutationObserver\"in e,passiveListener:function(){var t=!1;try{var a=Object.defineProperty({},\"passive\",{get:function(){t=!0}});e.addEventListener(\"testPassiveListener\",null,a)}catch(e){}return t}(),gestures:\"ongesturestart\"in e}}()),g}function P(e){return void 0===e&&(e={}),y||(y=function(e){var t=(void 0===e?{}:e).userAgent,a=z(),i=l(),s=i.navigator.platform,r=t||i.navigator.userAgent,n={ios:!1,android:!1},o=i.screen.width,d=i.screen.height,p=r.match(/(Android);?[\\s\\/]+([\\d.]+)?/),u=r.match(/(iPad).*OS\\s([\\d_]+)/),c=r.match(/(iPod)(.*OS\\s([\\d_]+))?/),h=!u&&r.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/),v=\"Win32\"===s,f=\"MacIntel\"===s;return!u&&f&&a.touch&&[\"1024x1366\",\"1366x1024\",\"834x1194\",\"1194x834\",\"834x1112\",\"1112x834\",\"768x1024\",\"1024x768\",\"820x1180\",\"1180x820\",\"810x1080\",\"1080x810\"].indexOf(o+\"x\"+d)>=0&&((u=r.match(/(Version)\\/([\\d.]+)/))||(u=[0,1,\"13_0_0\"]),f=!1),p&&!v&&(n.os=\"android\",n.android=!0),(u||h||c)&&(n.os=\"ios\",n.ios=!0),n}(e)),y}function k(){return w||(w=function(){var e,t=l();return{isEdge:!!t.navigator.userAgent.match(/Edge/g),isSafari:(e=t.navigator.userAgent.toLowerCase(),e.indexOf(\"safari\")>=0&&e.indexOf(\"chrome\")<0&&e.indexOf(\"android\")<0),isWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)}}()),w}Object.keys(b).forEach((function(e){m.fn[e]=b[e]}));var L={name:\"resize\",create:function(){var e=this;S(e,{resize:{resizeHandler:function(){e&&!e.destroyed&&e.initialized&&(e.emit(\"beforeResize\"),e.emit(\"resize\"))},orientationChangeHandler:function(){e&&!e.destroyed&&e.initialized&&e.emit(\"orientationchange\")}}})},on:{init:function(e){var t=l();t.addEventListener(\"resize\",e.resize.resizeHandler),t.addEventListener(\"orientationchange\",e.resize.orientationChangeHandler)},destroy:function(e){var t=l();t.removeEventListener(\"resize\",e.resize.resizeHandler),t.removeEventListener(\"orientationchange\",e.resize.orientationChangeHandler)}}},$={attach:function(e,t){void 0===t&&(t={});var a=l(),i=this,s=new(a.MutationObserver||a.WebkitMutationObserver)((function(e){if(1!==e.length){var t=function(){i.emit(\"observerUpdate\",e[0])};a.requestAnimationFrame?a.requestAnimationFrame(t):a.setTimeout(t,0)}else i.emit(\"observerUpdate\",e[0])}));s.observe(e,{attributes:void 0===t.attributes||t.attributes,childList:void 0===t.childList||t.childList,characterData:void 0===t.characterData||t.characterData}),i.observer.observers.push(s)},init:function(){var e=this;if(e.support.observer&&e.params.observer){if(e.params.observeParents)for(var t=e.$el.parents(),a=0;a<t.length;a+=1)e.observer.attach(t[a]);e.observer.attach(e.$el[0],{childList:e.params.observeSlideChildren}),e.observer.attach(e.$wrapperEl[0],{attributes:!1})}},destroy:function(){this.observer.observers.forEach((function(e){e.disconnect()})),this.observer.observers=[]}},I={name:\"observer\",params:{observer:!1,observeParents:!1,observeSlideChildren:!1},create:function(){M(this,{observer:t({},$,{observers:[]})})},on:{init:function(e){e.observer.init()},destroy:function(e){e.observer.destroy()}}};function O(e){var t=this,a=r(),i=l(),s=t.touchEventsData,n=t.params,o=t.touches;if(!t.animating||!n.preventInteractionOnTransition){var d=e;d.originalEvent&&(d=d.originalEvent);var p=m(d.target);if(\"wrapper\"!==n.touchEventsTarget||p.closest(t.wrapperEl).length)if(s.isTouchEvent=\"touchstart\"===d.type,s.isTouchEvent||!(\"which\"in d)||3!==d.which)if(!(!s.isTouchEvent&&\"button\"in d&&d.button>0))if(!s.isTouched||!s.isMoved)if(!!n.noSwipingClass&&\"\"!==n.noSwipingClass&&d.target&&d.target.shadowRoot&&e.path&&e.path[0]&&(p=m(e.path[0])),n.noSwiping&&p.closest(n.noSwipingSelector?n.noSwipingSelector:\".\"+n.noSwipingClass)[0])t.allowClick=!0;else if(!n.swipeHandler||p.closest(n.swipeHandler)[0]){o.currentX=\"touchstart\"===d.type?d.targetTouches[0].pageX:d.pageX,o.currentY=\"touchstart\"===d.type?d.targetTouches[0].pageY:d.pageY;var u=o.currentX,c=o.currentY,h=n.edgeSwipeDetection||n.iOSEdgeSwipeDetection,v=n.edgeSwipeThreshold||n.iOSEdgeSwipeThreshold;if(!h||!(u<=v||u>=i.innerWidth-v)){if(S(s,{isTouched:!0,isMoved:!1,allowTouchCallbacks:!0,isScrolling:void 0,startMoving:void 0}),o.startX=u,o.startY=c,s.touchStartTime=x(),t.allowClick=!0,t.updateSize(),t.swipeDirection=void 0,n.threshold>0&&(s.allowThresholdMove=!1),\"touchstart\"!==d.type){var f=!0;p.is(s.formElements)&&(f=!1),a.activeElement&&m(a.activeElement).is(s.formElements)&&a.activeElement!==p[0]&&a.activeElement.blur();var g=f&&t.allowTouchMove&&n.touchStartPreventDefault;!n.touchStartForcePreventDefault&&!g||p[0].isContentEditable||d.preventDefault()}t.emit(\"touchStart\",d)}}}}function A(e){var t=r(),a=this,i=a.touchEventsData,s=a.params,n=a.touches,l=a.rtlTranslate,o=e;if(o.originalEvent&&(o=o.originalEvent),i.isTouched){if(!i.isTouchEvent||\"touchmove\"===o.type){var d=\"touchmove\"===o.type&&o.targetTouches&&(o.targetTouches[0]||o.changedTouches[0]),p=\"touchmove\"===o.type?d.pageX:o.pageX,u=\"touchmove\"===o.type?d.pageY:o.pageY;if(o.preventedByNestedSwiper)return n.startX=p,void(n.startY=u);if(!a.allowTouchMove)return a.allowClick=!1,void(i.isTouched&&(S(n,{startX:p,startY:u,currentX:p,currentY:u}),i.touchStartTime=x()));if(i.isTouchEvent&&s.touchReleaseOnEdges&&!s.loop)if(a.isVertical()){if(u<n.startY&&a.translate<=a.maxTranslate()||u>n.startY&&a.translate>=a.minTranslate())return i.isTouched=!1,void(i.isMoved=!1)}else if(p<n.startX&&a.translate<=a.maxTranslate()||p>n.startX&&a.translate>=a.minTranslate())return;if(i.isTouchEvent&&t.activeElement&&o.target===t.activeElement&&m(o.target).is(i.formElements))return i.isMoved=!0,void(a.allowClick=!1);if(i.allowTouchCallbacks&&a.emit(\"touchMove\",o),!(o.targetTouches&&o.targetTouches.length>1)){n.currentX=p,n.currentY=u;var c=n.currentX-n.startX,h=n.currentY-n.startY;if(!(a.params.threshold&&Math.sqrt(Math.pow(c,2)+Math.pow(h,2))<a.params.threshold)){var v;if(void 0===i.isScrolling)a.isHorizontal()&&n.currentY===n.startY||a.isVertical()&&n.currentX===n.startX?i.isScrolling=!1:c*c+h*h>=25&&(v=180*Math.atan2(Math.abs(h),Math.abs(c))/Math.PI,i.isScrolling=a.isHorizontal()?v>s.touchAngle:90-v>s.touchAngle);if(i.isScrolling&&a.emit(\"touchMoveOpposite\",o),void 0===i.startMoving&&(n.currentX===n.startX&&n.currentY===n.startY||(i.startMoving=!0)),i.isScrolling)i.isTouched=!1;else if(i.startMoving){a.allowClick=!1,!s.cssMode&&o.cancelable&&o.preventDefault(),s.touchMoveStopPropagation&&!s.nested&&o.stopPropagation(),i.isMoved||(s.loop&&a.loopFix(),i.startTranslate=a.getTranslate(),a.setTransition(0),a.animating&&a.$wrapperEl.trigger(\"webkitTransitionEnd transitionend\"),i.allowMomentumBounce=!1,!s.grabCursor||!0!==a.allowSlideNext&&!0!==a.allowSlidePrev||a.setGrabCursor(!0),a.emit(\"sliderFirstMove\",o)),a.emit(\"sliderMove\",o),i.isMoved=!0;var f=a.isHorizontal()?c:h;n.diff=f,f*=s.touchRatio,l&&(f=-f),a.swipeDirection=f>0?\"prev\":\"next\",i.currentTranslate=f+i.startTranslate;var g=!0,y=s.resistanceRatio;if(s.touchReleaseOnEdges&&(y=0),f>0&&i.currentTranslate>a.minTranslate()?(g=!1,s.resistance&&(i.currentTranslate=a.minTranslate()-1+Math.pow(-a.minTranslate()+i.startTranslate+f,y))):f<0&&i.currentTranslate<a.maxTranslate()&&(g=!1,s.resistance&&(i.currentTranslate=a.maxTranslate()+1-Math.pow(a.maxTranslate()-i.startTranslate-f,y))),g&&(o.preventedByNestedSwiper=!0),!a.allowSlideNext&&\"next\"===a.swipeDirection&&i.currentTranslate<i.startTranslate&&(i.currentTranslate=i.startTranslate),!a.allowSlidePrev&&\"prev\"===a.swipeDirection&&i.currentTranslate>i.startTranslate&&(i.currentTranslate=i.startTranslate),s.threshold>0){if(!(Math.abs(f)>s.threshold||i.allowThresholdMove))return void(i.currentTranslate=i.startTranslate);if(!i.allowThresholdMove)return i.allowThresholdMove=!0,n.startX=n.currentX,n.startY=n.currentY,i.currentTranslate=i.startTranslate,void(n.diff=a.isHorizontal()?n.currentX-n.startX:n.currentY-n.startY)}s.followFinger&&!s.cssMode&&((s.freeMode||s.watchSlidesProgress||s.watchSlidesVisibility)&&(a.updateActiveIndex(),a.updateSlidesClasses()),s.freeMode&&(0===i.velocities.length&&i.velocities.push({position:n[a.isHorizontal()?\"startX\":\"startY\"],time:i.touchStartTime}),i.velocities.push({position:n[a.isHorizontal()?\"currentX\":\"currentY\"],time:x()})),a.updateProgress(i.currentTranslate),a.setTranslate(i.currentTranslate))}}}}}else i.startMoving&&i.isScrolling&&a.emit(\"touchMoveOpposite\",o)}function D(e){var t=this,a=t.touchEventsData,i=t.params,s=t.touches,r=t.rtlTranslate,n=t.$wrapperEl,l=t.slidesGrid,o=t.snapGrid,d=e;if(d.originalEvent&&(d=d.originalEvent),a.allowTouchCallbacks&&t.emit(\"touchEnd\",d),a.allowTouchCallbacks=!1,!a.isTouched)return a.isMoved&&i.grabCursor&&t.setGrabCursor(!1),a.isMoved=!1,void(a.startMoving=!1);i.grabCursor&&a.isMoved&&a.isTouched&&(!0===t.allowSlideNext||!0===t.allowSlidePrev)&&t.setGrabCursor(!1);var p,u=x(),c=u-a.touchStartTime;if(t.allowClick&&(t.updateClickedSlide(d),t.emit(\"tap click\",d),c<300&&u-a.lastClickTime<300&&t.emit(\"doubleTap doubleClick\",d)),a.lastClickTime=x(),E((function(){t.destroyed||(t.allowClick=!0)})),!a.isTouched||!a.isMoved||!t.swipeDirection||0===s.diff||a.currentTranslate===a.startTranslate)return a.isTouched=!1,a.isMoved=!1,void(a.startMoving=!1);if(a.isTouched=!1,a.isMoved=!1,a.startMoving=!1,p=i.followFinger?r?t.translate:-t.translate:-a.currentTranslate,!i.cssMode)if(i.freeMode){if(p<-t.minTranslate())return void t.slideTo(t.activeIndex);if(p>-t.maxTranslate())return void(t.slides.length<o.length?t.slideTo(o.length-1):t.slideTo(t.slides.length-1));if(i.freeModeMomentum){if(a.velocities.length>1){var h=a.velocities.pop(),v=a.velocities.pop(),f=h.position-v.position,m=h.time-v.time;t.velocity=f/m,t.velocity/=2,Math.abs(t.velocity)<i.freeModeMinimumVelocity&&(t.velocity=0),(m>150||x()-h.time>300)&&(t.velocity=0)}else t.velocity=0;t.velocity*=i.freeModeMomentumVelocityRatio,a.velocities.length=0;var g=1e3*i.freeModeMomentumRatio,y=t.velocity*g,w=t.translate+y;r&&(w=-w);var b,T,C=!1,S=20*Math.abs(t.velocity)*i.freeModeMomentumBounceRatio;if(w<t.maxTranslate())i.freeModeMomentumBounce?(w+t.maxTranslate()<-S&&(w=t.maxTranslate()-S),b=t.maxTranslate(),C=!0,a.allowMomentumBounce=!0):w=t.maxTranslate(),i.loop&&i.centeredSlides&&(T=!0);else if(w>t.minTranslate())i.freeModeMomentumBounce?(w-t.minTranslate()>S&&(w=t.minTranslate()+S),b=t.minTranslate(),C=!0,a.allowMomentumBounce=!0):w=t.minTranslate(),i.loop&&i.centeredSlides&&(T=!0);else if(i.freeModeSticky){for(var M,z=0;z<o.length;z+=1)if(o[z]>-w){M=z;break}w=-(w=Math.abs(o[M]-w)<Math.abs(o[M-1]-w)||\"next\"===t.swipeDirection?o[M]:o[M-1])}if(T&&t.once(\"transitionEnd\",(function(){t.loopFix()})),0!==t.velocity){if(g=r?Math.abs((-w-t.translate)/t.velocity):Math.abs((w-t.translate)/t.velocity),i.freeModeSticky){var P=Math.abs((r?-w:w)-t.translate),k=t.slidesSizesGrid[t.activeIndex];g=P<k?i.speed:P<2*k?1.5*i.speed:2.5*i.speed}}else if(i.freeModeSticky)return void t.slideToClosest();i.freeModeMomentumBounce&&C?(t.updateProgress(b),t.setTransition(g),t.setTranslate(w),t.transitionStart(!0,t.swipeDirection),t.animating=!0,n.transitionEnd((function(){t&&!t.destroyed&&a.allowMomentumBounce&&(t.emit(\"momentumBounce\"),t.setTransition(i.speed),setTimeout((function(){t.setTranslate(b),n.transitionEnd((function(){t&&!t.destroyed&&t.transitionEnd()}))}),0))}))):t.velocity?(t.updateProgress(w),t.setTransition(g),t.setTranslate(w),t.transitionStart(!0,t.swipeDirection),t.animating||(t.animating=!0,n.transitionEnd((function(){t&&!t.destroyed&&t.transitionEnd()})))):t.updateProgress(w),t.updateActiveIndex(),t.updateSlidesClasses()}else if(i.freeModeSticky)return void t.slideToClosest();(!i.freeModeMomentum||c>=i.longSwipesMs)&&(t.updateProgress(),t.updateActiveIndex(),t.updateSlidesClasses())}else{for(var L=0,$=t.slidesSizesGrid[0],I=0;I<l.length;I+=I<i.slidesPerGroupSkip?1:i.slidesPerGroup){var O=I<i.slidesPerGroupSkip-1?1:i.slidesPerGroup;void 0!==l[I+O]?p>=l[I]&&p<l[I+O]&&(L=I,$=l[I+O]-l[I]):p>=l[I]&&(L=I,$=l[l.length-1]-l[l.length-2])}var A=(p-l[L])/$,D=L<i.slidesPerGroupSkip-1?1:i.slidesPerGroup;if(c>i.longSwipesMs){if(!i.longSwipes)return void t.slideTo(t.activeIndex);\"next\"===t.swipeDirection&&(A>=i.longSwipesRatio?t.slideTo(L+D):t.slideTo(L)),\"prev\"===t.swipeDirection&&(A>1-i.longSwipesRatio?t.slideTo(L+D):t.slideTo(L))}else{if(!i.shortSwipes)return void t.slideTo(t.activeIndex);t.navigation&&(d.target===t.navigation.nextEl||d.target===t.navigation.prevEl)?d.target===t.navigation.nextEl?t.slideTo(L+D):t.slideTo(L):(\"next\"===t.swipeDirection&&t.slideTo(L+D),\"prev\"===t.swipeDirection&&t.slideTo(L))}}}function G(){var e=this,t=e.params,a=e.el;if(!a||0!==a.offsetWidth){t.breakpoints&&e.setBreakpoint();var i=e.allowSlideNext,s=e.allowSlidePrev,r=e.snapGrid;e.allowSlideNext=!0,e.allowSlidePrev=!0,e.updateSize(),e.updateSlides(),e.updateSlidesClasses(),(\"auto\"===t.slidesPerView||t.slidesPerView>1)&&e.isEnd&&!e.isBeginning&&!e.params.centeredSlides?e.slideTo(e.slides.length-1,0,!1,!0):e.slideTo(e.activeIndex,0,!1,!0),e.autoplay&&e.autoplay.running&&e.autoplay.paused&&e.autoplay.run(),e.allowSlidePrev=s,e.allowSlideNext=i,e.params.watchOverflow&&r!==e.snapGrid&&e.checkOverflow()}}function N(e){var t=this;t.allowClick||(t.params.preventClicks&&e.preventDefault(),t.params.preventClicksPropagation&&t.animating&&(e.stopPropagation(),e.stopImmediatePropagation()))}function B(){var e=this,t=e.wrapperEl,a=e.rtlTranslate;e.previousTranslate=e.translate,e.isHorizontal()?e.translate=a?t.scrollWidth-t.offsetWidth-t.scrollLeft:-t.scrollLeft:e.translate=-t.scrollTop,-0===e.translate&&(e.translate=0),e.updateActiveIndex(),e.updateSlidesClasses();var i=e.maxTranslate()-e.minTranslate();(0===i?0:(e.translate-e.minTranslate())/i)!==e.progress&&e.updateProgress(a?-e.translate:e.translate),e.emit(\"setTranslate\",e.translate,!1)}var H=!1;function X(){}var Y={init:!0,direction:\"horizontal\",touchEventsTarget:\"container\",initialSlide:0,speed:300,cssMode:!1,updateOnWindowResize:!0,nested:!1,width:null,height:null,preventInteractionOnTransition:!1,userAgent:null,url:null,edgeSwipeDetection:!1,edgeSwipeThreshold:20,freeMode:!1,freeModeMomentum:!0,freeModeMomentumRatio:1,freeModeMomentumBounce:!0,freeModeMomentumBounceRatio:1,freeModeMomentumVelocityRatio:1,freeModeSticky:!1,freeModeMinimumVelocity:.02,autoHeight:!1,setWrapperSize:!1,virtualTranslate:!1,effect:\"slide\",breakpoints:void 0,spaceBetween:0,slidesPerView:1,slidesPerColumn:1,slidesPerColumnFill:\"column\",slidesPerGroup:1,slidesPerGroupSkip:0,centeredSlides:!1,centeredSlidesBounds:!1,slidesOffsetBefore:0,slidesOffsetAfter:0,normalizeSlideIndex:!0,centerInsufficientSlides:!1,watchOverflow:!1,roundLengths:!1,touchRatio:1,touchAngle:45,simulateTouch:!0,shortSwipes:!0,longSwipes:!0,longSwipesRatio:.5,longSwipesMs:300,followFinger:!0,allowTouchMove:!0,threshold:0,touchMoveStopPropagation:!1,touchStartPreventDefault:!0,touchStartForcePreventDefault:!1,touchReleaseOnEdges:!1,uniqueNavElements:!0,resistance:!0,resistanceRatio:.85,watchSlidesProgress:!1,watchSlidesVisibility:!1,grabCursor:!1,preventClicks:!0,preventClicksPropagation:!0,slideToClickedSlide:!1,preloadImages:!0,updateOnImagesReady:!0,loop:!1,loopAdditionalSlides:0,loopedSlides:null,loopFillGroupWithBlank:!1,loopPreventsSlide:!0,allowSlidePrev:!0,allowSlideNext:!0,swipeHandler:null,noSwiping:!0,noSwipingClass:\"swiper-no-swiping\",noSwipingSelector:null,passiveListeners:!0,containerModifierClass:\"swiper-container-\",slideClass:\"swiper-slide\",slideBlankClass:\"swiper-slide-invisible-blank\",slideActiveClass:\"swiper-slide-active\",slideDuplicateActiveClass:\"swiper-slide-duplicate-active\",slideVisibleClass:\"swiper-slide-visible\",slideDuplicateClass:\"swiper-slide-duplicate\",slideNextClass:\"swiper-slide-next\",slideDuplicateNextClass:\"swiper-slide-duplicate-next\",slidePrevClass:\"swiper-slide-prev\",slideDuplicatePrevClass:\"swiper-slide-duplicate-prev\",wrapperClass:\"swiper-wrapper\",runCallbacksOnInit:!0,_emitClasses:!1},V={modular:{useParams:function(e){var t=this;t.modules&&Object.keys(t.modules).forEach((function(a){var i=t.modules[a];i.params&&S(e,i.params)}))},useModules:function(e){void 0===e&&(e={});var t=this;t.modules&&Object.keys(t.modules).forEach((function(a){var i=t.modules[a],s=e[a]||{};i.on&&t.on&&Object.keys(i.on).forEach((function(e){t.on(e,i.on[e])})),i.create&&i.create.bind(t)(s)}))}},eventsEmitter:{on:function(e,t,a){var i=this;if(\"function\"!=typeof t)return i;var s=a?\"unshift\":\"push\";return e.split(\" \").forEach((function(e){i.eventsListeners[e]||(i.eventsListeners[e]=[]),i.eventsListeners[e][s](t)})),i},once:function(e,t,a){var i=this;if(\"function\"!=typeof t)return i;function s(){i.off(e,s),s.__emitterProxy&&delete s.__emitterProxy;for(var a=arguments.length,r=new Array(a),n=0;n<a;n++)r[n]=arguments[n];t.apply(i,r)}return s.__emitterProxy=t,i.on(e,s,a)},onAny:function(e,t){var a=this;if(\"function\"!=typeof e)return a;var i=t?\"unshift\":\"push\";return a.eventsAnyListeners.indexOf(e)<0&&a.eventsAnyListeners[i](e),a},offAny:function(e){var t=this;if(!t.eventsAnyListeners)return t;var a=t.eventsAnyListeners.indexOf(e);return a>=0&&t.eventsAnyListeners.splice(a,1),t},off:function(e,t){var a=this;return a.eventsListeners?(e.split(\" \").forEach((function(e){void 0===t?a.eventsListeners[e]=[]:a.eventsListeners[e]&&a.eventsListeners[e].forEach((function(i,s){(i===t||i.__emitterProxy&&i.__emitterProxy===t)&&a.eventsListeners[e].splice(s,1)}))})),a):a},emit:function(){var e,t,a,i=this;if(!i.eventsListeners)return i;for(var s=arguments.length,r=new Array(s),n=0;n<s;n++)r[n]=arguments[n];\"string\"==typeof r[0]||Array.isArray(r[0])?(e=r[0],t=r.slice(1,r.length),a=i):(e=r[0].events,t=r[0].data,a=r[0].context||i),t.unshift(a);var l=Array.isArray(e)?e:e.split(\" \");return l.forEach((function(e){i.eventsAnyListeners&&i.eventsAnyListeners.length&&i.eventsAnyListeners.forEach((function(i){i.apply(a,[e].concat(t))})),i.eventsListeners&&i.eventsListeners[e]&&i.eventsListeners[e].forEach((function(e){e.apply(a,t)}))})),i}},update:{updateSize:function(){var e,t,a=this,i=a.$el;e=void 0!==a.params.width&&null!==a.params.width?a.params.width:i[0].clientWidth,t=void 0!==a.params.height&&null!==a.params.height?a.params.height:i[0].clientHeight,0===e&&a.isHorizontal()||0===t&&a.isVertical()||(e=e-parseInt(i.css(\"padding-left\")||0,10)-parseInt(i.css(\"padding-right\")||0,10),t=t-parseInt(i.css(\"padding-top\")||0,10)-parseInt(i.css(\"padding-bottom\")||0,10),Number.isNaN(e)&&(e=0),Number.isNaN(t)&&(t=0),S(a,{width:e,height:t,size:a.isHorizontal()?e:t}))},updateSlides:function(){var e=this,t=l(),a=e.params,i=e.$wrapperEl,s=e.size,r=e.rtlTranslate,n=e.wrongRTL,o=e.virtual&&a.virtual.enabled,d=o?e.virtual.slides.length:e.slides.length,p=i.children(\".\"+e.params.slideClass),u=o?e.virtual.slides.length:p.length,c=[],h=[],v=[];function f(e,t){return!a.cssMode||t!==p.length-1}var m=a.slidesOffsetBefore;\"function\"==typeof m&&(m=a.slidesOffsetBefore.call(e));var g=a.slidesOffsetAfter;\"function\"==typeof g&&(g=a.slidesOffsetAfter.call(e));var y=e.snapGrid.length,w=e.slidesGrid.length,b=a.spaceBetween,E=-m,x=0,T=0;if(void 0!==s){var C,M;\"string\"==typeof b&&b.indexOf(\"%\")>=0&&(b=parseFloat(b.replace(\"%\",\"\"))/100*s),e.virtualSize=-b,r?p.css({marginLeft:\"\",marginTop:\"\"}):p.css({marginRight:\"\",marginBottom:\"\"}),a.slidesPerColumn>1&&(C=Math.floor(u/a.slidesPerColumn)===u/e.params.slidesPerColumn?u:Math.ceil(u/a.slidesPerColumn)*a.slidesPerColumn,\"auto\"!==a.slidesPerView&&\"row\"===a.slidesPerColumnFill&&(C=Math.max(C,a.slidesPerView*a.slidesPerColumn)));for(var z,P=a.slidesPerColumn,k=C/P,L=Math.floor(u/a.slidesPerColumn),$=0;$<u;$+=1){M=0;var I=p.eq($);if(a.slidesPerColumn>1){var O=void 0,A=void 0,D=void 0;if(\"row\"===a.slidesPerColumnFill&&a.slidesPerGroup>1){var G=Math.floor($/(a.slidesPerGroup*a.slidesPerColumn)),N=$-a.slidesPerColumn*a.slidesPerGroup*G,B=0===G?a.slidesPerGroup:Math.min(Math.ceil((u-G*P*a.slidesPerGroup)/P),a.slidesPerGroup);O=(A=N-(D=Math.floor(N/B))*B+G*a.slidesPerGroup)+D*C/P,I.css({\"-webkit-box-ordinal-group\":O,\"-moz-box-ordinal-group\":O,\"-ms-flex-order\":O,\"-webkit-order\":O,order:O})}else\"column\"===a.slidesPerColumnFill?(D=$-(A=Math.floor($/P))*P,(A>L||A===L&&D===P-1)&&(D+=1)>=P&&(D=0,A+=1)):A=$-(D=Math.floor($/k))*k;I.css(\"margin-\"+(e.isHorizontal()?\"top\":\"left\"),0!==D&&a.spaceBetween&&a.spaceBetween+\"px\")}if(\"none\"!==I.css(\"display\")){if(\"auto\"===a.slidesPerView){var H=t.getComputedStyle(I[0],null),X=I[0].style.transform,Y=I[0].style.webkitTransform;if(X&&(I[0].style.transform=\"none\"),Y&&(I[0].style.webkitTransform=\"none\"),a.roundLengths)M=e.isHorizontal()?I.outerWidth(!0):I.outerHeight(!0);else if(e.isHorizontal()){var V=parseFloat(H.getPropertyValue(\"width\")||0),F=parseFloat(H.getPropertyValue(\"padding-left\")||0),R=parseFloat(H.getPropertyValue(\"padding-right\")||0),W=parseFloat(H.getPropertyValue(\"margin-left\")||0),q=parseFloat(H.getPropertyValue(\"margin-right\")||0),j=H.getPropertyValue(\"box-sizing\");if(j&&\"border-box\"===j)M=V+W+q;else{var _=I[0],U=_.clientWidth;M=V+F+R+W+q+(_.offsetWidth-U)}}else{var K=parseFloat(H.getPropertyValue(\"height\")||0),Z=parseFloat(H.getPropertyValue(\"padding-top\")||0),J=parseFloat(H.getPropertyValue(\"padding-bottom\")||0),Q=parseFloat(H.getPropertyValue(\"margin-top\")||0),ee=parseFloat(H.getPropertyValue(\"margin-bottom\")||0),te=H.getPropertyValue(\"box-sizing\");if(te&&\"border-box\"===te)M=K+Q+ee;else{var ae=I[0],ie=ae.clientHeight;M=K+Z+J+Q+ee+(ae.offsetHeight-ie)}}X&&(I[0].style.transform=X),Y&&(I[0].style.webkitTransform=Y),a.roundLengths&&(M=Math.floor(M))}else M=(s-(a.slidesPerView-1)*b)/a.slidesPerView,a.roundLengths&&(M=Math.floor(M)),p[$]&&(e.isHorizontal()?p[$].style.width=M+\"px\":p[$].style.height=M+\"px\");p[$]&&(p[$].swiperSlideSize=M),v.push(M),a.centeredSlides?(E=E+M/2+x/2+b,0===x&&0!==$&&(E=E-s/2-b),0===$&&(E=E-s/2-b),Math.abs(E)<.001&&(E=0),a.roundLengths&&(E=Math.floor(E)),T%a.slidesPerGroup==0&&c.push(E),h.push(E)):(a.roundLengths&&(E=Math.floor(E)),(T-Math.min(e.params.slidesPerGroupSkip,T))%e.params.slidesPerGroup==0&&c.push(E),h.push(E),E=E+M+b),e.virtualSize+=M+b,x=M,T+=1}}if(e.virtualSize=Math.max(e.virtualSize,s)+g,r&&n&&(\"slide\"===a.effect||\"coverflow\"===a.effect)&&i.css({width:e.virtualSize+a.spaceBetween+\"px\"}),a.setWrapperSize&&(e.isHorizontal()?i.css({width:e.virtualSize+a.spaceBetween+\"px\"}):i.css({height:e.virtualSize+a.spaceBetween+\"px\"})),a.slidesPerColumn>1&&(e.virtualSize=(M+a.spaceBetween)*C,e.virtualSize=Math.ceil(e.virtualSize/a.slidesPerColumn)-a.spaceBetween,e.isHorizontal()?i.css({width:e.virtualSize+a.spaceBetween+\"px\"}):i.css({height:e.virtualSize+a.spaceBetween+\"px\"}),a.centeredSlides)){z=[];for(var se=0;se<c.length;se+=1){var re=c[se];a.roundLengths&&(re=Math.floor(re)),c[se]<e.virtualSize+c[0]&&z.push(re)}c=z}if(!a.centeredSlides){z=[];for(var ne=0;ne<c.length;ne+=1){var le=c[ne];a.roundLengths&&(le=Math.floor(le)),c[ne]<=e.virtualSize-s&&z.push(le)}c=z,Math.floor(e.virtualSize-s)-Math.floor(c[c.length-1])>1&&c.push(e.virtualSize-s)}if(0===c.length&&(c=[0]),0!==a.spaceBetween&&(e.isHorizontal()?r?p.filter(f).css({marginLeft:b+\"px\"}):p.filter(f).css({marginRight:b+\"px\"}):p.filter(f).css({marginBottom:b+\"px\"})),a.centeredSlides&&a.centeredSlidesBounds){var oe=0;v.forEach((function(e){oe+=e+(a.spaceBetween?a.spaceBetween:0)}));var de=(oe-=a.spaceBetween)-s;c=c.map((function(e){return e<0?-m:e>de?de+g:e}))}if(a.centerInsufficientSlides){var pe=0;if(v.forEach((function(e){pe+=e+(a.spaceBetween?a.spaceBetween:0)})),(pe-=a.spaceBetween)<s){var ue=(s-pe)/2;c.forEach((function(e,t){c[t]=e-ue})),h.forEach((function(e,t){h[t]=e+ue}))}}S(e,{slides:p,snapGrid:c,slidesGrid:h,slidesSizesGrid:v}),u!==d&&e.emit(\"slidesLengthChange\"),c.length!==y&&(e.params.watchOverflow&&e.checkOverflow(),e.emit(\"snapGridLengthChange\")),h.length!==w&&e.emit(\"slidesGridLengthChange\"),(a.watchSlidesProgress||a.watchSlidesVisibility)&&e.updateSlidesOffset()}},updateAutoHeight:function(e){var t,a=this,i=[],s=0;if(\"number\"==typeof e?a.setTransition(e):!0===e&&a.setTransition(a.params.speed),\"auto\"!==a.params.slidesPerView&&a.params.slidesPerView>1)if(a.params.centeredSlides)a.visibleSlides.each((function(e){i.push(e)}));else for(t=0;t<Math.ceil(a.params.slidesPerView);t+=1){var r=a.activeIndex+t;if(r>a.slides.length)break;i.push(a.slides.eq(r)[0])}else i.push(a.slides.eq(a.activeIndex)[0]);for(t=0;t<i.length;t+=1)if(void 0!==i[t]){var n=i[t].offsetHeight;s=n>s?n:s}s&&a.$wrapperEl.css(\"height\",s+\"px\")},updateSlidesOffset:function(){for(var e=this.slides,t=0;t<e.length;t+=1)e[t].swiperSlideOffset=this.isHorizontal()?e[t].offsetLeft:e[t].offsetTop},updateSlidesProgress:function(e){void 0===e&&(e=this&&this.translate||0);var t=this,a=t.params,i=t.slides,s=t.rtlTranslate;if(0!==i.length){void 0===i[0].swiperSlideOffset&&t.updateSlidesOffset();var r=-e;s&&(r=e),i.removeClass(a.slideVisibleClass),t.visibleSlidesIndexes=[],t.visibleSlides=[];for(var n=0;n<i.length;n+=1){var l=i[n],o=(r+(a.centeredSlides?t.minTranslate():0)-l.swiperSlideOffset)/(l.swiperSlideSize+a.spaceBetween);if(a.watchSlidesVisibility||a.centeredSlides&&a.autoHeight){var d=-(r-l.swiperSlideOffset),p=d+t.slidesSizesGrid[n];(d>=0&&d<t.size-1||p>1&&p<=t.size||d<=0&&p>=t.size)&&(t.visibleSlides.push(l),t.visibleSlidesIndexes.push(n),i.eq(n).addClass(a.slideVisibleClass))}l.progress=s?-o:o}t.visibleSlides=m(t.visibleSlides)}},updateProgress:function(e){var t=this;if(void 0===e){var a=t.rtlTranslate?-1:1;e=t&&t.translate&&t.translate*a||0}var i=t.params,s=t.maxTranslate()-t.minTranslate(),r=t.progress,n=t.isBeginning,l=t.isEnd,o=n,d=l;0===s?(r=0,n=!0,l=!0):(n=(r=(e-t.minTranslate())/s)<=0,l=r>=1),S(t,{progress:r,isBeginning:n,isEnd:l}),(i.watchSlidesProgress||i.watchSlidesVisibility||i.centeredSlides&&i.autoHeight)&&t.updateSlidesProgress(e),n&&!o&&t.emit(\"reachBeginning toEdge\"),l&&!d&&t.emit(\"reachEnd toEdge\"),(o&&!n||d&&!l)&&t.emit(\"fromEdge\"),t.emit(\"progress\",r)},updateSlidesClasses:function(){var e,t=this,a=t.slides,i=t.params,s=t.$wrapperEl,r=t.activeIndex,n=t.realIndex,l=t.virtual&&i.virtual.enabled;a.removeClass(i.slideActiveClass+\" \"+i.slideNextClass+\" \"+i.slidePrevClass+\" \"+i.slideDuplicateActiveClass+\" \"+i.slideDuplicateNextClass+\" \"+i.slideDuplicatePrevClass),(e=l?t.$wrapperEl.find(\".\"+i.slideClass+'[data-swiper-slide-index=\"'+r+'\"]'):a.eq(r)).addClass(i.slideActiveClass),i.loop&&(e.hasClass(i.slideDuplicateClass)?s.children(\".\"+i.slideClass+\":not(.\"+i.slideDuplicateClass+')[data-swiper-slide-index=\"'+n+'\"]').addClass(i.slideDuplicateActiveClass):s.children(\".\"+i.slideClass+\".\"+i.slideDuplicateClass+'[data-swiper-slide-index=\"'+n+'\"]').addClass(i.slideDuplicateActiveClass));var o=e.nextAll(\".\"+i.slideClass).eq(0).addClass(i.slideNextClass);i.loop&&0===o.length&&(o=a.eq(0)).addClass(i.slideNextClass);var d=e.prevAll(\".\"+i.slideClass).eq(0).addClass(i.slidePrevClass);i.loop&&0===d.length&&(d=a.eq(-1)).addClass(i.slidePrevClass),i.loop&&(o.hasClass(i.slideDuplicateClass)?s.children(\".\"+i.slideClass+\":not(.\"+i.slideDuplicateClass+')[data-swiper-slide-index=\"'+o.attr(\"data-swiper-slide-index\")+'\"]').addClass(i.slideDuplicateNextClass):s.children(\".\"+i.slideClass+\".\"+i.slideDuplicateClass+'[data-swiper-slide-index=\"'+o.attr(\"data-swiper-slide-index\")+'\"]').addClass(i.slideDuplicateNextClass),d.hasClass(i.slideDuplicateClass)?s.children(\".\"+i.slideClass+\":not(.\"+i.slideDuplicateClass+')[data-swiper-slide-index=\"'+d.attr(\"data-swiper-slide-index\")+'\"]').addClass(i.slideDuplicatePrevClass):s.children(\".\"+i.slideClass+\".\"+i.slideDuplicateClass+'[data-swiper-slide-index=\"'+d.attr(\"data-swiper-slide-index\")+'\"]').addClass(i.slideDuplicatePrevClass)),t.emitSlidesClasses()},updateActiveIndex:function(e){var t,a=this,i=a.rtlTranslate?a.translate:-a.translate,s=a.slidesGrid,r=a.snapGrid,n=a.params,l=a.activeIndex,o=a.realIndex,d=a.snapIndex,p=e;if(void 0===p){for(var u=0;u<s.length;u+=1)void 0!==s[u+1]?i>=s[u]&&i<s[u+1]-(s[u+1]-s[u])/2?p=u:i>=s[u]&&i<s[u+1]&&(p=u+1):i>=s[u]&&(p=u);n.normalizeSlideIndex&&(p<0||void 0===p)&&(p=0)}if(r.indexOf(i)>=0)t=r.indexOf(i);else{var c=Math.min(n.slidesPerGroupSkip,p);t=c+Math.floor((p-c)/n.slidesPerGroup)}if(t>=r.length&&(t=r.length-1),p!==l){var h=parseInt(a.slides.eq(p).attr(\"data-swiper-slide-index\")||p,10);S(a,{snapIndex:t,realIndex:h,previousIndex:l,activeIndex:p}),a.emit(\"activeIndexChange\"),a.emit(\"snapIndexChange\"),o!==h&&a.emit(\"realIndexChange\"),(a.initialized||a.params.runCallbacksOnInit)&&a.emit(\"slideChange\")}else t!==d&&(a.snapIndex=t,a.emit(\"snapIndexChange\"))},updateClickedSlide:function(e){var t=this,a=t.params,i=m(e.target).closest(\".\"+a.slideClass)[0],s=!1;if(i)for(var r=0;r<t.slides.length;r+=1)t.slides[r]===i&&(s=!0);if(!i||!s)return t.clickedSlide=void 0,void(t.clickedIndex=void 0);t.clickedSlide=i,t.virtual&&t.params.virtual.enabled?t.clickedIndex=parseInt(m(i).attr(\"data-swiper-slide-index\"),10):t.clickedIndex=m(i).index(),a.slideToClickedSlide&&void 0!==t.clickedIndex&&t.clickedIndex!==t.activeIndex&&t.slideToClickedSlide()}},translate:{getTranslate:function(e){void 0===e&&(e=this.isHorizontal()?\"x\":\"y\");var t=this,a=t.params,i=t.rtlTranslate,s=t.translate,r=t.$wrapperEl;if(a.virtualTranslate)return i?-s:s;if(a.cssMode)return s;var n=T(r[0],e);return i&&(n=-n),n||0},setTranslate:function(e,t){var a=this,i=a.rtlTranslate,s=a.params,r=a.$wrapperEl,n=a.wrapperEl,l=a.progress,o=0,d=0;a.isHorizontal()?o=i?-e:e:d=e,s.roundLengths&&(o=Math.floor(o),d=Math.floor(d)),s.cssMode?n[a.isHorizontal()?\"scrollLeft\":\"scrollTop\"]=a.isHorizontal()?-o:-d:s.virtualTranslate||r.transform(\"translate3d(\"+o+\"px, \"+d+\"px, 0px)\"),a.previousTranslate=a.translate,a.translate=a.isHorizontal()?o:d;var p=a.maxTranslate()-a.minTranslate();(0===p?0:(e-a.minTranslate())/p)!==l&&a.updateProgress(e),a.emit(\"setTranslate\",a.translate,t)},minTranslate:function(){return-this.snapGrid[0]},maxTranslate:function(){return-this.snapGrid[this.snapGrid.length-1]},translateTo:function(e,t,a,i,s){void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0),void 0===i&&(i=!0);var r=this,n=r.params,l=r.wrapperEl;if(r.animating&&n.preventInteractionOnTransition)return!1;var o,d=r.minTranslate(),p=r.maxTranslate();if(o=i&&e>d?d:i&&e<p?p:e,r.updateProgress(o),n.cssMode){var u,c=r.isHorizontal();if(0===t)l[c?\"scrollLeft\":\"scrollTop\"]=-o;else if(l.scrollTo)l.scrollTo(((u={})[c?\"left\":\"top\"]=-o,u.behavior=\"smooth\",u));else l[c?\"scrollLeft\":\"scrollTop\"]=-o;return!0}return 0===t?(r.setTransition(0),r.setTranslate(o),a&&(r.emit(\"beforeTransitionStart\",t,s),r.emit(\"transitionEnd\"))):(r.setTransition(t),r.setTranslate(o),a&&(r.emit(\"beforeTransitionStart\",t,s),r.emit(\"transitionStart\")),r.animating||(r.animating=!0,r.onTranslateToWrapperTransitionEnd||(r.onTranslateToWrapperTransitionEnd=function(e){r&&!r.destroyed&&e.target===this&&(r.$wrapperEl[0].removeEventListener(\"transitionend\",r.onTranslateToWrapperTransitionEnd),r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\",r.onTranslateToWrapperTransitionEnd),r.onTranslateToWrapperTransitionEnd=null,delete r.onTranslateToWrapperTransitionEnd,a&&r.emit(\"transitionEnd\"))}),r.$wrapperEl[0].addEventListener(\"transitionend\",r.onTranslateToWrapperTransitionEnd),r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\",r.onTranslateToWrapperTransitionEnd))),!0}},transition:{setTransition:function(e,t){var a=this;a.params.cssMode||a.$wrapperEl.transition(e),a.emit(\"setTransition\",e,t)},transitionStart:function(e,t){void 0===e&&(e=!0);var a=this,i=a.activeIndex,s=a.params,r=a.previousIndex;if(!s.cssMode){s.autoHeight&&a.updateAutoHeight();var n=t;if(n||(n=i>r?\"next\":i<r?\"prev\":\"reset\"),a.emit(\"transitionStart\"),e&&i!==r){if(\"reset\"===n)return void a.emit(\"slideResetTransitionStart\");a.emit(\"slideChangeTransitionStart\"),\"next\"===n?a.emit(\"slideNextTransitionStart\"):a.emit(\"slidePrevTransitionStart\")}}},transitionEnd:function(e,t){void 0===e&&(e=!0);var a=this,i=a.activeIndex,s=a.previousIndex,r=a.params;if(a.animating=!1,!r.cssMode){a.setTransition(0);var n=t;if(n||(n=i>s?\"next\":i<s?\"prev\":\"reset\"),a.emit(\"transitionEnd\"),e&&i!==s){if(\"reset\"===n)return void a.emit(\"slideResetTransitionEnd\");a.emit(\"slideChangeTransitionEnd\"),\"next\"===n?a.emit(\"slideNextTransitionEnd\"):a.emit(\"slidePrevTransitionEnd\")}}}},slide:{slideTo:function(e,t,a,i){if(void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0),\"number\"!=typeof e&&\"string\"!=typeof e)throw new Error(\"The 'index' argument cannot have type other than 'number' or 'string'. [\"+typeof e+\"] given.\");if(\"string\"==typeof e){var s=parseInt(e,10);if(!isFinite(s))throw new Error(\"The passed-in 'index' (string) couldn't be converted to 'number'. [\"+e+\"] given.\");e=s}var r=this,n=e;n<0&&(n=0);var l=r.params,o=r.snapGrid,d=r.slidesGrid,p=r.previousIndex,u=r.activeIndex,c=r.rtlTranslate,h=r.wrapperEl;if(r.animating&&l.preventInteractionOnTransition)return!1;var v=Math.min(r.params.slidesPerGroupSkip,n),f=v+Math.floor((n-v)/r.params.slidesPerGroup);f>=o.length&&(f=o.length-1),(u||l.initialSlide||0)===(p||0)&&a&&r.emit(\"beforeSlideChangeStart\");var m,g=-o[f];if(r.updateProgress(g),l.normalizeSlideIndex)for(var y=0;y<d.length;y+=1)-Math.floor(100*g)>=Math.floor(100*d[y])&&(n=y);if(r.initialized&&n!==u){if(!r.allowSlideNext&&g<r.translate&&g<r.minTranslate())return!1;if(!r.allowSlidePrev&&g>r.translate&&g>r.maxTranslate()&&(u||0)!==n)return!1}if(m=n>u?\"next\":n<u?\"prev\":\"reset\",c&&-g===r.translate||!c&&g===r.translate)return r.updateActiveIndex(n),l.autoHeight&&r.updateAutoHeight(),r.updateSlidesClasses(),\"slide\"!==l.effect&&r.setTranslate(g),\"reset\"!==m&&(r.transitionStart(a,m),r.transitionEnd(a,m)),!1;if(l.cssMode){var w,b=r.isHorizontal(),E=-g;if(c&&(E=h.scrollWidth-h.offsetWidth-E),0===t)h[b?\"scrollLeft\":\"scrollTop\"]=E;else if(h.scrollTo)h.scrollTo(((w={})[b?\"left\":\"top\"]=E,w.behavior=\"smooth\",w));else h[b?\"scrollLeft\":\"scrollTop\"]=E;return!0}return 0===t?(r.setTransition(0),r.setTranslate(g),r.updateActiveIndex(n),r.updateSlidesClasses(),r.emit(\"beforeTransitionStart\",t,i),r.transitionStart(a,m),r.transitionEnd(a,m)):(r.setTransition(t),r.setTranslate(g),r.updateActiveIndex(n),r.updateSlidesClasses(),r.emit(\"beforeTransitionStart\",t,i),r.transitionStart(a,m),r.animating||(r.animating=!0,r.onSlideToWrapperTransitionEnd||(r.onSlideToWrapperTransitionEnd=function(e){r&&!r.destroyed&&e.target===this&&(r.$wrapperEl[0].removeEventListener(\"transitionend\",r.onSlideToWrapperTransitionEnd),r.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\",r.onSlideToWrapperTransitionEnd),r.onSlideToWrapperTransitionEnd=null,delete r.onSlideToWrapperTransitionEnd,r.transitionEnd(a,m))}),r.$wrapperEl[0].addEventListener(\"transitionend\",r.onSlideToWrapperTransitionEnd),r.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\",r.onSlideToWrapperTransitionEnd))),!0},slideToLoop:function(e,t,a,i){void 0===e&&(e=0),void 0===t&&(t=this.params.speed),void 0===a&&(a=!0);var s=this,r=e;return s.params.loop&&(r+=s.loopedSlides),s.slideTo(r,t,a,i)},slideNext:function(e,t,a){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0);var i=this,s=i.params,r=i.animating,n=i.activeIndex<s.slidesPerGroupSkip?1:s.slidesPerGroup;if(s.loop){if(r&&s.loopPreventsSlide)return!1;i.loopFix(),i._clientLeft=i.$wrapperEl[0].clientLeft}return i.slideTo(i.activeIndex+n,e,t,a)},slidePrev:function(e,t,a){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0);var i=this,s=i.params,r=i.animating,n=i.snapGrid,l=i.slidesGrid,o=i.rtlTranslate;if(s.loop){if(r&&s.loopPreventsSlide)return!1;i.loopFix(),i._clientLeft=i.$wrapperEl[0].clientLeft}function d(e){return e<0?-Math.floor(Math.abs(e)):Math.floor(e)}var p,u=d(o?i.translate:-i.translate),c=n.map((function(e){return d(e)})),h=(n[c.indexOf(u)],n[c.indexOf(u)-1]);return void 0===h&&s.cssMode&&n.forEach((function(e){!h&&u>=e&&(h=e)})),void 0!==h&&(p=l.indexOf(h))<0&&(p=i.activeIndex-1),i.slideTo(p,e,t,a)},slideReset:function(e,t,a){return void 0===e&&(e=this.params.speed),void 0===t&&(t=!0),this.slideTo(this.activeIndex,e,t,a)},slideToClosest:function(e,t,a,i){void 0===e&&(e=this.params.speed),void 0===t&&(t=!0),void 0===i&&(i=.5);var s=this,r=s.activeIndex,n=Math.min(s.params.slidesPerGroupSkip,r),l=n+Math.floor((r-n)/s.params.slidesPerGroup),o=s.rtlTranslate?s.translate:-s.translate;if(o>=s.snapGrid[l]){var d=s.snapGrid[l];o-d>(s.snapGrid[l+1]-d)*i&&(r+=s.params.slidesPerGroup)}else{var p=s.snapGrid[l-1];o-p<=(s.snapGrid[l]-p)*i&&(r-=s.params.slidesPerGroup)}return r=Math.max(r,0),r=Math.min(r,s.slidesGrid.length-1),s.slideTo(r,e,t,a)},slideToClickedSlide:function(){var e,t=this,a=t.params,i=t.$wrapperEl,s=\"auto\"===a.slidesPerView?t.slidesPerViewDynamic():a.slidesPerView,r=t.clickedIndex;if(a.loop){if(t.animating)return;e=parseInt(m(t.clickedSlide).attr(\"data-swiper-slide-index\"),10),a.centeredSlides?r<t.loopedSlides-s/2||r>t.slides.length-t.loopedSlides+s/2?(t.loopFix(),r=i.children(\".\"+a.slideClass+'[data-swiper-slide-index=\"'+e+'\"]:not(.'+a.slideDuplicateClass+\")\").eq(0).index(),E((function(){t.slideTo(r)}))):t.slideTo(r):r>t.slides.length-s?(t.loopFix(),r=i.children(\".\"+a.slideClass+'[data-swiper-slide-index=\"'+e+'\"]:not(.'+a.slideDuplicateClass+\")\").eq(0).index(),E((function(){t.slideTo(r)}))):t.slideTo(r)}else t.slideTo(r)}},loop:{loopCreate:function(){var e=this,t=r(),a=e.params,i=e.$wrapperEl;i.children(\".\"+a.slideClass+\".\"+a.slideDuplicateClass).remove();var s=i.children(\".\"+a.slideClass);if(a.loopFillGroupWithBlank){var n=a.slidesPerGroup-s.length%a.slidesPerGroup;if(n!==a.slidesPerGroup){for(var l=0;l<n;l+=1){var o=m(t.createElement(\"div\")).addClass(a.slideClass+\" \"+a.slideBlankClass);i.append(o)}s=i.children(\".\"+a.slideClass)}}\"auto\"!==a.slidesPerView||a.loopedSlides||(a.loopedSlides=s.length),e.loopedSlides=Math.ceil(parseFloat(a.loopedSlides||a.slidesPerView,10)),e.loopedSlides+=a.loopAdditionalSlides,e.loopedSlides>s.length&&(e.loopedSlides=s.length);var d=[],p=[];s.each((function(t,a){var i=m(t);a<e.loopedSlides&&p.push(t),a<s.length&&a>=s.length-e.loopedSlides&&d.push(t),i.attr(\"data-swiper-slide-index\",a)}));for(var u=0;u<p.length;u+=1)i.append(m(p[u].cloneNode(!0)).addClass(a.slideDuplicateClass));for(var c=d.length-1;c>=0;c-=1)i.prepend(m(d[c].cloneNode(!0)).addClass(a.slideDuplicateClass))},loopFix:function(){var e=this;e.emit(\"beforeLoopFix\");var t,a=e.activeIndex,i=e.slides,s=e.loopedSlides,r=e.allowSlidePrev,n=e.allowSlideNext,l=e.snapGrid,o=e.rtlTranslate;e.allowSlidePrev=!0,e.allowSlideNext=!0;var d=-l[a]-e.getTranslate();if(a<s)t=i.length-3*s+a,t+=s,e.slideTo(t,0,!1,!0)&&0!==d&&e.setTranslate((o?-e.translate:e.translate)-d);else if(a>=i.length-s){t=-i.length+a+s,t+=s,e.slideTo(t,0,!1,!0)&&0!==d&&e.setTranslate((o?-e.translate:e.translate)-d)}e.allowSlidePrev=r,e.allowSlideNext=n,e.emit(\"loopFix\")},loopDestroy:function(){var e=this,t=e.$wrapperEl,a=e.params,i=e.slides;t.children(\".\"+a.slideClass+\".\"+a.slideDuplicateClass+\",.\"+a.slideClass+\".\"+a.slideBlankClass).remove(),i.removeAttr(\"data-swiper-slide-index\")}},grabCursor:{setGrabCursor:function(e){var t=this;if(!(t.support.touch||!t.params.simulateTouch||t.params.watchOverflow&&t.isLocked||t.params.cssMode)){var a=t.el;a.style.cursor=\"move\",a.style.cursor=e?\"-webkit-grabbing\":\"-webkit-grab\",a.style.cursor=e?\"-moz-grabbin\":\"-moz-grab\",a.style.cursor=e?\"grabbing\":\"grab\"}},unsetGrabCursor:function(){var e=this;e.support.touch||e.params.watchOverflow&&e.isLocked||e.params.cssMode||(e.el.style.cursor=\"\")}},manipulation:{appendSlide:function(e){var t=this,a=t.$wrapperEl,i=t.params;if(i.loop&&t.loopDestroy(),\"object\"==typeof e&&\"length\"in e)for(var s=0;s<e.length;s+=1)e[s]&&a.append(e[s]);else a.append(e);i.loop&&t.loopCreate(),i.observer&&t.support.observer||t.update()},prependSlide:function(e){var t=this,a=t.params,i=t.$wrapperEl,s=t.activeIndex;a.loop&&t.loopDestroy();var r=s+1;if(\"object\"==typeof e&&\"length\"in e){for(var n=0;n<e.length;n+=1)e[n]&&i.prepend(e[n]);r=s+e.length}else i.prepend(e);a.loop&&t.loopCreate(),a.observer&&t.support.observer||t.update(),t.slideTo(r,0,!1)},addSlide:function(e,t){var a=this,i=a.$wrapperEl,s=a.params,r=a.activeIndex;s.loop&&(r-=a.loopedSlides,a.loopDestroy(),a.slides=i.children(\".\"+s.slideClass));var n=a.slides.length;if(e<=0)a.prependSlide(t);else if(e>=n)a.appendSlide(t);else{for(var l=r>e?r+1:r,o=[],d=n-1;d>=e;d-=1){var p=a.slides.eq(d);p.remove(),o.unshift(p)}if(\"object\"==typeof t&&\"length\"in t){for(var u=0;u<t.length;u+=1)t[u]&&i.append(t[u]);l=r>e?r+t.length:r}else i.append(t);for(var c=0;c<o.length;c+=1)i.append(o[c]);s.loop&&a.loopCreate(),s.observer&&a.support.observer||a.update(),s.loop?a.slideTo(l+a.loopedSlides,0,!1):a.slideTo(l,0,!1)}},removeSlide:function(e){var t=this,a=t.params,i=t.$wrapperEl,s=t.activeIndex;a.loop&&(s-=t.loopedSlides,t.loopDestroy(),t.slides=i.children(\".\"+a.slideClass));var r,n=s;if(\"object\"==typeof e&&\"length\"in e){for(var l=0;l<e.length;l+=1)r=e[l],t.slides[r]&&t.slides.eq(r).remove(),r<n&&(n-=1);n=Math.max(n,0)}else r=e,t.slides[r]&&t.slides.eq(r).remove(),r<n&&(n-=1),n=Math.max(n,0);a.loop&&t.loopCreate(),a.observer&&t.support.observer||t.update(),a.loop?t.slideTo(n+t.loopedSlides,0,!1):t.slideTo(n,0,!1)},removeAllSlides:function(){for(var e=[],t=0;t<this.slides.length;t+=1)e.push(t);this.removeSlide(e)}},events:{attachEvents:function(){var e=this,t=r(),a=e.params,i=e.touchEvents,s=e.el,n=e.wrapperEl,l=e.device,o=e.support;e.onTouchStart=O.bind(e),e.onTouchMove=A.bind(e),e.onTouchEnd=D.bind(e),a.cssMode&&(e.onScroll=B.bind(e)),e.onClick=N.bind(e);var d=!!a.nested;if(!o.touch&&o.pointerEvents)s.addEventListener(i.start,e.onTouchStart,!1),t.addEventListener(i.move,e.onTouchMove,d),t.addEventListener(i.end,e.onTouchEnd,!1);else{if(o.touch){var p=!(\"touchstart\"!==i.start||!o.passiveListener||!a.passiveListeners)&&{passive:!0,capture:!1};s.addEventListener(i.start,e.onTouchStart,p),s.addEventListener(i.move,e.onTouchMove,o.passiveListener?{passive:!1,capture:d}:d),s.addEventListener(i.end,e.onTouchEnd,p),i.cancel&&s.addEventListener(i.cancel,e.onTouchEnd,p),H||(t.addEventListener(\"touchstart\",X),H=!0)}(a.simulateTouch&&!l.ios&&!l.android||a.simulateTouch&&!o.touch&&l.ios)&&(s.addEventListener(\"mousedown\",e.onTouchStart,!1),t.addEventListener(\"mousemove\",e.onTouchMove,d),t.addEventListener(\"mouseup\",e.onTouchEnd,!1))}(a.preventClicks||a.preventClicksPropagation)&&s.addEventListener(\"click\",e.onClick,!0),a.cssMode&&n.addEventListener(\"scroll\",e.onScroll),a.updateOnWindowResize?e.on(l.ios||l.android?\"resize orientationchange observerUpdate\":\"resize observerUpdate\",G,!0):e.on(\"observerUpdate\",G,!0)},detachEvents:function(){var e=this,t=r(),a=e.params,i=e.touchEvents,s=e.el,n=e.wrapperEl,l=e.device,o=e.support,d=!!a.nested;if(!o.touch&&o.pointerEvents)s.removeEventListener(i.start,e.onTouchStart,!1),t.removeEventListener(i.move,e.onTouchMove,d),t.removeEventListener(i.end,e.onTouchEnd,!1);else{if(o.touch){var p=!(\"onTouchStart\"!==i.start||!o.passiveListener||!a.passiveListeners)&&{passive:!0,capture:!1};s.removeEventListener(i.start,e.onTouchStart,p),s.removeEventListener(i.move,e.onTouchMove,d),s.removeEventListener(i.end,e.onTouchEnd,p),i.cancel&&s.removeEventListener(i.cancel,e.onTouchEnd,p)}(a.simulateTouch&&!l.ios&&!l.android||a.simulateTouch&&!o.touch&&l.ios)&&(s.removeEventListener(\"mousedown\",e.onTouchStart,!1),t.removeEventListener(\"mousemove\",e.onTouchMove,d),t.removeEventListener(\"mouseup\",e.onTouchEnd,!1))}(a.preventClicks||a.preventClicksPropagation)&&s.removeEventListener(\"click\",e.onClick,!0),a.cssMode&&n.removeEventListener(\"scroll\",e.onScroll),e.off(l.ios||l.android?\"resize orientationchange observerUpdate\":\"resize observerUpdate\",G)}},breakpoints:{setBreakpoint:function(){var e=this,t=e.activeIndex,a=e.initialized,i=e.loopedSlides,s=void 0===i?0:i,r=e.params,n=e.$el,l=r.breakpoints;if(l&&(!l||0!==Object.keys(l).length)){var o=e.getBreakpoint(l);if(o&&e.currentBreakpoint!==o){var d=o in l?l[o]:void 0;d&&[\"slidesPerView\",\"spaceBetween\",\"slidesPerGroup\",\"slidesPerGroupSkip\",\"slidesPerColumn\"].forEach((function(e){var t=d[e];void 0!==t&&(d[e]=\"slidesPerView\"!==e||\"AUTO\"!==t&&\"auto\"!==t?\"slidesPerView\"===e?parseFloat(t):parseInt(t,10):\"auto\")}));var p=d||e.originalParams,u=r.slidesPerColumn>1,c=p.slidesPerColumn>1;u&&!c?(n.removeClass(r.containerModifierClass+\"multirow \"+r.containerModifierClass+\"multirow-column\"),e.emitContainerClasses()):!u&&c&&(n.addClass(r.containerModifierClass+\"multirow\"),\"column\"===p.slidesPerColumnFill&&n.addClass(r.containerModifierClass+\"multirow-column\"),e.emitContainerClasses());var h=p.direction&&p.direction!==r.direction,v=r.loop&&(p.slidesPerView!==r.slidesPerView||h);h&&a&&e.changeDirection(),S(e.params,p),S(e,{allowTouchMove:e.params.allowTouchMove,allowSlideNext:e.params.allowSlideNext,allowSlidePrev:e.params.allowSlidePrev}),e.currentBreakpoint=o,e.emit(\"_beforeBreakpoint\",p),v&&a&&(e.loopDestroy(),e.loopCreate(),e.updateSlides(),e.slideTo(t-s+e.loopedSlides,0,!1)),e.emit(\"breakpoint\",p)}}},getBreakpoint:function(e){var t=l();if(e){var a=!1,i=Object.keys(e).map((function(e){if(\"string\"==typeof e&&0===e.indexOf(\"@\")){var a=parseFloat(e.substr(1));return{value:t.innerHeight*a,point:e}}return{value:e,point:e}}));i.sort((function(e,t){return parseInt(e.value,10)-parseInt(t.value,10)}));for(var s=0;s<i.length;s+=1){var r=i[s],n=r.point;r.value<=t.innerWidth&&(a=n)}return a||\"max\"}}},checkOverflow:{checkOverflow:function(){var e=this,t=e.params,a=e.isLocked,i=e.slides.length>0&&t.slidesOffsetBefore+t.spaceBetween*(e.slides.length-1)+e.slides[0].offsetWidth*e.slides.length;t.slidesOffsetBefore&&t.slidesOffsetAfter&&i?e.isLocked=i<=e.size:e.isLocked=1===e.snapGrid.length,e.allowSlideNext=!e.isLocked,e.allowSlidePrev=!e.isLocked,a!==e.isLocked&&e.emit(e.isLocked?\"lock\":\"unlock\"),a&&a!==e.isLocked&&(e.isEnd=!1,e.navigation&&e.navigation.update())}},classes:{addClasses:function(){var e=this,t=e.classNames,a=e.params,i=e.rtl,s=e.$el,r=e.device,n=[];n.push(\"initialized\"),n.push(a.direction),a.freeMode&&n.push(\"free-mode\"),a.autoHeight&&n.push(\"autoheight\"),i&&n.push(\"rtl\"),a.slidesPerColumn>1&&(n.push(\"multirow\"),\"column\"===a.slidesPerColumnFill&&n.push(\"multirow-column\")),r.android&&n.push(\"android\"),r.ios&&n.push(\"ios\"),a.cssMode&&n.push(\"css-mode\"),n.forEach((function(e){t.push(a.containerModifierClass+e)})),s.addClass(t.join(\" \")),e.emitContainerClasses()},removeClasses:function(){var e=this,t=e.$el,a=e.classNames;t.removeClass(a.join(\" \")),e.emitContainerClasses()}},images:{loadImage:function(e,t,a,i,s,r){var n,o=l();function d(){r&&r()}m(e).parent(\"picture\")[0]||e.complete&&s?d():t?((n=new o.Image).onload=d,n.onerror=d,i&&(n.sizes=i),a&&(n.srcset=a),t&&(n.src=t)):d()},preloadImages:function(){var e=this;function t(){null!=e&&e&&!e.destroyed&&(void 0!==e.imagesLoaded&&(e.imagesLoaded+=1),e.imagesLoaded===e.imagesToLoad.length&&(e.params.updateOnImagesReady&&e.update(),e.emit(\"imagesReady\")))}e.imagesToLoad=e.$el.find(\"img\");for(var a=0;a<e.imagesToLoad.length;a+=1){var i=e.imagesToLoad[a];e.loadImage(i,i.currentSrc||i.getAttribute(\"src\"),i.srcset||i.getAttribute(\"srcset\"),i.sizes||i.getAttribute(\"sizes\"),!0,t)}}}},F={},R=function(){function t(){for(var e,a,i=arguments.length,s=new Array(i),r=0;r<i;r++)s[r]=arguments[r];1===s.length&&s[0].constructor&&s[0].constructor===Object?a=s[0]:(e=s[0],a=s[1]),a||(a={}),a=S({},a),e&&!a.el&&(a.el=e);var n=this;n.support=z(),n.device=P({userAgent:a.userAgent}),n.browser=k(),n.eventsListeners={},n.eventsAnyListeners=[],void 0===n.modules&&(n.modules={}),Object.keys(n.modules).forEach((function(e){var t=n.modules[e];if(t.params){var i=Object.keys(t.params)[0],s=t.params[i];if(\"object\"!=typeof s||null===s)return;if(!(i in a)||!(\"enabled\"in s))return;!0===a[i]&&(a[i]={enabled:!0}),\"object\"!=typeof a[i]||\"enabled\"in a[i]||(a[i].enabled=!0),a[i]||(a[i]={enabled:!1})}}));var l=S({},Y);n.useParams(l),n.params=S({},l,F,a),n.originalParams=S({},n.params),n.passedParams=S({},a),n.params&&n.params.on&&Object.keys(n.params.on).forEach((function(e){n.on(e,n.params.on[e])})),n.params&&n.params.onAny&&n.onAny(n.params.onAny),n.$=m;var o=m(n.params.el);if(e=o[0]){if(o.length>1){var d=[];return o.each((function(e){var i=S({},a,{el:e});d.push(new t(i))})),d}var p,u,c;return e.swiper=n,e&&e.shadowRoot&&e.shadowRoot.querySelector?(p=m(e.shadowRoot.querySelector(\".\"+n.params.wrapperClass))).children=function(e){return o.children(e)}:p=o.children(\".\"+n.params.wrapperClass),S(n,{$el:o,el:e,$wrapperEl:p,wrapperEl:p[0],classNames:[],slides:m(),slidesGrid:[],snapGrid:[],slidesSizesGrid:[],isHorizontal:function(){return\"horizontal\"===n.params.direction},isVertical:function(){return\"vertical\"===n.params.direction},rtl:\"rtl\"===e.dir.toLowerCase()||\"rtl\"===o.css(\"direction\"),rtlTranslate:\"horizontal\"===n.params.direction&&(\"rtl\"===e.dir.toLowerCase()||\"rtl\"===o.css(\"direction\")),wrongRTL:\"-webkit-box\"===p.css(\"display\"),activeIndex:0,realIndex:0,isBeginning:!0,isEnd:!1,translate:0,previousTranslate:0,progress:0,velocity:0,animating:!1,allowSlideNext:n.params.allowSlideNext,allowSlidePrev:n.params.allowSlidePrev,touchEvents:(u=[\"touchstart\",\"touchmove\",\"touchend\",\"touchcancel\"],c=[\"mousedown\",\"mousemove\",\"mouseup\"],n.support.pointerEvents&&(c=[\"pointerdown\",\"pointermove\",\"pointerup\"]),n.touchEventsTouch={start:u[0],move:u[1],end:u[2],cancel:u[3]},n.touchEventsDesktop={start:c[0],move:c[1],end:c[2]},n.support.touch||!n.params.simulateTouch?n.touchEventsTouch:n.touchEventsDesktop),touchEventsData:{isTouched:void 0,isMoved:void 0,allowTouchCallbacks:void 0,touchStartTime:void 0,isScrolling:void 0,currentTranslate:void 0,startTranslate:void 0,allowThresholdMove:void 0,formElements:\"input, select, option, textarea, button, video, label\",lastClickTime:x(),clickTimeout:void 0,velocities:[],allowMomentumBounce:void 0,isTouchEvent:void 0,startMoving:void 0},allowClick:!0,allowTouchMove:n.params.allowTouchMove,touches:{startX:0,startY:0,currentX:0,currentY:0,diff:0},imagesToLoad:[],imagesLoaded:0}),n.useModules(),n.emit(\"_swiper\"),n.params.init&&n.init(),n}}var a,i,s,r=t.prototype;return r.emitContainerClasses=function(){var e=this;if(e.params._emitClasses&&e.el){var t=e.el.className.split(\" \").filter((function(t){return 0===t.indexOf(\"swiper-container\")||0===t.indexOf(e.params.containerModifierClass)}));e.emit(\"_containerClasses\",t.join(\" \"))}},r.getSlideClasses=function(e){var t=this;return e.className.split(\" \").filter((function(e){return 0===e.indexOf(\"swiper-slide\")||0===e.indexOf(t.params.slideClass)})).join(\" \")},r.emitSlidesClasses=function(){var e=this;e.params._emitClasses&&e.el&&e.slides.each((function(t){var a=e.getSlideClasses(t);e.emit(\"_slideClass\",t,a)}))},r.slidesPerViewDynamic=function(){var e=this,t=e.params,a=e.slides,i=e.slidesGrid,s=e.size,r=e.activeIndex,n=1;if(t.centeredSlides){for(var l,o=a[r].swiperSlideSize,d=r+1;d<a.length;d+=1)a[d]&&!l&&(n+=1,(o+=a[d].swiperSlideSize)>s&&(l=!0));for(var p=r-1;p>=0;p-=1)a[p]&&!l&&(n+=1,(o+=a[p].swiperSlideSize)>s&&(l=!0))}else for(var u=r+1;u<a.length;u+=1)i[u]-i[r]<s&&(n+=1);return n},r.update=function(){var e=this;if(e&&!e.destroyed){var t=e.snapGrid,a=e.params;a.breakpoints&&e.setBreakpoint(),e.updateSize(),e.updateSlides(),e.updateProgress(),e.updateSlidesClasses(),e.params.freeMode?(i(),e.params.autoHeight&&e.updateAutoHeight()):((\"auto\"===e.params.slidesPerView||e.params.slidesPerView>1)&&e.isEnd&&!e.params.centeredSlides?e.slideTo(e.slides.length-1,0,!1,!0):e.slideTo(e.activeIndex,0,!1,!0))||i(),a.watchOverflow&&t!==e.snapGrid&&e.checkOverflow(),e.emit(\"update\")}function i(){var t=e.rtlTranslate?-1*e.translate:e.translate,a=Math.min(Math.max(t,e.maxTranslate()),e.minTranslate());e.setTranslate(a),e.updateActiveIndex(),e.updateSlidesClasses()}},r.changeDirection=function(e,t){void 0===t&&(t=!0);var a=this,i=a.params.direction;return e||(e=\"horizontal\"===i?\"vertical\":\"horizontal\"),e===i||\"horizontal\"!==e&&\"vertical\"!==e||(a.$el.removeClass(\"\"+a.params.containerModifierClass+i).addClass(\"\"+a.params.containerModifierClass+e),a.emitContainerClasses(),a.params.direction=e,a.slides.each((function(t){\"vertical\"===e?t.style.width=\"\":t.style.height=\"\"})),a.emit(\"changeDirection\"),t&&a.update()),a},r.init=function(){var e=this;e.initialized||(e.emit(\"beforeInit\"),e.params.breakpoints&&e.setBreakpoint(),e.addClasses(),e.params.loop&&e.loopCreate(),e.updateSize(),e.updateSlides(),e.params.watchOverflow&&e.checkOverflow(),e.params.grabCursor&&e.setGrabCursor(),e.params.preloadImages&&e.preloadImages(),e.params.loop?e.slideTo(e.params.initialSlide+e.loopedSlides,0,e.params.runCallbacksOnInit):e.slideTo(e.params.initialSlide,0,e.params.runCallbacksOnInit),e.attachEvents(),e.initialized=!0,e.emit(\"init\"),e.emit(\"afterInit\"))},r.destroy=function(e,t){void 0===e&&(e=!0),void 0===t&&(t=!0);var a,i=this,s=i.params,r=i.$el,n=i.$wrapperEl,l=i.slides;return void 0===i.params||i.destroyed||(i.emit(\"beforeDestroy\"),i.initialized=!1,i.detachEvents(),s.loop&&i.loopDestroy(),t&&(i.removeClasses(),r.removeAttr(\"style\"),n.removeAttr(\"style\"),l&&l.length&&l.removeClass([s.slideVisibleClass,s.slideActiveClass,s.slideNextClass,s.slidePrevClass].join(\" \")).removeAttr(\"style\").removeAttr(\"data-swiper-slide-index\")),i.emit(\"destroy\"),Object.keys(i.eventsListeners).forEach((function(e){i.off(e)})),!1!==e&&(i.$el[0].swiper=null,a=i,Object.keys(a).forEach((function(e){try{a[e]=null}catch(e){}try{delete a[e]}catch(e){}}))),i.destroyed=!0),null},t.extendDefaults=function(e){S(F,e)},t.installModule=function(e){t.prototype.modules||(t.prototype.modules={});var a=e.name||Object.keys(t.prototype.modules).length+\"_\"+x();t.prototype.modules[a]=e},t.use=function(e){return Array.isArray(e)?(e.forEach((function(e){return t.installModule(e)})),t):(t.installModule(e),t)},a=t,s=[{key:\"extendedDefaults\",get:function(){return F}},{key:\"defaults\",get:function(){return Y}}],(i=null)&&e(a.prototype,i),s&&e(a,s),t}();Object.keys(V).forEach((function(e){Object.keys(V[e]).forEach((function(t){R.prototype[t]=V[e][t]}))})),R.use([L,I]);var W={update:function(e){var t=this,a=t.params,i=a.slidesPerView,s=a.slidesPerGroup,r=a.centeredSlides,n=t.params.virtual,l=n.addSlidesBefore,o=n.addSlidesAfter,d=t.virtual,p=d.from,u=d.to,c=d.slides,h=d.slidesGrid,v=d.renderSlide,f=d.offset;t.updateActiveIndex();var m,g,y,w=t.activeIndex||0;m=t.rtlTranslate?\"right\":t.isHorizontal()?\"left\":\"top\",r?(g=Math.floor(i/2)+s+o,y=Math.floor(i/2)+s+l):(g=i+(s-1)+o,y=s+l);var b=Math.max((w||0)-y,0),E=Math.min((w||0)+g,c.length-1),x=(t.slidesGrid[b]||0)-(t.slidesGrid[0]||0);function T(){t.updateSlides(),t.updateProgress(),t.updateSlidesClasses(),t.lazy&&t.params.lazy.enabled&&t.lazy.load()}if(S(t.virtual,{from:b,to:E,offset:x,slidesGrid:t.slidesGrid}),p===b&&u===E&&!e)return t.slidesGrid!==h&&x!==f&&t.slides.css(m,x+\"px\"),void t.updateProgress();if(t.params.virtual.renderExternal)return t.params.virtual.renderExternal.call(t,{offset:x,from:b,to:E,slides:function(){for(var e=[],t=b;t<=E;t+=1)e.push(c[t]);return e}()}),void(t.params.virtual.renderExternalUpdate&&T());var C=[],M=[];if(e)t.$wrapperEl.find(\".\"+t.params.slideClass).remove();else for(var z=p;z<=u;z+=1)(z<b||z>E)&&t.$wrapperEl.find(\".\"+t.params.slideClass+'[data-swiper-slide-index=\"'+z+'\"]').remove();for(var P=0;P<c.length;P+=1)P>=b&&P<=E&&(void 0===u||e?M.push(P):(P>u&&M.push(P),P<p&&C.push(P)));M.forEach((function(e){t.$wrapperEl.append(v(c[e],e))})),C.sort((function(e,t){return t-e})).forEach((function(e){t.$wrapperEl.prepend(v(c[e],e))})),t.$wrapperEl.children(\".swiper-slide\").css(m,x+\"px\"),T()},renderSlide:function(e,t){var a=this,i=a.params.virtual;if(i.cache&&a.virtual.cache[t])return a.virtual.cache[t];var s=i.renderSlide?m(i.renderSlide.call(a,e,t)):m('<div class=\"'+a.params.slideClass+'\" data-swiper-slide-index=\"'+t+'\">'+e+\"</div>\");return s.attr(\"data-swiper-slide-index\")||s.attr(\"data-swiper-slide-index\",t),i.cache&&(a.virtual.cache[t]=s),s},appendSlide:function(e){var t=this;if(\"object\"==typeof e&&\"length\"in e)for(var a=0;a<e.length;a+=1)e[a]&&t.virtual.slides.push(e[a]);else t.virtual.slides.push(e);t.virtual.update(!0)},prependSlide:function(e){var t=this,a=t.activeIndex,i=a+1,s=1;if(Array.isArray(e)){for(var r=0;r<e.length;r+=1)e[r]&&t.virtual.slides.unshift(e[r]);i=a+e.length,s=e.length}else t.virtual.slides.unshift(e);if(t.params.virtual.cache){var n=t.virtual.cache,l={};Object.keys(n).forEach((function(e){var t=n[e],a=t.attr(\"data-swiper-slide-index\");a&&t.attr(\"data-swiper-slide-index\",parseInt(a,10)+1),l[parseInt(e,10)+s]=t})),t.virtual.cache=l}t.virtual.update(!0),t.slideTo(i,0)},removeSlide:function(e){var t=this;if(null!=e){var a=t.activeIndex;if(Array.isArray(e))for(var i=e.length-1;i>=0;i-=1)t.virtual.slides.splice(e[i],1),t.params.virtual.cache&&delete t.virtual.cache[e[i]],e[i]<a&&(a-=1),a=Math.max(a,0);else t.virtual.slides.splice(e,1),t.params.virtual.cache&&delete t.virtual.cache[e],e<a&&(a-=1),a=Math.max(a,0);t.virtual.update(!0),t.slideTo(a,0)}},removeAllSlides:function(){var e=this;e.virtual.slides=[],e.params.virtual.cache&&(e.virtual.cache={}),e.virtual.update(!0),e.slideTo(0,0)}},q={name:\"virtual\",params:{virtual:{enabled:!1,slides:[],cache:!0,renderSlide:null,renderExternal:null,renderExternalUpdate:!0,addSlidesBefore:0,addSlidesAfter:0}},create:function(){M(this,{virtual:t({},W,{slides:this.params.virtual.slides,cache:{}})})},on:{beforeInit:function(e){if(e.params.virtual.enabled){e.classNames.push(e.params.containerModifierClass+\"virtual\");var t={watchSlidesProgress:!0};S(e.params,t),S(e.originalParams,t),e.params.initialSlide||e.virtual.update()}},setTranslate:function(e){e.params.virtual.enabled&&e.virtual.update()}}},j={handle:function(e){var t=this,a=l(),i=r(),s=t.rtlTranslate,n=e;n.originalEvent&&(n=n.originalEvent);var o=n.keyCode||n.charCode,d=t.params.keyboard.pageUpDown,p=d&&33===o,u=d&&34===o,c=37===o,h=39===o,v=38===o,f=40===o;if(!t.allowSlideNext&&(t.isHorizontal()&&h||t.isVertical()&&f||u))return!1;if(!t.allowSlidePrev&&(t.isHorizontal()&&c||t.isVertical()&&v||p))return!1;if(!(n.shiftKey||n.altKey||n.ctrlKey||n.metaKey||i.activeElement&&i.activeElement.nodeName&&(\"input\"===i.activeElement.nodeName.toLowerCase()||\"textarea\"===i.activeElement.nodeName.toLowerCase()))){if(t.params.keyboard.onlyInViewport&&(p||u||c||h||v||f)){var m=!1;if(t.$el.parents(\".\"+t.params.slideClass).length>0&&0===t.$el.parents(\".\"+t.params.slideActiveClass).length)return;var g=a.innerWidth,y=a.innerHeight,w=t.$el.offset();s&&(w.left-=t.$el[0].scrollLeft);for(var b=[[w.left,w.top],[w.left+t.width,w.top],[w.left,w.top+t.height],[w.left+t.width,w.top+t.height]],E=0;E<b.length;E+=1){var x=b[E];if(x[0]>=0&&x[0]<=g&&x[1]>=0&&x[1]<=y){if(0===x[0]&&0===x[1])continue;m=!0}}if(!m)return}t.isHorizontal()?((p||u||c||h)&&(n.preventDefault?n.preventDefault():n.returnValue=!1),((u||h)&&!s||(p||c)&&s)&&t.slideNext(),((p||c)&&!s||(u||h)&&s)&&t.slidePrev()):((p||u||v||f)&&(n.preventDefault?n.preventDefault():n.returnValue=!1),(u||f)&&t.slideNext(),(p||v)&&t.slidePrev()),t.emit(\"keyPress\",o)}},enable:function(){var e=this,t=r();e.keyboard.enabled||(m(t).on(\"keydown\",e.keyboard.handle),e.keyboard.enabled=!0)},disable:function(){var e=this,t=r();e.keyboard.enabled&&(m(t).off(\"keydown\",e.keyboard.handle),e.keyboard.enabled=!1)}},_={name:\"keyboard\",params:{keyboard:{enabled:!1,onlyInViewport:!0,pageUpDown:!0}},create:function(){M(this,{keyboard:t({enabled:!1},j)})},on:{init:function(e){e.params.keyboard.enabled&&e.keyboard.enable()},destroy:function(e){e.keyboard.enabled&&e.keyboard.disable()}}};var U={lastScrollTime:x(),lastEventBeforeSnap:void 0,recentWheelEvents:[],event:function(){return l().navigator.userAgent.indexOf(\"firefox\")>-1?\"DOMMouseScroll\":function(){var e=r(),t=\"onwheel\",a=t in e;if(!a){var i=e.createElement(\"div\");i.setAttribute(t,\"return;\"),a=\"function\"==typeof i.onwheel}return!a&&e.implementation&&e.implementation.hasFeature&&!0!==e.implementation.hasFeature(\"\",\"\")&&(a=e.implementation.hasFeature(\"Events.wheel\",\"3.0\")),a}()?\"wheel\":\"mousewheel\"},normalize:function(e){var t=0,a=0,i=0,s=0;return\"detail\"in e&&(a=e.detail),\"wheelDelta\"in e&&(a=-e.wheelDelta/120),\"wheelDeltaY\"in e&&(a=-e.wheelDeltaY/120),\"wheelDeltaX\"in e&&(t=-e.wheelDeltaX/120),\"axis\"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=a,a=0),i=10*t,s=10*a,\"deltaY\"in e&&(s=e.deltaY),\"deltaX\"in e&&(i=e.deltaX),e.shiftKey&&!i&&(i=s,s=0),(i||s)&&e.deltaMode&&(1===e.deltaMode?(i*=40,s*=40):(i*=800,s*=800)),i&&!t&&(t=i<1?-1:1),s&&!a&&(a=s<1?-1:1),{spinX:t,spinY:a,pixelX:i,pixelY:s}},handleMouseEnter:function(){this.mouseEntered=!0},handleMouseLeave:function(){this.mouseEntered=!1},handle:function(e){var t=e,a=this,i=a.params.mousewheel;a.params.cssMode&&t.preventDefault();var s=a.$el;if(\"container\"!==a.params.mousewheel.eventsTarget&&(s=m(a.params.mousewheel.eventsTarget)),!a.mouseEntered&&!s[0].contains(t.target)&&!i.releaseOnEdges)return!0;t.originalEvent&&(t=t.originalEvent);var r=0,n=a.rtlTranslate?-1:1,l=U.normalize(t);if(i.forceToAxis)if(a.isHorizontal()){if(!(Math.abs(l.pixelX)>Math.abs(l.pixelY)))return!0;r=-l.pixelX*n}else{if(!(Math.abs(l.pixelY)>Math.abs(l.pixelX)))return!0;r=-l.pixelY}else r=Math.abs(l.pixelX)>Math.abs(l.pixelY)?-l.pixelX*n:-l.pixelY;if(0===r)return!0;i.invert&&(r=-r);var o=a.getTranslate()+r*i.sensitivity;if(o>=a.minTranslate()&&(o=a.minTranslate()),o<=a.maxTranslate()&&(o=a.maxTranslate()),(!!a.params.loop||!(o===a.minTranslate()||o===a.maxTranslate()))&&a.params.nested&&t.stopPropagation(),a.params.freeMode){var d={time:x(),delta:Math.abs(r),direction:Math.sign(r)},p=a.mousewheel.lastEventBeforeSnap,u=p&&d.time<p.time+500&&d.delta<=p.delta&&d.direction===p.direction;if(!u){a.mousewheel.lastEventBeforeSnap=void 0,a.params.loop&&a.loopFix();var c=a.getTranslate()+r*i.sensitivity,h=a.isBeginning,v=a.isEnd;if(c>=a.minTranslate()&&(c=a.minTranslate()),c<=a.maxTranslate()&&(c=a.maxTranslate()),a.setTransition(0),a.setTranslate(c),a.updateProgress(),a.updateActiveIndex(),a.updateSlidesClasses(),(!h&&a.isBeginning||!v&&a.isEnd)&&a.updateSlidesClasses(),a.params.freeModeSticky){clearTimeout(a.mousewheel.timeout),a.mousewheel.timeout=void 0;var f=a.mousewheel.recentWheelEvents;f.length>=15&&f.shift();var g=f.length?f[f.length-1]:void 0,y=f[0];if(f.push(d),g&&(d.delta>g.delta||d.direction!==g.direction))f.splice(0);else if(f.length>=15&&d.time-y.time<500&&y.delta-d.delta>=1&&d.delta<=6){var w=r>0?.8:.2;a.mousewheel.lastEventBeforeSnap=d,f.splice(0),a.mousewheel.timeout=E((function(){a.slideToClosest(a.params.speed,!0,void 0,w)}),0)}a.mousewheel.timeout||(a.mousewheel.timeout=E((function(){a.mousewheel.lastEventBeforeSnap=d,f.splice(0),a.slideToClosest(a.params.speed,!0,void 0,.5)}),500))}if(u||a.emit(\"scroll\",t),a.params.autoplay&&a.params.autoplayDisableOnInteraction&&a.autoplay.stop(),c===a.minTranslate()||c===a.maxTranslate())return!0}}else{var b={time:x(),delta:Math.abs(r),direction:Math.sign(r),raw:e},T=a.mousewheel.recentWheelEvents;T.length>=2&&T.shift();var C=T.length?T[T.length-1]:void 0;if(T.push(b),C?(b.direction!==C.direction||b.delta>C.delta||b.time>C.time+150)&&a.mousewheel.animateSlider(b):a.mousewheel.animateSlider(b),a.mousewheel.releaseScroll(b))return!0}return t.preventDefault?t.preventDefault():t.returnValue=!1,!1},animateSlider:function(e){var t=this,a=l();return!(this.params.mousewheel.thresholdDelta&&e.delta<this.params.mousewheel.thresholdDelta)&&(!(this.params.mousewheel.thresholdTime&&x()-t.mousewheel.lastScrollTime<this.params.mousewheel.thresholdTime)&&(e.delta>=6&&x()-t.mousewheel.lastScrollTime<60||(e.direction<0?t.isEnd&&!t.params.loop||t.animating||(t.slideNext(),t.emit(\"scroll\",e.raw)):t.isBeginning&&!t.params.loop||t.animating||(t.slidePrev(),t.emit(\"scroll\",e.raw)),t.mousewheel.lastScrollTime=(new a.Date).getTime(),!1)))},releaseScroll:function(e){var t=this,a=t.params.mousewheel;if(e.direction<0){if(t.isEnd&&!t.params.loop&&a.releaseOnEdges)return!0}else if(t.isBeginning&&!t.params.loop&&a.releaseOnEdges)return!0;return!1},enable:function(){var e=this,t=U.event();if(e.params.cssMode)return e.wrapperEl.removeEventListener(t,e.mousewheel.handle),!0;if(!t)return!1;if(e.mousewheel.enabled)return!1;var a=e.$el;return\"container\"!==e.params.mousewheel.eventsTarget&&(a=m(e.params.mousewheel.eventsTarget)),a.on(\"mouseenter\",e.mousewheel.handleMouseEnter),a.on(\"mouseleave\",e.mousewheel.handleMouseLeave),a.on(t,e.mousewheel.handle),e.mousewheel.enabled=!0,!0},disable:function(){var e=this,t=U.event();if(e.params.cssMode)return e.wrapperEl.addEventListener(t,e.mousewheel.handle),!0;if(!t)return!1;if(!e.mousewheel.enabled)return!1;var a=e.$el;return\"container\"!==e.params.mousewheel.eventsTarget&&(a=m(e.params.mousewheel.eventsTarget)),a.off(t,e.mousewheel.handle),e.mousewheel.enabled=!1,!0}},K={update:function(){var e=this,t=e.params.navigation;if(!e.params.loop){var a=e.navigation,i=a.$nextEl,s=a.$prevEl;s&&s.length>0&&(e.isBeginning?s.addClass(t.disabledClass):s.removeClass(t.disabledClass),s[e.params.watchOverflow&&e.isLocked?\"addClass\":\"removeClass\"](t.lockClass)),i&&i.length>0&&(e.isEnd?i.addClass(t.disabledClass):i.removeClass(t.disabledClass),i[e.params.watchOverflow&&e.isLocked?\"addClass\":\"removeClass\"](t.lockClass))}},onPrevClick:function(e){var t=this;e.preventDefault(),t.isBeginning&&!t.params.loop||t.slidePrev()},onNextClick:function(e){var t=this;e.preventDefault(),t.isEnd&&!t.params.loop||t.slideNext()},init:function(){var e,t,a=this,i=a.params.navigation;(i.nextEl||i.prevEl)&&(i.nextEl&&(e=m(i.nextEl),a.params.uniqueNavElements&&\"string\"==typeof i.nextEl&&e.length>1&&1===a.$el.find(i.nextEl).length&&(e=a.$el.find(i.nextEl))),i.prevEl&&(t=m(i.prevEl),a.params.uniqueNavElements&&\"string\"==typeof i.prevEl&&t.length>1&&1===a.$el.find(i.prevEl).length&&(t=a.$el.find(i.prevEl))),e&&e.length>0&&e.on(\"click\",a.navigation.onNextClick),t&&t.length>0&&t.on(\"click\",a.navigation.onPrevClick),S(a.navigation,{$nextEl:e,nextEl:e&&e[0],$prevEl:t,prevEl:t&&t[0]}))},destroy:function(){var e=this,t=e.navigation,a=t.$nextEl,i=t.$prevEl;a&&a.length&&(a.off(\"click\",e.navigation.onNextClick),a.removeClass(e.params.navigation.disabledClass)),i&&i.length&&(i.off(\"click\",e.navigation.onPrevClick),i.removeClass(e.params.navigation.disabledClass))}},Z={update:function(){var e=this,t=e.rtl,a=e.params.pagination;if(a.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var i,s=e.virtual&&e.params.virtual.enabled?e.virtual.slides.length:e.slides.length,r=e.pagination.$el,n=e.params.loop?Math.ceil((s-2*e.loopedSlides)/e.params.slidesPerGroup):e.snapGrid.length;if(e.params.loop?((i=Math.ceil((e.activeIndex-e.loopedSlides)/e.params.slidesPerGroup))>s-1-2*e.loopedSlides&&(i-=s-2*e.loopedSlides),i>n-1&&(i-=n),i<0&&\"bullets\"!==e.params.paginationType&&(i=n+i)):i=void 0!==e.snapIndex?e.snapIndex:e.activeIndex||0,\"bullets\"===a.type&&e.pagination.bullets&&e.pagination.bullets.length>0){var l,o,d,p=e.pagination.bullets;if(a.dynamicBullets&&(e.pagination.bulletSize=p.eq(0)[e.isHorizontal()?\"outerWidth\":\"outerHeight\"](!0),r.css(e.isHorizontal()?\"width\":\"height\",e.pagination.bulletSize*(a.dynamicMainBullets+4)+\"px\"),a.dynamicMainBullets>1&&void 0!==e.previousIndex&&(e.pagination.dynamicBulletIndex+=i-e.previousIndex,e.pagination.dynamicBulletIndex>a.dynamicMainBullets-1?e.pagination.dynamicBulletIndex=a.dynamicMainBullets-1:e.pagination.dynamicBulletIndex<0&&(e.pagination.dynamicBulletIndex=0)),l=i-e.pagination.dynamicBulletIndex,d=((o=l+(Math.min(p.length,a.dynamicMainBullets)-1))+l)/2),p.removeClass(a.bulletActiveClass+\" \"+a.bulletActiveClass+\"-next \"+a.bulletActiveClass+\"-next-next \"+a.bulletActiveClass+\"-prev \"+a.bulletActiveClass+\"-prev-prev \"+a.bulletActiveClass+\"-main\"),r.length>1)p.each((function(e){var t=m(e),s=t.index();s===i&&t.addClass(a.bulletActiveClass),a.dynamicBullets&&(s>=l&&s<=o&&t.addClass(a.bulletActiveClass+\"-main\"),s===l&&t.prev().addClass(a.bulletActiveClass+\"-prev\").prev().addClass(a.bulletActiveClass+\"-prev-prev\"),s===o&&t.next().addClass(a.bulletActiveClass+\"-next\").next().addClass(a.bulletActiveClass+\"-next-next\"))}));else{var u=p.eq(i),c=u.index();if(u.addClass(a.bulletActiveClass),a.dynamicBullets){for(var h=p.eq(l),v=p.eq(o),f=l;f<=o;f+=1)p.eq(f).addClass(a.bulletActiveClass+\"-main\");if(e.params.loop)if(c>=p.length-a.dynamicMainBullets){for(var g=a.dynamicMainBullets;g>=0;g-=1)p.eq(p.length-g).addClass(a.bulletActiveClass+\"-main\");p.eq(p.length-a.dynamicMainBullets-1).addClass(a.bulletActiveClass+\"-prev\")}else h.prev().addClass(a.bulletActiveClass+\"-prev\").prev().addClass(a.bulletActiveClass+\"-prev-prev\"),v.next().addClass(a.bulletActiveClass+\"-next\").next().addClass(a.bulletActiveClass+\"-next-next\");else h.prev().addClass(a.bulletActiveClass+\"-prev\").prev().addClass(a.bulletActiveClass+\"-prev-prev\"),v.next().addClass(a.bulletActiveClass+\"-next\").next().addClass(a.bulletActiveClass+\"-next-next\")}}if(a.dynamicBullets){var y=Math.min(p.length,a.dynamicMainBullets+4),w=(e.pagination.bulletSize*y-e.pagination.bulletSize)/2-d*e.pagination.bulletSize,b=t?\"right\":\"left\";p.css(e.isHorizontal()?b:\"top\",w+\"px\")}}if(\"fraction\"===a.type&&(r.find(\".\"+a.currentClass).text(a.formatFractionCurrent(i+1)),r.find(\".\"+a.totalClass).text(a.formatFractionTotal(n))),\"progressbar\"===a.type){var E;E=a.progressbarOpposite?e.isHorizontal()?\"vertical\":\"horizontal\":e.isHorizontal()?\"horizontal\":\"vertical\";var x=(i+1)/n,T=1,C=1;\"horizontal\"===E?T=x:C=x,r.find(\".\"+a.progressbarFillClass).transform(\"translate3d(0,0,0) scaleX(\"+T+\") scaleY(\"+C+\")\").transition(e.params.speed)}\"custom\"===a.type&&a.renderCustom?(r.html(a.renderCustom(e,i+1,n)),e.emit(\"paginationRender\",r[0])):e.emit(\"paginationUpdate\",r[0]),r[e.params.watchOverflow&&e.isLocked?\"addClass\":\"removeClass\"](a.lockClass)}},render:function(){var e=this,t=e.params.pagination;if(t.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var a=e.virtual&&e.params.virtual.enabled?e.virtual.slides.length:e.slides.length,i=e.pagination.$el,s=\"\";if(\"bullets\"===t.type){for(var r=e.params.loop?Math.ceil((a-2*e.loopedSlides)/e.params.slidesPerGroup):e.snapGrid.length,n=0;n<r;n+=1)t.renderBullet?s+=t.renderBullet.call(e,n,t.bulletClass):s+=\"<\"+t.bulletElement+' class=\"'+t.bulletClass+'\"></'+t.bulletElement+\">\";i.html(s),e.pagination.bullets=i.find(\".\"+t.bulletClass.replace(/ /g,\".\"))}\"fraction\"===t.type&&(s=t.renderFraction?t.renderFraction.call(e,t.currentClass,t.totalClass):'<span class=\"'+t.currentClass+'\"></span> / <span class=\"'+t.totalClass+'\"></span>',i.html(s)),\"progressbar\"===t.type&&(s=t.renderProgressbar?t.renderProgressbar.call(e,t.progressbarFillClass):'<span class=\"'+t.progressbarFillClass+'\"></span>',i.html(s)),\"custom\"!==t.type&&e.emit(\"paginationRender\",e.pagination.$el[0])}},init:function(){var e=this,t=e.params.pagination;if(t.el){var a=m(t.el);0!==a.length&&(e.params.uniqueNavElements&&\"string\"==typeof t.el&&a.length>1&&(a=e.$el.find(t.el)),\"bullets\"===t.type&&t.clickable&&a.addClass(t.clickableClass),a.addClass(t.modifierClass+t.type),\"bullets\"===t.type&&t.dynamicBullets&&(a.addClass(\"\"+t.modifierClass+t.type+\"-dynamic\"),e.pagination.dynamicBulletIndex=0,t.dynamicMainBullets<1&&(t.dynamicMainBullets=1)),\"progressbar\"===t.type&&t.progressbarOpposite&&a.addClass(t.progressbarOppositeClass),t.clickable&&a.on(\"click\",\".\"+t.bulletClass.replace(/ /g,\".\"),(function(t){t.preventDefault();var a=m(this).index()*e.params.slidesPerGroup;e.params.loop&&(a+=e.loopedSlides),e.slideTo(a)})),S(e.pagination,{$el:a,el:a[0]}))}},destroy:function(){var e=this,t=e.params.pagination;if(t.el&&e.pagination.el&&e.pagination.$el&&0!==e.pagination.$el.length){var a=e.pagination.$el;a.removeClass(t.hiddenClass),a.removeClass(t.modifierClass+t.type),e.pagination.bullets&&e.pagination.bullets.removeClass(t.bulletActiveClass),t.clickable&&a.off(\"click\",\".\"+t.bulletClass.replace(/ /g,\".\"))}}},J={setTranslate:function(){var e=this;if(e.params.scrollbar.el&&e.scrollbar.el){var t=e.scrollbar,a=e.rtlTranslate,i=e.progress,s=t.dragSize,r=t.trackSize,n=t.$dragEl,l=t.$el,o=e.params.scrollbar,d=s,p=(r-s)*i;a?(p=-p)>0?(d=s-p,p=0):-p+s>r&&(d=r+p):p<0?(d=s+p,p=0):p+s>r&&(d=r-p),e.isHorizontal()?(n.transform(\"translate3d(\"+p+\"px, 0, 0)\"),n[0].style.width=d+\"px\"):(n.transform(\"translate3d(0px, \"+p+\"px, 0)\"),n[0].style.height=d+\"px\"),o.hide&&(clearTimeout(e.scrollbar.timeout),l[0].style.opacity=1,e.scrollbar.timeout=setTimeout((function(){l[0].style.opacity=0,l.transition(400)}),1e3))}},setTransition:function(e){var t=this;t.params.scrollbar.el&&t.scrollbar.el&&t.scrollbar.$dragEl.transition(e)},updateSize:function(){var e=this;if(e.params.scrollbar.el&&e.scrollbar.el){var t=e.scrollbar,a=t.$dragEl,i=t.$el;a[0].style.width=\"\",a[0].style.height=\"\";var s,r=e.isHorizontal()?i[0].offsetWidth:i[0].offsetHeight,n=e.size/e.virtualSize,l=n*(r/e.size);s=\"auto\"===e.params.scrollbar.dragSize?r*n:parseInt(e.params.scrollbar.dragSize,10),e.isHorizontal()?a[0].style.width=s+\"px\":a[0].style.height=s+\"px\",i[0].style.display=n>=1?\"none\":\"\",e.params.scrollbar.hide&&(i[0].style.opacity=0),S(t,{trackSize:r,divider:n,moveDivider:l,dragSize:s}),t.$el[e.params.watchOverflow&&e.isLocked?\"addClass\":\"removeClass\"](e.params.scrollbar.lockClass)}},getPointerPosition:function(e){return this.isHorizontal()?\"touchstart\"===e.type||\"touchmove\"===e.type?e.targetTouches[0].clientX:e.clientX:\"touchstart\"===e.type||\"touchmove\"===e.type?e.targetTouches[0].clientY:e.clientY},setDragPosition:function(e){var t,a=this,i=a.scrollbar,s=a.rtlTranslate,r=i.$el,n=i.dragSize,l=i.trackSize,o=i.dragStartPos;t=(i.getPointerPosition(e)-r.offset()[a.isHorizontal()?\"left\":\"top\"]-(null!==o?o:n/2))/(l-n),t=Math.max(Math.min(t,1),0),s&&(t=1-t);var d=a.minTranslate()+(a.maxTranslate()-a.minTranslate())*t;a.updateProgress(d),a.setTranslate(d),a.updateActiveIndex(),a.updateSlidesClasses()},onDragStart:function(e){var t=this,a=t.params.scrollbar,i=t.scrollbar,s=t.$wrapperEl,r=i.$el,n=i.$dragEl;t.scrollbar.isTouched=!0,t.scrollbar.dragStartPos=e.target===n[0]||e.target===n?i.getPointerPosition(e)-e.target.getBoundingClientRect()[t.isHorizontal()?\"left\":\"top\"]:null,e.preventDefault(),e.stopPropagation(),s.transition(100),n.transition(100),i.setDragPosition(e),clearTimeout(t.scrollbar.dragTimeout),r.transition(0),a.hide&&r.css(\"opacity\",1),t.params.cssMode&&t.$wrapperEl.css(\"scroll-snap-type\",\"none\"),t.emit(\"scrollbarDragStart\",e)},onDragMove:function(e){var t=this,a=t.scrollbar,i=t.$wrapperEl,s=a.$el,r=a.$dragEl;t.scrollbar.isTouched&&(e.preventDefault?e.preventDefault():e.returnValue=!1,a.setDragPosition(e),i.transition(0),s.transition(0),r.transition(0),t.emit(\"scrollbarDragMove\",e))},onDragEnd:function(e){var t=this,a=t.params.scrollbar,i=t.scrollbar,s=t.$wrapperEl,r=i.$el;t.scrollbar.isTouched&&(t.scrollbar.isTouched=!1,t.params.cssMode&&(t.$wrapperEl.css(\"scroll-snap-type\",\"\"),s.transition(\"\")),a.hide&&(clearTimeout(t.scrollbar.dragTimeout),t.scrollbar.dragTimeout=E((function(){r.css(\"opacity\",0),r.transition(400)}),1e3)),t.emit(\"scrollbarDragEnd\",e),a.snapOnRelease&&t.slideToClosest())},enableDraggable:function(){var e=this;if(e.params.scrollbar.el){var t=r(),a=e.scrollbar,i=e.touchEventsTouch,s=e.touchEventsDesktop,n=e.params,l=e.support,o=a.$el[0],d=!(!l.passiveListener||!n.passiveListeners)&&{passive:!1,capture:!1},p=!(!l.passiveListener||!n.passiveListeners)&&{passive:!0,capture:!1};l.touch?(o.addEventListener(i.start,e.scrollbar.onDragStart,d),o.addEventListener(i.move,e.scrollbar.onDragMove,d),o.addEventListener(i.end,e.scrollbar.onDragEnd,p)):(o.addEventListener(s.start,e.scrollbar.onDragStart,d),t.addEventListener(s.move,e.scrollbar.onDragMove,d),t.addEventListener(s.end,e.scrollbar.onDragEnd,p))}},disableDraggable:function(){var e=this;if(e.params.scrollbar.el){var t=r(),a=e.scrollbar,i=e.touchEventsTouch,s=e.touchEventsDesktop,n=e.params,l=e.support,o=a.$el[0],d=!(!l.passiveListener||!n.passiveListeners)&&{passive:!1,capture:!1},p=!(!l.passiveListener||!n.passiveListeners)&&{passive:!0,capture:!1};l.touch?(o.removeEventListener(i.start,e.scrollbar.onDragStart,d),o.removeEventListener(i.move,e.scrollbar.onDragMove,d),o.removeEventListener(i.end,e.scrollbar.onDragEnd,p)):(o.removeEventListener(s.start,e.scrollbar.onDragStart,d),t.removeEventListener(s.move,e.scrollbar.onDragMove,d),t.removeEventListener(s.end,e.scrollbar.onDragEnd,p))}},init:function(){var e=this;if(e.params.scrollbar.el){var t=e.scrollbar,a=e.$el,i=e.params.scrollbar,s=m(i.el);e.params.uniqueNavElements&&\"string\"==typeof i.el&&s.length>1&&1===a.find(i.el).length&&(s=a.find(i.el));var r=s.find(\".\"+e.params.scrollbar.dragClass);0===r.length&&(r=m('<div class=\"'+e.params.scrollbar.dragClass+'\"></div>'),s.append(r)),S(t,{$el:s,el:s[0],$dragEl:r,dragEl:r[0]}),i.draggable&&t.enableDraggable()}},destroy:function(){this.scrollbar.disableDraggable()}},Q={setTransform:function(e,t){var a=this.rtl,i=m(e),s=a?-1:1,r=i.attr(\"data-swiper-parallax\")||\"0\",n=i.attr(\"data-swiper-parallax-x\"),l=i.attr(\"data-swiper-parallax-y\"),o=i.attr(\"data-swiper-parallax-scale\"),d=i.attr(\"data-swiper-parallax-opacity\");if(n||l?(n=n||\"0\",l=l||\"0\"):this.isHorizontal()?(n=r,l=\"0\"):(l=r,n=\"0\"),n=n.indexOf(\"%\")>=0?parseInt(n,10)*t*s+\"%\":n*t*s+\"px\",l=l.indexOf(\"%\")>=0?parseInt(l,10)*t+\"%\":l*t+\"px\",null!=d){var p=d-(d-1)*(1-Math.abs(t));i[0].style.opacity=p}if(null==o)i.transform(\"translate3d(\"+n+\", \"+l+\", 0px)\");else{var u=o-(o-1)*(1-Math.abs(t));i.transform(\"translate3d(\"+n+\", \"+l+\", 0px) scale(\"+u+\")\")}},setTranslate:function(){var e=this,t=e.$el,a=e.slides,i=e.progress,s=e.snapGrid;t.children(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each((function(t){e.parallax.setTransform(t,i)})),a.each((function(t,a){var r=t.progress;e.params.slidesPerGroup>1&&\"auto\"!==e.params.slidesPerView&&(r+=Math.ceil(a/2)-i*(s.length-1)),r=Math.min(Math.max(r,-1),1),m(t).find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each((function(t){e.parallax.setTransform(t,r)}))}))},setTransition:function(e){void 0===e&&(e=this.params.speed);this.$el.find(\"[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]\").each((function(t){var a=m(t),i=parseInt(a.attr(\"data-swiper-parallax-duration\"),10)||e;0===e&&(i=0),a.transition(i)}))}},ee={getDistanceBetweenTouches:function(e){if(e.targetTouches.length<2)return 1;var t=e.targetTouches[0].pageX,a=e.targetTouches[0].pageY,i=e.targetTouches[1].pageX,s=e.targetTouches[1].pageY;return Math.sqrt(Math.pow(i-t,2)+Math.pow(s-a,2))},onGestureStart:function(e){var t=this,a=t.support,i=t.params.zoom,s=t.zoom,r=s.gesture;if(s.fakeGestureTouched=!1,s.fakeGestureMoved=!1,!a.gestures){if(\"touchstart\"!==e.type||\"touchstart\"===e.type&&e.targetTouches.length<2)return;s.fakeGestureTouched=!0,r.scaleStart=ee.getDistanceBetweenTouches(e)}r.$slideEl&&r.$slideEl.length||(r.$slideEl=m(e.target).closest(\".\"+t.params.slideClass),0===r.$slideEl.length&&(r.$slideEl=t.slides.eq(t.activeIndex)),r.$imageEl=r.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"),r.$imageWrapEl=r.$imageEl.parent(\".\"+i.containerClass),r.maxRatio=r.$imageWrapEl.attr(\"data-swiper-zoom\")||i.maxRatio,0!==r.$imageWrapEl.length)?(r.$imageEl&&r.$imageEl.transition(0),t.zoom.isScaling=!0):r.$imageEl=void 0},onGestureChange:function(e){var t=this,a=t.support,i=t.params.zoom,s=t.zoom,r=s.gesture;if(!a.gestures){if(\"touchmove\"!==e.type||\"touchmove\"===e.type&&e.targetTouches.length<2)return;s.fakeGestureMoved=!0,r.scaleMove=ee.getDistanceBetweenTouches(e)}r.$imageEl&&0!==r.$imageEl.length?(a.gestures?s.scale=e.scale*s.currentScale:s.scale=r.scaleMove/r.scaleStart*s.currentScale,s.scale>r.maxRatio&&(s.scale=r.maxRatio-1+Math.pow(s.scale-r.maxRatio+1,.5)),s.scale<i.minRatio&&(s.scale=i.minRatio+1-Math.pow(i.minRatio-s.scale+1,.5)),r.$imageEl.transform(\"translate3d(0,0,0) scale(\"+s.scale+\")\")):\"gesturechange\"===e.type&&s.onGestureStart(e)},onGestureEnd:function(e){var t=this,a=t.device,i=t.support,s=t.params.zoom,r=t.zoom,n=r.gesture;if(!i.gestures){if(!r.fakeGestureTouched||!r.fakeGestureMoved)return;if(\"touchend\"!==e.type||\"touchend\"===e.type&&e.changedTouches.length<2&&!a.android)return;r.fakeGestureTouched=!1,r.fakeGestureMoved=!1}n.$imageEl&&0!==n.$imageEl.length&&(r.scale=Math.max(Math.min(r.scale,n.maxRatio),s.minRatio),n.$imageEl.transition(t.params.speed).transform(\"translate3d(0,0,0) scale(\"+r.scale+\")\"),r.currentScale=r.scale,r.isScaling=!1,1===r.scale&&(n.$slideEl=void 0))},onTouchStart:function(e){var t=this.device,a=this.zoom,i=a.gesture,s=a.image;i.$imageEl&&0!==i.$imageEl.length&&(s.isTouched||(t.android&&e.cancelable&&e.preventDefault(),s.isTouched=!0,s.touchesStart.x=\"touchstart\"===e.type?e.targetTouches[0].pageX:e.pageX,s.touchesStart.y=\"touchstart\"===e.type?e.targetTouches[0].pageY:e.pageY))},onTouchMove:function(e){var t=this,a=t.zoom,i=a.gesture,s=a.image,r=a.velocity;if(i.$imageEl&&0!==i.$imageEl.length&&(t.allowClick=!1,s.isTouched&&i.$slideEl)){s.isMoved||(s.width=i.$imageEl[0].offsetWidth,s.height=i.$imageEl[0].offsetHeight,s.startX=T(i.$imageWrapEl[0],\"x\")||0,s.startY=T(i.$imageWrapEl[0],\"y\")||0,i.slideWidth=i.$slideEl[0].offsetWidth,i.slideHeight=i.$slideEl[0].offsetHeight,i.$imageWrapEl.transition(0),t.rtl&&(s.startX=-s.startX,s.startY=-s.startY));var n=s.width*a.scale,l=s.height*a.scale;if(!(n<i.slideWidth&&l<i.slideHeight)){if(s.minX=Math.min(i.slideWidth/2-n/2,0),s.maxX=-s.minX,s.minY=Math.min(i.slideHeight/2-l/2,0),s.maxY=-s.minY,s.touchesCurrent.x=\"touchmove\"===e.type?e.targetTouches[0].pageX:e.pageX,s.touchesCurrent.y=\"touchmove\"===e.type?e.targetTouches[0].pageY:e.pageY,!s.isMoved&&!a.isScaling){if(t.isHorizontal()&&(Math.floor(s.minX)===Math.floor(s.startX)&&s.touchesCurrent.x<s.touchesStart.x||Math.floor(s.maxX)===Math.floor(s.startX)&&s.touchesCurrent.x>s.touchesStart.x))return void(s.isTouched=!1);if(!t.isHorizontal()&&(Math.floor(s.minY)===Math.floor(s.startY)&&s.touchesCurrent.y<s.touchesStart.y||Math.floor(s.maxY)===Math.floor(s.startY)&&s.touchesCurrent.y>s.touchesStart.y))return void(s.isTouched=!1)}e.cancelable&&e.preventDefault(),e.stopPropagation(),s.isMoved=!0,s.currentX=s.touchesCurrent.x-s.touchesStart.x+s.startX,s.currentY=s.touchesCurrent.y-s.touchesStart.y+s.startY,s.currentX<s.minX&&(s.currentX=s.minX+1-Math.pow(s.minX-s.currentX+1,.8)),s.currentX>s.maxX&&(s.currentX=s.maxX-1+Math.pow(s.currentX-s.maxX+1,.8)),s.currentY<s.minY&&(s.currentY=s.minY+1-Math.pow(s.minY-s.currentY+1,.8)),s.currentY>s.maxY&&(s.currentY=s.maxY-1+Math.pow(s.currentY-s.maxY+1,.8)),r.prevPositionX||(r.prevPositionX=s.touchesCurrent.x),r.prevPositionY||(r.prevPositionY=s.touchesCurrent.y),r.prevTime||(r.prevTime=Date.now()),r.x=(s.touchesCurrent.x-r.prevPositionX)/(Date.now()-r.prevTime)/2,r.y=(s.touchesCurrent.y-r.prevPositionY)/(Date.now()-r.prevTime)/2,Math.abs(s.touchesCurrent.x-r.prevPositionX)<2&&(r.x=0),Math.abs(s.touchesCurrent.y-r.prevPositionY)<2&&(r.y=0),r.prevPositionX=s.touchesCurrent.x,r.prevPositionY=s.touchesCurrent.y,r.prevTime=Date.now(),i.$imageWrapEl.transform(\"translate3d(\"+s.currentX+\"px, \"+s.currentY+\"px,0)\")}}},onTouchEnd:function(){var e=this.zoom,t=e.gesture,a=e.image,i=e.velocity;if(t.$imageEl&&0!==t.$imageEl.length){if(!a.isTouched||!a.isMoved)return a.isTouched=!1,void(a.isMoved=!1);a.isTouched=!1,a.isMoved=!1;var s=300,r=300,n=i.x*s,l=a.currentX+n,o=i.y*r,d=a.currentY+o;0!==i.x&&(s=Math.abs((l-a.currentX)/i.x)),0!==i.y&&(r=Math.abs((d-a.currentY)/i.y));var p=Math.max(s,r);a.currentX=l,a.currentY=d;var u=a.width*e.scale,c=a.height*e.scale;a.minX=Math.min(t.slideWidth/2-u/2,0),a.maxX=-a.minX,a.minY=Math.min(t.slideHeight/2-c/2,0),a.maxY=-a.minY,a.currentX=Math.max(Math.min(a.currentX,a.maxX),a.minX),a.currentY=Math.max(Math.min(a.currentY,a.maxY),a.minY),t.$imageWrapEl.transition(p).transform(\"translate3d(\"+a.currentX+\"px, \"+a.currentY+\"px,0)\")}},onTransitionEnd:function(){var e=this,t=e.zoom,a=t.gesture;a.$slideEl&&e.previousIndex!==e.activeIndex&&(a.$imageEl&&a.$imageEl.transform(\"translate3d(0,0,0) scale(1)\"),a.$imageWrapEl&&a.$imageWrapEl.transform(\"translate3d(0,0,0)\"),t.scale=1,t.currentScale=1,a.$slideEl=void 0,a.$imageEl=void 0,a.$imageWrapEl=void 0)},toggle:function(e){var t=this.zoom;t.scale&&1!==t.scale?t.out():t.in(e)},in:function(e){var t,a,i,s,r,n,l,o,d,p,u,c,h,v,f,m,g=this,y=g.zoom,w=g.params.zoom,b=y.gesture,E=y.image;(b.$slideEl||(g.params.virtual&&g.params.virtual.enabled&&g.virtual?b.$slideEl=g.$wrapperEl.children(\".\"+g.params.slideActiveClass):b.$slideEl=g.slides.eq(g.activeIndex),b.$imageEl=b.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"),b.$imageWrapEl=b.$imageEl.parent(\".\"+w.containerClass)),b.$imageEl&&0!==b.$imageEl.length)&&(b.$slideEl.addClass(\"\"+w.zoomedSlideClass),void 0===E.touchesStart.x&&e?(t=\"touchend\"===e.type?e.changedTouches[0].pageX:e.pageX,a=\"touchend\"===e.type?e.changedTouches[0].pageY:e.pageY):(t=E.touchesStart.x,a=E.touchesStart.y),y.scale=b.$imageWrapEl.attr(\"data-swiper-zoom\")||w.maxRatio,y.currentScale=b.$imageWrapEl.attr(\"data-swiper-zoom\")||w.maxRatio,e?(f=b.$slideEl[0].offsetWidth,m=b.$slideEl[0].offsetHeight,i=b.$slideEl.offset().left+f/2-t,s=b.$slideEl.offset().top+m/2-a,l=b.$imageEl[0].offsetWidth,o=b.$imageEl[0].offsetHeight,d=l*y.scale,p=o*y.scale,h=-(u=Math.min(f/2-d/2,0)),v=-(c=Math.min(m/2-p/2,0)),(r=i*y.scale)<u&&(r=u),r>h&&(r=h),(n=s*y.scale)<c&&(n=c),n>v&&(n=v)):(r=0,n=0),b.$imageWrapEl.transition(300).transform(\"translate3d(\"+r+\"px, \"+n+\"px,0)\"),b.$imageEl.transition(300).transform(\"translate3d(0,0,0) scale(\"+y.scale+\")\"))},out:function(){var e=this,t=e.zoom,a=e.params.zoom,i=t.gesture;i.$slideEl||(e.params.virtual&&e.params.virtual.enabled&&e.virtual?i.$slideEl=e.$wrapperEl.children(\".\"+e.params.slideActiveClass):i.$slideEl=e.slides.eq(e.activeIndex),i.$imageEl=i.$slideEl.find(\"img, svg, canvas, picture, .swiper-zoom-target\"),i.$imageWrapEl=i.$imageEl.parent(\".\"+a.containerClass)),i.$imageEl&&0!==i.$imageEl.length&&(t.scale=1,t.currentScale=1,i.$imageWrapEl.transition(300).transform(\"translate3d(0,0,0)\"),i.$imageEl.transition(300).transform(\"translate3d(0,0,0) scale(1)\"),i.$slideEl.removeClass(\"\"+a.zoomedSlideClass),i.$slideEl=void 0)},toggleGestures:function(e){var t=this,a=t.zoom,i=a.slideSelector,s=a.passiveListener;t.$wrapperEl[e](\"gesturestart\",i,a.onGestureStart,s),t.$wrapperEl[e](\"gesturechange\",i,a.onGestureChange,s),t.$wrapperEl[e](\"gestureend\",i,a.onGestureEnd,s)},enableGestures:function(){this.zoom.gesturesEnabled||(this.zoom.gesturesEnabled=!0,this.zoom.toggleGestures(\"on\"))},disableGestures:function(){this.zoom.gesturesEnabled&&(this.zoom.gesturesEnabled=!1,this.zoom.toggleGestures(\"off\"))},enable:function(){var e=this,t=e.support,a=e.zoom;if(!a.enabled){a.enabled=!0;var i=!(\"touchstart\"!==e.touchEvents.start||!t.passiveListener||!e.params.passiveListeners)&&{passive:!0,capture:!1},s=!t.passiveListener||{passive:!1,capture:!0},r=\".\"+e.params.slideClass;e.zoom.passiveListener=i,e.zoom.slideSelector=r,t.gestures?(e.$wrapperEl.on(e.touchEvents.start,e.zoom.enableGestures,i),e.$wrapperEl.on(e.touchEvents.end,e.zoom.disableGestures,i)):\"touchstart\"===e.touchEvents.start&&(e.$wrapperEl.on(e.touchEvents.start,r,a.onGestureStart,i),e.$wrapperEl.on(e.touchEvents.move,r,a.onGestureChange,s),e.$wrapperEl.on(e.touchEvents.end,r,a.onGestureEnd,i),e.touchEvents.cancel&&e.$wrapperEl.on(e.touchEvents.cancel,r,a.onGestureEnd,i)),e.$wrapperEl.on(e.touchEvents.move,\".\"+e.params.zoom.containerClass,a.onTouchMove,s)}},disable:function(){var e=this,t=e.zoom;if(t.enabled){var a=e.support;e.zoom.enabled=!1;var i=!(\"touchstart\"!==e.touchEvents.start||!a.passiveListener||!e.params.passiveListeners)&&{passive:!0,capture:!1},s=!a.passiveListener||{passive:!1,capture:!0},r=\".\"+e.params.slideClass;a.gestures?(e.$wrapperEl.off(e.touchEvents.start,e.zoom.enableGestures,i),e.$wrapperEl.off(e.touchEvents.end,e.zoom.disableGestures,i)):\"touchstart\"===e.touchEvents.start&&(e.$wrapperEl.off(e.touchEvents.start,r,t.onGestureStart,i),e.$wrapperEl.off(e.touchEvents.move,r,t.onGestureChange,s),e.$wrapperEl.off(e.touchEvents.end,r,t.onGestureEnd,i),e.touchEvents.cancel&&e.$wrapperEl.off(e.touchEvents.cancel,r,t.onGestureEnd,i)),e.$wrapperEl.off(e.touchEvents.move,\".\"+e.params.zoom.containerClass,t.onTouchMove,s)}}},te={loadInSlide:function(e,t){void 0===t&&(t=!0);var a=this,i=a.params.lazy;if(void 0!==e&&0!==a.slides.length){var s=a.virtual&&a.params.virtual.enabled?a.$wrapperEl.children(\".\"+a.params.slideClass+'[data-swiper-slide-index=\"'+e+'\"]'):a.slides.eq(e),r=s.find(\".\"+i.elementClass+\":not(.\"+i.loadedClass+\"):not(.\"+i.loadingClass+\")\");!s.hasClass(i.elementClass)||s.hasClass(i.loadedClass)||s.hasClass(i.loadingClass)||r.push(s[0]),0!==r.length&&r.each((function(e){var r=m(e);r.addClass(i.loadingClass);var n=r.attr(\"data-background\"),l=r.attr(\"data-src\"),o=r.attr(\"data-srcset\"),d=r.attr(\"data-sizes\"),p=r.parent(\"picture\");a.loadImage(r[0],l||n,o,d,!1,(function(){if(null!=a&&a&&(!a||a.params)&&!a.destroyed){if(n?(r.css(\"background-image\",'url(\"'+n+'\")'),r.removeAttr(\"data-background\")):(o&&(r.attr(\"srcset\",o),r.removeAttr(\"data-srcset\")),d&&(r.attr(\"sizes\",d),r.removeAttr(\"data-sizes\")),p.length&&p.children(\"source\").each((function(e){var t=m(e);t.attr(\"data-srcset\")&&(t.attr(\"srcset\",t.attr(\"data-srcset\")),t.removeAttr(\"data-srcset\"))})),l&&(r.attr(\"src\",l),r.removeAttr(\"data-src\"))),r.addClass(i.loadedClass).removeClass(i.loadingClass),s.find(\".\"+i.preloaderClass).remove(),a.params.loop&&t){var e=s.attr(\"data-swiper-slide-index\");if(s.hasClass(a.params.slideDuplicateClass)){var u=a.$wrapperEl.children('[data-swiper-slide-index=\"'+e+'\"]:not(.'+a.params.slideDuplicateClass+\")\");a.lazy.loadInSlide(u.index(),!1)}else{var c=a.$wrapperEl.children(\".\"+a.params.slideDuplicateClass+'[data-swiper-slide-index=\"'+e+'\"]');a.lazy.loadInSlide(c.index(),!1)}}a.emit(\"lazyImageReady\",s[0],r[0]),a.params.autoHeight&&a.updateAutoHeight()}})),a.emit(\"lazyImageLoad\",s[0],r[0])}))}},load:function(){var e=this,t=e.$wrapperEl,a=e.params,i=e.slides,s=e.activeIndex,r=e.virtual&&a.virtual.enabled,n=a.lazy,l=a.slidesPerView;function o(e){if(r){if(t.children(\".\"+a.slideClass+'[data-swiper-slide-index=\"'+e+'\"]').length)return!0}else if(i[e])return!0;return!1}function d(e){return r?m(e).attr(\"data-swiper-slide-index\"):m(e).index()}if(\"auto\"===l&&(l=0),e.lazy.initialImageLoaded||(e.lazy.initialImageLoaded=!0),e.params.watchSlidesVisibility)t.children(\".\"+a.slideVisibleClass).each((function(t){var a=r?m(t).attr(\"data-swiper-slide-index\"):m(t).index();e.lazy.loadInSlide(a)}));else if(l>1)for(var p=s;p<s+l;p+=1)o(p)&&e.lazy.loadInSlide(p);else e.lazy.loadInSlide(s);if(n.loadPrevNext)if(l>1||n.loadPrevNextAmount&&n.loadPrevNextAmount>1){for(var u=n.loadPrevNextAmount,c=l,h=Math.min(s+c+Math.max(u,c),i.length),v=Math.max(s-Math.max(c,u),0),f=s+l;f<h;f+=1)o(f)&&e.lazy.loadInSlide(f);for(var g=v;g<s;g+=1)o(g)&&e.lazy.loadInSlide(g)}else{var y=t.children(\".\"+a.slideNextClass);y.length>0&&e.lazy.loadInSlide(d(y));var w=t.children(\".\"+a.slidePrevClass);w.length>0&&e.lazy.loadInSlide(d(w))}},checkInViewOnLoad:function(){var e=l(),t=this;if(t&&!t.destroyed){var a=t.params.lazy.scrollingElement?m(t.params.lazy.scrollingElement):m(e),i=a[0]===e,s=i?e.innerWidth:a[0].offsetWidth,r=i?e.innerHeight:a[0].offsetHeight,n=t.$el.offset(),o=!1;t.rtlTranslate&&(n.left-=t.$el[0].scrollLeft);for(var d=[[n.left,n.top],[n.left+t.width,n.top],[n.left,n.top+t.height],[n.left+t.width,n.top+t.height]],p=0;p<d.length;p+=1){var u=d[p];if(u[0]>=0&&u[0]<=s&&u[1]>=0&&u[1]<=r){if(0===u[0]&&0===u[1])continue;o=!0}}o?(t.lazy.load(),a.off(\"scroll\",t.lazy.checkInViewOnLoad)):t.lazy.scrollHandlerAttached||(t.lazy.scrollHandlerAttached=!0,a.on(\"scroll\",t.lazy.checkInViewOnLoad))}}},ae={LinearSpline:function(e,t){var a,i,s,r,n,l=function(e,t){for(i=-1,a=e.length;a-i>1;)e[s=a+i>>1]<=t?i=s:a=s;return a};return this.x=e,this.y=t,this.lastIndex=e.length-1,this.interpolate=function(e){return e?(n=l(this.x,e),r=n-1,(e-this.x[r])*(this.y[n]-this.y[r])/(this.x[n]-this.x[r])+this.y[r]):0},this},getInterpolateFunction:function(e){var t=this;t.controller.spline||(t.controller.spline=t.params.loop?new ae.LinearSpline(t.slidesGrid,e.slidesGrid):new ae.LinearSpline(t.snapGrid,e.snapGrid))},setTranslate:function(e,t){var a,i,s=this,r=s.controller.control,n=s.constructor;function l(e){var t=s.rtlTranslate?-s.translate:s.translate;\"slide\"===s.params.controller.by&&(s.controller.getInterpolateFunction(e),i=-s.controller.spline.interpolate(-t)),i&&\"container\"!==s.params.controller.by||(a=(e.maxTranslate()-e.minTranslate())/(s.maxTranslate()-s.minTranslate()),i=(t-s.minTranslate())*a+e.minTranslate()),s.params.controller.inverse&&(i=e.maxTranslate()-i),e.updateProgress(i),e.setTranslate(i,s),e.updateActiveIndex(),e.updateSlidesClasses()}if(Array.isArray(r))for(var o=0;o<r.length;o+=1)r[o]!==t&&r[o]instanceof n&&l(r[o]);else r instanceof n&&t!==r&&l(r)},setTransition:function(e,t){var a,i=this,s=i.constructor,r=i.controller.control;function n(t){t.setTransition(e,i),0!==e&&(t.transitionStart(),t.params.autoHeight&&E((function(){t.updateAutoHeight()})),t.$wrapperEl.transitionEnd((function(){r&&(t.params.loop&&\"slide\"===i.params.controller.by&&t.loopFix(),t.transitionEnd())})))}if(Array.isArray(r))for(a=0;a<r.length;a+=1)r[a]!==t&&r[a]instanceof s&&n(r[a]);else r instanceof s&&t!==r&&n(r)}},ie={getRandomNumber:function(e){void 0===e&&(e=16);return\"x\".repeat(e).replace(/x/g,(function(){return Math.round(16*Math.random()).toString(16)}))},makeElFocusable:function(e){return e.attr(\"tabIndex\",\"0\"),e},makeElNotFocusable:function(e){return e.attr(\"tabIndex\",\"-1\"),e},addElRole:function(e,t){return e.attr(\"role\",t),e},addElRoleDescription:function(e,t){return e.attr(\"aria-role-description\",t),e},addElControls:function(e,t){return e.attr(\"aria-controls\",t),e},addElLabel:function(e,t){return e.attr(\"aria-label\",t),e},addElId:function(e,t){return e.attr(\"id\",t),e},addElLive:function(e,t){return e.attr(\"aria-live\",t),e},disableEl:function(e){return e.attr(\"aria-disabled\",!0),e},enableEl:function(e){return e.attr(\"aria-disabled\",!1),e},onEnterKey:function(e){var t=this,a=t.params.a11y;if(13===e.keyCode){var i=m(e.target);t.navigation&&t.navigation.$nextEl&&i.is(t.navigation.$nextEl)&&(t.isEnd&&!t.params.loop||t.slideNext(),t.isEnd?t.a11y.notify(a.lastSlideMessage):t.a11y.notify(a.nextSlideMessage)),t.navigation&&t.navigation.$prevEl&&i.is(t.navigation.$prevEl)&&(t.isBeginning&&!t.params.loop||t.slidePrev(),t.isBeginning?t.a11y.notify(a.firstSlideMessage):t.a11y.notify(a.prevSlideMessage)),t.pagination&&i.is(\".\"+t.params.pagination.bulletClass.replace(/ /g,\".\"))&&i[0].click()}},notify:function(e){var t=this.a11y.liveRegion;0!==t.length&&(t.html(\"\"),t.html(e))},updateNavigation:function(){var e=this;if(!e.params.loop&&e.navigation){var t=e.navigation,a=t.$nextEl,i=t.$prevEl;i&&i.length>0&&(e.isBeginning?(e.a11y.disableEl(i),e.a11y.makeElNotFocusable(i)):(e.a11y.enableEl(i),e.a11y.makeElFocusable(i))),a&&a.length>0&&(e.isEnd?(e.a11y.disableEl(a),e.a11y.makeElNotFocusable(a)):(e.a11y.enableEl(a),e.a11y.makeElFocusable(a)))}},updatePagination:function(){var e=this,t=e.params.a11y;e.pagination&&e.params.pagination.clickable&&e.pagination.bullets&&e.pagination.bullets.length&&e.pagination.bullets.each((function(a){var i=m(a);e.a11y.makeElFocusable(i),e.params.pagination.renderBullet||(e.a11y.addElRole(i,\"button\"),e.a11y.addElLabel(i,t.paginationBulletMessage.replace(/\\{\\{index\\}\\}/,i.index()+1)))}))},init:function(){var e=this,t=e.params.a11y;e.$el.append(e.a11y.liveRegion);var a=e.$el;t.containerRoleDescriptionMessage&&e.a11y.addElRoleDescription(a,t.containerRoleDescriptionMessage),t.containerMessage&&e.a11y.addElLabel(a,t.containerMessage);var i,s,r,n=e.$wrapperEl,l=n.attr(\"id\")||\"swiper-wrapper-\"+e.a11y.getRandomNumber(16);e.a11y.addElId(n,l),i=e.params.autoplay&&e.params.autoplay.enabled?\"off\":\"polite\",e.a11y.addElLive(n,i),t.itemRoleDescriptionMessage&&e.a11y.addElRoleDescription(m(e.slides),t.itemRoleDescriptionMessage),e.a11y.addElRole(m(e.slides),\"group\"),e.slides.each((function(t){var a=m(t);e.a11y.addElLabel(a,a.index()+1+\" / \"+e.slides.length)})),e.navigation&&e.navigation.$nextEl&&(s=e.navigation.$nextEl),e.navigation&&e.navigation.$prevEl&&(r=e.navigation.$prevEl),s&&s.length&&(e.a11y.makeElFocusable(s),\"BUTTON\"!==s[0].tagName&&(e.a11y.addElRole(s,\"button\"),s.on(\"keydown\",e.a11y.onEnterKey)),e.a11y.addElLabel(s,t.nextSlideMessage),e.a11y.addElControls(s,l)),r&&r.length&&(e.a11y.makeElFocusable(r),\"BUTTON\"!==r[0].tagName&&(e.a11y.addElRole(r,\"button\"),r.on(\"keydown\",e.a11y.onEnterKey)),e.a11y.addElLabel(r,t.prevSlideMessage),e.a11y.addElControls(r,l)),e.pagination&&e.params.pagination.clickable&&e.pagination.bullets&&e.pagination.bullets.length&&e.pagination.$el.on(\"keydown\",\".\"+e.params.pagination.bulletClass.replace(/ /g,\".\"),e.a11y.onEnterKey)},destroy:function(){var e,t,a=this;a.a11y.liveRegion&&a.a11y.liveRegion.length>0&&a.a11y.liveRegion.remove(),a.navigation&&a.navigation.$nextEl&&(e=a.navigation.$nextEl),a.navigation&&a.navigation.$prevEl&&(t=a.navigation.$prevEl),e&&e.off(\"keydown\",a.a11y.onEnterKey),t&&t.off(\"keydown\",a.a11y.onEnterKey),a.pagination&&a.params.pagination.clickable&&a.pagination.bullets&&a.pagination.bullets.length&&a.pagination.$el.off(\"keydown\",\".\"+a.params.pagination.bulletClass.replace(/ /g,\".\"),a.a11y.onEnterKey)}},se={init:function(){var e=this,t=l();if(e.params.history){if(!t.history||!t.history.pushState)return e.params.history.enabled=!1,void(e.params.hashNavigation.enabled=!0);var a=e.history;a.initialized=!0,a.paths=se.getPathValues(e.params.url),(a.paths.key||a.paths.value)&&(a.scrollToSlide(0,a.paths.value,e.params.runCallbacksOnInit),e.params.history.replaceState||t.addEventListener(\"popstate\",e.history.setHistoryPopState))}},destroy:function(){var e=l();this.params.history.replaceState||e.removeEventListener(\"popstate\",this.history.setHistoryPopState)},setHistoryPopState:function(){var e=this;e.history.paths=se.getPathValues(e.params.url),e.history.scrollToSlide(e.params.speed,e.history.paths.value,!1)},getPathValues:function(e){var t=l(),a=(e?new URL(e):t.location).pathname.slice(1).split(\"/\").filter((function(e){return\"\"!==e})),i=a.length;return{key:a[i-2],value:a[i-1]}},setHistory:function(e,t){var a=this,i=l();if(a.history.initialized&&a.params.history.enabled){var s;s=a.params.url?new URL(a.params.url):i.location;var r=a.slides.eq(t),n=se.slugify(r.attr(\"data-history\"));s.pathname.includes(e)||(n=e+\"/\"+n);var o=i.history.state;o&&o.value===n||(a.params.history.replaceState?i.history.replaceState({value:n},null,n):i.history.pushState({value:n},null,n))}},slugify:function(e){return e.toString().replace(/\\s+/g,\"-\").replace(/[^\\w-]+/g,\"\").replace(/--+/g,\"-\").replace(/^-+/,\"\").replace(/-+$/,\"\")},scrollToSlide:function(e,t,a){var i=this;if(t)for(var s=0,r=i.slides.length;s<r;s+=1){var n=i.slides.eq(s);if(se.slugify(n.attr(\"data-history\"))===t&&!n.hasClass(i.params.slideDuplicateClass)){var l=n.index();i.slideTo(l,e,a)}}else i.slideTo(0,e,a)}},re={onHashCange:function(){var e=this,t=r();e.emit(\"hashChange\");var a=t.location.hash.replace(\"#\",\"\");if(a!==e.slides.eq(e.activeIndex).attr(\"data-hash\")){var i=e.$wrapperEl.children(\".\"+e.params.slideClass+'[data-hash=\"'+a+'\"]').index();if(void 0===i)return;e.slideTo(i)}},setHash:function(){var e=this,t=l(),a=r();if(e.hashNavigation.initialized&&e.params.hashNavigation.enabled)if(e.params.hashNavigation.replaceState&&t.history&&t.history.replaceState)t.history.replaceState(null,null,\"#\"+e.slides.eq(e.activeIndex).attr(\"data-hash\")||\"\"),e.emit(\"hashSet\");else{var i=e.slides.eq(e.activeIndex),s=i.attr(\"data-hash\")||i.attr(\"data-history\");a.location.hash=s||\"\",e.emit(\"hashSet\")}},init:function(){var e=this,t=r(),a=l();if(!(!e.params.hashNavigation.enabled||e.params.history&&e.params.history.enabled)){e.hashNavigation.initialized=!0;var i=t.location.hash.replace(\"#\",\"\");if(i)for(var s=0,n=e.slides.length;s<n;s+=1){var o=e.slides.eq(s);if((o.attr(\"data-hash\")||o.attr(\"data-history\"))===i&&!o.hasClass(e.params.slideDuplicateClass)){var d=o.index();e.slideTo(d,0,e.params.runCallbacksOnInit,!0)}}e.params.hashNavigation.watchState&&m(a).on(\"hashchange\",e.hashNavigation.onHashCange)}},destroy:function(){var e=l();this.params.hashNavigation.watchState&&m(e).off(\"hashchange\",this.hashNavigation.onHashCange)}},ne={run:function(){var e=this,t=e.slides.eq(e.activeIndex),a=e.params.autoplay.delay;t.attr(\"data-swiper-autoplay\")&&(a=t.attr(\"data-swiper-autoplay\")||e.params.autoplay.delay),clearTimeout(e.autoplay.timeout),e.autoplay.timeout=E((function(){var t;e.params.autoplay.reverseDirection?e.params.loop?(e.loopFix(),t=e.slidePrev(e.params.speed,!0,!0),e.emit(\"autoplay\")):e.isBeginning?e.params.autoplay.stopOnLastSlide?e.autoplay.stop():(t=e.slideTo(e.slides.length-1,e.params.speed,!0,!0),e.emit(\"autoplay\")):(t=e.slidePrev(e.params.speed,!0,!0),e.emit(\"autoplay\")):e.params.loop?(e.loopFix(),t=e.slideNext(e.params.speed,!0,!0),e.emit(\"autoplay\")):e.isEnd?e.params.autoplay.stopOnLastSlide?e.autoplay.stop():(t=e.slideTo(0,e.params.speed,!0,!0),e.emit(\"autoplay\")):(t=e.slideNext(e.params.speed,!0,!0),e.emit(\"autoplay\")),(e.params.cssMode&&e.autoplay.running||!1===t)&&e.autoplay.run()}),a)},start:function(){var e=this;return void 0===e.autoplay.timeout&&(!e.autoplay.running&&(e.autoplay.running=!0,e.emit(\"autoplayStart\"),e.autoplay.run(),!0))},stop:function(){var e=this;return!!e.autoplay.running&&(void 0!==e.autoplay.timeout&&(e.autoplay.timeout&&(clearTimeout(e.autoplay.timeout),e.autoplay.timeout=void 0),e.autoplay.running=!1,e.emit(\"autoplayStop\"),!0))},pause:function(e){var t=this;t.autoplay.running&&(t.autoplay.paused||(t.autoplay.timeout&&clearTimeout(t.autoplay.timeout),t.autoplay.paused=!0,0!==e&&t.params.autoplay.waitForTransition?(t.$wrapperEl[0].addEventListener(\"transitionend\",t.autoplay.onTransitionEnd),t.$wrapperEl[0].addEventListener(\"webkitTransitionEnd\",t.autoplay.onTransitionEnd)):(t.autoplay.paused=!1,t.autoplay.run())))},onVisibilityChange:function(){var e=this,t=r();\"hidden\"===t.visibilityState&&e.autoplay.running&&e.autoplay.pause(),\"visible\"===t.visibilityState&&e.autoplay.paused&&(e.autoplay.run(),e.autoplay.paused=!1)},onTransitionEnd:function(e){var t=this;t&&!t.destroyed&&t.$wrapperEl&&e.target===t.$wrapperEl[0]&&(t.$wrapperEl[0].removeEventListener(\"transitionend\",t.autoplay.onTransitionEnd),t.$wrapperEl[0].removeEventListener(\"webkitTransitionEnd\",t.autoplay.onTransitionEnd),t.autoplay.paused=!1,t.autoplay.running?t.autoplay.run():t.autoplay.stop())}},le={setTranslate:function(){for(var e=this,t=e.slides,a=0;a<t.length;a+=1){var i=e.slides.eq(a),s=-i[0].swiperSlideOffset;e.params.virtualTranslate||(s-=e.translate);var r=0;e.isHorizontal()||(r=s,s=0);var n=e.params.fadeEffect.crossFade?Math.max(1-Math.abs(i[0].progress),0):1+Math.min(Math.max(i[0].progress,-1),0);i.css({opacity:n}).transform(\"translate3d(\"+s+\"px, \"+r+\"px, 0px)\")}},setTransition:function(e){var t=this,a=t.slides,i=t.$wrapperEl;if(a.transition(e),t.params.virtualTranslate&&0!==e){var s=!1;a.transitionEnd((function(){if(!s&&t&&!t.destroyed){s=!0,t.animating=!1;for(var e=[\"webkitTransitionEnd\",\"transitionend\"],a=0;a<e.length;a+=1)i.trigger(e[a])}}))}}},oe={setTranslate:function(){var e,t=this,a=t.$el,i=t.$wrapperEl,s=t.slides,r=t.width,n=t.height,l=t.rtlTranslate,o=t.size,d=t.browser,p=t.params.cubeEffect,u=t.isHorizontal(),c=t.virtual&&t.params.virtual.enabled,h=0;p.shadow&&(u?(0===(e=i.find(\".swiper-cube-shadow\")).length&&(e=m('<div class=\"swiper-cube-shadow\"></div>'),i.append(e)),e.css({height:r+\"px\"})):0===(e=a.find(\".swiper-cube-shadow\")).length&&(e=m('<div class=\"swiper-cube-shadow\"></div>'),a.append(e)));for(var v=0;v<s.length;v+=1){var f=s.eq(v),g=v;c&&(g=parseInt(f.attr(\"data-swiper-slide-index\"),10));var y=90*g,w=Math.floor(y/360);l&&(y=-y,w=Math.floor(-y/360));var b=Math.max(Math.min(f[0].progress,1),-1),E=0,x=0,T=0;g%4==0?(E=4*-w*o,T=0):(g-1)%4==0?(E=0,T=4*-w*o):(g-2)%4==0?(E=o+4*w*o,T=o):(g-3)%4==0&&(E=-o,T=3*o+4*o*w),l&&(E=-E),u||(x=E,E=0);var C=\"rotateX(\"+(u?0:-y)+\"deg) rotateY(\"+(u?y:0)+\"deg) translate3d(\"+E+\"px, \"+x+\"px, \"+T+\"px)\";if(b<=1&&b>-1&&(h=90*g+90*b,l&&(h=90*-g-90*b)),f.transform(C),p.slideShadows){var S=u?f.find(\".swiper-slide-shadow-left\"):f.find(\".swiper-slide-shadow-top\"),M=u?f.find(\".swiper-slide-shadow-right\"):f.find(\".swiper-slide-shadow-bottom\");0===S.length&&(S=m('<div class=\"swiper-slide-shadow-'+(u?\"left\":\"top\")+'\"></div>'),f.append(S)),0===M.length&&(M=m('<div class=\"swiper-slide-shadow-'+(u?\"right\":\"bottom\")+'\"></div>'),f.append(M)),S.length&&(S[0].style.opacity=Math.max(-b,0)),M.length&&(M[0].style.opacity=Math.max(b,0))}}if(i.css({\"-webkit-transform-origin\":\"50% 50% -\"+o/2+\"px\",\"-moz-transform-origin\":\"50% 50% -\"+o/2+\"px\",\"-ms-transform-origin\":\"50% 50% -\"+o/2+\"px\",\"transform-origin\":\"50% 50% -\"+o/2+\"px\"}),p.shadow)if(u)e.transform(\"translate3d(0px, \"+(r/2+p.shadowOffset)+\"px, \"+-r/2+\"px) rotateX(90deg) rotateZ(0deg) scale(\"+p.shadowScale+\")\");else{var z=Math.abs(h)-90*Math.floor(Math.abs(h)/90),P=1.5-(Math.sin(2*z*Math.PI/360)/2+Math.cos(2*z*Math.PI/360)/2),k=p.shadowScale,L=p.shadowScale/P,$=p.shadowOffset;e.transform(\"scale3d(\"+k+\", 1, \"+L+\") translate3d(0px, \"+(n/2+$)+\"px, \"+-n/2/L+\"px) rotateX(-90deg)\")}var I=d.isSafari||d.isWebView?-o/2:0;i.transform(\"translate3d(0px,0,\"+I+\"px) rotateX(\"+(t.isHorizontal()?0:h)+\"deg) rotateY(\"+(t.isHorizontal()?-h:0)+\"deg)\")},setTransition:function(e){var t=this,a=t.$el;t.slides.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e),t.params.cubeEffect.shadow&&!t.isHorizontal()&&a.find(\".swiper-cube-shadow\").transition(e)}},de={setTranslate:function(){for(var e=this,t=e.slides,a=e.rtlTranslate,i=0;i<t.length;i+=1){var s=t.eq(i),r=s[0].progress;e.params.flipEffect.limitRotation&&(r=Math.max(Math.min(s[0].progress,1),-1));var n=-180*r,l=0,o=-s[0].swiperSlideOffset,d=0;if(e.isHorizontal()?a&&(n=-n):(d=o,o=0,l=-n,n=0),s[0].style.zIndex=-Math.abs(Math.round(r))+t.length,e.params.flipEffect.slideShadows){var p=e.isHorizontal()?s.find(\".swiper-slide-shadow-left\"):s.find(\".swiper-slide-shadow-top\"),u=e.isHorizontal()?s.find(\".swiper-slide-shadow-right\"):s.find(\".swiper-slide-shadow-bottom\");0===p.length&&(p=m('<div class=\"swiper-slide-shadow-'+(e.isHorizontal()?\"left\":\"top\")+'\"></div>'),s.append(p)),0===u.length&&(u=m('<div class=\"swiper-slide-shadow-'+(e.isHorizontal()?\"right\":\"bottom\")+'\"></div>'),s.append(u)),p.length&&(p[0].style.opacity=Math.max(-r,0)),u.length&&(u[0].style.opacity=Math.max(r,0))}s.transform(\"translate3d(\"+o+\"px, \"+d+\"px, 0px) rotateX(\"+l+\"deg) rotateY(\"+n+\"deg)\")}},setTransition:function(e){var t=this,a=t.slides,i=t.activeIndex,s=t.$wrapperEl;if(a.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e),t.params.virtualTranslate&&0!==e){var r=!1;a.eq(i).transitionEnd((function(){if(!r&&t&&!t.destroyed){r=!0,t.animating=!1;for(var e=[\"webkitTransitionEnd\",\"transitionend\"],a=0;a<e.length;a+=1)s.trigger(e[a])}}))}}},pe={setTranslate:function(){for(var e=this,t=e.width,a=e.height,i=e.slides,s=e.slidesSizesGrid,r=e.params.coverflowEffect,n=e.isHorizontal(),l=e.translate,o=n?t/2-l:a/2-l,d=n?r.rotate:-r.rotate,p=r.depth,u=0,c=i.length;u<c;u+=1){var h=i.eq(u),v=s[u],f=(o-h[0].swiperSlideOffset-v/2)/v*r.modifier,g=n?d*f:0,y=n?0:d*f,w=-p*Math.abs(f),b=r.stretch;\"string\"==typeof b&&-1!==b.indexOf(\"%\")&&(b=parseFloat(r.stretch)/100*v);var E=n?0:b*f,x=n?b*f:0,T=1-(1-r.scale)*Math.abs(f);Math.abs(x)<.001&&(x=0),Math.abs(E)<.001&&(E=0),Math.abs(w)<.001&&(w=0),Math.abs(g)<.001&&(g=0),Math.abs(y)<.001&&(y=0),Math.abs(T)<.001&&(T=0);var C=\"translate3d(\"+x+\"px,\"+E+\"px,\"+w+\"px)  rotateX(\"+y+\"deg) rotateY(\"+g+\"deg) scale(\"+T+\")\";if(h.transform(C),h[0].style.zIndex=1-Math.abs(Math.round(f)),r.slideShadows){var S=n?h.find(\".swiper-slide-shadow-left\"):h.find(\".swiper-slide-shadow-top\"),M=n?h.find(\".swiper-slide-shadow-right\"):h.find(\".swiper-slide-shadow-bottom\");0===S.length&&(S=m('<div class=\"swiper-slide-shadow-'+(n?\"left\":\"top\")+'\"></div>'),h.append(S)),0===M.length&&(M=m('<div class=\"swiper-slide-shadow-'+(n?\"right\":\"bottom\")+'\"></div>'),h.append(M)),S.length&&(S[0].style.opacity=f>0?f:0),M.length&&(M[0].style.opacity=-f>0?-f:0)}}},setTransition:function(e){this.slides.transition(e).find(\".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left\").transition(e)}},ue={init:function(){var e=this,t=e.params.thumbs;if(e.thumbs.initialized)return!1;e.thumbs.initialized=!0;var a=e.constructor;return t.swiper instanceof a?(e.thumbs.swiper=t.swiper,S(e.thumbs.swiper.originalParams,{watchSlidesProgress:!0,slideToClickedSlide:!1}),S(e.thumbs.swiper.params,{watchSlidesProgress:!0,slideToClickedSlide:!1})):C(t.swiper)&&(e.thumbs.swiper=new a(S({},t.swiper,{watchSlidesVisibility:!0,watchSlidesProgress:!0,slideToClickedSlide:!1})),e.thumbs.swiperCreated=!0),e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass),e.thumbs.swiper.on(\"tap\",e.thumbs.onThumbClick),!0},onThumbClick:function(){var e=this,t=e.thumbs.swiper;if(t){var a=t.clickedIndex,i=t.clickedSlide;if(!(i&&m(i).hasClass(e.params.thumbs.slideThumbActiveClass)||null==a)){var s;if(s=t.params.loop?parseInt(m(t.clickedSlide).attr(\"data-swiper-slide-index\"),10):a,e.params.loop){var r=e.activeIndex;e.slides.eq(r).hasClass(e.params.slideDuplicateClass)&&(e.loopFix(),e._clientLeft=e.$wrapperEl[0].clientLeft,r=e.activeIndex);var n=e.slides.eq(r).prevAll('[data-swiper-slide-index=\"'+s+'\"]').eq(0).index(),l=e.slides.eq(r).nextAll('[data-swiper-slide-index=\"'+s+'\"]').eq(0).index();s=void 0===n?l:void 0===l?n:l-r<r-n?l:n}e.slideTo(s)}}},update:function(e){var t=this,a=t.thumbs.swiper;if(a){var i=\"auto\"===a.params.slidesPerView?a.slidesPerViewDynamic():a.params.slidesPerView,s=t.params.thumbs.autoScrollOffset,r=s&&!a.params.loop;if(t.realIndex!==a.realIndex||r){var n,l,o=a.activeIndex;if(a.params.loop){a.slides.eq(o).hasClass(a.params.slideDuplicateClass)&&(a.loopFix(),a._clientLeft=a.$wrapperEl[0].clientLeft,o=a.activeIndex);var d=a.slides.eq(o).prevAll('[data-swiper-slide-index=\"'+t.realIndex+'\"]').eq(0).index(),p=a.slides.eq(o).nextAll('[data-swiper-slide-index=\"'+t.realIndex+'\"]').eq(0).index();n=void 0===d?p:void 0===p?d:p-o==o-d?o:p-o<o-d?p:d,l=t.activeIndex>t.previousIndex?\"next\":\"prev\"}else l=(n=t.realIndex)>t.previousIndex?\"next\":\"prev\";r&&(n+=\"next\"===l?s:-1*s),a.visibleSlidesIndexes&&a.visibleSlidesIndexes.indexOf(n)<0&&(a.params.centeredSlides?n=n>o?n-Math.floor(i/2)+1:n+Math.floor(i/2)-1:n>o&&(n=n-i+1),a.slideTo(n,e?0:void 0))}var u=1,c=t.params.thumbs.slideThumbActiveClass;if(t.params.slidesPerView>1&&!t.params.centeredSlides&&(u=t.params.slidesPerView),t.params.thumbs.multipleActiveThumbs||(u=1),u=Math.floor(u),a.slides.removeClass(c),a.params.loop||a.params.virtual&&a.params.virtual.enabled)for(var h=0;h<u;h+=1)a.$wrapperEl.children('[data-swiper-slide-index=\"'+(t.realIndex+h)+'\"]').addClass(c);else for(var v=0;v<u;v+=1)a.slides.eq(t.realIndex+v).addClass(c)}}},ce=[q,_,{name:\"mousewheel\",params:{mousewheel:{enabled:!1,releaseOnEdges:!1,invert:!1,forceToAxis:!1,sensitivity:1,eventsTarget:\"container\",thresholdDelta:null,thresholdTime:null}},create:function(){M(this,{mousewheel:{enabled:!1,lastScrollTime:x(),lastEventBeforeSnap:void 0,recentWheelEvents:[],enable:U.enable,disable:U.disable,handle:U.handle,handleMouseEnter:U.handleMouseEnter,handleMouseLeave:U.handleMouseLeave,animateSlider:U.animateSlider,releaseScroll:U.releaseScroll}})},on:{init:function(e){!e.params.mousewheel.enabled&&e.params.cssMode&&e.mousewheel.disable(),e.params.mousewheel.enabled&&e.mousewheel.enable()},destroy:function(e){e.params.cssMode&&e.mousewheel.enable(),e.mousewheel.enabled&&e.mousewheel.disable()}}},{name:\"navigation\",params:{navigation:{nextEl:null,prevEl:null,hideOnClick:!1,disabledClass:\"swiper-button-disabled\",hiddenClass:\"swiper-button-hidden\",lockClass:\"swiper-button-lock\"}},create:function(){M(this,{navigation:t({},K)})},on:{init:function(e){e.navigation.init(),e.navigation.update()},toEdge:function(e){e.navigation.update()},fromEdge:function(e){e.navigation.update()},destroy:function(e){e.navigation.destroy()},click:function(e,t){var a,i=e.navigation,s=i.$nextEl,r=i.$prevEl;!e.params.navigation.hideOnClick||m(t.target).is(r)||m(t.target).is(s)||(s?a=s.hasClass(e.params.navigation.hiddenClass):r&&(a=r.hasClass(e.params.navigation.hiddenClass)),!0===a?e.emit(\"navigationShow\"):e.emit(\"navigationHide\"),s&&s.toggleClass(e.params.navigation.hiddenClass),r&&r.toggleClass(e.params.navigation.hiddenClass))}}},{name:\"pagination\",params:{pagination:{el:null,bulletElement:\"span\",clickable:!1,hideOnClick:!1,renderBullet:null,renderProgressbar:null,renderFraction:null,renderCustom:null,progressbarOpposite:!1,type:\"bullets\",dynamicBullets:!1,dynamicMainBullets:1,formatFractionCurrent:function(e){return e},formatFractionTotal:function(e){return e},bulletClass:\"swiper-pagination-bullet\",bulletActiveClass:\"swiper-pagination-bullet-active\",modifierClass:\"swiper-pagination-\",currentClass:\"swiper-pagination-current\",totalClass:\"swiper-pagination-total\",hiddenClass:\"swiper-pagination-hidden\",progressbarFillClass:\"swiper-pagination-progressbar-fill\",progressbarOppositeClass:\"swiper-pagination-progressbar-opposite\",clickableClass:\"swiper-pagination-clickable\",lockClass:\"swiper-pagination-lock\"}},create:function(){M(this,{pagination:t({dynamicBulletIndex:0},Z)})},on:{init:function(e){e.pagination.init(),e.pagination.render(),e.pagination.update()},activeIndexChange:function(e){(e.params.loop||void 0===e.snapIndex)&&e.pagination.update()},snapIndexChange:function(e){e.params.loop||e.pagination.update()},slidesLengthChange:function(e){e.params.loop&&(e.pagination.render(),e.pagination.update())},snapGridLengthChange:function(e){e.params.loop||(e.pagination.render(),e.pagination.update())},destroy:function(e){e.pagination.destroy()},click:function(e,t){e.params.pagination.el&&e.params.pagination.hideOnClick&&e.pagination.$el.length>0&&!m(t.target).hasClass(e.params.pagination.bulletClass)&&(!0===e.pagination.$el.hasClass(e.params.pagination.hiddenClass)?e.emit(\"paginationShow\"):e.emit(\"paginationHide\"),e.pagination.$el.toggleClass(e.params.pagination.hiddenClass))}}},{name:\"scrollbar\",params:{scrollbar:{el:null,dragSize:\"auto\",hide:!1,draggable:!1,snapOnRelease:!0,lockClass:\"swiper-scrollbar-lock\",dragClass:\"swiper-scrollbar-drag\"}},create:function(){M(this,{scrollbar:t({isTouched:!1,timeout:null,dragTimeout:null},J)})},on:{init:function(e){e.scrollbar.init(),e.scrollbar.updateSize(),e.scrollbar.setTranslate()},update:function(e){e.scrollbar.updateSize()},resize:function(e){e.scrollbar.updateSize()},observerUpdate:function(e){e.scrollbar.updateSize()},setTranslate:function(e){e.scrollbar.setTranslate()},setTransition:function(e,t){e.scrollbar.setTransition(t)},destroy:function(e){e.scrollbar.destroy()}}},{name:\"parallax\",params:{parallax:{enabled:!1}},create:function(){M(this,{parallax:t({},Q)})},on:{beforeInit:function(e){e.params.parallax.enabled&&(e.params.watchSlidesProgress=!0,e.originalParams.watchSlidesProgress=!0)},init:function(e){e.params.parallax.enabled&&e.parallax.setTranslate()},setTranslate:function(e){e.params.parallax.enabled&&e.parallax.setTranslate()},setTransition:function(e,t){e.params.parallax.enabled&&e.parallax.setTransition(t)}}},{name:\"zoom\",params:{zoom:{enabled:!1,maxRatio:3,minRatio:1,toggle:!0,containerClass:\"swiper-zoom-container\",zoomedSlideClass:\"swiper-slide-zoomed\"}},create:function(){var e=this;M(e,{zoom:t({enabled:!1,scale:1,currentScale:1,isScaling:!1,gesture:{$slideEl:void 0,slideWidth:void 0,slideHeight:void 0,$imageEl:void 0,$imageWrapEl:void 0,maxRatio:3},image:{isTouched:void 0,isMoved:void 0,currentX:void 0,currentY:void 0,minX:void 0,minY:void 0,maxX:void 0,maxY:void 0,width:void 0,height:void 0,startX:void 0,startY:void 0,touchesStart:{},touchesCurrent:{}},velocity:{x:void 0,y:void 0,prevPositionX:void 0,prevPositionY:void 0,prevTime:void 0}},ee)});var a=1;Object.defineProperty(e.zoom,\"scale\",{get:function(){return a},set:function(t){if(a!==t){var i=e.zoom.gesture.$imageEl?e.zoom.gesture.$imageEl[0]:void 0,s=e.zoom.gesture.$slideEl?e.zoom.gesture.$slideEl[0]:void 0;e.emit(\"zoomChange\",t,i,s)}a=t}})},on:{init:function(e){e.params.zoom.enabled&&e.zoom.enable()},destroy:function(e){e.zoom.disable()},touchStart:function(e,t){e.zoom.enabled&&e.zoom.onTouchStart(t)},touchEnd:function(e,t){e.zoom.enabled&&e.zoom.onTouchEnd(t)},doubleTap:function(e,t){e.params.zoom.enabled&&e.zoom.enabled&&e.params.zoom.toggle&&e.zoom.toggle(t)},transitionEnd:function(e){e.zoom.enabled&&e.params.zoom.enabled&&e.zoom.onTransitionEnd()},slideChange:function(e){e.zoom.enabled&&e.params.zoom.enabled&&e.params.cssMode&&e.zoom.onTransitionEnd()}}},{name:\"lazy\",params:{lazy:{checkInView:!1,enabled:!1,loadPrevNext:!1,loadPrevNextAmount:1,loadOnTransitionStart:!1,scrollingElement:\"\",elementClass:\"swiper-lazy\",loadingClass:\"swiper-lazy-loading\",loadedClass:\"swiper-lazy-loaded\",preloaderClass:\"swiper-lazy-preloader\"}},create:function(){M(this,{lazy:t({initialImageLoaded:!1},te)})},on:{beforeInit:function(e){e.params.lazy.enabled&&e.params.preloadImages&&(e.params.preloadImages=!1)},init:function(e){e.params.lazy.enabled&&!e.params.loop&&0===e.params.initialSlide&&(e.params.lazy.checkInView?e.lazy.checkInViewOnLoad():e.lazy.load())},scroll:function(e){e.params.freeMode&&!e.params.freeModeSticky&&e.lazy.load()},resize:function(e){e.params.lazy.enabled&&e.lazy.load()},scrollbarDragMove:function(e){e.params.lazy.enabled&&e.lazy.load()},transitionStart:function(e){e.params.lazy.enabled&&(e.params.lazy.loadOnTransitionStart||!e.params.lazy.loadOnTransitionStart&&!e.lazy.initialImageLoaded)&&e.lazy.load()},transitionEnd:function(e){e.params.lazy.enabled&&!e.params.lazy.loadOnTransitionStart&&e.lazy.load()},slideChange:function(e){e.params.lazy.enabled&&e.params.cssMode&&e.lazy.load()}}},{name:\"controller\",params:{controller:{control:void 0,inverse:!1,by:\"slide\"}},create:function(){M(this,{controller:t({control:this.params.controller.control},ae)})},on:{update:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},resize:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},observerUpdate:function(e){e.controller.control&&e.controller.spline&&(e.controller.spline=void 0,delete e.controller.spline)},setTranslate:function(e,t,a){e.controller.control&&e.controller.setTranslate(t,a)},setTransition:function(e,t,a){e.controller.control&&e.controller.setTransition(t,a)}}},{name:\"a11y\",params:{a11y:{enabled:!0,notificationClass:\"swiper-notification\",prevSlideMessage:\"Previous slide\",nextSlideMessage:\"Next slide\",firstSlideMessage:\"This is the first slide\",lastSlideMessage:\"This is the last slide\",paginationBulletMessage:\"Go to slide {{index}}\",containerMessage:null,containerRoleDescriptionMessage:null,itemRoleDescriptionMessage:null}},create:function(){M(this,{a11y:t({},ie,{liveRegion:m('<span class=\"'+this.params.a11y.notificationClass+'\" aria-live=\"assertive\" aria-atomic=\"true\"></span>')})})},on:{afterInit:function(e){e.params.a11y.enabled&&(e.a11y.init(),e.a11y.updateNavigation())},toEdge:function(e){e.params.a11y.enabled&&e.a11y.updateNavigation()},fromEdge:function(e){e.params.a11y.enabled&&e.a11y.updateNavigation()},paginationUpdate:function(e){e.params.a11y.enabled&&e.a11y.updatePagination()},destroy:function(e){e.params.a11y.enabled&&e.a11y.destroy()}}},{name:\"history\",params:{history:{enabled:!1,replaceState:!1,key:\"slides\"}},create:function(){M(this,{history:t({},se)})},on:{init:function(e){e.params.history.enabled&&e.history.init()},destroy:function(e){e.params.history.enabled&&e.history.destroy()},transitionEnd:function(e){e.history.initialized&&e.history.setHistory(e.params.history.key,e.activeIndex)},slideChange:function(e){e.history.initialized&&e.params.cssMode&&e.history.setHistory(e.params.history.key,e.activeIndex)}}},{name:\"hash-navigation\",params:{hashNavigation:{enabled:!1,replaceState:!1,watchState:!1}},create:function(){M(this,{hashNavigation:t({initialized:!1},re)})},on:{init:function(e){e.params.hashNavigation.enabled&&e.hashNavigation.init()},destroy:function(e){e.params.hashNavigation.enabled&&e.hashNavigation.destroy()},transitionEnd:function(e){e.hashNavigation.initialized&&e.hashNavigation.setHash()},slideChange:function(e){e.hashNavigation.initialized&&e.params.cssMode&&e.hashNavigation.setHash()}}},{name:\"autoplay\",params:{autoplay:{enabled:!1,delay:3e3,waitForTransition:!0,disableOnInteraction:!0,stopOnLastSlide:!1,reverseDirection:!1}},create:function(){M(this,{autoplay:t({},ne,{running:!1,paused:!1})})},on:{init:function(e){e.params.autoplay.enabled&&(e.autoplay.start(),r().addEventListener(\"visibilitychange\",e.autoplay.onVisibilityChange))},beforeTransitionStart:function(e,t,a){e.autoplay.running&&(a||!e.params.autoplay.disableOnInteraction?e.autoplay.pause(t):e.autoplay.stop())},sliderFirstMove:function(e){e.autoplay.running&&(e.params.autoplay.disableOnInteraction?e.autoplay.stop():e.autoplay.pause())},touchEnd:function(e){e.params.cssMode&&e.autoplay.paused&&!e.params.autoplay.disableOnInteraction&&e.autoplay.run()},destroy:function(e){e.autoplay.running&&e.autoplay.stop(),r().removeEventListener(\"visibilitychange\",e.autoplay.onVisibilityChange)}}},{name:\"effect-fade\",params:{fadeEffect:{crossFade:!1}},create:function(){M(this,{fadeEffect:t({},le)})},on:{beforeInit:function(e){if(\"fade\"===e.params.effect){e.classNames.push(e.params.containerModifierClass+\"fade\");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!0};S(e.params,t),S(e.originalParams,t)}},setTranslate:function(e){\"fade\"===e.params.effect&&e.fadeEffect.setTranslate()},setTransition:function(e,t){\"fade\"===e.params.effect&&e.fadeEffect.setTransition(t)}}},{name:\"effect-cube\",params:{cubeEffect:{slideShadows:!0,shadow:!0,shadowOffset:20,shadowScale:.94}},create:function(){M(this,{cubeEffect:t({},oe)})},on:{beforeInit:function(e){if(\"cube\"===e.params.effect){e.classNames.push(e.params.containerModifierClass+\"cube\"),e.classNames.push(e.params.containerModifierClass+\"3d\");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,resistanceRatio:0,spaceBetween:0,centeredSlides:!1,virtualTranslate:!0};S(e.params,t),S(e.originalParams,t)}},setTranslate:function(e){\"cube\"===e.params.effect&&e.cubeEffect.setTranslate()},setTransition:function(e,t){\"cube\"===e.params.effect&&e.cubeEffect.setTransition(t)}}},{name:\"effect-flip\",params:{flipEffect:{slideShadows:!0,limitRotation:!0}},create:function(){M(this,{flipEffect:t({},de)})},on:{beforeInit:function(e){if(\"flip\"===e.params.effect){e.classNames.push(e.params.containerModifierClass+\"flip\"),e.classNames.push(e.params.containerModifierClass+\"3d\");var t={slidesPerView:1,slidesPerColumn:1,slidesPerGroup:1,watchSlidesProgress:!0,spaceBetween:0,virtualTranslate:!0};S(e.params,t),S(e.originalParams,t)}},setTranslate:function(e){\"flip\"===e.params.effect&&e.flipEffect.setTranslate()},setTransition:function(e,t){\"flip\"===e.params.effect&&e.flipEffect.setTransition(t)}}},{name:\"effect-coverflow\",params:{coverflowEffect:{rotate:50,stretch:0,depth:100,scale:1,modifier:1,slideShadows:!0}},create:function(){M(this,{coverflowEffect:t({},pe)})},on:{beforeInit:function(e){\"coverflow\"===e.params.effect&&(e.classNames.push(e.params.containerModifierClass+\"coverflow\"),e.classNames.push(e.params.containerModifierClass+\"3d\"),e.params.watchSlidesProgress=!0,e.originalParams.watchSlidesProgress=!0)},setTranslate:function(e){\"coverflow\"===e.params.effect&&e.coverflowEffect.setTranslate()},setTransition:function(e,t){\"coverflow\"===e.params.effect&&e.coverflowEffect.setTransition(t)}}},{name:\"thumbs\",params:{thumbs:{swiper:null,multipleActiveThumbs:!0,autoScrollOffset:0,slideThumbActiveClass:\"swiper-slide-thumb-active\",thumbsContainerClass:\"swiper-container-thumbs\"}},create:function(){M(this,{thumbs:t({swiper:null,initialized:!1},ue)})},on:{beforeInit:function(e){var t=e.params.thumbs;t&&t.swiper&&(e.thumbs.init(),e.thumbs.update(!0))},slideChange:function(e){e.thumbs.swiper&&e.thumbs.update()},update:function(e){e.thumbs.swiper&&e.thumbs.update()},resize:function(e){e.thumbs.swiper&&e.thumbs.update()},observerUpdate:function(e){e.thumbs.swiper&&e.thumbs.update()},setTransition:function(e,t){var a=e.thumbs.swiper;a&&a.setTransition(t)},beforeDestroy:function(e){var t=e.thumbs.swiper;t&&e.thumbs.swiperCreated&&t&&t.destroy()}}}];return R.use(ce),R}));\n//# sourceMappingURL=swiper-bundle.min.js.map","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.echarts = {}));\n}(this, (function (exports) { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    }\n\n    var Browser = (function () {\n        function Browser() {\n            this.firefox = false;\n            this.ie = false;\n            this.edge = false;\n            this.newEdge = false;\n            this.weChat = false;\n        }\n        return Browser;\n    }());\n    var Env = (function () {\n        function Env() {\n            this.browser = new Browser();\n            this.node = false;\n            this.wxa = false;\n            this.worker = false;\n            this.canvasSupported = false;\n            this.svgSupported = false;\n            this.touchEventsSupported = false;\n            this.pointerEventsSupported = false;\n            this.domSupported = false;\n        }\n        return Env;\n    }());\n    var env = new Env();\n    if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {\n        env.wxa = true;\n        env.canvasSupported = true;\n        env.touchEventsSupported = true;\n    }\n    else if (typeof document === 'undefined' && typeof self !== 'undefined') {\n        env.worker = true;\n        env.canvasSupported = true;\n    }\n    else if (typeof navigator === 'undefined') {\n        env.node = true;\n        env.canvasSupported = true;\n        env.svgSupported = true;\n    }\n    else {\n        detect(navigator.userAgent, env);\n    }\n    function detect(ua, env) {\n        var browser = env.browser;\n        var firefox = ua.match(/Firefox\\/([\\d.]+)/);\n        var ie = ua.match(/MSIE\\s([\\d.]+)/)\n            || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n        var edge = ua.match(/Edge?\\/([\\d.]+)/);\n        var weChat = (/micromessenger/i).test(ua);\n        if (firefox) {\n            browser.firefox = true;\n            browser.version = firefox[1];\n        }\n        if (ie) {\n            browser.ie = true;\n            browser.version = ie[1];\n        }\n        if (edge) {\n            browser.edge = true;\n            browser.version = edge[1];\n            browser.newEdge = +edge[1].split('.')[0] > 18;\n        }\n        if (weChat) {\n            browser.weChat = true;\n        }\n        env.canvasSupported = !!document.createElement('canvas').getContext;\n        env.svgSupported = typeof SVGRect !== 'undefined';\n        env.touchEventsSupported = 'ontouchstart' in window && !browser.ie && !browser.edge;\n        env.pointerEventsSupported = 'onpointerdown' in window\n            && (browser.edge || (browser.ie && +browser.version >= 11));\n        env.domSupported = typeof document !== 'undefined';\n    }\n\n    var BUILTIN_OBJECT = {\n        '[object Function]': true,\n        '[object RegExp]': true,\n        '[object Date]': true,\n        '[object Error]': true,\n        '[object CanvasGradient]': true,\n        '[object CanvasPattern]': true,\n        '[object Image]': true,\n        '[object Canvas]': true\n    };\n    var TYPED_ARRAY = {\n        '[object Int8Array]': true,\n        '[object Uint8Array]': true,\n        '[object Uint8ClampedArray]': true,\n        '[object Int16Array]': true,\n        '[object Uint16Array]': true,\n        '[object Int32Array]': true,\n        '[object Uint32Array]': true,\n        '[object Float32Array]': true,\n        '[object Float64Array]': true\n    };\n    var objToString = Object.prototype.toString;\n    var arrayProto = Array.prototype;\n    var nativeForEach = arrayProto.forEach;\n    var nativeFilter = arrayProto.filter;\n    var nativeSlice = arrayProto.slice;\n    var nativeMap = arrayProto.map;\n    var ctorFunction = function () { }.constructor;\n    var protoFunction = ctorFunction ? ctorFunction.prototype : null;\n    var methods = {};\n    function $override(name, fn) {\n        methods[name] = fn;\n    }\n    var idStart = 0x0907;\n    function guid() {\n        return idStart++;\n    }\n    function logError() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (typeof console !== 'undefined') {\n            console.error.apply(console, args);\n        }\n    }\n    function clone(source) {\n        if (source == null || typeof source !== 'object') {\n            return source;\n        }\n        var result = source;\n        var typeStr = objToString.call(source);\n        if (typeStr === '[object Array]') {\n            if (!isPrimitive(source)) {\n                result = [];\n                for (var i = 0, len = source.length; i < len; i++) {\n                    result[i] = clone(source[i]);\n                }\n            }\n        }\n        else if (TYPED_ARRAY[typeStr]) {\n            if (!isPrimitive(source)) {\n                var Ctor = source.constructor;\n                if (Ctor.from) {\n                    result = Ctor.from(source);\n                }\n                else {\n                    result = new Ctor(source.length);\n                    for (var i = 0, len = source.length; i < len; i++) {\n                        result[i] = clone(source[i]);\n                    }\n                }\n            }\n        }\n        else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n            result = {};\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    result[key] = clone(source[key]);\n                }\n            }\n        }\n        return result;\n    }\n    function merge(target, source, overwrite) {\n        if (!isObject(source) || !isObject(target)) {\n            return overwrite ? clone(source) : target;\n        }\n        for (var key in source) {\n            if (source.hasOwnProperty(key)) {\n                var targetProp = target[key];\n                var sourceProp = source[key];\n                if (isObject(sourceProp)\n                    && isObject(targetProp)\n                    && !isArray(sourceProp)\n                    && !isArray(targetProp)\n                    && !isDom(sourceProp)\n                    && !isDom(targetProp)\n                    && !isBuiltInObject(sourceProp)\n                    && !isBuiltInObject(targetProp)\n                    && !isPrimitive(sourceProp)\n                    && !isPrimitive(targetProp)) {\n                    merge(targetProp, sourceProp, overwrite);\n                }\n                else if (overwrite || !(key in target)) {\n                    target[key] = clone(source[key]);\n                }\n            }\n        }\n        return target;\n    }\n    function mergeAll(targetAndSources, overwrite) {\n        var result = targetAndSources[0];\n        for (var i = 1, len = targetAndSources.length; i < len; i++) {\n            result = merge(result, targetAndSources[i], overwrite);\n        }\n        return result;\n    }\n    function extend(target, source) {\n        if (Object.assign) {\n            Object.assign(target, source);\n        }\n        else {\n            for (var key in source) {\n                if (source.hasOwnProperty(key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    }\n    function defaults(target, source, overlay) {\n        var keysArr = keys(source);\n        for (var i = 0; i < keysArr.length; i++) {\n            var key = keysArr[i];\n            if ((overlay ? source[key] != null : target[key] == null)) {\n                target[key] = source[key];\n            }\n        }\n        return target;\n    }\n    var createCanvas = function () {\n        return methods.createCanvas();\n    };\n    methods.createCanvas = function () {\n        return document.createElement('canvas');\n    };\n    function indexOf(array, value) {\n        if (array) {\n            if (array.indexOf) {\n                return array.indexOf(value);\n            }\n            for (var i = 0, len = array.length; i < len; i++) {\n                if (array[i] === value) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    function inherits(clazz, baseClazz) {\n        var clazzPrototype = clazz.prototype;\n        function F() { }\n        F.prototype = baseClazz.prototype;\n        clazz.prototype = new F();\n        for (var prop in clazzPrototype) {\n            if (clazzPrototype.hasOwnProperty(prop)) {\n                clazz.prototype[prop] = clazzPrototype[prop];\n            }\n        }\n        clazz.prototype.constructor = clazz;\n        clazz.superClass = baseClazz;\n    }\n    function mixin(target, source, override) {\n        target = 'prototype' in target ? target.prototype : target;\n        source = 'prototype' in source ? source.prototype : source;\n        if (Object.getOwnPropertyNames) {\n            var keyList = Object.getOwnPropertyNames(source);\n            for (var i = 0; i < keyList.length; i++) {\n                var key = keyList[i];\n                if (key !== 'constructor') {\n                    if ((override ? source[key] != null : target[key] == null)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n        }\n        else {\n            defaults(target, source, override);\n        }\n    }\n    function isArrayLike(data) {\n        if (!data) {\n            return false;\n        }\n        if (typeof data === 'string') {\n            return false;\n        }\n        return typeof data.length === 'number';\n    }\n    function each(arr, cb, context) {\n        if (!(arr && cb)) {\n            return;\n        }\n        if (arr.forEach && arr.forEach === nativeForEach) {\n            arr.forEach(cb, context);\n        }\n        else if (arr.length === +arr.length) {\n            for (var i = 0, len = arr.length; i < len; i++) {\n                cb.call(context, arr[i], i, arr);\n            }\n        }\n        else {\n            for (var key in arr) {\n                if (arr.hasOwnProperty(key)) {\n                    cb.call(context, arr[key], key, arr);\n                }\n            }\n        }\n    }\n    function map(arr, cb, context) {\n        if (!arr) {\n            return [];\n        }\n        if (!cb) {\n            return slice(arr);\n        }\n        if (arr.map && arr.map === nativeMap) {\n            return arr.map(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = arr.length; i < len; i++) {\n                result.push(cb.call(context, arr[i], i, arr));\n            }\n            return result;\n        }\n    }\n    function reduce(arr, cb, memo, context) {\n        if (!(arr && cb)) {\n            return;\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n            memo = cb.call(context, memo, arr[i], i, arr);\n        }\n        return memo;\n    }\n    function filter(arr, cb, context) {\n        if (!arr) {\n            return [];\n        }\n        if (!cb) {\n            return slice(arr);\n        }\n        if (arr.filter && arr.filter === nativeFilter) {\n            return arr.filter(cb, context);\n        }\n        else {\n            var result = [];\n            for (var i = 0, len = arr.length; i < len; i++) {\n                if (cb.call(context, arr[i], i, arr)) {\n                    result.push(arr[i]);\n                }\n            }\n            return result;\n        }\n    }\n    function find(arr, cb, context) {\n        if (!(arr && cb)) {\n            return;\n        }\n        for (var i = 0, len = arr.length; i < len; i++) {\n            if (cb.call(context, arr[i], i, arr)) {\n                return arr[i];\n            }\n        }\n    }\n    function keys(obj) {\n        if (!obj) {\n            return [];\n        }\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keyList = [];\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                keyList.push(key);\n            }\n        }\n        return keyList;\n    }\n    function bindPolyfill(func, context) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        return function () {\n            return func.apply(context, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    var bind = (protoFunction && isFunction(protoFunction.bind))\n        ? protoFunction.call.bind(protoFunction.bind)\n        : bindPolyfill;\n    function curry(func) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return function () {\n            return func.apply(this, args.concat(nativeSlice.call(arguments)));\n        };\n    }\n    function isArray(value) {\n        if (Array.isArray) {\n            return Array.isArray(value);\n        }\n        return objToString.call(value) === '[object Array]';\n    }\n    function isFunction(value) {\n        return typeof value === 'function';\n    }\n    function isString(value) {\n        return typeof value === 'string';\n    }\n    function isStringSafe(value) {\n        return objToString.call(value) === '[object String]';\n    }\n    function isNumber(value) {\n        return typeof value === 'number';\n    }\n    function isObject(value) {\n        var type = typeof value;\n        return type === 'function' || (!!value && type === 'object');\n    }\n    function isBuiltInObject(value) {\n        return !!BUILTIN_OBJECT[objToString.call(value)];\n    }\n    function isTypedArray(value) {\n        return !!TYPED_ARRAY[objToString.call(value)];\n    }\n    function isDom(value) {\n        return typeof value === 'object'\n            && typeof value.nodeType === 'number'\n            && typeof value.ownerDocument === 'object';\n    }\n    function isGradientObject(value) {\n        return value.colorStops != null;\n    }\n    function isPatternObject(value) {\n        return value.image != null;\n    }\n    function isRegExp(value) {\n        return objToString.call(value) === '[object RegExp]';\n    }\n    function eqNaN(value) {\n        return value !== value;\n    }\n    function retrieve() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        for (var i = 0, len = args.length; i < len; i++) {\n            if (args[i] != null) {\n                return args[i];\n            }\n        }\n    }\n    function retrieve2(value0, value1) {\n        return value0 != null\n            ? value0\n            : value1;\n    }\n    function retrieve3(value0, value1, value2) {\n        return value0 != null\n            ? value0\n            : value1 != null\n                ? value1\n                : value2;\n    }\n    function slice(arr) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        return nativeSlice.apply(arr, args);\n    }\n    function normalizeCssArray(val) {\n        if (typeof (val) === 'number') {\n            return [val, val, val, val];\n        }\n        var len = val.length;\n        if (len === 2) {\n            return [val[0], val[1], val[0], val[1]];\n        }\n        else if (len === 3) {\n            return [val[0], val[1], val[2], val[1]];\n        }\n        return val;\n    }\n    function assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n    function trim(str) {\n        if (str == null) {\n            return null;\n        }\n        else if (typeof str.trim === 'function') {\n            return str.trim();\n        }\n        else {\n            return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n        }\n    }\n    var primitiveKey = '__ec_primitive__';\n    function setAsPrimitive(obj) {\n        obj[primitiveKey] = true;\n    }\n    function isPrimitive(obj) {\n        return obj[primitiveKey];\n    }\n    var HashMap = (function () {\n        function HashMap(obj) {\n            this.data = {};\n            var isArr = isArray(obj);\n            this.data = {};\n            var thisMap = this;\n            (obj instanceof HashMap)\n                ? obj.each(visit)\n                : (obj && each(obj, visit));\n            function visit(value, key) {\n                isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n            }\n        }\n        HashMap.prototype.get = function (key) {\n            return this.data.hasOwnProperty(key) ? this.data[key] : null;\n        };\n        HashMap.prototype.set = function (key, value) {\n            return (this.data[key] = value);\n        };\n        HashMap.prototype.each = function (cb, context) {\n            for (var key in this.data) {\n                if (this.data.hasOwnProperty(key)) {\n                    cb.call(context, this.data[key], key);\n                }\n            }\n        };\n        HashMap.prototype.keys = function () {\n            return keys(this.data);\n        };\n        HashMap.prototype.removeKey = function (key) {\n            delete this.data[key];\n        };\n        return HashMap;\n    }());\n    function createHashMap(obj) {\n        return new HashMap(obj);\n    }\n    function concatArray(a, b) {\n        var newArray = new a.constructor(a.length + b.length);\n        for (var i = 0; i < a.length; i++) {\n            newArray[i] = a[i];\n        }\n        var offset = a.length;\n        for (var i = 0; i < b.length; i++) {\n            newArray[i + offset] = b[i];\n        }\n        return newArray;\n    }\n    function createObject(proto, properties) {\n        var obj;\n        if (Object.create) {\n            obj = Object.create(proto);\n        }\n        else {\n            var StyleCtor = function () { };\n            StyleCtor.prototype = proto;\n            obj = new StyleCtor();\n        }\n        if (properties) {\n            extend(obj, properties);\n        }\n        return obj;\n    }\n    function hasOwn(own, prop) {\n        return own.hasOwnProperty(prop);\n    }\n    function noop() { }\n\n    var util = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        $override: $override,\n        guid: guid,\n        logError: logError,\n        clone: clone,\n        merge: merge,\n        mergeAll: mergeAll,\n        extend: extend,\n        defaults: defaults,\n        createCanvas: createCanvas,\n        indexOf: indexOf,\n        inherits: inherits,\n        mixin: mixin,\n        isArrayLike: isArrayLike,\n        each: each,\n        map: map,\n        reduce: reduce,\n        filter: filter,\n        find: find,\n        keys: keys,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isFunction: isFunction,\n        isString: isString,\n        isStringSafe: isStringSafe,\n        isNumber: isNumber,\n        isObject: isObject,\n        isBuiltInObject: isBuiltInObject,\n        isTypedArray: isTypedArray,\n        isDom: isDom,\n        isGradientObject: isGradientObject,\n        isPatternObject: isPatternObject,\n        isRegExp: isRegExp,\n        eqNaN: eqNaN,\n        retrieve: retrieve,\n        retrieve2: retrieve2,\n        retrieve3: retrieve3,\n        slice: slice,\n        normalizeCssArray: normalizeCssArray,\n        assert: assert,\n        trim: trim,\n        setAsPrimitive: setAsPrimitive,\n        isPrimitive: isPrimitive,\n        HashMap: HashMap,\n        createHashMap: createHashMap,\n        concatArray: concatArray,\n        createObject: createObject,\n        hasOwn: hasOwn,\n        noop: noop\n    });\n\n    function create(x, y) {\n        if (x == null) {\n            x = 0;\n        }\n        if (y == null) {\n            y = 0;\n        }\n        return [x, y];\n    }\n    function copy(out, v) {\n        out[0] = v[0];\n        out[1] = v[1];\n        return out;\n    }\n    function clone$1(v) {\n        return [v[0], v[1]];\n    }\n    function set(out, a, b) {\n        out[0] = a;\n        out[1] = b;\n        return out;\n    }\n    function add(out, v1, v2) {\n        out[0] = v1[0] + v2[0];\n        out[1] = v1[1] + v2[1];\n        return out;\n    }\n    function scaleAndAdd(out, v1, v2, a) {\n        out[0] = v1[0] + v2[0] * a;\n        out[1] = v1[1] + v2[1] * a;\n        return out;\n    }\n    function sub(out, v1, v2) {\n        out[0] = v1[0] - v2[0];\n        out[1] = v1[1] - v2[1];\n        return out;\n    }\n    function len(v) {\n        return Math.sqrt(lenSquare(v));\n    }\n    var length = len;\n    function lenSquare(v) {\n        return v[0] * v[0] + v[1] * v[1];\n    }\n    var lengthSquare = lenSquare;\n    function mul(out, v1, v2) {\n        out[0] = v1[0] * v2[0];\n        out[1] = v1[1] * v2[1];\n        return out;\n    }\n    function div(out, v1, v2) {\n        out[0] = v1[0] / v2[0];\n        out[1] = v1[1] / v2[1];\n        return out;\n    }\n    function dot(v1, v2) {\n        return v1[0] * v2[0] + v1[1] * v2[1];\n    }\n    function scale(out, v, s) {\n        out[0] = v[0] * s;\n        out[1] = v[1] * s;\n        return out;\n    }\n    function normalize(out, v) {\n        var d = len(v);\n        if (d === 0) {\n            out[0] = 0;\n            out[1] = 0;\n        }\n        else {\n            out[0] = v[0] / d;\n            out[1] = v[1] / d;\n        }\n        return out;\n    }\n    function distance(v1, v2) {\n        return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0])\n            + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n    }\n    var dist = distance;\n    function distanceSquare(v1, v2) {\n        return (v1[0] - v2[0]) * (v1[0] - v2[0])\n            + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n    }\n    var distSquare = distanceSquare;\n    function negate(out, v) {\n        out[0] = -v[0];\n        out[1] = -v[1];\n        return out;\n    }\n    function lerp(out, v1, v2, t) {\n        out[0] = v1[0] + t * (v2[0] - v1[0]);\n        out[1] = v1[1] + t * (v2[1] - v1[1]);\n        return out;\n    }\n    function applyTransform(out, v, m) {\n        var x = v[0];\n        var y = v[1];\n        out[0] = m[0] * x + m[2] * y + m[4];\n        out[1] = m[1] * x + m[3] * y + m[5];\n        return out;\n    }\n    function min(out, v1, v2) {\n        out[0] = Math.min(v1[0], v2[0]);\n        out[1] = Math.min(v1[1], v2[1]);\n        return out;\n    }\n    function max(out, v1, v2) {\n        out[0] = Math.max(v1[0], v2[0]);\n        out[1] = Math.max(v1[1], v2[1]);\n        return out;\n    }\n\n    var vector = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        create: create,\n        copy: copy,\n        clone: clone$1,\n        set: set,\n        add: add,\n        scaleAndAdd: scaleAndAdd,\n        sub: sub,\n        len: len,\n        length: length,\n        lenSquare: lenSquare,\n        lengthSquare: lengthSquare,\n        mul: mul,\n        div: div,\n        dot: dot,\n        scale: scale,\n        normalize: normalize,\n        distance: distance,\n        dist: dist,\n        distanceSquare: distanceSquare,\n        distSquare: distSquare,\n        negate: negate,\n        lerp: lerp,\n        applyTransform: applyTransform,\n        min: min,\n        max: max\n    });\n\n    var Param = (function () {\n        function Param(target, e) {\n            this.target = target;\n            this.topTarget = e && e.topTarget;\n        }\n        return Param;\n    }());\n    var Draggable = (function () {\n        function Draggable(handler) {\n            this.handler = handler;\n            handler.on('mousedown', this._dragStart, this);\n            handler.on('mousemove', this._drag, this);\n            handler.on('mouseup', this._dragEnd, this);\n        }\n        Draggable.prototype._dragStart = function (e) {\n            var draggingTarget = e.target;\n            while (draggingTarget && !draggingTarget.draggable) {\n                draggingTarget = draggingTarget.parent;\n            }\n            if (draggingTarget) {\n                this._draggingTarget = draggingTarget;\n                draggingTarget.dragging = true;\n                this._x = e.offsetX;\n                this._y = e.offsetY;\n                this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragstart', e.event);\n            }\n        };\n        Draggable.prototype._drag = function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                var x = e.offsetX;\n                var y = e.offsetY;\n                var dx = x - this._x;\n                var dy = y - this._y;\n                this._x = x;\n                this._y = y;\n                draggingTarget.drift(dx, dy, e);\n                this.handler.dispatchToElement(new Param(draggingTarget, e), 'drag', e.event);\n                var dropTarget = this.handler.findHover(x, y, draggingTarget).target;\n                var lastDropTarget = this._dropTarget;\n                this._dropTarget = dropTarget;\n                if (draggingTarget !== dropTarget) {\n                    if (lastDropTarget && dropTarget !== lastDropTarget) {\n                        this.handler.dispatchToElement(new Param(lastDropTarget, e), 'dragleave', e.event);\n                    }\n                    if (dropTarget && dropTarget !== lastDropTarget) {\n                        this.handler.dispatchToElement(new Param(dropTarget, e), 'dragenter', e.event);\n                    }\n                }\n            }\n        };\n        Draggable.prototype._dragEnd = function (e) {\n            var draggingTarget = this._draggingTarget;\n            if (draggingTarget) {\n                draggingTarget.dragging = false;\n            }\n            this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragend', e.event);\n            if (this._dropTarget) {\n                this.handler.dispatchToElement(new Param(this._dropTarget, e), 'drop', e.event);\n            }\n            this._draggingTarget = null;\n            this._dropTarget = null;\n        };\n        return Draggable;\n    }());\n\n    var Eventful = (function () {\n        function Eventful(eventProcessors) {\n            if (eventProcessors) {\n                this._$eventProcessor = eventProcessors;\n            }\n        }\n        Eventful.prototype.on = function (event, query, handler, context) {\n            if (!this._$handlers) {\n                this._$handlers = {};\n            }\n            var _h = this._$handlers;\n            if (typeof query === 'function') {\n                context = handler;\n                handler = query;\n                query = null;\n            }\n            if (!handler || !event) {\n                return this;\n            }\n            var eventProcessor = this._$eventProcessor;\n            if (query != null && eventProcessor && eventProcessor.normalizeQuery) {\n                query = eventProcessor.normalizeQuery(query);\n            }\n            if (!_h[event]) {\n                _h[event] = [];\n            }\n            for (var i = 0; i < _h[event].length; i++) {\n                if (_h[event][i].h === handler) {\n                    return this;\n                }\n            }\n            var wrap = {\n                h: handler,\n                query: query,\n                ctx: (context || this),\n                callAtLast: handler.zrEventfulCallAtLast\n            };\n            var lastIndex = _h[event].length - 1;\n            var lastWrap = _h[event][lastIndex];\n            (lastWrap && lastWrap.callAtLast)\n                ? _h[event].splice(lastIndex, 0, wrap)\n                : _h[event].push(wrap);\n            return this;\n        };\n        Eventful.prototype.isSilent = function (eventName) {\n            var _h = this._$handlers;\n            return !_h || !_h[eventName] || !_h[eventName].length;\n        };\n        Eventful.prototype.off = function (eventType, handler) {\n            var _h = this._$handlers;\n            if (!_h) {\n                return this;\n            }\n            if (!eventType) {\n                this._$handlers = {};\n                return this;\n            }\n            if (handler) {\n                if (_h[eventType]) {\n                    var newList = [];\n                    for (var i = 0, l = _h[eventType].length; i < l; i++) {\n                        if (_h[eventType][i].h !== handler) {\n                            newList.push(_h[eventType][i]);\n                        }\n                    }\n                    _h[eventType] = newList;\n                }\n                if (_h[eventType] && _h[eventType].length === 0) {\n                    delete _h[eventType];\n                }\n            }\n            else {\n                delete _h[eventType];\n            }\n            return this;\n        };\n        Eventful.prototype.trigger = function (eventType) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            if (!this._$handlers) {\n                return this;\n            }\n            var _h = this._$handlers[eventType];\n            var eventProcessor = this._$eventProcessor;\n            if (_h) {\n                var argLen = args.length;\n                var len = _h.length;\n                for (var i = 0; i < len; i++) {\n                    var hItem = _h[i];\n                    if (eventProcessor\n                        && eventProcessor.filter\n                        && hItem.query != null\n                        && !eventProcessor.filter(eventType, hItem.query)) {\n                        continue;\n                    }\n                    switch (argLen) {\n                        case 0:\n                            hItem.h.call(hItem.ctx);\n                            break;\n                        case 1:\n                            hItem.h.call(hItem.ctx, args[0]);\n                            break;\n                        case 2:\n                            hItem.h.call(hItem.ctx, args[0], args[1]);\n                            break;\n                        default:\n                            hItem.h.apply(hItem.ctx, args);\n                            break;\n                    }\n                }\n            }\n            eventProcessor && eventProcessor.afterTrigger\n                && eventProcessor.afterTrigger(eventType);\n            return this;\n        };\n        Eventful.prototype.triggerWithContext = function (type) {\n            if (!this._$handlers) {\n                return this;\n            }\n            var _h = this._$handlers[type];\n            var eventProcessor = this._$eventProcessor;\n            if (_h) {\n                var args = arguments;\n                var argLen = args.length;\n                var ctx = args[argLen - 1];\n                var len = _h.length;\n                for (var i = 0; i < len; i++) {\n                    var hItem = _h[i];\n                    if (eventProcessor\n                        && eventProcessor.filter\n                        && hItem.query != null\n                        && !eventProcessor.filter(type, hItem.query)) {\n                        continue;\n                    }\n                    switch (argLen) {\n                        case 0:\n                            hItem.h.call(ctx);\n                            break;\n                        case 1:\n                            hItem.h.call(ctx, args[0]);\n                            break;\n                        case 2:\n                            hItem.h.call(ctx, args[0], args[1]);\n                            break;\n                        default:\n                            hItem.h.apply(ctx, args.slice(1, argLen - 1));\n                            break;\n                    }\n                }\n            }\n            eventProcessor && eventProcessor.afterTrigger\n                && eventProcessor.afterTrigger(type);\n            return this;\n        };\n        return Eventful;\n    }());\n\n    var LN2 = Math.log(2);\n    function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {\n        var cacheKey = rowMask + '-' + colMask;\n        var fullRank = rows.length;\n        if (detCache.hasOwnProperty(cacheKey)) {\n            return detCache[cacheKey];\n        }\n        if (rank === 1) {\n            var colStart = Math.round(Math.log(((1 << fullRank) - 1) & ~colMask) / LN2);\n            return rows[rowStart][colStart];\n        }\n        var subRowMask = rowMask | (1 << rowStart);\n        var subRowStart = rowStart + 1;\n        while (rowMask & (1 << subRowStart)) {\n            subRowStart++;\n        }\n        var sum = 0;\n        for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {\n            var colTag = 1 << j;\n            if (!(colTag & colMask)) {\n                sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j]\n                    * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);\n                colLocalIdx++;\n            }\n        }\n        detCache[cacheKey] = sum;\n        return sum;\n    }\n    function buildTransformer(src, dest) {\n        var mA = [\n            [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],\n            [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],\n            [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],\n            [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],\n            [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],\n            [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],\n            [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],\n            [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]\n        ];\n        var detCache = {};\n        var det = determinant(mA, 8, 0, 0, 0, detCache);\n        if (det === 0) {\n            return;\n        }\n        var vh = [];\n        for (var i = 0; i < 8; i++) {\n            for (var j = 0; j < 8; j++) {\n                vh[j] == null && (vh[j] = 0);\n                vh[j] += ((i + j) % 2 ? -1 : 1)\n                    * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache)\n                    / det * dest[i];\n            }\n        }\n        return function (out, srcPointX, srcPointY) {\n            var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;\n            out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;\n            out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;\n        };\n    }\n\n    var EVENT_SAVED_PROP = '___zrEVENTSAVED';\n    var _calcOut = [];\n    function transformLocalCoord(out, elFrom, elTarget, inX, inY) {\n        return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true)\n            && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);\n    }\n    function transformCoordWithViewport(out, el, inX, inY, inverse) {\n        if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {\n            var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n            var markers = prepareCoordMarkers(el, saved);\n            var transformer = preparePointerTransformer(markers, saved, inverse);\n            if (transformer) {\n                transformer(out, inX, inY);\n                return true;\n            }\n        }\n        return false;\n    }\n    function prepareCoordMarkers(el, saved) {\n        var markers = saved.markers;\n        if (markers) {\n            return markers;\n        }\n        markers = saved.markers = [];\n        var propLR = ['left', 'right'];\n        var propTB = ['top', 'bottom'];\n        for (var i = 0; i < 4; i++) {\n            var marker = document.createElement('div');\n            var stl = marker.style;\n            var idxLR = i % 2;\n            var idxTB = (i >> 1) % 2;\n            stl.cssText = [\n                'position: absolute',\n                'visibility: hidden',\n                'padding: 0',\n                'margin: 0',\n                'border-width: 0',\n                'user-select: none',\n                'width:0',\n                'height:0',\n                propLR[idxLR] + ':0',\n                propTB[idxTB] + ':0',\n                propLR[1 - idxLR] + ':auto',\n                propTB[1 - idxTB] + ':auto',\n                ''\n            ].join('!important;');\n            el.appendChild(marker);\n            markers.push(marker);\n        }\n        return markers;\n    }\n    function preparePointerTransformer(markers, saved, inverse) {\n        var transformerName = inverse ? 'invTrans' : 'trans';\n        var transformer = saved[transformerName];\n        var oldSrcCoords = saved.srcCoords;\n        var srcCoords = [];\n        var destCoords = [];\n        var oldCoordTheSame = true;\n        for (var i = 0; i < 4; i++) {\n            var rect = markers[i].getBoundingClientRect();\n            var ii = 2 * i;\n            var x = rect.left;\n            var y = rect.top;\n            srcCoords.push(x, y);\n            oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n            destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n        }\n        return (oldCoordTheSame && transformer)\n            ? transformer\n            : (saved.srcCoords = srcCoords,\n                saved[transformerName] = inverse\n                    ? buildTransformer(destCoords, srcCoords)\n                    : buildTransformer(srcCoords, destCoords));\n    }\n    function isCanvasEl(el) {\n        return el.nodeName.toUpperCase() === 'CANVAS';\n    }\n\n    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;\n    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\n    var _calcOut$1 = [];\n    function clientToLocal(el, e, out, calculate) {\n        out = out || {};\n        if (calculate || !env.canvasSupported) {\n            calculateZrXY(el, e, out);\n        }\n        else if (env.browser.firefox\n            && e.layerX != null\n            && e.layerX !== e.offsetX) {\n            out.zrX = e.layerX;\n            out.zrY = e.layerY;\n        }\n        else if (e.offsetX != null) {\n            out.zrX = e.offsetX;\n            out.zrY = e.offsetY;\n        }\n        else {\n            calculateZrXY(el, e, out);\n        }\n        return out;\n    }\n    function calculateZrXY(el, e, out) {\n        if (env.domSupported && el.getBoundingClientRect) {\n            var ex = e.clientX;\n            var ey = e.clientY;\n            if (isCanvasEl(el)) {\n                var box = el.getBoundingClientRect();\n                out.zrX = ex - box.left;\n                out.zrY = ey - box.top;\n                return;\n            }\n            else {\n                if (transformCoordWithViewport(_calcOut$1, el, ex, ey)) {\n                    out.zrX = _calcOut$1[0];\n                    out.zrY = _calcOut$1[1];\n                    return;\n                }\n            }\n        }\n        out.zrX = out.zrY = 0;\n    }\n    function getNativeEvent(e) {\n        return e\n            || window.event;\n    }\n    function normalizeEvent(el, e, calculate) {\n        e = getNativeEvent(e);\n        if (e.zrX != null) {\n            return e;\n        }\n        var eventType = e.type;\n        var isTouch = eventType && eventType.indexOf('touch') >= 0;\n        if (!isTouch) {\n            clientToLocal(el, e, e, calculate);\n            var wheelDelta = getWheelDeltaMayPolyfill(e);\n            e.zrDelta = wheelDelta ? wheelDelta / 120 : -(e.detail || 0) / 3;\n        }\n        else {\n            var touch = eventType !== 'touchend'\n                ? e.targetTouches[0]\n                : e.changedTouches[0];\n            touch && clientToLocal(el, touch, e, calculate);\n        }\n        var button = e.button;\n        if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n            e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\n        }\n        return e;\n    }\n    function getWheelDeltaMayPolyfill(e) {\n        var rawWheelDelta = e.wheelDelta;\n        if (rawWheelDelta) {\n            return rawWheelDelta;\n        }\n        var deltaX = e.deltaX;\n        var deltaY = e.deltaY;\n        if (deltaX == null || deltaY == null) {\n            return rawWheelDelta;\n        }\n        var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);\n        var sign = deltaY > 0 ? -1\n            : deltaY < 0 ? 1\n                : deltaX > 0 ? -1\n                    : 1;\n        return 3 * delta * sign;\n    }\n    function addEventListener(el, name, handler, opt) {\n        if (isDomLevel2) {\n            el.addEventListener(name, handler, opt);\n        }\n        else {\n            el.attachEvent('on' + name, handler);\n        }\n    }\n    function removeEventListener(el, name, handler, opt) {\n        if (isDomLevel2) {\n            el.removeEventListener(name, handler, opt);\n        }\n        else {\n            el.detachEvent('on' + name, handler);\n        }\n    }\n    var stop = isDomLevel2\n        ? function (e) {\n            e.preventDefault();\n            e.stopPropagation();\n            e.cancelBubble = true;\n        }\n        : function (e) {\n            e.returnValue = false;\n            e.cancelBubble = true;\n        };\n    function isMiddleOrRightButtonOnMouseUpDown(e) {\n        return e.which === 2 || e.which === 3;\n    }\n\n    var GestureMgr = (function () {\n        function GestureMgr() {\n            this._track = [];\n        }\n        GestureMgr.prototype.recognize = function (event, target, root) {\n            this._doTrack(event, target, root);\n            return this._recognize(event);\n        };\n        GestureMgr.prototype.clear = function () {\n            this._track.length = 0;\n            return this;\n        };\n        GestureMgr.prototype._doTrack = function (event, target, root) {\n            var touches = event.touches;\n            if (!touches) {\n                return;\n            }\n            var trackItem = {\n                points: [],\n                touches: [],\n                target: target,\n                event: event\n            };\n            for (var i = 0, len = touches.length; i < len; i++) {\n                var touch = touches[i];\n                var pos = clientToLocal(root, touch, {});\n                trackItem.points.push([pos.zrX, pos.zrY]);\n                trackItem.touches.push(touch);\n            }\n            this._track.push(trackItem);\n        };\n        GestureMgr.prototype._recognize = function (event) {\n            for (var eventName in recognizers) {\n                if (recognizers.hasOwnProperty(eventName)) {\n                    var gestureInfo = recognizers[eventName](this._track, event);\n                    if (gestureInfo) {\n                        return gestureInfo;\n                    }\n                }\n            }\n        };\n        return GestureMgr;\n    }());\n    function dist$1(pointPair) {\n        var dx = pointPair[1][0] - pointPair[0][0];\n        var dy = pointPair[1][1] - pointPair[0][1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    function center(pointPair) {\n        return [\n            (pointPair[0][0] + pointPair[1][0]) / 2,\n            (pointPair[0][1] + pointPair[1][1]) / 2\n        ];\n    }\n    var recognizers = {\n        pinch: function (tracks, event) {\n            var trackLen = tracks.length;\n            if (!trackLen) {\n                return;\n            }\n            var pinchEnd = (tracks[trackLen - 1] || {}).points;\n            var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;\n            if (pinchPre\n                && pinchPre.length > 1\n                && pinchEnd\n                && pinchEnd.length > 1) {\n                var pinchScale = dist$1(pinchEnd) / dist$1(pinchPre);\n                !isFinite(pinchScale) && (pinchScale = 1);\n                event.pinchScale = pinchScale;\n                var pinchCenter = center(pinchEnd);\n                event.pinchX = pinchCenter[0];\n                event.pinchY = pinchCenter[1];\n                return {\n                    type: 'pinch',\n                    target: tracks[0].target,\n                    event: event\n                };\n            }\n        }\n    };\n\n    var SILENT = 'silent';\n    function makeEventPacket(eveType, targetInfo, event) {\n        return {\n            type: eveType,\n            event: event,\n            target: targetInfo.target,\n            topTarget: targetInfo.topTarget,\n            cancelBubble: false,\n            offsetX: event.zrX,\n            offsetY: event.zrY,\n            gestureEvent: event.gestureEvent,\n            pinchX: event.pinchX,\n            pinchY: event.pinchY,\n            pinchScale: event.pinchScale,\n            wheelDelta: event.zrDelta,\n            zrByTouch: event.zrByTouch,\n            which: event.which,\n            stop: stopEvent\n        };\n    }\n    function stopEvent() {\n        stop(this.event);\n    }\n    var EmptyProxy = (function (_super) {\n        __extends(EmptyProxy, _super);\n        function EmptyProxy() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handler = null;\n            return _this;\n        }\n        EmptyProxy.prototype.dispose = function () { };\n        EmptyProxy.prototype.setCursor = function () { };\n        return EmptyProxy;\n    }(Eventful));\n    var HoveredResult = (function () {\n        function HoveredResult(x, y) {\n            this.x = x;\n            this.y = y;\n        }\n        return HoveredResult;\n    }());\n    var handlerNames = [\n        'click', 'dblclick', 'mousewheel', 'mouseout',\n        'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n    ];\n    var Handler = (function (_super) {\n        __extends(Handler, _super);\n        function Handler(storage, painter, proxy, painterRoot) {\n            var _this = _super.call(this) || this;\n            _this._hovered = new HoveredResult(0, 0);\n            _this.storage = storage;\n            _this.painter = painter;\n            _this.painterRoot = painterRoot;\n            proxy = proxy || new EmptyProxy();\n            _this.proxy = null;\n            _this.setHandlerProxy(proxy);\n            _this._draggingMgr = new Draggable(_this);\n            return _this;\n        }\n        Handler.prototype.setHandlerProxy = function (proxy) {\n            if (this.proxy) {\n                this.proxy.dispose();\n            }\n            if (proxy) {\n                each(handlerNames, function (name) {\n                    proxy.on && proxy.on(name, this[name], this);\n                }, this);\n                proxy.handler = this;\n            }\n            this.proxy = proxy;\n        };\n        Handler.prototype.mousemove = function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var isOutside = isOutsideBoundary(this, x, y);\n            var lastHovered = this._hovered;\n            var lastHoveredTarget = lastHovered.target;\n            if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n                lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n                lastHoveredTarget = lastHovered.target;\n            }\n            var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);\n            var hoveredTarget = hovered.target;\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');\n            if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(lastHovered, 'mouseout', event);\n            }\n            this.dispatchToElement(hovered, 'mousemove', event);\n            if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n                this.dispatchToElement(hovered, 'mouseover', event);\n            }\n        };\n        Handler.prototype.mouseout = function (event) {\n            var eventControl = event.zrEventControl;\n            if (eventControl !== 'only_globalout') {\n                this.dispatchToElement(this._hovered, 'mouseout', event);\n            }\n            if (eventControl !== 'no_globalout') {\n                this.trigger('globalout', { type: 'globalout', event: event });\n            }\n        };\n        Handler.prototype.resize = function () {\n            this._hovered = new HoveredResult(0, 0);\n        };\n        Handler.prototype.dispatch = function (eventName, eventArgs) {\n            var handler = this[eventName];\n            handler && handler.call(this, eventArgs);\n        };\n        Handler.prototype.dispose = function () {\n            this.proxy.dispose();\n            this.storage = null;\n            this.proxy = null;\n            this.painter = null;\n        };\n        Handler.prototype.setCursorStyle = function (cursorStyle) {\n            var proxy = this.proxy;\n            proxy.setCursor && proxy.setCursor(cursorStyle);\n        };\n        Handler.prototype.dispatchToElement = function (targetInfo, eventName, event) {\n            targetInfo = targetInfo || {};\n            var el = targetInfo.target;\n            if (el && el.silent) {\n                return;\n            }\n            var eventKey = ('on' + eventName);\n            var eventPacket = makeEventPacket(eventName, targetInfo, event);\n            while (el) {\n                el[eventKey]\n                    && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));\n                el.trigger(eventName, eventPacket);\n                el = el.__hostTarget ? el.__hostTarget : el.parent;\n                if (eventPacket.cancelBubble) {\n                    break;\n                }\n            }\n            if (!eventPacket.cancelBubble) {\n                this.trigger(eventName, eventPacket);\n                if (this.painter && this.painter.eachOtherLayer) {\n                    this.painter.eachOtherLayer(function (layer) {\n                        if (typeof (layer[eventKey]) === 'function') {\n                            layer[eventKey].call(layer, eventPacket);\n                        }\n                        if (layer.trigger) {\n                            layer.trigger(eventName, eventPacket);\n                        }\n                    });\n                }\n            }\n        };\n        Handler.prototype.findHover = function (x, y, exclude) {\n            var list = this.storage.getDisplayList();\n            var out = new HoveredResult(x, y);\n            for (var i = list.length - 1; i >= 0; i--) {\n                var hoverCheckResult = void 0;\n                if (list[i] !== exclude\n                    && !list[i].ignore\n                    && (hoverCheckResult = isHover(list[i], x, y))) {\n                    !out.topTarget && (out.topTarget = list[i]);\n                    if (hoverCheckResult !== SILENT) {\n                        out.target = list[i];\n                        break;\n                    }\n                }\n            }\n            return out;\n        };\n        Handler.prototype.processGesture = function (event, stage) {\n            if (!this._gestureMgr) {\n                this._gestureMgr = new GestureMgr();\n            }\n            var gestureMgr = this._gestureMgr;\n            stage === 'start' && gestureMgr.clear();\n            var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\n            stage === 'end' && gestureMgr.clear();\n            if (gestureInfo) {\n                var type = gestureInfo.type;\n                event.gestureEvent = type;\n                var res = new HoveredResult();\n                res.target = gestureInfo.target;\n                this.dispatchToElement(res, type, gestureInfo.event);\n            }\n        };\n        return Handler;\n    }(Eventful));\n    each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n        Handler.prototype[name] = function (event) {\n            var x = event.zrX;\n            var y = event.zrY;\n            var isOutside = isOutsideBoundary(this, x, y);\n            var hovered;\n            var hoveredTarget;\n            if (name !== 'mouseup' || !isOutside) {\n                hovered = this.findHover(x, y);\n                hoveredTarget = hovered.target;\n            }\n            if (name === 'mousedown') {\n                this._downEl = hoveredTarget;\n                this._downPoint = [event.zrX, event.zrY];\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'mouseup') {\n                this._upEl = hoveredTarget;\n            }\n            else if (name === 'click') {\n                if (this._downEl !== this._upEl\n                    || !this._downPoint\n                    || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n                    return;\n                }\n                this._downPoint = null;\n            }\n            this.dispatchToElement(hovered, name, event);\n        };\n    });\n    function isHover(displayable, x, y) {\n        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n            var el = displayable;\n            var isSilent = void 0;\n            var ignoreClip = false;\n            while (el) {\n                if (el.ignoreClip) {\n                    ignoreClip = true;\n                }\n                if (!ignoreClip) {\n                    var clipPath = el.getClipPath();\n                    if (clipPath && !clipPath.contain(x, y)) {\n                        return false;\n                    }\n                    if (el.silent) {\n                        isSilent = true;\n                    }\n                }\n                var hostEl = el.__hostTarget;\n                el = hostEl ? hostEl : el.parent;\n            }\n            return isSilent ? SILENT : true;\n        }\n        return false;\n    }\n    function isOutsideBoundary(handlerInstance, x, y) {\n        var painter = handlerInstance.painter;\n        return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\n    }\n\n    function create$1() {\n        return [1, 0, 0, 1, 0, 0];\n    }\n    function identity(out) {\n        out[0] = 1;\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 1;\n        out[4] = 0;\n        out[5] = 0;\n        return out;\n    }\n    function copy$1(out, m) {\n        out[0] = m[0];\n        out[1] = m[1];\n        out[2] = m[2];\n        out[3] = m[3];\n        out[4] = m[4];\n        out[5] = m[5];\n        return out;\n    }\n    function mul$1(out, m1, m2) {\n        var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n        var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n        var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n        var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n        var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n        var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n        out[0] = out0;\n        out[1] = out1;\n        out[2] = out2;\n        out[3] = out3;\n        out[4] = out4;\n        out[5] = out5;\n        return out;\n    }\n    function translate(out, a, v) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[4] = a[4] + v[0];\n        out[5] = a[5] + v[1];\n        return out;\n    }\n    function rotate(out, a, rad) {\n        var aa = a[0];\n        var ac = a[2];\n        var atx = a[4];\n        var ab = a[1];\n        var ad = a[3];\n        var aty = a[5];\n        var st = Math.sin(rad);\n        var ct = Math.cos(rad);\n        out[0] = aa * ct + ab * st;\n        out[1] = -aa * st + ab * ct;\n        out[2] = ac * ct + ad * st;\n        out[3] = -ac * st + ct * ad;\n        out[4] = ct * atx + st * aty;\n        out[5] = ct * aty - st * atx;\n        return out;\n    }\n    function scale$1(out, a, v) {\n        var vx = v[0];\n        var vy = v[1];\n        out[0] = a[0] * vx;\n        out[1] = a[1] * vy;\n        out[2] = a[2] * vx;\n        out[3] = a[3] * vy;\n        out[4] = a[4] * vx;\n        out[5] = a[5] * vy;\n        return out;\n    }\n    function invert(out, a) {\n        var aa = a[0];\n        var ac = a[2];\n        var atx = a[4];\n        var ab = a[1];\n        var ad = a[3];\n        var aty = a[5];\n        var det = aa * ad - ab * ac;\n        if (!det) {\n            return null;\n        }\n        det = 1.0 / det;\n        out[0] = ad * det;\n        out[1] = -ab * det;\n        out[2] = -ac * det;\n        out[3] = aa * det;\n        out[4] = (ac * aty - ad * atx) * det;\n        out[5] = (ab * atx - aa * aty) * det;\n        return out;\n    }\n    function clone$2(a) {\n        var b = create$1();\n        copy$1(b, a);\n        return b;\n    }\n\n    var matrix = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        create: create$1,\n        identity: identity,\n        copy: copy$1,\n        mul: mul$1,\n        translate: translate,\n        rotate: rotate,\n        scale: scale$1,\n        invert: invert,\n        clone: clone$2\n    });\n\n    var mIdentity = identity;\n    var EPSILON = 5e-5;\n    function isNotAroundZero(val) {\n        return val > EPSILON || val < -EPSILON;\n    }\n    var scaleTmp = [];\n    var tmpTransform = [];\n    var originTransform = create$1();\n    var abs = Math.abs;\n    var Transformable = (function () {\n        function Transformable() {\n        }\n        Transformable.prototype.setPosition = function (arr) {\n            this.x = arr[0];\n            this.y = arr[1];\n        };\n        Transformable.prototype.setScale = function (arr) {\n            this.scaleX = arr[0];\n            this.scaleY = arr[1];\n        };\n        Transformable.prototype.setOrigin = function (arr) {\n            this.originX = arr[0];\n            this.originY = arr[1];\n        };\n        Transformable.prototype.needLocalTransform = function () {\n            return isNotAroundZero(this.rotation)\n                || isNotAroundZero(this.x)\n                || isNotAroundZero(this.y)\n                || isNotAroundZero(this.scaleX - 1)\n                || isNotAroundZero(this.scaleY - 1);\n        };\n        Transformable.prototype.updateTransform = function () {\n            var parent = this.parent;\n            var parentHasTransform = parent && parent.transform;\n            var needLocalTransform = this.needLocalTransform();\n            var m = this.transform;\n            if (!(needLocalTransform || parentHasTransform)) {\n                m && mIdentity(m);\n                return;\n            }\n            m = m || create$1();\n            if (needLocalTransform) {\n                this.getLocalTransform(m);\n            }\n            else {\n                mIdentity(m);\n            }\n            if (parentHasTransform) {\n                if (needLocalTransform) {\n                    mul$1(m, parent.transform, m);\n                }\n                else {\n                    copy$1(m, parent.transform);\n                }\n            }\n            this.transform = m;\n            this._resolveGlobalScaleRatio(m);\n        };\n        Transformable.prototype._resolveGlobalScaleRatio = function (m) {\n            var globalScaleRatio = this.globalScaleRatio;\n            if (globalScaleRatio != null && globalScaleRatio !== 1) {\n                this.getGlobalScale(scaleTmp);\n                var relX = scaleTmp[0] < 0 ? -1 : 1;\n                var relY = scaleTmp[1] < 0 ? -1 : 1;\n                var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;\n                var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;\n                m[0] *= sx;\n                m[1] *= sx;\n                m[2] *= sy;\n                m[3] *= sy;\n            }\n            this.invTransform = this.invTransform || create$1();\n            invert(this.invTransform, m);\n        };\n        Transformable.prototype.getLocalTransform = function (m) {\n            return Transformable.getLocalTransform(this, m);\n        };\n        Transformable.prototype.getComputedTransform = function () {\n            var transformNode = this;\n            var ancestors = [];\n            while (transformNode) {\n                ancestors.push(transformNode);\n                transformNode = transformNode.parent;\n            }\n            while (transformNode = ancestors.pop()) {\n                transformNode.updateTransform();\n            }\n            return this.transform;\n        };\n        Transformable.prototype.setLocalTransform = function (m) {\n            if (!m) {\n                return;\n            }\n            var sx = m[0] * m[0] + m[1] * m[1];\n            var sy = m[2] * m[2] + m[3] * m[3];\n            if (isNotAroundZero(sx - 1)) {\n                sx = Math.sqrt(sx);\n            }\n            if (isNotAroundZero(sy - 1)) {\n                sy = Math.sqrt(sy);\n            }\n            if (m[0] < 0) {\n                sx = -sx;\n            }\n            if (m[3] < 0) {\n                sy = -sy;\n            }\n            this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n            if (sx < 0 && sy < 0) {\n                this.rotation += Math.PI;\n                sx = -sx;\n                sy = -sy;\n            }\n            this.x = m[4];\n            this.y = m[5];\n            this.scaleX = sx;\n            this.scaleY = sy;\n        };\n        Transformable.prototype.decomposeTransform = function () {\n            if (!this.transform) {\n                return;\n            }\n            var parent = this.parent;\n            var m = this.transform;\n            if (parent && parent.transform) {\n                mul$1(tmpTransform, parent.invTransform, m);\n                m = tmpTransform;\n            }\n            var ox = this.originX;\n            var oy = this.originY;\n            if (ox || oy) {\n                originTransform[4] = ox;\n                originTransform[5] = oy;\n                mul$1(tmpTransform, m, originTransform);\n                tmpTransform[4] -= ox;\n                tmpTransform[5] -= oy;\n                m = tmpTransform;\n            }\n            this.setLocalTransform(m);\n        };\n        Transformable.prototype.getGlobalScale = function (out) {\n            var m = this.transform;\n            out = out || [];\n            if (!m) {\n                out[0] = 1;\n                out[1] = 1;\n                return out;\n            }\n            out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n            out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n            if (m[0] < 0) {\n                out[0] = -out[0];\n            }\n            if (m[3] < 0) {\n                out[1] = -out[1];\n            }\n            return out;\n        };\n        Transformable.prototype.transformCoordToLocal = function (x, y) {\n            var v2 = [x, y];\n            var invTransform = this.invTransform;\n            if (invTransform) {\n                applyTransform(v2, v2, invTransform);\n            }\n            return v2;\n        };\n        Transformable.prototype.transformCoordToGlobal = function (x, y) {\n            var v2 = [x, y];\n            var transform = this.transform;\n            if (transform) {\n                applyTransform(v2, v2, transform);\n            }\n            return v2;\n        };\n        Transformable.prototype.getLineScale = function () {\n            var m = this.transform;\n            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10\n                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))\n                : 1;\n        };\n        Transformable.getLocalTransform = function (target, m) {\n            m = m || [];\n            mIdentity(m);\n            var ox = target.originX || 0;\n            var oy = target.originY || 0;\n            var sx = target.scaleX;\n            var sy = target.scaleY;\n            var rotation = target.rotation || 0;\n            var x = target.x;\n            var y = target.y;\n            m[4] -= ox;\n            m[5] -= oy;\n            m[0] *= sx;\n            m[1] *= sy;\n            m[2] *= sx;\n            m[3] *= sy;\n            m[4] *= sx;\n            m[5] *= sy;\n            if (rotation) {\n                rotate(m, m, rotation);\n            }\n            m[4] += ox;\n            m[5] += oy;\n            m[4] += x;\n            m[5] += y;\n            return m;\n        };\n        Transformable.initDefaultProps = (function () {\n            var proto = Transformable.prototype;\n            proto.x = 0;\n            proto.y = 0;\n            proto.scaleX = 1;\n            proto.scaleY = 1;\n            proto.originX = 0;\n            proto.originY = 0;\n            proto.rotation = 0;\n            proto.globalScaleRatio = 1;\n        })();\n        return Transformable;\n    }());\n\n    var easing = {\n        linear: function (k) {\n            return k;\n        },\n        quadraticIn: function (k) {\n            return k * k;\n        },\n        quadraticOut: function (k) {\n            return k * (2 - k);\n        },\n        quadraticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k;\n            }\n            return -0.5 * (--k * (k - 2) - 1);\n        },\n        cubicIn: function (k) {\n            return k * k * k;\n        },\n        cubicOut: function (k) {\n            return --k * k * k + 1;\n        },\n        cubicInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k + 2);\n        },\n        quarticIn: function (k) {\n            return k * k * k * k;\n        },\n        quarticOut: function (k) {\n            return 1 - (--k * k * k * k);\n        },\n        quarticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k;\n            }\n            return -0.5 * ((k -= 2) * k * k * k - 2);\n        },\n        quinticIn: function (k) {\n            return k * k * k * k * k;\n        },\n        quinticOut: function (k) {\n            return --k * k * k * k * k + 1;\n        },\n        quinticInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return 0.5 * k * k * k * k * k;\n            }\n            return 0.5 * ((k -= 2) * k * k * k * k + 2);\n        },\n        sinusoidalIn: function (k) {\n            return 1 - Math.cos(k * Math.PI / 2);\n        },\n        sinusoidalOut: function (k) {\n            return Math.sin(k * Math.PI / 2);\n        },\n        sinusoidalInOut: function (k) {\n            return 0.5 * (1 - Math.cos(Math.PI * k));\n        },\n        exponentialIn: function (k) {\n            return k === 0 ? 0 : Math.pow(1024, k - 1);\n        },\n        exponentialOut: function (k) {\n            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n        },\n        exponentialInOut: function (k) {\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if ((k *= 2) < 1) {\n                return 0.5 * Math.pow(1024, k - 1);\n            }\n            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n        },\n        circularIn: function (k) {\n            return 1 - Math.sqrt(1 - k * k);\n        },\n        circularOut: function (k) {\n            return Math.sqrt(1 - (--k * k));\n        },\n        circularInOut: function (k) {\n            if ((k *= 2) < 1) {\n                return -0.5 * (Math.sqrt(1 - k * k) - 1);\n            }\n            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n        },\n        elasticIn: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1;\n                s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return -(a * Math.pow(2, 10 * (k -= 1))\n                * Math.sin((k - s) * (2 * Math.PI) / p));\n        },\n        elasticOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1;\n                s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            return (a * Math.pow(2, -10 * k)\n                * Math.sin((k - s) * (2 * Math.PI) / p) + 1);\n        },\n        elasticInOut: function (k) {\n            var s;\n            var a = 0.1;\n            var p = 0.4;\n            if (k === 0) {\n                return 0;\n            }\n            if (k === 1) {\n                return 1;\n            }\n            if (!a || a < 1) {\n                a = 1;\n                s = p / 4;\n            }\n            else {\n                s = p * Math.asin(1 / a) / (2 * Math.PI);\n            }\n            if ((k *= 2) < 1) {\n                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))\n                    * Math.sin((k - s) * (2 * Math.PI) / p));\n            }\n            return a * Math.pow(2, -10 * (k -= 1))\n                * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n        },\n        backIn: function (k) {\n            var s = 1.70158;\n            return k * k * ((s + 1) * k - s);\n        },\n        backOut: function (k) {\n            var s = 1.70158;\n            return --k * k * ((s + 1) * k + s) + 1;\n        },\n        backInOut: function (k) {\n            var s = 1.70158 * 1.525;\n            if ((k *= 2) < 1) {\n                return 0.5 * (k * k * ((s + 1) * k - s));\n            }\n            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n        },\n        bounceIn: function (k) {\n            return 1 - easing.bounceOut(1 - k);\n        },\n        bounceOut: function (k) {\n            if (k < (1 / 2.75)) {\n                return 7.5625 * k * k;\n            }\n            else if (k < (2 / 2.75)) {\n                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n            }\n            else if (k < (2.5 / 2.75)) {\n                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n            }\n            else {\n                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n            }\n        },\n        bounceInOut: function (k) {\n            if (k < 0.5) {\n                return easing.bounceIn(k * 2) * 0.5;\n            }\n            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n        }\n    };\n\n    var Clip = (function () {\n        function Clip(opts) {\n            this._initialized = false;\n            this._startTime = 0;\n            this._pausedTime = 0;\n            this._paused = false;\n            this._life = opts.life || 1000;\n            this._delay = opts.delay || 0;\n            this.loop = opts.loop == null ? false : opts.loop;\n            this.gap = opts.gap || 0;\n            this.easing = opts.easing || 'linear';\n            this.onframe = opts.onframe;\n            this.ondestroy = opts.ondestroy;\n            this.onrestart = opts.onrestart;\n        }\n        Clip.prototype.step = function (globalTime, deltaTime) {\n            if (!this._initialized) {\n                this._startTime = globalTime + this._delay;\n                this._initialized = true;\n            }\n            if (this._paused) {\n                this._pausedTime += deltaTime;\n                return;\n            }\n            var percent = (globalTime - this._startTime - this._pausedTime) / this._life;\n            if (percent < 0) {\n                percent = 0;\n            }\n            percent = Math.min(percent, 1);\n            var easing$1 = this.easing;\n            var easingFunc = typeof easing$1 === 'string'\n                ? easing[easing$1] : easing$1;\n            var schedule = typeof easingFunc === 'function'\n                ? easingFunc(percent)\n                : percent;\n            this.onframe && this.onframe(schedule);\n            if (percent === 1) {\n                if (this.loop) {\n                    this._restart(globalTime);\n                    this.onrestart && this.onrestart();\n                }\n                else {\n                    return true;\n                }\n            }\n            return false;\n        };\n        Clip.prototype._restart = function (globalTime) {\n            var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n            this._startTime = globalTime - remainder + this.gap;\n            this._pausedTime = 0;\n        };\n        Clip.prototype.pause = function () {\n            this._paused = true;\n        };\n        Clip.prototype.resume = function () {\n            this._paused = false;\n        };\n        return Clip;\n    }());\n\n    var Entry = (function () {\n        function Entry(val) {\n            this.value = val;\n        }\n        return Entry;\n    }());\n    var LinkedList = (function () {\n        function LinkedList() {\n            this._len = 0;\n        }\n        LinkedList.prototype.insert = function (val) {\n            var entry = new Entry(val);\n            this.insertEntry(entry);\n            return entry;\n        };\n        LinkedList.prototype.insertEntry = function (entry) {\n            if (!this.head) {\n                this.head = this.tail = entry;\n            }\n            else {\n                this.tail.next = entry;\n                entry.prev = this.tail;\n                entry.next = null;\n                this.tail = entry;\n            }\n            this._len++;\n        };\n        LinkedList.prototype.remove = function (entry) {\n            var prev = entry.prev;\n            var next = entry.next;\n            if (prev) {\n                prev.next = next;\n            }\n            else {\n                this.head = next;\n            }\n            if (next) {\n                next.prev = prev;\n            }\n            else {\n                this.tail = prev;\n            }\n            entry.next = entry.prev = null;\n            this._len--;\n        };\n        LinkedList.prototype.len = function () {\n            return this._len;\n        };\n        LinkedList.prototype.clear = function () {\n            this.head = this.tail = null;\n            this._len = 0;\n        };\n        return LinkedList;\n    }());\n    var LRU = (function () {\n        function LRU(maxSize) {\n            this._list = new LinkedList();\n            this._maxSize = 10;\n            this._map = {};\n            this._maxSize = maxSize;\n        }\n        LRU.prototype.put = function (key, value) {\n            var list = this._list;\n            var map = this._map;\n            var removed = null;\n            if (map[key] == null) {\n                var len = list.len();\n                var entry = this._lastRemovedEntry;\n                if (len >= this._maxSize && len > 0) {\n                    var leastUsedEntry = list.head;\n                    list.remove(leastUsedEntry);\n                    delete map[leastUsedEntry.key];\n                    removed = leastUsedEntry.value;\n                    this._lastRemovedEntry = leastUsedEntry;\n                }\n                if (entry) {\n                    entry.value = value;\n                }\n                else {\n                    entry = new Entry(value);\n                }\n                entry.key = key;\n                list.insertEntry(entry);\n                map[key] = entry;\n            }\n            return removed;\n        };\n        LRU.prototype.get = function (key) {\n            var entry = this._map[key];\n            var list = this._list;\n            if (entry != null) {\n                if (entry !== list.tail) {\n                    list.remove(entry);\n                    list.insertEntry(entry);\n                }\n                return entry.value;\n            }\n        };\n        LRU.prototype.clear = function () {\n            this._list.clear();\n            this._map = {};\n        };\n        LRU.prototype.len = function () {\n            return this._list.len();\n        };\n        return LRU;\n    }());\n\n    var kCSSColorTable = {\n        'transparent': [0, 0, 0, 0], 'aliceblue': [240, 248, 255, 1],\n        'antiquewhite': [250, 235, 215, 1], 'aqua': [0, 255, 255, 1],\n        'aquamarine': [127, 255, 212, 1], 'azure': [240, 255, 255, 1],\n        'beige': [245, 245, 220, 1], 'bisque': [255, 228, 196, 1],\n        'black': [0, 0, 0, 1], 'blanchedalmond': [255, 235, 205, 1],\n        'blue': [0, 0, 255, 1], 'blueviolet': [138, 43, 226, 1],\n        'brown': [165, 42, 42, 1], 'burlywood': [222, 184, 135, 1],\n        'cadetblue': [95, 158, 160, 1], 'chartreuse': [127, 255, 0, 1],\n        'chocolate': [210, 105, 30, 1], 'coral': [255, 127, 80, 1],\n        'cornflowerblue': [100, 149, 237, 1], 'cornsilk': [255, 248, 220, 1],\n        'crimson': [220, 20, 60, 1], 'cyan': [0, 255, 255, 1],\n        'darkblue': [0, 0, 139, 1], 'darkcyan': [0, 139, 139, 1],\n        'darkgoldenrod': [184, 134, 11, 1], 'darkgray': [169, 169, 169, 1],\n        'darkgreen': [0, 100, 0, 1], 'darkgrey': [169, 169, 169, 1],\n        'darkkhaki': [189, 183, 107, 1], 'darkmagenta': [139, 0, 139, 1],\n        'darkolivegreen': [85, 107, 47, 1], 'darkorange': [255, 140, 0, 1],\n        'darkorchid': [153, 50, 204, 1], 'darkred': [139, 0, 0, 1],\n        'darksalmon': [233, 150, 122, 1], 'darkseagreen': [143, 188, 143, 1],\n        'darkslateblue': [72, 61, 139, 1], 'darkslategray': [47, 79, 79, 1],\n        'darkslategrey': [47, 79, 79, 1], 'darkturquoise': [0, 206, 209, 1],\n        'darkviolet': [148, 0, 211, 1], 'deeppink': [255, 20, 147, 1],\n        'deepskyblue': [0, 191, 255, 1], 'dimgray': [105, 105, 105, 1],\n        'dimgrey': [105, 105, 105, 1], 'dodgerblue': [30, 144, 255, 1],\n        'firebrick': [178, 34, 34, 1], 'floralwhite': [255, 250, 240, 1],\n        'forestgreen': [34, 139, 34, 1], 'fuchsia': [255, 0, 255, 1],\n        'gainsboro': [220, 220, 220, 1], 'ghostwhite': [248, 248, 255, 1],\n        'gold': [255, 215, 0, 1], 'goldenrod': [218, 165, 32, 1],\n        'gray': [128, 128, 128, 1], 'green': [0, 128, 0, 1],\n        'greenyellow': [173, 255, 47, 1], 'grey': [128, 128, 128, 1],\n        'honeydew': [240, 255, 240, 1], 'hotpink': [255, 105, 180, 1],\n        'indianred': [205, 92, 92, 1], 'indigo': [75, 0, 130, 1],\n        'ivory': [255, 255, 240, 1], 'khaki': [240, 230, 140, 1],\n        'lavender': [230, 230, 250, 1], 'lavenderblush': [255, 240, 245, 1],\n        'lawngreen': [124, 252, 0, 1], 'lemonchiffon': [255, 250, 205, 1],\n        'lightblue': [173, 216, 230, 1], 'lightcoral': [240, 128, 128, 1],\n        'lightcyan': [224, 255, 255, 1], 'lightgoldenrodyellow': [250, 250, 210, 1],\n        'lightgray': [211, 211, 211, 1], 'lightgreen': [144, 238, 144, 1],\n        'lightgrey': [211, 211, 211, 1], 'lightpink': [255, 182, 193, 1],\n        'lightsalmon': [255, 160, 122, 1], 'lightseagreen': [32, 178, 170, 1],\n        'lightskyblue': [135, 206, 250, 1], 'lightslategray': [119, 136, 153, 1],\n        'lightslategrey': [119, 136, 153, 1], 'lightsteelblue': [176, 196, 222, 1],\n        'lightyellow': [255, 255, 224, 1], 'lime': [0, 255, 0, 1],\n        'limegreen': [50, 205, 50, 1], 'linen': [250, 240, 230, 1],\n        'magenta': [255, 0, 255, 1], 'maroon': [128, 0, 0, 1],\n        'mediumaquamarine': [102, 205, 170, 1], 'mediumblue': [0, 0, 205, 1],\n        'mediumorchid': [186, 85, 211, 1], 'mediumpurple': [147, 112, 219, 1],\n        'mediumseagreen': [60, 179, 113, 1], 'mediumslateblue': [123, 104, 238, 1],\n        'mediumspringgreen': [0, 250, 154, 1], 'mediumturquoise': [72, 209, 204, 1],\n        'mediumvioletred': [199, 21, 133, 1], 'midnightblue': [25, 25, 112, 1],\n        'mintcream': [245, 255, 250, 1], 'mistyrose': [255, 228, 225, 1],\n        'moccasin': [255, 228, 181, 1], 'navajowhite': [255, 222, 173, 1],\n        'navy': [0, 0, 128, 1], 'oldlace': [253, 245, 230, 1],\n        'olive': [128, 128, 0, 1], 'olivedrab': [107, 142, 35, 1],\n        'orange': [255, 165, 0, 1], 'orangered': [255, 69, 0, 1],\n        'orchid': [218, 112, 214, 1], 'palegoldenrod': [238, 232, 170, 1],\n        'palegreen': [152, 251, 152, 1], 'paleturquoise': [175, 238, 238, 1],\n        'palevioletred': [219, 112, 147, 1], 'papayawhip': [255, 239, 213, 1],\n        'peachpuff': [255, 218, 185, 1], 'peru': [205, 133, 63, 1],\n        'pink': [255, 192, 203, 1], 'plum': [221, 160, 221, 1],\n        'powderblue': [176, 224, 230, 1], 'purple': [128, 0, 128, 1],\n        'red': [255, 0, 0, 1], 'rosybrown': [188, 143, 143, 1],\n        'royalblue': [65, 105, 225, 1], 'saddlebrown': [139, 69, 19, 1],\n        'salmon': [250, 128, 114, 1], 'sandybrown': [244, 164, 96, 1],\n        'seagreen': [46, 139, 87, 1], 'seashell': [255, 245, 238, 1],\n        'sienna': [160, 82, 45, 1], 'silver': [192, 192, 192, 1],\n        'skyblue': [135, 206, 235, 1], 'slateblue': [106, 90, 205, 1],\n        'slategray': [112, 128, 144, 1], 'slategrey': [112, 128, 144, 1],\n        'snow': [255, 250, 250, 1], 'springgreen': [0, 255, 127, 1],\n        'steelblue': [70, 130, 180, 1], 'tan': [210, 180, 140, 1],\n        'teal': [0, 128, 128, 1], 'thistle': [216, 191, 216, 1],\n        'tomato': [255, 99, 71, 1], 'turquoise': [64, 224, 208, 1],\n        'violet': [238, 130, 238, 1], 'wheat': [245, 222, 179, 1],\n        'white': [255, 255, 255, 1], 'whitesmoke': [245, 245, 245, 1],\n        'yellow': [255, 255, 0, 1], 'yellowgreen': [154, 205, 50, 1]\n    };\n    function clampCssByte(i) {\n        i = Math.round(i);\n        return i < 0 ? 0 : i > 255 ? 255 : i;\n    }\n    function clampCssAngle(i) {\n        i = Math.round(i);\n        return i < 0 ? 0 : i > 360 ? 360 : i;\n    }\n    function clampCssFloat(f) {\n        return f < 0 ? 0 : f > 1 ? 1 : f;\n    }\n    function parseCssInt(val) {\n        var str = val;\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssByte(parseFloat(str) / 100 * 255);\n        }\n        return clampCssByte(parseInt(str, 10));\n    }\n    function parseCssFloat(val) {\n        var str = val;\n        if (str.length && str.charAt(str.length - 1) === '%') {\n            return clampCssFloat(parseFloat(str) / 100);\n        }\n        return clampCssFloat(parseFloat(str));\n    }\n    function cssHueToRgb(m1, m2, h) {\n        if (h < 0) {\n            h += 1;\n        }\n        else if (h > 1) {\n            h -= 1;\n        }\n        if (h * 6 < 1) {\n            return m1 + (m2 - m1) * h * 6;\n        }\n        if (h * 2 < 1) {\n            return m2;\n        }\n        if (h * 3 < 2) {\n            return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n        }\n        return m1;\n    }\n    function lerpNumber(a, b, p) {\n        return a + (b - a) * p;\n    }\n    function setRgba(out, r, g, b, a) {\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n        return out;\n    }\n    function copyRgba(out, a) {\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        return out;\n    }\n    var colorCache = new LRU(20);\n    var lastRemovedArr = null;\n    function putToCache(colorStr, rgbaArr) {\n        if (lastRemovedArr) {\n            copyRgba(lastRemovedArr, rgbaArr);\n        }\n        lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));\n    }\n    function parse(colorStr, rgbaArr) {\n        if (!colorStr) {\n            return;\n        }\n        rgbaArr = rgbaArr || [];\n        var cached = colorCache.get(colorStr);\n        if (cached) {\n            return copyRgba(rgbaArr, cached);\n        }\n        colorStr = colorStr + '';\n        var str = colorStr.replace(/ /g, '').toLowerCase();\n        if (str in kCSSColorTable) {\n            copyRgba(rgbaArr, kCSSColorTable[str]);\n            putToCache(colorStr, rgbaArr);\n            return rgbaArr;\n        }\n        var strLen = str.length;\n        if (str.charAt(0) === '#') {\n            if (strLen === 4 || strLen === 5) {\n                var iv = parseInt(str.slice(1, 4), 16);\n                if (!(iv >= 0 && iv <= 0xfff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                setRgba(rgbaArr, ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), strLen === 5 ? parseInt(str.slice(4), 16) / 0xf : 1);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            else if (strLen === 7 || strLen === 9) {\n                var iv = parseInt(str.slice(1, 7), 16);\n                if (!(iv >= 0 && iv <= 0xffffff)) {\n                    setRgba(rgbaArr, 0, 0, 0, 1);\n                    return;\n                }\n                setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, strLen === 9 ? parseInt(str.slice(7), 16) / 0xff : 1);\n                putToCache(colorStr, rgbaArr);\n                return rgbaArr;\n            }\n            return;\n        }\n        var op = str.indexOf('(');\n        var ep = str.indexOf(')');\n        if (op !== -1 && ep + 1 === strLen) {\n            var fname = str.substr(0, op);\n            var params = str.substr(op + 1, ep - (op + 1)).split(',');\n            var alpha = 1;\n            switch (fname) {\n                case 'rgba':\n                    if (params.length !== 4) {\n                        return params.length === 3\n                            ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1)\n                            : setRgba(rgbaArr, 0, 0, 0, 1);\n                    }\n                    alpha = parseCssFloat(params.pop());\n                case 'rgb':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsla':\n                    if (params.length !== 4) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    params[3] = parseCssFloat(params[3]);\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                case 'hsl':\n                    if (params.length !== 3) {\n                        setRgba(rgbaArr, 0, 0, 0, 1);\n                        return;\n                    }\n                    hsla2rgba(params, rgbaArr);\n                    putToCache(colorStr, rgbaArr);\n                    return rgbaArr;\n                default:\n                    return;\n            }\n        }\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return;\n    }\n    function hsla2rgba(hsla, rgba) {\n        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;\n        var s = parseCssFloat(hsla[1]);\n        var l = parseCssFloat(hsla[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        rgba = rgba || [];\n        setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n        if (hsla.length === 4) {\n            rgba[3] = hsla[3];\n        }\n        return rgba;\n    }\n    function rgba2hsla(rgba) {\n        if (!rgba) {\n            return;\n        }\n        var R = rgba[0] / 255;\n        var G = rgba[1] / 255;\n        var B = rgba[2] / 255;\n        var vMin = Math.min(R, G, B);\n        var vMax = Math.max(R, G, B);\n        var delta = vMax - vMin;\n        var L = (vMax + vMin) / 2;\n        var H;\n        var S;\n        if (delta === 0) {\n            H = 0;\n            S = 0;\n        }\n        else {\n            if (L < 0.5) {\n                S = delta / (vMax + vMin);\n            }\n            else {\n                S = delta / (2 - vMax - vMin);\n            }\n            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;\n            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;\n            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;\n            if (R === vMax) {\n                H = deltaB - deltaG;\n            }\n            else if (G === vMax) {\n                H = (1 / 3) + deltaR - deltaB;\n            }\n            else if (B === vMax) {\n                H = (2 / 3) + deltaG - deltaR;\n            }\n            if (H < 0) {\n                H += 1;\n            }\n            if (H > 1) {\n                H -= 1;\n            }\n        }\n        var hsla = [H * 360, S, L];\n        if (rgba[3] != null) {\n            hsla.push(rgba[3]);\n        }\n        return hsla;\n    }\n    function lift(color, level) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            for (var i = 0; i < 3; i++) {\n                if (level < 0) {\n                    colorArr[i] = colorArr[i] * (1 - level) | 0;\n                }\n                else {\n                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;\n                }\n                if (colorArr[i] > 255) {\n                    colorArr[i] = 255;\n                }\n                else if (colorArr[i] < 0) {\n                    colorArr[i] = 0;\n                }\n            }\n            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n        }\n    }\n    function toHex(color) {\n        var colorArr = parse(color);\n        if (colorArr) {\n            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);\n        }\n    }\n    function fastLerp(normalizedValue, colors, out) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        out = out || [];\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = colors[leftIndex];\n        var rightColor = colors[rightIndex];\n        var dv = value - leftIndex;\n        out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n        out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n        out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n        out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n        return out;\n    }\n    var fastMapToColor = fastLerp;\n    function lerp$1(normalizedValue, colors, fullOutput) {\n        if (!(colors && colors.length)\n            || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n            return;\n        }\n        var value = normalizedValue * (colors.length - 1);\n        var leftIndex = Math.floor(value);\n        var rightIndex = Math.ceil(value);\n        var leftColor = parse(colors[leftIndex]);\n        var rightColor = parse(colors[rightIndex]);\n        var dv = value - leftIndex;\n        var color = stringify([\n            clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),\n            clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),\n            clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),\n            clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))\n        ], 'rgba');\n        return fullOutput\n            ? {\n                color: color,\n                leftIndex: leftIndex,\n                rightIndex: rightIndex,\n                value: value\n            }\n            : color;\n    }\n    var mapToColor = lerp$1;\n    function modifyHSL(color, h, s, l) {\n        var colorArr = parse(color);\n        if (color) {\n            colorArr = rgba2hsla(colorArr);\n            h != null && (colorArr[0] = clampCssAngle(h));\n            s != null && (colorArr[1] = parseCssFloat(s));\n            l != null && (colorArr[2] = parseCssFloat(l));\n            return stringify(hsla2rgba(colorArr), 'rgba');\n        }\n    }\n    function modifyAlpha(color, alpha) {\n        var colorArr = parse(color);\n        if (colorArr && alpha != null) {\n            colorArr[3] = clampCssFloat(alpha);\n            return stringify(colorArr, 'rgba');\n        }\n    }\n    function stringify(arrColor, type) {\n        if (!arrColor || !arrColor.length) {\n            return;\n        }\n        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n            colorStr += ',' + arrColor[3];\n        }\n        return type + '(' + colorStr + ')';\n    }\n    function lum(color, backgroundLum) {\n        var arr = parse(color);\n        return arr\n            ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255\n                + (1 - arr[3]) * backgroundLum\n            : 0;\n    }\n    function random() {\n        var r = Math.round(Math.random() * 255);\n        var g = Math.round(Math.random() * 255);\n        var b = Math.round(Math.random() * 255);\n        return 'rgb(' + r + ',' + g + ',' + b + ')';\n    }\n\n    var color = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        parse: parse,\n        lift: lift,\n        toHex: toHex,\n        fastLerp: fastLerp,\n        fastMapToColor: fastMapToColor,\n        lerp: lerp$1,\n        mapToColor: mapToColor,\n        modifyHSL: modifyHSL,\n        modifyAlpha: modifyAlpha,\n        stringify: stringify,\n        lum: lum,\n        random: random\n    });\n\n    var arraySlice = Array.prototype.slice;\n    function interpolateNumber(p0, p1, percent) {\n        return (p1 - p0) * percent + p0;\n    }\n    function step(p0, p1, percent) {\n        return percent > 0.5 ? p1 : p0;\n    }\n    function interpolate1DArray(out, p0, p1, percent) {\n        var len = p0.length;\n        for (var i = 0; i < len; i++) {\n            out[i] = interpolateNumber(p0[i], p1[i], percent);\n        }\n    }\n    function interpolate2DArray(out, p0, p1, percent) {\n        var len = p0.length;\n        var len2 = len && p0[0].length;\n        for (var i = 0; i < len; i++) {\n            if (!out[i]) {\n                out[i] = [];\n            }\n            for (var j = 0; j < len2; j++) {\n                out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n            }\n        }\n    }\n    function add1DArray(out, p0, p1, sign) {\n        var len = p0.length;\n        for (var i = 0; i < len; i++) {\n            out[i] = p0[i] + p1[i] * sign;\n        }\n        return out;\n    }\n    function add2DArray(out, p0, p1, sign) {\n        var len = p0.length;\n        var len2 = len && p0[0].length;\n        for (var i = 0; i < len; i++) {\n            if (!out[i]) {\n                out[i] = [];\n            }\n            for (var j = 0; j < len2; j++) {\n                out[i][j] = p0[i][j] + p1[i][j] * sign;\n            }\n        }\n        return out;\n    }\n    function fillArray(val0, val1, arrDim) {\n        var arr0 = val0;\n        var arr1 = val1;\n        if (!arr0.push || !arr1.push) {\n            return;\n        }\n        var arr0Len = arr0.length;\n        var arr1Len = arr1.length;\n        if (arr0Len !== arr1Len) {\n            var isPreviousLarger = arr0Len > arr1Len;\n            if (isPreviousLarger) {\n                arr0.length = arr1Len;\n            }\n            else {\n                for (var i = arr0Len; i < arr1Len; i++) {\n                    arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n                }\n            }\n        }\n        var len2 = arr0[0] && arr0[0].length;\n        for (var i = 0; i < arr0.length; i++) {\n            if (arrDim === 1) {\n                if (isNaN(arr0[i])) {\n                    arr0[i] = arr1[i];\n                }\n            }\n            else {\n                for (var j = 0; j < len2; j++) {\n                    if (isNaN(arr0[i][j])) {\n                        arr0[i][j] = arr1[i][j];\n                    }\n                }\n            }\n        }\n    }\n    function is1DArraySame(arr0, arr1) {\n        var len = arr0.length;\n        if (len !== arr1.length) {\n            return false;\n        }\n        for (var i = 0; i < len; i++) {\n            if (arr0[i] !== arr1[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n            + v0 * t + p1;\n    }\n    function catmullRomInterpolate1DArray(out, p0, p1, p2, p3, t, t2, t3) {\n        var len = p0.length;\n        for (var i = 0; i < len; i++) {\n            out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n        }\n    }\n    function catmullRomInterpolate2DArray(out, p0, p1, p2, p3, t, t2, t3) {\n        var len = p0.length;\n        var len2 = p0[0].length;\n        for (var i = 0; i < len; i++) {\n            if (!out[i]) {\n                out[1] = [];\n            }\n            for (var j = 0; j < len2; j++) {\n                out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n            }\n        }\n    }\n    function cloneValue(value) {\n        if (isArrayLike(value)) {\n            var len = value.length;\n            if (isArrayLike(value[0])) {\n                var ret = [];\n                for (var i = 0; i < len; i++) {\n                    ret.push(arraySlice.call(value[i]));\n                }\n                return ret;\n            }\n            return arraySlice.call(value);\n        }\n        return value;\n    }\n    function rgba2String(rgba) {\n        rgba[0] = Math.floor(rgba[0]);\n        rgba[1] = Math.floor(rgba[1]);\n        rgba[2] = Math.floor(rgba[2]);\n        return 'rgba(' + rgba.join(',') + ')';\n    }\n    function guessArrayDim(value) {\n        return isArrayLike(value && value[0]) ? 2 : 1;\n    }\n    var tmpRgba = [0, 0, 0, 0];\n    var Track = (function () {\n        function Track(propName) {\n            this.keyframes = [];\n            this.maxTime = 0;\n            this.arrDim = 0;\n            this.interpolable = true;\n            this._needsSort = false;\n            this._isAllValueEqual = true;\n            this._lastFrame = 0;\n            this._lastFramePercent = 0;\n            this.propName = propName;\n        }\n        Track.prototype.isFinished = function () {\n            return this._finished;\n        };\n        Track.prototype.setFinished = function () {\n            this._finished = true;\n            if (this._additiveTrack) {\n                this._additiveTrack.setFinished();\n            }\n        };\n        Track.prototype.needsAnimate = function () {\n            return !this._isAllValueEqual && this.keyframes.length >= 2 && this.interpolable;\n        };\n        Track.prototype.getAdditiveTrack = function () {\n            return this._additiveTrack;\n        };\n        Track.prototype.addKeyframe = function (time, value) {\n            if (time >= this.maxTime) {\n                this.maxTime = time;\n            }\n            else {\n                this._needsSort = true;\n            }\n            var keyframes = this.keyframes;\n            var len = keyframes.length;\n            if (this.interpolable) {\n                if (isArrayLike(value)) {\n                    var arrayDim = guessArrayDim(value);\n                    if (len > 0 && this.arrDim !== arrayDim) {\n                        this.interpolable = false;\n                        return;\n                    }\n                    if (arrayDim === 1 && typeof value[0] !== 'number'\n                        || arrayDim === 2 && typeof value[0][0] !== 'number') {\n                        this.interpolable = false;\n                        return;\n                    }\n                    if (len > 0) {\n                        var lastFrame = keyframes[len - 1];\n                        if (this._isAllValueEqual) {\n                            if (arrayDim === 1) {\n                                if (!is1DArraySame(value, lastFrame.value)) {\n                                    this._isAllValueEqual = false;\n                                }\n                            }\n                            else {\n                                this._isAllValueEqual = false;\n                            }\n                        }\n                    }\n                    this.arrDim = arrayDim;\n                }\n                else {\n                    if (this.arrDim > 0) {\n                        this.interpolable = false;\n                        return;\n                    }\n                    if (typeof value === 'string') {\n                        var colorArray = parse(value);\n                        if (colorArray) {\n                            value = colorArray;\n                            this.isValueColor = true;\n                        }\n                        else {\n                            this.interpolable = false;\n                        }\n                    }\n                    else if (typeof value !== 'number') {\n                        this.interpolable = false;\n                        return;\n                    }\n                    if (this._isAllValueEqual && len > 0) {\n                        var lastFrame = keyframes[len - 1];\n                        if (this.isValueColor && !is1DArraySame(lastFrame.value, value)) {\n                            this._isAllValueEqual = false;\n                        }\n                        else if (lastFrame.value !== value) {\n                            this._isAllValueEqual = false;\n                        }\n                    }\n                }\n            }\n            var kf = {\n                time: time,\n                value: value,\n                percent: 0\n            };\n            this.keyframes.push(kf);\n            return kf;\n        };\n        Track.prototype.prepare = function (additiveTrack) {\n            var kfs = this.keyframes;\n            if (this._needsSort) {\n                kfs.sort(function (a, b) {\n                    return a.time - b.time;\n                });\n            }\n            var arrDim = this.arrDim;\n            var kfsLen = kfs.length;\n            var lastKf = kfs[kfsLen - 1];\n            for (var i = 0; i < kfsLen; i++) {\n                kfs[i].percent = kfs[i].time / this.maxTime;\n                if (arrDim > 0 && i !== kfsLen - 1) {\n                    fillArray(kfs[i].value, lastKf.value, arrDim);\n                }\n            }\n            if (additiveTrack\n                && this.needsAnimate()\n                && additiveTrack.needsAnimate()\n                && arrDim === additiveTrack.arrDim\n                && this.isValueColor === additiveTrack.isValueColor\n                && !additiveTrack._finished) {\n                this._additiveTrack = additiveTrack;\n                var startValue = kfs[0].value;\n                for (var i = 0; i < kfsLen; i++) {\n                    if (arrDim === 0) {\n                        if (this.isValueColor) {\n                            kfs[i].additiveValue\n                                = add1DArray([], kfs[i].value, startValue, -1);\n                        }\n                        else {\n                            kfs[i].additiveValue = kfs[i].value - startValue;\n                        }\n                    }\n                    else if (arrDim === 1) {\n                        kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);\n                    }\n                    else if (arrDim === 2) {\n                        kfs[i].additiveValue = add2DArray([], kfs[i].value, startValue, -1);\n                    }\n                }\n            }\n        };\n        Track.prototype.step = function (target, percent) {\n            if (this._finished) {\n                return;\n            }\n            if (this._additiveTrack && this._additiveTrack._finished) {\n                this._additiveTrack = null;\n            }\n            var isAdditive = this._additiveTrack != null;\n            var valueKey = isAdditive ? 'additiveValue' : 'value';\n            var keyframes = this.keyframes;\n            var kfsNum = this.keyframes.length;\n            var propName = this.propName;\n            var arrDim = this.arrDim;\n            var isValueColor = this.isValueColor;\n            var frameIdx;\n            if (percent < 0) {\n                frameIdx = 0;\n            }\n            else if (percent < this._lastFramePercent) {\n                var start = Math.min(this._lastFrame + 1, kfsNum - 1);\n                for (frameIdx = start; frameIdx >= 0; frameIdx--) {\n                    if (keyframes[frameIdx].percent <= percent) {\n                        break;\n                    }\n                }\n                frameIdx = Math.min(frameIdx, kfsNum - 2);\n            }\n            else {\n                for (frameIdx = this._lastFrame; frameIdx < kfsNum; frameIdx++) {\n                    if (keyframes[frameIdx].percent > percent) {\n                        break;\n                    }\n                }\n                frameIdx = Math.min(frameIdx - 1, kfsNum - 2);\n            }\n            var nextFrame = keyframes[frameIdx + 1];\n            var frame = keyframes[frameIdx];\n            if (!(frame && nextFrame)) {\n                return;\n            }\n            this._lastFrame = frameIdx;\n            this._lastFramePercent = percent;\n            var range = (nextFrame.percent - frame.percent);\n            if (range === 0) {\n                return;\n            }\n            var w = (percent - frame.percent) / range;\n            var targetArr = isAdditive ? this._additiveValue\n                : (isValueColor ? tmpRgba : target[propName]);\n            if ((arrDim > 0 || isValueColor) && !targetArr) {\n                targetArr = this._additiveValue = [];\n            }\n            if (this.useSpline) {\n                var p1 = keyframes[frameIdx][valueKey];\n                var p0 = keyframes[frameIdx === 0 ? frameIdx : frameIdx - 1][valueKey];\n                var p2 = keyframes[frameIdx > kfsNum - 2 ? kfsNum - 1 : frameIdx + 1][valueKey];\n                var p3 = keyframes[frameIdx > kfsNum - 3 ? kfsNum - 1 : frameIdx + 2][valueKey];\n                if (arrDim > 0) {\n                    arrDim === 1\n                        ? catmullRomInterpolate1DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w)\n                        : catmullRomInterpolate2DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w);\n                }\n                else if (isValueColor) {\n                    catmullRomInterpolate1DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w);\n                    if (!isAdditive) {\n                        target[propName] = rgba2String(targetArr);\n                    }\n                }\n                else {\n                    var value = void 0;\n                    if (!this.interpolable) {\n                        value = p2;\n                    }\n                    else {\n                        value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n                    }\n                    if (isAdditive) {\n                        this._additiveValue = value;\n                    }\n                    else {\n                        target[propName] = value;\n                    }\n                }\n            }\n            else {\n                if (arrDim > 0) {\n                    arrDim === 1\n                        ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)\n                        : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n                }\n                else if (isValueColor) {\n                    interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);\n                    if (!isAdditive) {\n                        target[propName] = rgba2String(targetArr);\n                    }\n                }\n                else {\n                    var value = void 0;\n                    if (!this.interpolable) {\n                        value = step(frame[valueKey], nextFrame[valueKey], w);\n                    }\n                    else {\n                        value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);\n                    }\n                    if (isAdditive) {\n                        this._additiveValue = value;\n                    }\n                    else {\n                        target[propName] = value;\n                    }\n                }\n            }\n            if (isAdditive) {\n                this._addToTarget(target);\n            }\n        };\n        Track.prototype._addToTarget = function (target) {\n            var arrDim = this.arrDim;\n            var propName = this.propName;\n            var additiveValue = this._additiveValue;\n            if (arrDim === 0) {\n                if (this.isValueColor) {\n                    parse(target[propName], tmpRgba);\n                    add1DArray(tmpRgba, tmpRgba, additiveValue, 1);\n                    target[propName] = rgba2String(tmpRgba);\n                }\n                else {\n                    target[propName] = target[propName] + additiveValue;\n                }\n            }\n            else if (arrDim === 1) {\n                add1DArray(target[propName], target[propName], additiveValue, 1);\n            }\n            else if (arrDim === 2) {\n                add2DArray(target[propName], target[propName], additiveValue, 1);\n            }\n        };\n        return Track;\n    }());\n    var Animator = (function () {\n        function Animator(target, loop, additiveTo) {\n            this._tracks = {};\n            this._trackKeys = [];\n            this._delay = 0;\n            this._maxTime = 0;\n            this._paused = false;\n            this._started = 0;\n            this._clip = null;\n            this._target = target;\n            this._loop = loop;\n            if (loop && additiveTo) {\n                logError('Can\\' use additive animation on looped animation.');\n                return;\n            }\n            this._additiveAnimators = additiveTo;\n        }\n        Animator.prototype.getTarget = function () {\n            return this._target;\n        };\n        Animator.prototype.changeTarget = function (target) {\n            this._target = target;\n        };\n        Animator.prototype.when = function (time, props) {\n            return this.whenWithKeys(time, props, keys(props));\n        };\n        Animator.prototype.whenWithKeys = function (time, props, propNames) {\n            var tracks = this._tracks;\n            for (var i = 0; i < propNames.length; i++) {\n                var propName = propNames[i];\n                var track = tracks[propName];\n                if (!track) {\n                    track = tracks[propName] = new Track(propName);\n                    var initialValue = void 0;\n                    var additiveTrack = this._getAdditiveTrack(propName);\n                    if (additiveTrack) {\n                        var lastFinalKf = additiveTrack.keyframes[additiveTrack.keyframes.length - 1];\n                        initialValue = lastFinalKf && lastFinalKf.value;\n                        if (additiveTrack.isValueColor && initialValue) {\n                            initialValue = rgba2String(initialValue);\n                        }\n                    }\n                    else {\n                        initialValue = this._target[propName];\n                    }\n                    if (initialValue == null) {\n                        continue;\n                    }\n                    if (time !== 0) {\n                        track.addKeyframe(0, cloneValue(initialValue));\n                    }\n                    this._trackKeys.push(propName);\n                }\n                track.addKeyframe(time, cloneValue(props[propName]));\n            }\n            this._maxTime = Math.max(this._maxTime, time);\n            return this;\n        };\n        Animator.prototype.pause = function () {\n            this._clip.pause();\n            this._paused = true;\n        };\n        Animator.prototype.resume = function () {\n            this._clip.resume();\n            this._paused = false;\n        };\n        Animator.prototype.isPaused = function () {\n            return !!this._paused;\n        };\n        Animator.prototype._doneCallback = function () {\n            this._setTracksFinished();\n            this._clip = null;\n            var doneList = this._doneList;\n            if (doneList) {\n                var len = doneList.length;\n                for (var i = 0; i < len; i++) {\n                    doneList[i].call(this);\n                }\n            }\n        };\n        Animator.prototype._abortedCallback = function () {\n            this._setTracksFinished();\n            var animation = this.animation;\n            var abortedList = this._abortedList;\n            if (animation) {\n                animation.removeClip(this._clip);\n            }\n            this._clip = null;\n            if (abortedList) {\n                for (var i = 0; i < abortedList.length; i++) {\n                    abortedList[i].call(this);\n                }\n            }\n        };\n        Animator.prototype._setTracksFinished = function () {\n            var tracks = this._tracks;\n            var tracksKeys = this._trackKeys;\n            for (var i = 0; i < tracksKeys.length; i++) {\n                tracks[tracksKeys[i]].setFinished();\n            }\n        };\n        Animator.prototype._getAdditiveTrack = function (trackName) {\n            var additiveTrack;\n            var additiveAnimators = this._additiveAnimators;\n            if (additiveAnimators) {\n                for (var i = 0; i < additiveAnimators.length; i++) {\n                    var track = additiveAnimators[i].getTrack(trackName);\n                    if (track) {\n                        additiveTrack = track;\n                    }\n                }\n            }\n            return additiveTrack;\n        };\n        Animator.prototype.start = function (easing, forceAnimate) {\n            if (this._started > 0) {\n                return;\n            }\n            this._started = 1;\n            var self = this;\n            var tracks = [];\n            for (var i = 0; i < this._trackKeys.length; i++) {\n                var propName = this._trackKeys[i];\n                var track = this._tracks[propName];\n                var additiveTrack = this._getAdditiveTrack(propName);\n                var kfs = track.keyframes;\n                track.prepare(additiveTrack);\n                if (track.needsAnimate()) {\n                    tracks.push(track);\n                }\n                else if (!track.interpolable) {\n                    var lastKf = kfs[kfs.length - 1];\n                    if (lastKf) {\n                        self._target[track.propName] = lastKf.value;\n                    }\n                }\n            }\n            if (tracks.length || forceAnimate) {\n                var clip = new Clip({\n                    life: this._maxTime,\n                    loop: this._loop,\n                    delay: this._delay,\n                    onframe: function (percent) {\n                        self._started = 2;\n                        var additiveAnimators = self._additiveAnimators;\n                        if (additiveAnimators) {\n                            var stillHasAdditiveAnimator = false;\n                            for (var i = 0; i < additiveAnimators.length; i++) {\n                                if (additiveAnimators[i]._clip) {\n                                    stillHasAdditiveAnimator = true;\n                                    break;\n                                }\n                            }\n                            if (!stillHasAdditiveAnimator) {\n                                self._additiveAnimators = null;\n                            }\n                        }\n                        for (var i = 0; i < tracks.length; i++) {\n                            tracks[i].step(self._target, percent);\n                        }\n                        var onframeList = self._onframeList;\n                        if (onframeList) {\n                            for (var i = 0; i < onframeList.length; i++) {\n                                onframeList[i](self._target, percent);\n                            }\n                        }\n                    },\n                    ondestroy: function () {\n                        self._doneCallback();\n                    }\n                });\n                this._clip = clip;\n                if (this.animation) {\n                    this.animation.addClip(clip);\n                }\n                if (easing && easing !== 'spline') {\n                    clip.easing = easing;\n                }\n            }\n            else {\n                this._doneCallback();\n            }\n            return this;\n        };\n        Animator.prototype.stop = function (forwardToLast) {\n            if (!this._clip) {\n                return;\n            }\n            var clip = this._clip;\n            if (forwardToLast) {\n                clip.onframe(1);\n            }\n            this._abortedCallback();\n        };\n        Animator.prototype.delay = function (time) {\n            this._delay = time;\n            return this;\n        };\n        Animator.prototype.during = function (cb) {\n            if (cb) {\n                if (!this._onframeList) {\n                    this._onframeList = [];\n                }\n                this._onframeList.push(cb);\n            }\n            return this;\n        };\n        Animator.prototype.done = function (cb) {\n            if (cb) {\n                if (!this._doneList) {\n                    this._doneList = [];\n                }\n                this._doneList.push(cb);\n            }\n            return this;\n        };\n        Animator.prototype.aborted = function (cb) {\n            if (cb) {\n                if (!this._abortedList) {\n                    this._abortedList = [];\n                }\n                this._abortedList.push(cb);\n            }\n            return this;\n        };\n        Animator.prototype.getClip = function () {\n            return this._clip;\n        };\n        Animator.prototype.getTrack = function (propName) {\n            return this._tracks[propName];\n        };\n        Animator.prototype.stopTracks = function (propNames, forwardToLast) {\n            if (!propNames.length || !this._clip) {\n                return true;\n            }\n            var tracks = this._tracks;\n            var tracksKeys = this._trackKeys;\n            for (var i = 0; i < propNames.length; i++) {\n                var track = tracks[propNames[i]];\n                if (track) {\n                    if (forwardToLast) {\n                        track.step(this._target, 1);\n                    }\n                    else if (this._started === 1) {\n                        track.step(this._target, 0);\n                    }\n                    track.setFinished();\n                }\n            }\n            var allAborted = true;\n            for (var i = 0; i < tracksKeys.length; i++) {\n                if (!tracks[tracksKeys[i]].isFinished()) {\n                    allAborted = false;\n                    break;\n                }\n            }\n            if (allAborted) {\n                this._abortedCallback();\n            }\n            return allAborted;\n        };\n        Animator.prototype.saveFinalToTarget = function (target, trackKeys) {\n            if (!target) {\n                return;\n            }\n            trackKeys = trackKeys || this._trackKeys;\n            for (var i = 0; i < trackKeys.length; i++) {\n                var propName = trackKeys[i];\n                var track = this._tracks[propName];\n                if (!track || track.isFinished()) {\n                    continue;\n                }\n                var kfs = track.keyframes;\n                var lastKf = kfs[kfs.length - 1];\n                if (lastKf) {\n                    var val = cloneValue(lastKf.value);\n                    if (track.isValueColor) {\n                        val = rgba2String(val);\n                    }\n                    target[propName] = val;\n                }\n            }\n        };\n        Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {\n            trackKeys = trackKeys || keys(finalProps);\n            for (var i = 0; i < trackKeys.length; i++) {\n                var propName = trackKeys[i];\n                var track = this._tracks[propName];\n                if (!track) {\n                    continue;\n                }\n                var kfs = track.keyframes;\n                if (kfs.length > 1) {\n                    var lastKf = kfs.pop();\n                    track.addKeyframe(lastKf.time, finalProps[propName]);\n                    track.prepare(track.getAdditiveTrack());\n                }\n            }\n        };\n        return Animator;\n    }());\n\n    var Point = (function () {\n        function Point(x, y) {\n            this.x = x || 0;\n            this.y = y || 0;\n        }\n        Point.prototype.copy = function (other) {\n            this.x = other.x;\n            this.y = other.y;\n            return this;\n        };\n        Point.prototype.clone = function () {\n            return new Point(this.x, this.y);\n        };\n        Point.prototype.set = function (x, y) {\n            this.x = x;\n            this.y = y;\n            return this;\n        };\n        Point.prototype.equal = function (other) {\n            return other.x === this.x && other.y === this.y;\n        };\n        Point.prototype.add = function (other) {\n            this.x += other.x;\n            this.y += other.y;\n            return this;\n        };\n        Point.prototype.scale = function (scalar) {\n            this.x *= scalar;\n            this.y *= scalar;\n        };\n        Point.prototype.scaleAndAdd = function (other, scalar) {\n            this.x += other.x * scalar;\n            this.y += other.y * scalar;\n        };\n        Point.prototype.sub = function (other) {\n            this.x -= other.x;\n            this.y -= other.y;\n            return this;\n        };\n        Point.prototype.dot = function (other) {\n            return this.x * other.x + this.y * other.y;\n        };\n        Point.prototype.len = function () {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        };\n        Point.prototype.lenSquare = function () {\n            return this.x * this.x + this.y * this.y;\n        };\n        Point.prototype.normalize = function () {\n            var len = this.len();\n            this.x /= len;\n            this.y /= len;\n            return this;\n        };\n        Point.prototype.distance = function (other) {\n            var dx = this.x - other.x;\n            var dy = this.y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        };\n        Point.prototype.distanceSquare = function (other) {\n            var dx = this.x - other.x;\n            var dy = this.y - other.y;\n            return dx * dx + dy * dy;\n        };\n        Point.prototype.negate = function () {\n            this.x = -this.x;\n            this.y = -this.y;\n            return this;\n        };\n        Point.prototype.transform = function (m) {\n            if (!m) {\n                return;\n            }\n            var x = this.x;\n            var y = this.y;\n            this.x = m[0] * x + m[2] * y + m[4];\n            this.y = m[1] * x + m[3] * y + m[5];\n            return this;\n        };\n        Point.prototype.toArray = function (out) {\n            out[0] = this.x;\n            out[1] = this.y;\n            return out;\n        };\n        Point.prototype.fromArray = function (input) {\n            this.x = input[0];\n            this.y = input[1];\n        };\n        Point.set = function (p, x, y) {\n            p.x = x;\n            p.y = y;\n        };\n        Point.copy = function (p, p2) {\n            p.x = p2.x;\n            p.y = p2.y;\n        };\n        Point.len = function (p) {\n            return Math.sqrt(p.x * p.x + p.y * p.y);\n        };\n        Point.lenSquare = function (p) {\n            return p.x * p.x + p.y * p.y;\n        };\n        Point.dot = function (p0, p1) {\n            return p0.x * p1.x + p0.y * p1.y;\n        };\n        Point.add = function (out, p0, p1) {\n            out.x = p0.x + p1.x;\n            out.y = p0.y + p1.y;\n        };\n        Point.sub = function (out, p0, p1) {\n            out.x = p0.x - p1.x;\n            out.y = p0.y - p1.y;\n        };\n        Point.scale = function (out, p0, scalar) {\n            out.x = p0.x * scalar;\n            out.y = p0.y * scalar;\n        };\n        Point.scaleAndAdd = function (out, p0, p1, scalar) {\n            out.x = p0.x + p1.x * scalar;\n            out.y = p0.y + p1.y * scalar;\n        };\n        Point.lerp = function (out, p0, p1, t) {\n            var onet = 1 - t;\n            out.x = onet * p0.x + t * p1.x;\n            out.y = onet * p0.y + t * p1.y;\n        };\n        return Point;\n    }());\n\n    var mathMin = Math.min;\n    var mathMax = Math.max;\n    var lt = new Point();\n    var rb = new Point();\n    var lb = new Point();\n    var rt = new Point();\n    var minTv = new Point();\n    var maxTv = new Point();\n    var BoundingRect = (function () {\n        function BoundingRect(x, y, width, height) {\n            if (width < 0 && isFinite(width)) {\n                x = x + width;\n                width = -width;\n            }\n            if (height < 0 && isFinite(height)) {\n                y = y + height;\n                height = -height;\n            }\n            this.x = x;\n            this.y = y;\n            this.width = width;\n            this.height = height;\n        }\n        BoundingRect.prototype.union = function (other) {\n            var x = mathMin(other.x, this.x);\n            var y = mathMin(other.y, this.y);\n            if (isFinite(this.x) && isFinite(this.width)) {\n                this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n            }\n            else {\n                this.width = other.width;\n            }\n            if (isFinite(this.y) && isFinite(this.height)) {\n                this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n            }\n            else {\n                this.height = other.height;\n            }\n            this.x = x;\n            this.y = y;\n        };\n        BoundingRect.prototype.applyTransform = function (m) {\n            BoundingRect.applyTransform(this, this, m);\n        };\n        BoundingRect.prototype.calculateTransform = function (b) {\n            var a = this;\n            var sx = b.width / a.width;\n            var sy = b.height / a.height;\n            var m = create$1();\n            translate(m, m, [-a.x, -a.y]);\n            scale$1(m, m, [sx, sy]);\n            translate(m, m, [b.x, b.y]);\n            return m;\n        };\n        BoundingRect.prototype.intersect = function (b, mtv) {\n            if (!b) {\n                return false;\n            }\n            if (!(b instanceof BoundingRect)) {\n                b = BoundingRect.create(b);\n            }\n            var a = this;\n            var ax0 = a.x;\n            var ax1 = a.x + a.width;\n            var ay0 = a.y;\n            var ay1 = a.y + a.height;\n            var bx0 = b.x;\n            var bx1 = b.x + b.width;\n            var by0 = b.y;\n            var by1 = b.y + b.height;\n            var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n            if (mtv) {\n                var dMin = Infinity;\n                var dMax = 0;\n                var d0 = Math.abs(ax1 - bx0);\n                var d1 = Math.abs(bx1 - ax0);\n                var d2 = Math.abs(ay1 - by0);\n                var d3 = Math.abs(by1 - ay0);\n                var dx = Math.min(d0, d1);\n                var dy = Math.min(d2, d3);\n                if (ax1 < bx0 || bx1 < ax0) {\n                    if (dx > dMax) {\n                        dMax = dx;\n                        if (d0 < d1) {\n                            Point.set(maxTv, -d0, 0);\n                        }\n                        else {\n                            Point.set(maxTv, d1, 0);\n                        }\n                    }\n                }\n                else {\n                    if (dx < dMin) {\n                        dMin = dx;\n                        if (d0 < d1) {\n                            Point.set(minTv, d0, 0);\n                        }\n                        else {\n                            Point.set(minTv, -d1, 0);\n                        }\n                    }\n                }\n                if (ay1 < by0 || by1 < ay0) {\n                    if (dy > dMax) {\n                        dMax = dy;\n                        if (d2 < d3) {\n                            Point.set(maxTv, 0, -d2);\n                        }\n                        else {\n                            Point.set(maxTv, 0, d3);\n                        }\n                    }\n                }\n                else {\n                    if (dx < dMin) {\n                        dMin = dx;\n                        if (d2 < d3) {\n                            Point.set(minTv, 0, d2);\n                        }\n                        else {\n                            Point.set(minTv, 0, -d3);\n                        }\n                    }\n                }\n            }\n            if (mtv) {\n                Point.copy(mtv, overlap ? minTv : maxTv);\n            }\n            return overlap;\n        };\n        BoundingRect.prototype.contain = function (x, y) {\n            var rect = this;\n            return x >= rect.x\n                && x <= (rect.x + rect.width)\n                && y >= rect.y\n                && y <= (rect.y + rect.height);\n        };\n        BoundingRect.prototype.clone = function () {\n            return new BoundingRect(this.x, this.y, this.width, this.height);\n        };\n        BoundingRect.prototype.copy = function (other) {\n            BoundingRect.copy(this, other);\n        };\n        BoundingRect.prototype.plain = function () {\n            return {\n                x: this.x,\n                y: this.y,\n                width: this.width,\n                height: this.height\n            };\n        };\n        BoundingRect.prototype.isFinite = function () {\n            return isFinite(this.x)\n                && isFinite(this.y)\n                && isFinite(this.width)\n                && isFinite(this.height);\n        };\n        BoundingRect.prototype.isZero = function () {\n            return this.width === 0 || this.height === 0;\n        };\n        BoundingRect.create = function (rect) {\n            return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n        };\n        BoundingRect.copy = function (target, source) {\n            target.x = source.x;\n            target.y = source.y;\n            target.width = source.width;\n            target.height = source.height;\n        };\n        BoundingRect.applyTransform = function (target, source, m) {\n            if (!m) {\n                if (target !== source) {\n                    BoundingRect.copy(target, source);\n                }\n                return;\n            }\n            if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {\n                var sx = m[0];\n                var sy = m[3];\n                var tx = m[4];\n                var ty = m[5];\n                target.x = source.x * sx + tx;\n                target.y = source.y * sy + ty;\n                target.width = source.width * sx;\n                target.height = source.height * sy;\n                if (target.width < 0) {\n                    target.x += target.width;\n                    target.width = -target.width;\n                }\n                if (target.height < 0) {\n                    target.y += target.height;\n                    target.height = -target.height;\n                }\n                return;\n            }\n            lt.x = lb.x = source.x;\n            lt.y = rt.y = source.y;\n            rb.x = rt.x = source.x + source.width;\n            rb.y = lb.y = source.y + source.height;\n            lt.transform(m);\n            rt.transform(m);\n            rb.transform(m);\n            lb.transform(m);\n            target.x = mathMin(lt.x, rb.x, lb.x, rt.x);\n            target.y = mathMin(lt.y, rb.y, lb.y, rt.y);\n            var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);\n            var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);\n            target.width = maxX - target.x;\n            target.height = maxY - target.y;\n        };\n        return BoundingRect;\n    }());\n\n    var textWidthCache = {};\n    var DEFAULT_FONT = '12px sans-serif';\n    var _ctx;\n    var _cachedFont;\n    function defaultMeasureText(text, font) {\n        if (!_ctx) {\n            _ctx = createCanvas().getContext('2d');\n        }\n        if (_cachedFont !== font) {\n            _cachedFont = _ctx.font = font || DEFAULT_FONT;\n        }\n        return _ctx.measureText(text);\n    }\n    var methods$1 = {\n        measureText: defaultMeasureText\n    };\n    function getWidth(text, font) {\n        font = font || DEFAULT_FONT;\n        var cacheOfFont = textWidthCache[font];\n        if (!cacheOfFont) {\n            cacheOfFont = textWidthCache[font] = new LRU(500);\n        }\n        var width = cacheOfFont.get(text);\n        if (width == null) {\n            width = methods$1.measureText(text, font).width;\n            cacheOfFont.put(text, width);\n        }\n        return width;\n    }\n    function innerGetBoundingRect(text, font, textAlign, textBaseline) {\n        var width = getWidth(text, font);\n        var height = getLineHeight(font);\n        var x = adjustTextX(0, width, textAlign);\n        var y = adjustTextY(0, height, textBaseline);\n        var rect = new BoundingRect(x, y, width, height);\n        return rect;\n    }\n    function getBoundingRect(text, font, textAlign, textBaseline) {\n        var textLines = ((text || '') + '').split('\\n');\n        var len = textLines.length;\n        if (len === 1) {\n            return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);\n        }\n        else {\n            var uniondRect = new BoundingRect(0, 0, 0, 0);\n            for (var i = 0; i < textLines.length; i++) {\n                var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);\n                i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);\n            }\n            return uniondRect;\n        }\n    }\n    function adjustTextX(x, width, textAlign) {\n        if (textAlign === 'right') {\n            x -= width;\n        }\n        else if (textAlign === 'center') {\n            x -= width / 2;\n        }\n        return x;\n    }\n    function adjustTextY(y, height, verticalAlign) {\n        if (verticalAlign === 'middle') {\n            y -= height / 2;\n        }\n        else if (verticalAlign === 'bottom') {\n            y -= height;\n        }\n        return y;\n    }\n    function getLineHeight(font) {\n        return getWidth('', font);\n    }\n    function parsePercent(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n    function calculateTextPosition(out, opts, rect) {\n        var textPosition = opts.position || 'inside';\n        var distance = opts.distance != null ? opts.distance : 5;\n        var height = rect.height;\n        var width = rect.width;\n        var halfHeight = height / 2;\n        var x = rect.x;\n        var y = rect.y;\n        var textAlign = 'left';\n        var textVerticalAlign = 'top';\n        if (textPosition instanceof Array) {\n            x += parsePercent(textPosition[0], rect.width);\n            y += parsePercent(textPosition[1], rect.height);\n            textAlign = null;\n            textVerticalAlign = null;\n        }\n        else {\n            switch (textPosition) {\n                case 'left':\n                    x -= distance;\n                    y += halfHeight;\n                    textAlign = 'right';\n                    textVerticalAlign = 'middle';\n                    break;\n                case 'right':\n                    x += distance + width;\n                    y += halfHeight;\n                    textVerticalAlign = 'middle';\n                    break;\n                case 'top':\n                    x += width / 2;\n                    y -= distance;\n                    textAlign = 'center';\n                    textVerticalAlign = 'bottom';\n                    break;\n                case 'bottom':\n                    x += width / 2;\n                    y += height + distance;\n                    textAlign = 'center';\n                    break;\n                case 'inside':\n                    x += width / 2;\n                    y += halfHeight;\n                    textAlign = 'center';\n                    textVerticalAlign = 'middle';\n                    break;\n                case 'insideLeft':\n                    x += distance;\n                    y += halfHeight;\n                    textVerticalAlign = 'middle';\n                    break;\n                case 'insideRight':\n                    x += width - distance;\n                    y += halfHeight;\n                    textAlign = 'right';\n                    textVerticalAlign = 'middle';\n                    break;\n                case 'insideTop':\n                    x += width / 2;\n                    y += distance;\n                    textAlign = 'center';\n                    break;\n                case 'insideBottom':\n                    x += width / 2;\n                    y += height - distance;\n                    textAlign = 'center';\n                    textVerticalAlign = 'bottom';\n                    break;\n                case 'insideTopLeft':\n                    x += distance;\n                    y += distance;\n                    break;\n                case 'insideTopRight':\n                    x += width - distance;\n                    y += distance;\n                    textAlign = 'right';\n                    break;\n                case 'insideBottomLeft':\n                    x += distance;\n                    y += height - distance;\n                    textVerticalAlign = 'bottom';\n                    break;\n                case 'insideBottomRight':\n                    x += width - distance;\n                    y += height - distance;\n                    textAlign = 'right';\n                    textVerticalAlign = 'bottom';\n                    break;\n            }\n        }\n        out = out || {};\n        out.x = x;\n        out.y = y;\n        out.align = textAlign;\n        out.verticalAlign = textVerticalAlign;\n        return out;\n    }\n\n    var dpr = 1;\n    if (typeof window !== 'undefined') {\n        dpr = Math.max(window.devicePixelRatio\n            || (window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI)\n            || 1, 1);\n    }\n    var devicePixelRatio = dpr;\n    var DARK_MODE_THRESHOLD = 0.4;\n    var DARK_LABEL_COLOR = '#333';\n    var LIGHT_LABEL_COLOR = '#ccc';\n    var LIGHTER_LABEL_COLOR = '#eee';\n\n    var PRESERVED_NORMAL_STATE = '__zr_normal__';\n    var PRIMARY_STATES_KEYS = ['x', 'y', 'scaleX', 'scaleY', 'originX', 'originY', 'rotation', 'ignore'];\n    var DEFAULT_ANIMATABLE_MAP = {\n        x: true,\n        y: true,\n        scaleX: true,\n        scaleY: true,\n        originX: true,\n        originY: true,\n        rotation: true,\n        ignore: false\n    };\n    var tmpTextPosCalcRes = {};\n    var tmpBoundingRect = new BoundingRect(0, 0, 0, 0);\n    var Element = (function () {\n        function Element(props) {\n            this.id = guid();\n            this.animators = [];\n            this.currentStates = [];\n            this.states = {};\n            this._init(props);\n        }\n        Element.prototype._init = function (props) {\n            this.attr(props);\n        };\n        Element.prototype.drift = function (dx, dy, e) {\n            switch (this.draggable) {\n                case 'horizontal':\n                    dy = 0;\n                    break;\n                case 'vertical':\n                    dx = 0;\n                    break;\n            }\n            var m = this.transform;\n            if (!m) {\n                m = this.transform = [1, 0, 0, 1, 0, 0];\n            }\n            m[4] += dx;\n            m[5] += dy;\n            this.decomposeTransform();\n            this.markRedraw();\n        };\n        Element.prototype.beforeUpdate = function () { };\n        Element.prototype.afterUpdate = function () { };\n        Element.prototype.update = function () {\n            this.updateTransform();\n            if (this.__dirty) {\n                this.updateInnerText();\n            }\n        };\n        Element.prototype.updateInnerText = function (forceUpdate) {\n            var textEl = this._textContent;\n            if (textEl && (!textEl.ignore || forceUpdate)) {\n                if (!this.textConfig) {\n                    this.textConfig = {};\n                }\n                var textConfig = this.textConfig;\n                var isLocal = textConfig.local;\n                var attachedTransform = textEl.attachedTransform;\n                var textAlign = void 0;\n                var textVerticalAlign = void 0;\n                var textStyleChanged = false;\n                if (isLocal) {\n                    attachedTransform.parent = this;\n                }\n                else {\n                    attachedTransform.parent = null;\n                }\n                var innerOrigin = false;\n                attachedTransform.x = textEl.x;\n                attachedTransform.y = textEl.y;\n                attachedTransform.originX = textEl.originX;\n                attachedTransform.originY = textEl.originY;\n                attachedTransform.rotation = textEl.rotation;\n                attachedTransform.scaleX = textEl.scaleX;\n                attachedTransform.scaleY = textEl.scaleY;\n                if (textConfig.position != null) {\n                    var layoutRect = tmpBoundingRect;\n                    if (textConfig.layoutRect) {\n                        layoutRect.copy(textConfig.layoutRect);\n                    }\n                    else {\n                        layoutRect.copy(this.getBoundingRect());\n                    }\n                    if (!isLocal) {\n                        layoutRect.applyTransform(this.transform);\n                    }\n                    if (this.calculateTextPosition) {\n                        this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);\n                    }\n                    else {\n                        calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);\n                    }\n                    attachedTransform.x = tmpTextPosCalcRes.x;\n                    attachedTransform.y = tmpTextPosCalcRes.y;\n                    textAlign = tmpTextPosCalcRes.align;\n                    textVerticalAlign = tmpTextPosCalcRes.verticalAlign;\n                    var textOrigin = textConfig.origin;\n                    if (textOrigin && textConfig.rotation != null) {\n                        var relOriginX = void 0;\n                        var relOriginY = void 0;\n                        if (textOrigin === 'center') {\n                            relOriginX = layoutRect.width * 0.5;\n                            relOriginY = layoutRect.height * 0.5;\n                        }\n                        else {\n                            relOriginX = parsePercent(textOrigin[0], layoutRect.width);\n                            relOriginY = parsePercent(textOrigin[1], layoutRect.height);\n                        }\n                        innerOrigin = true;\n                        attachedTransform.originX = -attachedTransform.x + relOriginX + (isLocal ? 0 : layoutRect.x);\n                        attachedTransform.originY = -attachedTransform.y + relOriginY + (isLocal ? 0 : layoutRect.y);\n                    }\n                }\n                if (textConfig.rotation != null) {\n                    attachedTransform.rotation = textConfig.rotation;\n                }\n                var textOffset = textConfig.offset;\n                if (textOffset) {\n                    attachedTransform.x += textOffset[0];\n                    attachedTransform.y += textOffset[1];\n                    if (!innerOrigin) {\n                        attachedTransform.originX = -textOffset[0];\n                        attachedTransform.originY = -textOffset[1];\n                    }\n                }\n                var isInside = textConfig.inside == null\n                    ? (typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0)\n                    : textConfig.inside;\n                var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});\n                var textFill = void 0;\n                var textStroke = void 0;\n                var autoStroke = void 0;\n                if (isInside && this.canBeInsideText()) {\n                    textFill = textConfig.insideFill;\n                    textStroke = textConfig.insideStroke;\n                    if (textFill == null || textFill === 'auto') {\n                        textFill = this.getInsideTextFill();\n                    }\n                    if (textStroke == null || textStroke === 'auto') {\n                        textStroke = this.getInsideTextStroke(textFill);\n                        autoStroke = true;\n                    }\n                }\n                else {\n                    textFill = textConfig.outsideFill;\n                    textStroke = textConfig.outsideStroke;\n                    if (textFill == null || textFill === 'auto') {\n                        textFill = this.getOutsideFill();\n                    }\n                    if (textStroke == null || textStroke === 'auto') {\n                        textStroke = this.getOutsideStroke(textFill);\n                        autoStroke = true;\n                    }\n                }\n                textFill = textFill || '#000';\n                if (textFill !== innerTextDefaultStyle.fill\n                    || textStroke !== innerTextDefaultStyle.stroke\n                    || autoStroke !== innerTextDefaultStyle.autoStroke\n                    || textAlign !== innerTextDefaultStyle.align\n                    || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {\n                    textStyleChanged = true;\n                    innerTextDefaultStyle.fill = textFill;\n                    innerTextDefaultStyle.stroke = textStroke;\n                    innerTextDefaultStyle.autoStroke = autoStroke;\n                    innerTextDefaultStyle.align = textAlign;\n                    innerTextDefaultStyle.verticalAlign = textVerticalAlign;\n                    textEl.setDefaultTextStyle(innerTextDefaultStyle);\n                }\n                if (textStyleChanged) {\n                    textEl.dirtyStyle();\n                }\n                textEl.markRedraw();\n            }\n        };\n        Element.prototype.canBeInsideText = function () {\n            return true;\n        };\n        Element.prototype.getInsideTextFill = function () {\n            return '#fff';\n        };\n        Element.prototype.getInsideTextStroke = function (textFill) {\n            return '#000';\n        };\n        Element.prototype.getOutsideFill = function () {\n            return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;\n        };\n        Element.prototype.getOutsideStroke = function (textFill) {\n            var backgroundColor = this.__zr && this.__zr.getBackgroundColor();\n            var colorArr = typeof backgroundColor === 'string' && parse(backgroundColor);\n            if (!colorArr) {\n                colorArr = [255, 255, 255, 1];\n            }\n            var alpha = colorArr[3];\n            var isDark = this.__zr.isDarkMode();\n            for (var i = 0; i < 3; i++) {\n                colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);\n            }\n            colorArr[3] = 1;\n            return stringify(colorArr, 'rgba');\n        };\n        Element.prototype.traverse = function (cb, context) { };\n        Element.prototype.attrKV = function (key, value) {\n            if (key === 'textConfig') {\n                this.setTextConfig(value);\n            }\n            else if (key === 'textContent') {\n                this.setTextContent(value);\n            }\n            else if (key === 'clipPath') {\n                this.setClipPath(value);\n            }\n            else if (key === 'extra') {\n                this.extra = this.extra || {};\n                extend(this.extra, value);\n            }\n            else {\n                this[key] = value;\n            }\n        };\n        Element.prototype.hide = function () {\n            this.ignore = true;\n            this.markRedraw();\n        };\n        Element.prototype.show = function () {\n            this.ignore = false;\n            this.markRedraw();\n        };\n        Element.prototype.attr = function (keyOrObj, value) {\n            if (typeof keyOrObj === 'string') {\n                this.attrKV(keyOrObj, value);\n            }\n            else if (isObject(keyOrObj)) {\n                var obj = keyOrObj;\n                var keysArr = keys(obj);\n                for (var i = 0; i < keysArr.length; i++) {\n                    var key = keysArr[i];\n                    this.attrKV(key, keyOrObj[key]);\n                }\n            }\n            this.markRedraw();\n            return this;\n        };\n        Element.prototype.saveCurrentToNormalState = function (toState) {\n            this._innerSaveToNormal(toState);\n            var normalState = this._normalState;\n            for (var i = 0; i < this.animators.length; i++) {\n                var animator = this.animators[i];\n                var fromStateTransition = animator.__fromStateTransition;\n                if (fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {\n                    continue;\n                }\n                var targetName = animator.targetName;\n                var target = targetName\n                    ? normalState[targetName] : normalState;\n                animator.saveFinalToTarget(target);\n            }\n        };\n        Element.prototype._innerSaveToNormal = function (toState) {\n            var normalState = this._normalState;\n            if (!normalState) {\n                normalState = this._normalState = {};\n            }\n            if (toState.textConfig && !normalState.textConfig) {\n                normalState.textConfig = this.textConfig;\n            }\n            this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);\n        };\n        Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {\n            for (var i = 0; i < primaryKeys.length; i++) {\n                var key = primaryKeys[i];\n                if (toState[key] != null && !(key in normalState)) {\n                    normalState[key] = this[key];\n                }\n            }\n        };\n        Element.prototype.hasState = function () {\n            return this.currentStates.length > 0;\n        };\n        Element.prototype.getState = function (name) {\n            return this.states[name];\n        };\n        Element.prototype.ensureState = function (name) {\n            var states = this.states;\n            if (!states[name]) {\n                states[name] = {};\n            }\n            return states[name];\n        };\n        Element.prototype.clearStates = function (noAnimation) {\n            this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);\n        };\n        Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation) {\n            var toNormalState = stateName === PRESERVED_NORMAL_STATE;\n            var hasStates = this.hasState();\n            if (!hasStates && toNormalState) {\n                return;\n            }\n            var currentStates = this.currentStates;\n            var animationCfg = this.stateTransition;\n            if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {\n                return;\n            }\n            var state;\n            if (this.stateProxy && !toNormalState) {\n                state = this.stateProxy(stateName);\n            }\n            if (!state) {\n                state = (this.states && this.states[stateName]);\n            }\n            if (!state && !toNormalState) {\n                logError(\"State \" + stateName + \" not exists.\");\n                return;\n            }\n            if (!toNormalState) {\n                this.saveCurrentToNormalState(state);\n            }\n            var useHoverLayer = !!(state && state.hoverLayer);\n            if (useHoverLayer) {\n                this._toggleHoverLayerFlag(true);\n            }\n            this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n            if (this._textContent) {\n                this._textContent.useState(stateName, keepCurrentStates);\n            }\n            if (this._textGuide) {\n                this._textGuide.useState(stateName, keepCurrentStates);\n            }\n            if (toNormalState) {\n                this.currentStates = [];\n                this._normalState = {};\n            }\n            else {\n                if (!keepCurrentStates) {\n                    this.currentStates = [stateName];\n                }\n                else {\n                    this.currentStates.push(stateName);\n                }\n            }\n            this._updateAnimationTargets();\n            this.markRedraw();\n            if (!useHoverLayer && this.__inHover) {\n                this._toggleHoverLayerFlag(false);\n                this.__dirty &= ~Element.REDARAW_BIT;\n            }\n            return state;\n        };\n        Element.prototype.useStates = function (states, noAnimation) {\n            if (!states.length) {\n                this.clearStates();\n            }\n            else {\n                var stateObjects = [];\n                var currentStates = this.currentStates;\n                var len = states.length;\n                var notChange = len === currentStates.length;\n                if (notChange) {\n                    for (var i = 0; i < len; i++) {\n                        if (states[i] !== currentStates[i]) {\n                            notChange = false;\n                            break;\n                        }\n                    }\n                }\n                if (notChange) {\n                    return;\n                }\n                for (var i = 0; i < len; i++) {\n                    var stateName = states[i];\n                    var stateObj = void 0;\n                    if (this.stateProxy) {\n                        stateObj = this.stateProxy(stateName, states);\n                    }\n                    if (!stateObj) {\n                        stateObj = this.states[stateName];\n                    }\n                    if (stateObj) {\n                        stateObjects.push(stateObj);\n                    }\n                }\n                var useHoverLayer = !!(stateObjects[len - 1] && stateObjects[len - 1].hoverLayer);\n                if (useHoverLayer) {\n                    this._toggleHoverLayerFlag(true);\n                }\n                var mergedState = this._mergeStates(stateObjects);\n                var animationCfg = this.stateTransition;\n                this.saveCurrentToNormalState(mergedState);\n                this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);\n                if (this._textContent) {\n                    this._textContent.useStates(states);\n                }\n                if (this._textGuide) {\n                    this._textGuide.useStates(states);\n                }\n                this._updateAnimationTargets();\n                this.currentStates = states.slice();\n                this.markRedraw();\n                if (!useHoverLayer && this.__inHover) {\n                    this._toggleHoverLayerFlag(false);\n                    this.__dirty &= ~Element.REDARAW_BIT;\n                }\n            }\n        };\n        Element.prototype._updateAnimationTargets = function () {\n            for (var i = 0; i < this.animators.length; i++) {\n                var animator = this.animators[i];\n                if (animator.targetName) {\n                    animator.changeTarget(this[animator.targetName]);\n                }\n            }\n        };\n        Element.prototype.removeState = function (state) {\n            var idx = indexOf(this.currentStates, state);\n            if (idx >= 0) {\n                var currentStates = this.currentStates.slice();\n                currentStates.splice(idx, 1);\n                this.useStates(currentStates);\n            }\n        };\n        Element.prototype.replaceState = function (oldState, newState, forceAdd) {\n            var currentStates = this.currentStates.slice();\n            var idx = indexOf(currentStates, oldState);\n            var newStateExists = indexOf(currentStates, newState) >= 0;\n            if (idx >= 0) {\n                if (!newStateExists) {\n                    currentStates[idx] = newState;\n                }\n                else {\n                    currentStates.splice(idx, 1);\n                }\n            }\n            else if (forceAdd && !newStateExists) {\n                currentStates.push(newState);\n            }\n            this.useStates(currentStates);\n        };\n        Element.prototype.toggleState = function (state, enable) {\n            if (enable) {\n                this.useState(state, true);\n            }\n            else {\n                this.removeState(state);\n            }\n        };\n        Element.prototype._mergeStates = function (states) {\n            var mergedState = {};\n            var mergedTextConfig;\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i];\n                extend(mergedState, state);\n                if (state.textConfig) {\n                    mergedTextConfig = mergedTextConfig || {};\n                    extend(mergedTextConfig, state.textConfig);\n                }\n            }\n            if (mergedTextConfig) {\n                mergedState.textConfig = mergedTextConfig;\n            }\n            return mergedState;\n        };\n        Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {\n            var needsRestoreToNormal = !(state && keepCurrentStates);\n            if (state && state.textConfig) {\n                this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);\n                extend(this.textConfig, state.textConfig);\n            }\n            else if (needsRestoreToNormal) {\n                if (normalState.textConfig) {\n                    this.textConfig = normalState.textConfig;\n                }\n            }\n            var transitionTarget = {};\n            var hasTransition = false;\n            for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {\n                var key = PRIMARY_STATES_KEYS[i];\n                var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];\n                if (state && state[key] != null) {\n                    if (propNeedsTransition) {\n                        hasTransition = true;\n                        transitionTarget[key] = state[key];\n                    }\n                    else {\n                        this[key] = state[key];\n                    }\n                }\n                else if (needsRestoreToNormal) {\n                    if (normalState[key] != null) {\n                        if (propNeedsTransition) {\n                            hasTransition = true;\n                            transitionTarget[key] = normalState[key];\n                        }\n                        else {\n                            this[key] = normalState[key];\n                        }\n                    }\n                }\n            }\n            if (!transition) {\n                for (var i = 0; i < this.animators.length; i++) {\n                    var animator = this.animators[i];\n                    var targetName = animator.targetName;\n                    animator.__changeFinalValue(targetName\n                        ? (state || normalState)[targetName]\n                        : (state || normalState));\n                }\n            }\n            if (hasTransition) {\n                this._transitionState(stateName, transitionTarget, animationCfg);\n            }\n        };\n        Element.prototype._attachComponent = function (componentEl) {\n            if (componentEl.__zr && !componentEl.__hostTarget) {\n                throw new Error('Text element has been added to zrender.');\n            }\n            if (componentEl === this) {\n                throw new Error('Recursive component attachment.');\n            }\n            var zr = this.__zr;\n            if (zr) {\n                componentEl.addSelfToZr(zr);\n            }\n            componentEl.__zr = zr;\n            componentEl.__hostTarget = this;\n        };\n        Element.prototype._detachComponent = function (componentEl) {\n            if (componentEl.__zr) {\n                componentEl.removeSelfFromZr(componentEl.__zr);\n            }\n            componentEl.__zr = null;\n            componentEl.__hostTarget = null;\n        };\n        Element.prototype.getClipPath = function () {\n            return this._clipPath;\n        };\n        Element.prototype.setClipPath = function (clipPath) {\n            if (this._clipPath && this._clipPath !== clipPath) {\n                this.removeClipPath();\n            }\n            this._attachComponent(clipPath);\n            this._clipPath = clipPath;\n            this.markRedraw();\n        };\n        Element.prototype.removeClipPath = function () {\n            var clipPath = this._clipPath;\n            if (clipPath) {\n                this._detachComponent(clipPath);\n                this._clipPath = null;\n                this.markRedraw();\n            }\n        };\n        Element.prototype.getTextContent = function () {\n            return this._textContent;\n        };\n        Element.prototype.setTextContent = function (textEl) {\n            var previousTextContent = this._textContent;\n            if (previousTextContent === textEl) {\n                return;\n            }\n            if (previousTextContent && previousTextContent !== textEl) {\n                this.removeTextContent();\n            }\n            if (textEl.__zr && !textEl.__hostTarget) {\n                throw new Error('Text element has been added to zrender.');\n            }\n            textEl.attachedTransform = new Transformable();\n            this._attachComponent(textEl);\n            this._textContent = textEl;\n            this.markRedraw();\n        };\n        Element.prototype.setTextConfig = function (cfg) {\n            if (!this.textConfig) {\n                this.textConfig = {};\n            }\n            extend(this.textConfig, cfg);\n            this.markRedraw();\n        };\n        Element.prototype.removeTextContent = function () {\n            var textEl = this._textContent;\n            if (textEl) {\n                textEl.attachedTransform = null;\n                this._detachComponent(textEl);\n                this._textContent = null;\n                this._innerTextDefaultStyle = null;\n                this.markRedraw();\n            }\n        };\n        Element.prototype.getTextGuideLine = function () {\n            return this._textGuide;\n        };\n        Element.prototype.setTextGuideLine = function (guideLine) {\n            if (this._textGuide && this._textGuide !== guideLine) {\n                this.removeTextGuideLine();\n            }\n            this._attachComponent(guideLine);\n            this._textGuide = guideLine;\n            this.markRedraw();\n        };\n        Element.prototype.removeTextGuideLine = function () {\n            var textGuide = this._textGuide;\n            if (textGuide) {\n                this._detachComponent(textGuide);\n                this._textGuide = null;\n                this.markRedraw();\n            }\n        };\n        Element.prototype.markRedraw = function () {\n            this.__dirty |= Element.REDARAW_BIT;\n            var zr = this.__zr;\n            if (zr) {\n                if (this.__inHover) {\n                    zr.refreshHover();\n                }\n                else {\n                    zr.refresh();\n                }\n            }\n            if (this.__hostTarget) {\n                this.__hostTarget.markRedraw();\n            }\n        };\n        Element.prototype.dirty = function () {\n            this.markRedraw();\n        };\n        Element.prototype._toggleHoverLayerFlag = function (inHover) {\n            this.__inHover = inHover;\n            var textContent = this._textContent;\n            var textGuide = this._textGuide;\n            if (textContent) {\n                textContent.__inHover = inHover;\n            }\n            if (textGuide) {\n                textGuide.__inHover = inHover;\n            }\n        };\n        Element.prototype.addSelfToZr = function (zr) {\n            this.__zr = zr;\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.addAnimator(animators[i]);\n                }\n            }\n            if (this._clipPath) {\n                this._clipPath.addSelfToZr(zr);\n            }\n            if (this._textContent) {\n                this._textContent.addSelfToZr(zr);\n            }\n            if (this._textGuide) {\n                this._textGuide.addSelfToZr(zr);\n            }\n        };\n        Element.prototype.removeSelfFromZr = function (zr) {\n            this.__zr = null;\n            var animators = this.animators;\n            if (animators) {\n                for (var i = 0; i < animators.length; i++) {\n                    zr.animation.removeAnimator(animators[i]);\n                }\n            }\n            if (this._clipPath) {\n                this._clipPath.removeSelfFromZr(zr);\n            }\n            if (this._textContent) {\n                this._textContent.removeSelfFromZr(zr);\n            }\n            if (this._textGuide) {\n                this._textGuide.removeSelfFromZr(zr);\n            }\n        };\n        Element.prototype.animate = function (key, loop) {\n            var target = key ? this[key] : this;\n            if (!target) {\n                logError('Property \"'\n                    + key\n                    + '\" is not existed in element '\n                    + this.id);\n                return;\n            }\n            var animator = new Animator(target, loop);\n            this.addAnimator(animator, key);\n            return animator;\n        };\n        Element.prototype.addAnimator = function (animator, key) {\n            var zr = this.__zr;\n            var el = this;\n            animator.during(function () {\n                el.updateDuringAnimation(key);\n            }).done(function () {\n                var animators = el.animators;\n                var idx = indexOf(animators, animator);\n                if (idx >= 0) {\n                    animators.splice(idx, 1);\n                }\n            });\n            this.animators.push(animator);\n            if (zr) {\n                zr.animation.addAnimator(animator);\n            }\n            zr && zr.wakeUp();\n        };\n        Element.prototype.updateDuringAnimation = function (key) {\n            this.markRedraw();\n        };\n        Element.prototype.stopAnimation = function (scope, forwardToLast) {\n            var animators = this.animators;\n            var len = animators.length;\n            var leftAnimators = [];\n            for (var i = 0; i < len; i++) {\n                var animator = animators[i];\n                if (!scope || scope === animator.scope) {\n                    animator.stop(forwardToLast);\n                }\n                else {\n                    leftAnimators.push(animator);\n                }\n            }\n            this.animators = leftAnimators;\n            return this;\n        };\n        Element.prototype.animateTo = function (target, cfg, animationProps) {\n            animateTo(this, target, cfg, animationProps);\n        };\n        Element.prototype.animateFrom = function (target, cfg, animationProps) {\n            animateTo(this, target, cfg, animationProps, true);\n        };\n        Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {\n            var animators = animateTo(this, target, cfg, animationProps);\n            for (var i = 0; i < animators.length; i++) {\n                animators[i].__fromStateTransition = stateName;\n            }\n        };\n        Element.prototype.getBoundingRect = function () {\n            return null;\n        };\n        Element.prototype.getPaintRect = function () {\n            return null;\n        };\n        Element.REDARAW_BIT = 1;\n        Element.initDefaultProps = (function () {\n            var elProto = Element.prototype;\n            elProto.type = 'element';\n            elProto.name = '';\n            elProto.ignore = false;\n            elProto.silent = false;\n            elProto.isGroup = false;\n            elProto.draggable = false;\n            elProto.dragging = false;\n            elProto.ignoreClip = false;\n            elProto.__inHover = false;\n            elProto.__dirty = Element.REDARAW_BIT;\n            var logs = {};\n            function logDeprecatedError(key, xKey, yKey) {\n                if (!logs[key + xKey + yKey]) {\n                    console.warn(\"DEPRECATED: '\" + key + \"' has been deprecated. use '\" + xKey + \"', '\" + yKey + \"' instead\");\n                    logs[key + xKey + yKey] = true;\n                }\n            }\n            function createLegacyProperty(key, privateKey, xKey, yKey) {\n                Object.defineProperty(elProto, key, {\n                    get: function () {\n                        logDeprecatedError(key, xKey, yKey);\n                        if (!this[privateKey]) {\n                            var pos = this[privateKey] = [];\n                            enhanceArray(this, pos);\n                        }\n                        return this[privateKey];\n                    },\n                    set: function (pos) {\n                        logDeprecatedError(key, xKey, yKey);\n                        this[xKey] = pos[0];\n                        this[yKey] = pos[1];\n                        this[privateKey] = pos;\n                        enhanceArray(this, pos);\n                    }\n                });\n                function enhanceArray(self, pos) {\n                    Object.defineProperty(pos, 0, {\n                        get: function () {\n                            return self[xKey];\n                        },\n                        set: function (val) {\n                            self[xKey] = val;\n                        }\n                    });\n                    Object.defineProperty(pos, 1, {\n                        get: function () {\n                            return self[yKey];\n                        },\n                        set: function (val) {\n                            self[yKey] = val;\n                        }\n                    });\n                }\n            }\n            if (Object.defineProperty && (!env.browser.ie || env.browser.version > 8)) {\n                createLegacyProperty('position', '_legacyPos', 'x', 'y');\n                createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY');\n                createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY');\n            }\n        })();\n        return Element;\n    }());\n    mixin(Element, Eventful);\n    mixin(Element, Transformable);\n    function animateTo(animatable, target, cfg, animationProps, reverse) {\n        cfg = cfg || {};\n        var animators = [];\n        animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse);\n        var finishCount = animators.length;\n        var doneHappened = false;\n        var cfgDone = cfg.done;\n        var cfgAborted = cfg.aborted;\n        var doneCb = function () {\n            doneHappened = true;\n            finishCount--;\n            if (finishCount <= 0) {\n                doneHappened\n                    ? (cfgDone && cfgDone())\n                    : (cfgAborted && cfgAborted());\n            }\n        };\n        var abortedCb = function () {\n            finishCount--;\n            if (finishCount <= 0) {\n                doneHappened\n                    ? (cfgDone && cfgDone())\n                    : (cfgAborted && cfgAborted());\n            }\n        };\n        if (!finishCount) {\n            cfgDone && cfgDone();\n        }\n        if (animators.length > 0 && cfg.during) {\n            animators[0].during(function (target, percent) {\n                cfg.during(percent);\n            });\n        }\n        for (var i = 0; i < animators.length; i++) {\n            var animator = animators[i];\n            if (doneCb) {\n                animator.done(doneCb);\n            }\n            if (abortedCb) {\n                animator.aborted(abortedCb);\n            }\n            animator.start(cfg.easing, cfg.force);\n        }\n        return animators;\n    }\n    function copyArrShallow(source, target, len) {\n        for (var i = 0; i < len; i++) {\n            source[i] = target[i];\n        }\n    }\n    function is2DArray(value) {\n        return isArrayLike(value[0]);\n    }\n    function copyValue(target, source, key) {\n        if (isArrayLike(source[key])) {\n            if (!isArrayLike(target[key])) {\n                target[key] = [];\n            }\n            if (isTypedArray(source[key])) {\n                var len = source[key].length;\n                if (target[key].length !== len) {\n                    target[key] = new (source[key].constructor)(len);\n                    copyArrShallow(target[key], source[key], len);\n                }\n            }\n            else {\n                var sourceArr = source[key];\n                var targetArr = target[key];\n                var len0 = sourceArr.length;\n                if (is2DArray(sourceArr)) {\n                    var len1 = sourceArr[0].length;\n                    for (var i = 0; i < len0; i++) {\n                        if (!targetArr[i]) {\n                            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);\n                        }\n                        else {\n                            copyArrShallow(targetArr[i], sourceArr[i], len1);\n                        }\n                    }\n                }\n                else {\n                    copyArrShallow(targetArr, sourceArr, len0);\n                }\n                targetArr.length = sourceArr.length;\n            }\n        }\n        else {\n            target[key] = source[key];\n        }\n    }\n    function animateToShallow(animatable, topKey, source, target, cfg, animationProps, animators, reverse) {\n        var animatableKeys = [];\n        var changedKeys = [];\n        var targetKeys = keys(target);\n        var duration = cfg.duration;\n        var delay = cfg.delay;\n        var additive = cfg.additive;\n        var setToFinal = cfg.setToFinal;\n        var animateAll = !isObject(animationProps);\n        for (var k = 0; k < targetKeys.length; k++) {\n            var innerKey = targetKeys[k];\n            if (source[innerKey] != null\n                && target[innerKey] != null\n                && (animateAll || animationProps[innerKey])) {\n                if (isObject(target[innerKey]) && !isArrayLike(target[innerKey])) {\n                    if (topKey) {\n                        if (!reverse) {\n                            source[innerKey] = target[innerKey];\n                            animatable.updateDuringAnimation(topKey);\n                        }\n                        continue;\n                    }\n                    animateToShallow(animatable, innerKey, source[innerKey], target[innerKey], cfg, animationProps && animationProps[innerKey], animators, reverse);\n                }\n                else {\n                    animatableKeys.push(innerKey);\n                    changedKeys.push(innerKey);\n                }\n            }\n            else if (!reverse) {\n                source[innerKey] = target[innerKey];\n                animatable.updateDuringAnimation(topKey);\n                changedKeys.push(innerKey);\n            }\n        }\n        var keyLen = animatableKeys.length;\n        if (keyLen > 0\n            || (cfg.force && !animators.length)) {\n            var existsAnimators = animatable.animators;\n            var existsAnimatorsOnSameTarget = [];\n            for (var i = 0; i < existsAnimators.length; i++) {\n                if (existsAnimators[i].targetName === topKey) {\n                    existsAnimatorsOnSameTarget.push(existsAnimators[i]);\n                }\n            }\n            if (!additive && existsAnimatorsOnSameTarget.length) {\n                for (var i = 0; i < existsAnimatorsOnSameTarget.length; i++) {\n                    var allAborted = existsAnimatorsOnSameTarget[i].stopTracks(changedKeys);\n                    if (allAborted) {\n                        var idx = indexOf(existsAnimators, existsAnimatorsOnSameTarget[i]);\n                        existsAnimators.splice(idx, 1);\n                    }\n                }\n            }\n            var revertedSource = void 0;\n            var reversedTarget = void 0;\n            var sourceClone = void 0;\n            if (reverse) {\n                reversedTarget = {};\n                if (setToFinal) {\n                    revertedSource = {};\n                }\n                for (var i = 0; i < keyLen; i++) {\n                    var innerKey = animatableKeys[i];\n                    reversedTarget[innerKey] = source[innerKey];\n                    if (setToFinal) {\n                        revertedSource[innerKey] = target[innerKey];\n                    }\n                    else {\n                        source[innerKey] = target[innerKey];\n                    }\n                }\n            }\n            else if (setToFinal) {\n                sourceClone = {};\n                for (var i = 0; i < keyLen; i++) {\n                    var innerKey = animatableKeys[i];\n                    sourceClone[innerKey] = cloneValue(source[innerKey]);\n                    copyValue(source, target, innerKey);\n                }\n            }\n            var animator = new Animator(source, false, additive ? existsAnimatorsOnSameTarget : null);\n            animator.targetName = topKey;\n            if (cfg.scope) {\n                animator.scope = cfg.scope;\n            }\n            if (setToFinal && revertedSource) {\n                animator.whenWithKeys(0, revertedSource, animatableKeys);\n            }\n            if (sourceClone) {\n                animator.whenWithKeys(0, sourceClone, animatableKeys);\n            }\n            animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animatableKeys).delay(delay || 0);\n            animatable.addAnimator(animator, topKey);\n            animators.push(animator);\n        }\n    }\n\n    var DEFAULT_MIN_MERGE = 32;\n    var DEFAULT_MIN_GALLOPING = 7;\n    function minRunLength(n) {\n        var r = 0;\n        while (n >= DEFAULT_MIN_MERGE) {\n            r |= n & 1;\n            n >>= 1;\n        }\n        return n + r;\n    }\n    function makeAscendingRun(array, lo, hi, compare) {\n        var runHi = lo + 1;\n        if (runHi === hi) {\n            return 1;\n        }\n        if (compare(array[runHi++], array[lo]) < 0) {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n                runHi++;\n            }\n            reverseRun(array, lo, runHi);\n        }\n        else {\n            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n                runHi++;\n            }\n        }\n        return runHi - lo;\n    }\n    function reverseRun(array, lo, hi) {\n        hi--;\n        while (lo < hi) {\n            var t = array[lo];\n            array[lo++] = array[hi];\n            array[hi--] = t;\n        }\n    }\n    function binaryInsertionSort(array, lo, hi, start, compare) {\n        if (start === lo) {\n            start++;\n        }\n        for (; start < hi; start++) {\n            var pivot = array[start];\n            var left = lo;\n            var right = start;\n            var mid;\n            while (left < right) {\n                mid = left + right >>> 1;\n                if (compare(pivot, array[mid]) < 0) {\n                    right = mid;\n                }\n                else {\n                    left = mid + 1;\n                }\n            }\n            var n = start - left;\n            switch (n) {\n                case 3:\n                    array[left + 3] = array[left + 2];\n                case 2:\n                    array[left + 2] = array[left + 1];\n                case 1:\n                    array[left + 1] = array[left];\n                    break;\n                default:\n                    while (n > 0) {\n                        array[left + n] = array[left + n - 1];\n                        n--;\n                    }\n            }\n            array[left] = pivot;\n        }\n    }\n    function gallopLeft(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) > 0) {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        else {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) > 0) {\n                lastOffset = m + 1;\n            }\n            else {\n                offset = m;\n            }\n        }\n        return offset;\n    }\n    function gallopRight(value, array, start, length, hint, compare) {\n        var lastOffset = 0;\n        var maxOffset = 0;\n        var offset = 1;\n        if (compare(value, array[start + hint]) < 0) {\n            maxOffset = hint + 1;\n            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            var tmp = lastOffset;\n            lastOffset = hint - offset;\n            offset = hint - tmp;\n        }\n        else {\n            maxOffset = length - hint;\n            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n                lastOffset = offset;\n                offset = (offset << 1) + 1;\n                if (offset <= 0) {\n                    offset = maxOffset;\n                }\n            }\n            if (offset > maxOffset) {\n                offset = maxOffset;\n            }\n            lastOffset += hint;\n            offset += hint;\n        }\n        lastOffset++;\n        while (lastOffset < offset) {\n            var m = lastOffset + (offset - lastOffset >>> 1);\n            if (compare(value, array[start + m]) < 0) {\n                offset = m;\n            }\n            else {\n                lastOffset = m + 1;\n            }\n        }\n        return offset;\n    }\n    function TimSort(array, compare) {\n        var minGallop = DEFAULT_MIN_GALLOPING;\n        var length = 0;\n        var runStart;\n        var runLength;\n        var stackSize = 0;\n        length = array.length;\n        var tmp = [];\n        runStart = [];\n        runLength = [];\n        function pushRun(_runStart, _runLength) {\n            runStart[stackSize] = _runStart;\n            runLength[stackSize] = _runLength;\n            stackSize += 1;\n        }\n        function mergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if ((n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1])\n                    || (n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1])) {\n                    if (runLength[n - 1] < runLength[n + 1]) {\n                        n--;\n                    }\n                }\n                else if (runLength[n] > runLength[n + 1]) {\n                    break;\n                }\n                mergeAt(n);\n            }\n        }\n        function forceMergeRuns() {\n            while (stackSize > 1) {\n                var n = stackSize - 2;\n                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n                    n--;\n                }\n                mergeAt(n);\n            }\n        }\n        function mergeAt(i) {\n            var start1 = runStart[i];\n            var length1 = runLength[i];\n            var start2 = runStart[i + 1];\n            var length2 = runLength[i + 1];\n            runLength[i] = length1 + length2;\n            if (i === stackSize - 3) {\n                runStart[i + 1] = runStart[i + 2];\n                runLength[i + 1] = runLength[i + 2];\n            }\n            stackSize--;\n            var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n            start1 += k;\n            length1 -= k;\n            if (length1 === 0) {\n                return;\n            }\n            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n            if (length2 === 0) {\n                return;\n            }\n            if (length1 <= length2) {\n                mergeLow(start1, length1, start2, length2);\n            }\n            else {\n                mergeHigh(start1, length1, start2, length2);\n            }\n        }\n        function mergeLow(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length1; i++) {\n                tmp[i] = array[start1 + i];\n            }\n            var cursor1 = 0;\n            var cursor2 = start2;\n            var dest = start1;\n            array[dest++] = array[cursor2++];\n            if (--length2 === 0) {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n                return;\n            }\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n                return;\n            }\n            var _minGallop = minGallop;\n            var count1;\n            var count2;\n            var exit;\n            while (1) {\n                count1 = 0;\n                count2 = 0;\n                exit = false;\n                do {\n                    if (compare(array[cursor2], tmp[cursor1]) < 0) {\n                        array[dest++] = array[cursor2++];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest++] = tmp[cursor1++];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n                    if (count1 !== 0) {\n                        for (i = 0; i < count1; i++) {\n                            array[dest + i] = tmp[cursor1 + i];\n                        }\n                        dest += count1;\n                        cursor1 += count1;\n                        length1 -= count1;\n                        if (length1 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = array[cursor2++];\n                    if (--length2 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n                    if (count2 !== 0) {\n                        for (i = 0; i < count2; i++) {\n                            array[dest + i] = array[cursor2 + i];\n                        }\n                        dest += count2;\n                        cursor2 += count2;\n                        length2 -= count2;\n                        if (length2 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest++] = tmp[cursor1++];\n                    if (--length1 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            minGallop < 1 && (minGallop = 1);\n            if (length1 === 1) {\n                for (i = 0; i < length2; i++) {\n                    array[dest + i] = array[cursor2 + i];\n                }\n                array[dest + length2] = tmp[cursor1];\n            }\n            else if (length1 === 0) {\n                throw new Error();\n            }\n            else {\n                for (i = 0; i < length1; i++) {\n                    array[dest + i] = tmp[cursor1 + i];\n                }\n            }\n        }\n        function mergeHigh(start1, length1, start2, length2) {\n            var i = 0;\n            for (i = 0; i < length2; i++) {\n                tmp[i] = array[start2 + i];\n            }\n            var cursor1 = start1 + length1 - 1;\n            var cursor2 = length2 - 1;\n            var dest = start2 + length2 - 1;\n            var customCursor = 0;\n            var customDest = 0;\n            array[dest--] = array[cursor1--];\n            if (--length1 === 0) {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n                return;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n                return;\n            }\n            var _minGallop = minGallop;\n            while (true) {\n                var count1 = 0;\n                var count2 = 0;\n                var exit = false;\n                do {\n                    if (compare(tmp[cursor2], array[cursor1]) < 0) {\n                        array[dest--] = array[cursor1--];\n                        count1++;\n                        count2 = 0;\n                        if (--length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    else {\n                        array[dest--] = tmp[cursor2--];\n                        count2++;\n                        count1 = 0;\n                        if (--length2 === 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                } while ((count1 | count2) < _minGallop);\n                if (exit) {\n                    break;\n                }\n                do {\n                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n                    if (count1 !== 0) {\n                        dest -= count1;\n                        cursor1 -= count1;\n                        length1 -= count1;\n                        customDest = dest + 1;\n                        customCursor = cursor1 + 1;\n                        for (i = count1 - 1; i >= 0; i--) {\n                            array[customDest + i] = array[customCursor + i];\n                        }\n                        if (length1 === 0) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = tmp[cursor2--];\n                    if (--length2 === 1) {\n                        exit = true;\n                        break;\n                    }\n                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n                    if (count2 !== 0) {\n                        dest -= count2;\n                        cursor2 -= count2;\n                        length2 -= count2;\n                        customDest = dest + 1;\n                        customCursor = cursor2 + 1;\n                        for (i = 0; i < count2; i++) {\n                            array[customDest + i] = tmp[customCursor + i];\n                        }\n                        if (length2 <= 1) {\n                            exit = true;\n                            break;\n                        }\n                    }\n                    array[dest--] = array[cursor1--];\n                    if (--length1 === 0) {\n                        exit = true;\n                        break;\n                    }\n                    _minGallop--;\n                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n                if (exit) {\n                    break;\n                }\n                if (_minGallop < 0) {\n                    _minGallop = 0;\n                }\n                _minGallop += 2;\n            }\n            minGallop = _minGallop;\n            if (minGallop < 1) {\n                minGallop = 1;\n            }\n            if (length2 === 1) {\n                dest -= length1;\n                cursor1 -= length1;\n                customDest = dest + 1;\n                customCursor = cursor1 + 1;\n                for (i = length1 - 1; i >= 0; i--) {\n                    array[customDest + i] = array[customCursor + i];\n                }\n                array[dest] = tmp[cursor2];\n            }\n            else if (length2 === 0) {\n                throw new Error();\n            }\n            else {\n                customCursor = dest - (length2 - 1);\n                for (i = 0; i < length2; i++) {\n                    array[customCursor + i] = tmp[i];\n                }\n            }\n        }\n        return {\n            mergeRuns: mergeRuns,\n            forceMergeRuns: forceMergeRuns,\n            pushRun: pushRun\n        };\n    }\n    function sort(array, compare, lo, hi) {\n        if (!lo) {\n            lo = 0;\n        }\n        if (!hi) {\n            hi = array.length;\n        }\n        var remaining = hi - lo;\n        if (remaining < 2) {\n            return;\n        }\n        var runLength = 0;\n        if (remaining < DEFAULT_MIN_MERGE) {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n            return;\n        }\n        var ts = TimSort(array, compare);\n        var minRun = minRunLength(remaining);\n        do {\n            runLength = makeAscendingRun(array, lo, hi, compare);\n            if (runLength < minRun) {\n                var force = remaining;\n                if (force > minRun) {\n                    force = minRun;\n                }\n                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n                runLength = force;\n            }\n            ts.pushRun(lo, runLength);\n            ts.mergeRuns();\n            remaining -= runLength;\n            lo += runLength;\n        } while (remaining !== 0);\n        ts.forceMergeRuns();\n    }\n\n    var invalidZErrorLogged = false;\n    function logInvalidZError() {\n        if (invalidZErrorLogged) {\n            return;\n        }\n        invalidZErrorLogged = true;\n        console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors');\n    }\n    function shapeCompareFunc(a, b) {\n        if (a.zlevel === b.zlevel) {\n            if (a.z === b.z) {\n                return a.z2 - b.z2;\n            }\n            return a.z - b.z;\n        }\n        return a.zlevel - b.zlevel;\n    }\n    var Storage = (function () {\n        function Storage() {\n            this._roots = [];\n            this._displayList = [];\n            this._displayListLen = 0;\n            this.displayableSortFunc = shapeCompareFunc;\n        }\n        Storage.prototype.traverse = function (cb, context) {\n            for (var i = 0; i < this._roots.length; i++) {\n                this._roots[i].traverse(cb, context);\n            }\n        };\n        Storage.prototype.getDisplayList = function (update, includeIgnore) {\n            includeIgnore = includeIgnore || false;\n            var displayList = this._displayList;\n            if (update || !displayList.length) {\n                this.updateDisplayList(includeIgnore);\n            }\n            return displayList;\n        };\n        Storage.prototype.updateDisplayList = function (includeIgnore) {\n            this._displayListLen = 0;\n            var roots = this._roots;\n            var displayList = this._displayList;\n            for (var i = 0, len = roots.length; i < len; i++) {\n                this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n            }\n            displayList.length = this._displayListLen;\n            env.canvasSupported && sort(displayList, shapeCompareFunc);\n        };\n        Storage.prototype._updateAndAddDisplayable = function (el, clipPaths, includeIgnore) {\n            if (el.ignore && !includeIgnore) {\n                return;\n            }\n            el.beforeUpdate();\n            el.update();\n            el.afterUpdate();\n            var userSetClipPath = el.getClipPath();\n            if (el.ignoreClip) {\n                clipPaths = null;\n            }\n            else if (userSetClipPath) {\n                if (clipPaths) {\n                    clipPaths = clipPaths.slice();\n                }\n                else {\n                    clipPaths = [];\n                }\n                var currentClipPath = userSetClipPath;\n                var parentClipPath = el;\n                while (currentClipPath) {\n                    currentClipPath.parent = parentClipPath;\n                    currentClipPath.updateTransform();\n                    clipPaths.push(currentClipPath);\n                    parentClipPath = currentClipPath;\n                    currentClipPath = currentClipPath.getClipPath();\n                }\n            }\n            if (el.childrenRef) {\n                var children = el.childrenRef();\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    if (el.__dirty) {\n                        child.__dirty |= Element.REDARAW_BIT;\n                    }\n                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n                }\n                el.__dirty = 0;\n            }\n            else {\n                var disp = el;\n                if (clipPaths && clipPaths.length) {\n                    disp.__clipPaths = clipPaths;\n                }\n                else if (disp.__clipPaths && disp.__clipPaths.length > 0) {\n                    disp.__clipPaths = [];\n                }\n                if (isNaN(disp.z)) {\n                    logInvalidZError();\n                    disp.z = 0;\n                }\n                if (isNaN(disp.z2)) {\n                    logInvalidZError();\n                    disp.z2 = 0;\n                }\n                if (isNaN(disp.zlevel)) {\n                    logInvalidZError();\n                    disp.zlevel = 0;\n                }\n                this._displayList[this._displayListLen++] = disp;\n            }\n            var decalEl = el.getDecalElement && el.getDecalElement();\n            if (decalEl) {\n                this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);\n            }\n            var textGuide = el.getTextGuideLine();\n            if (textGuide) {\n                this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);\n            }\n            var textEl = el.getTextContent();\n            if (textEl) {\n                this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);\n            }\n        };\n        Storage.prototype.addRoot = function (el) {\n            if (el.__zr && el.__zr.storage === this) {\n                return;\n            }\n            this._roots.push(el);\n        };\n        Storage.prototype.delRoot = function (el) {\n            if (el instanceof Array) {\n                for (var i = 0, l = el.length; i < l; i++) {\n                    this.delRoot(el[i]);\n                }\n                return;\n            }\n            var idx = indexOf(this._roots, el);\n            if (idx >= 0) {\n                this._roots.splice(idx, 1);\n            }\n        };\n        Storage.prototype.delAllRoots = function () {\n            this._roots = [];\n            this._displayList = [];\n            this._displayListLen = 0;\n            return;\n        };\n        Storage.prototype.getRoots = function () {\n            return this._roots;\n        };\n        Storage.prototype.dispose = function () {\n            this._displayList = null;\n            this._roots = null;\n        };\n        return Storage;\n    }());\n\n    var requestAnimationFrame;\n    requestAnimationFrame = (typeof window !== 'undefined'\n        && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))\n            || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))\n            || window.mozRequestAnimationFrame\n            || window.webkitRequestAnimationFrame)) || function (func) {\n        return setTimeout(func, 16);\n    };\n    var requestAnimationFrame$1 = requestAnimationFrame;\n\n    var Animation = (function (_super) {\n        __extends(Animation, _super);\n        function Animation(opts) {\n            var _this = _super.call(this) || this;\n            _this._running = false;\n            _this._time = 0;\n            _this._pausedTime = 0;\n            _this._pauseStart = 0;\n            _this._paused = false;\n            opts = opts || {};\n            _this.stage = opts.stage || {};\n            _this.onframe = opts.onframe || function () { };\n            return _this;\n        }\n        Animation.prototype.addClip = function (clip) {\n            if (clip.animation) {\n                this.removeClip(clip);\n            }\n            if (!this._clipsHead) {\n                this._clipsHead = this._clipsTail = clip;\n            }\n            else {\n                this._clipsTail.next = clip;\n                clip.prev = this._clipsTail;\n                clip.next = null;\n                this._clipsTail = clip;\n            }\n            clip.animation = this;\n        };\n        Animation.prototype.addAnimator = function (animator) {\n            animator.animation = this;\n            var clip = animator.getClip();\n            if (clip) {\n                this.addClip(clip);\n            }\n        };\n        Animation.prototype.removeClip = function (clip) {\n            if (!clip.animation) {\n                return;\n            }\n            var prev = clip.prev;\n            var next = clip.next;\n            if (prev) {\n                prev.next = next;\n            }\n            else {\n                this._clipsHead = next;\n            }\n            if (next) {\n                next.prev = prev;\n            }\n            else {\n                this._clipsTail = prev;\n            }\n            clip.next = clip.prev = clip.animation = null;\n        };\n        Animation.prototype.removeAnimator = function (animator) {\n            var clip = animator.getClip();\n            if (clip) {\n                this.removeClip(clip);\n            }\n            animator.animation = null;\n        };\n        Animation.prototype.update = function (notTriggerFrameAndStageUpdate) {\n            var time = new Date().getTime() - this._pausedTime;\n            var delta = time - this._time;\n            var clip = this._clipsHead;\n            while (clip) {\n                var nextClip = clip.next;\n                var finished = clip.step(time, delta);\n                if (finished) {\n                    clip.ondestroy && clip.ondestroy();\n                    this.removeClip(clip);\n                    clip = nextClip;\n                }\n                else {\n                    clip = nextClip;\n                }\n            }\n            this._time = time;\n            if (!notTriggerFrameAndStageUpdate) {\n                this.onframe(delta);\n                this.trigger('frame', delta);\n                this.stage.update && this.stage.update();\n            }\n        };\n        Animation.prototype._startLoop = function () {\n            var self = this;\n            this._running = true;\n            function step() {\n                if (self._running) {\n                    requestAnimationFrame$1(step);\n                    !self._paused && self.update();\n                }\n            }\n            requestAnimationFrame$1(step);\n        };\n        Animation.prototype.start = function () {\n            if (this._running) {\n                return;\n            }\n            this._time = new Date().getTime();\n            this._pausedTime = 0;\n            this._startLoop();\n        };\n        Animation.prototype.stop = function () {\n            this._running = false;\n        };\n        Animation.prototype.pause = function () {\n            if (!this._paused) {\n                this._pauseStart = new Date().getTime();\n                this._paused = true;\n            }\n        };\n        Animation.prototype.resume = function () {\n            if (this._paused) {\n                this._pausedTime += (new Date().getTime()) - this._pauseStart;\n                this._paused = false;\n            }\n        };\n        Animation.prototype.clear = function () {\n            var clip = this._clipsHead;\n            while (clip) {\n                var nextClip = clip.next;\n                clip.prev = clip.next = clip.animation = null;\n                clip = nextClip;\n            }\n            this._clipsHead = this._clipsTail = null;\n        };\n        Animation.prototype.isFinished = function () {\n            return this._clipsHead == null;\n        };\n        Animation.prototype.animate = function (target, options) {\n            options = options || {};\n            this.start();\n            var animator = new Animator(target, options.loop);\n            this.addAnimator(animator);\n            return animator;\n        };\n        return Animation;\n    }(Eventful));\n\n    var TOUCH_CLICK_DELAY = 300;\n    var globalEventSupported = env.domSupported;\n    var localNativeListenerNames = (function () {\n        var mouseHandlerNames = [\n            'click', 'dblclick', 'mousewheel', 'wheel', 'mouseout',\n            'mouseup', 'mousedown', 'mousemove', 'contextmenu'\n        ];\n        var touchHandlerNames = [\n            'touchstart', 'touchend', 'touchmove'\n        ];\n        var pointerEventNameMap = {\n            pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1\n        };\n        var pointerHandlerNames = map(mouseHandlerNames, function (name) {\n            var nm = name.replace('mouse', 'pointer');\n            return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n        });\n        return {\n            mouse: mouseHandlerNames,\n            touch: touchHandlerNames,\n            pointer: pointerHandlerNames\n        };\n    })();\n    var globalNativeListenerNames = {\n        mouse: ['mousemove', 'mouseup'],\n        pointer: ['pointermove', 'pointerup']\n    };\n    var wheelEventSupported = false;\n    function isPointerFromTouch(event) {\n        var pointerType = event.pointerType;\n        return pointerType === 'pen' || pointerType === 'touch';\n    }\n    function setTouchTimer(scope) {\n        scope.touching = true;\n        if (scope.touchTimer != null) {\n            clearTimeout(scope.touchTimer);\n            scope.touchTimer = null;\n        }\n        scope.touchTimer = setTimeout(function () {\n            scope.touching = false;\n            scope.touchTimer = null;\n        }, 700);\n    }\n    function markTouch(event) {\n        event && (event.zrByTouch = true);\n    }\n    function normalizeGlobalEvent(instance, event) {\n        return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\n    }\n    function isLocalEl(instance, el) {\n        var elTmp = el;\n        var isLocal = false;\n        while (elTmp && elTmp.nodeType !== 9\n            && !(isLocal = elTmp.domBelongToZr\n                || (elTmp !== el && elTmp === instance.painterRoot))) {\n            elTmp = elTmp.parentNode;\n        }\n        return isLocal;\n    }\n    var FakeGlobalEvent = (function () {\n        function FakeGlobalEvent(instance, event) {\n            this.stopPropagation = noop;\n            this.stopImmediatePropagation = noop;\n            this.preventDefault = noop;\n            this.type = event.type;\n            this.target = this.currentTarget = instance.dom;\n            this.pointerType = event.pointerType;\n            this.clientX = event.clientX;\n            this.clientY = event.clientY;\n        }\n        return FakeGlobalEvent;\n    }());\n    var localDOMHandlers = {\n        mousedown: function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.__mayPointerCapture = [event.zrX, event.zrY];\n            this.trigger('mousedown', event);\n        },\n        mousemove: function (event) {\n            event = normalizeEvent(this.dom, event);\n            var downPoint = this.__mayPointerCapture;\n            if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\n                this.__togglePointerCapture(true);\n            }\n            this.trigger('mousemove', event);\n        },\n        mouseup: function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.__togglePointerCapture(false);\n            this.trigger('mouseup', event);\n        },\n        mouseout: function (event) {\n            event = normalizeEvent(this.dom, event);\n            var element = event.toElement || event.relatedTarget;\n            if (!isLocalEl(this, element)) {\n                if (this.__pointerCapturing) {\n                    event.zrEventControl = 'no_globalout';\n                }\n                this.trigger('mouseout', event);\n            }\n        },\n        wheel: function (event) {\n            wheelEventSupported = true;\n            event = normalizeEvent(this.dom, event);\n            this.trigger('mousewheel', event);\n        },\n        mousewheel: function (event) {\n            if (wheelEventSupported) {\n                return;\n            }\n            event = normalizeEvent(this.dom, event);\n            this.trigger('mousewheel', event);\n        },\n        touchstart: function (event) {\n            event = normalizeEvent(this.dom, event);\n            markTouch(event);\n            this.__lastTouchMoment = new Date();\n            this.handler.processGesture(event, 'start');\n            localDOMHandlers.mousemove.call(this, event);\n            localDOMHandlers.mousedown.call(this, event);\n        },\n        touchmove: function (event) {\n            event = normalizeEvent(this.dom, event);\n            markTouch(event);\n            this.handler.processGesture(event, 'change');\n            localDOMHandlers.mousemove.call(this, event);\n        },\n        touchend: function (event) {\n            event = normalizeEvent(this.dom, event);\n            markTouch(event);\n            this.handler.processGesture(event, 'end');\n            localDOMHandlers.mouseup.call(this, event);\n            if (+new Date() - (+this.__lastTouchMoment) < TOUCH_CLICK_DELAY) {\n                localDOMHandlers.click.call(this, event);\n            }\n        },\n        pointerdown: function (event) {\n            localDOMHandlers.mousedown.call(this, event);\n        },\n        pointermove: function (event) {\n            if (!isPointerFromTouch(event)) {\n                localDOMHandlers.mousemove.call(this, event);\n            }\n        },\n        pointerup: function (event) {\n            localDOMHandlers.mouseup.call(this, event);\n        },\n        pointerout: function (event) {\n            if (!isPointerFromTouch(event)) {\n                localDOMHandlers.mouseout.call(this, event);\n            }\n        }\n    };\n    each(['click', 'dblclick', 'contextmenu'], function (name) {\n        localDOMHandlers[name] = function (event) {\n            event = normalizeEvent(this.dom, event);\n            this.trigger(name, event);\n        };\n    });\n    var globalDOMHandlers = {\n        pointermove: function (event) {\n            if (!isPointerFromTouch(event)) {\n                globalDOMHandlers.mousemove.call(this, event);\n            }\n        },\n        pointerup: function (event) {\n            globalDOMHandlers.mouseup.call(this, event);\n        },\n        mousemove: function (event) {\n            this.trigger('mousemove', event);\n        },\n        mouseup: function (event) {\n            var pointerCaptureReleasing = this.__pointerCapturing;\n            this.__togglePointerCapture(false);\n            this.trigger('mouseup', event);\n            if (pointerCaptureReleasing) {\n                event.zrEventControl = 'only_globalout';\n                this.trigger('mouseout', event);\n            }\n        }\n    };\n    function mountLocalDOMEventListeners(instance, scope) {\n        var domHandlers = scope.domHandlers;\n        if (env.pointerEventsSupported) {\n            each(localNativeListenerNames.pointer, function (nativeEventName) {\n                mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n                    domHandlers[nativeEventName].call(instance, event);\n                });\n            });\n        }\n        else {\n            if (env.touchEventsSupported) {\n                each(localNativeListenerNames.touch, function (nativeEventName) {\n                    mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n                        domHandlers[nativeEventName].call(instance, event);\n                        setTouchTimer(scope);\n                    });\n                });\n            }\n            each(localNativeListenerNames.mouse, function (nativeEventName) {\n                mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n                    event = getNativeEvent(event);\n                    if (!scope.touching) {\n                        domHandlers[nativeEventName].call(instance, event);\n                    }\n                });\n            });\n        }\n    }\n    function mountGlobalDOMEventListeners(instance, scope) {\n        if (env.pointerEventsSupported) {\n            each(globalNativeListenerNames.pointer, mount);\n        }\n        else if (!env.touchEventsSupported) {\n            each(globalNativeListenerNames.mouse, mount);\n        }\n        function mount(nativeEventName) {\n            function nativeEventListener(event) {\n                event = getNativeEvent(event);\n                if (!isLocalEl(instance, event.target)) {\n                    event = normalizeGlobalEvent(instance, event);\n                    scope.domHandlers[nativeEventName].call(instance, event);\n                }\n            }\n            mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });\n        }\n    }\n    function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\n        scope.mounted[nativeEventName] = listener;\n        scope.listenerOpts[nativeEventName] = opt;\n        addEventListener(scope.domTarget, nativeEventName, listener, opt);\n    }\n    function unmountDOMEventListeners(scope) {\n        var mounted = scope.mounted;\n        for (var nativeEventName in mounted) {\n            if (mounted.hasOwnProperty(nativeEventName)) {\n                removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\n            }\n        }\n        scope.mounted = {};\n    }\n    var DOMHandlerScope = (function () {\n        function DOMHandlerScope(domTarget, domHandlers) {\n            this.mounted = {};\n            this.listenerOpts = {};\n            this.touching = false;\n            this.domTarget = domTarget;\n            this.domHandlers = domHandlers;\n        }\n        return DOMHandlerScope;\n    }());\n    var HandlerDomProxy = (function (_super) {\n        __extends(HandlerDomProxy, _super);\n        function HandlerDomProxy(dom, painterRoot) {\n            var _this = _super.call(this) || this;\n            _this.__pointerCapturing = false;\n            _this.dom = dom;\n            _this.painterRoot = painterRoot;\n            _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n            if (globalEventSupported) {\n                _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\n            }\n            mountLocalDOMEventListeners(_this, _this._localHandlerScope);\n            return _this;\n        }\n        HandlerDomProxy.prototype.dispose = function () {\n            unmountDOMEventListeners(this._localHandlerScope);\n            if (globalEventSupported) {\n                unmountDOMEventListeners(this._globalHandlerScope);\n            }\n        };\n        HandlerDomProxy.prototype.setCursor = function (cursorStyle) {\n            this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n        };\n        HandlerDomProxy.prototype.__togglePointerCapture = function (isPointerCapturing) {\n            this.__mayPointerCapture = null;\n            if (globalEventSupported\n                && ((+this.__pointerCapturing) ^ (+isPointerCapturing))) {\n                this.__pointerCapturing = isPointerCapturing;\n                var globalHandlerScope = this._globalHandlerScope;\n                isPointerCapturing\n                    ? mountGlobalDOMEventListeners(this, globalHandlerScope)\n                    : unmountDOMEventListeners(globalHandlerScope);\n            }\n        };\n        return HandlerDomProxy;\n    }(Eventful));\n\n    var Group = (function (_super) {\n        __extends(Group, _super);\n        function Group(opts) {\n            var _this = _super.call(this) || this;\n            _this.isGroup = true;\n            _this._children = [];\n            _this.attr(opts);\n            return _this;\n        }\n        Group.prototype.childrenRef = function () {\n            return this._children;\n        };\n        Group.prototype.children = function () {\n            return this._children.slice();\n        };\n        Group.prototype.childAt = function (idx) {\n            return this._children[idx];\n        };\n        Group.prototype.childOfName = function (name) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                if (children[i].name === name) {\n                    return children[i];\n                }\n            }\n        };\n        Group.prototype.childCount = function () {\n            return this._children.length;\n        };\n        Group.prototype.add = function (child) {\n            if (child) {\n                if (child !== this && child.parent !== this) {\n                    this._children.push(child);\n                    this._doAdd(child);\n                }\n                if (child.__hostTarget) {\n                    throw 'This elemenet has been used as an attachment';\n                }\n            }\n            return this;\n        };\n        Group.prototype.addBefore = function (child, nextSibling) {\n            if (child && child !== this && child.parent !== this\n                && nextSibling && nextSibling.parent === this) {\n                var children = this._children;\n                var idx = children.indexOf(nextSibling);\n                if (idx >= 0) {\n                    children.splice(idx, 0, child);\n                    this._doAdd(child);\n                }\n            }\n            return this;\n        };\n        Group.prototype.replaceAt = function (child, index) {\n            var children = this._children;\n            var old = children[index];\n            if (child && child !== this && child.parent !== this && child !== old) {\n                children[index] = child;\n                old.parent = null;\n                var zr = this.__zr;\n                if (zr) {\n                    old.removeSelfFromZr(zr);\n                }\n                this._doAdd(child);\n            }\n            return this;\n        };\n        Group.prototype._doAdd = function (child) {\n            if (child.parent) {\n                child.parent.remove(child);\n            }\n            child.parent = this;\n            var zr = this.__zr;\n            if (zr && zr !== child.__zr) {\n                child.addSelfToZr(zr);\n            }\n            zr && zr.refresh();\n        };\n        Group.prototype.remove = function (child) {\n            var zr = this.__zr;\n            var children = this._children;\n            var idx = indexOf(children, child);\n            if (idx < 0) {\n                return this;\n            }\n            children.splice(idx, 1);\n            child.parent = null;\n            if (zr) {\n                child.removeSelfFromZr(zr);\n            }\n            zr && zr.refresh();\n            return this;\n        };\n        Group.prototype.removeAll = function () {\n            var children = this._children;\n            var zr = this.__zr;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (zr) {\n                    child.removeSelfFromZr(zr);\n                }\n                child.parent = null;\n            }\n            children.length = 0;\n            return this;\n        };\n        Group.prototype.eachChild = function (cb, context) {\n            var children = this._children;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                cb.call(context, child, i);\n            }\n            return this;\n        };\n        Group.prototype.traverse = function (cb, context) {\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                var stopped = cb.call(context, child);\n                if (child.isGroup && !stopped) {\n                    child.traverse(cb, context);\n                }\n            }\n            return this;\n        };\n        Group.prototype.addSelfToZr = function (zr) {\n            _super.prototype.addSelfToZr.call(this, zr);\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                child.addSelfToZr(zr);\n            }\n        };\n        Group.prototype.removeSelfFromZr = function (zr) {\n            _super.prototype.removeSelfFromZr.call(this, zr);\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                child.removeSelfFromZr(zr);\n            }\n        };\n        Group.prototype.getBoundingRect = function (includeChildren) {\n            var tmpRect = new BoundingRect(0, 0, 0, 0);\n            var children = includeChildren || this._children;\n            var tmpMat = [];\n            var rect = null;\n            for (var i = 0; i < children.length; i++) {\n                var child = children[i];\n                if (child.ignore || child.invisible) {\n                    continue;\n                }\n                var childRect = child.getBoundingRect();\n                var transform = child.getLocalTransform(tmpMat);\n                if (transform) {\n                    BoundingRect.applyTransform(tmpRect, childRect, transform);\n                    rect = rect || tmpRect.clone();\n                    rect.union(tmpRect);\n                }\n                else {\n                    rect = rect || childRect.clone();\n                    rect.union(childRect);\n                }\n            }\n            return rect || tmpRect;\n        };\n        return Group;\n    }(Element));\n    Group.prototype.type = 'group';\n\n    /*!\n    * ZRender, a high performance 2d drawing library.\n    *\n    * Copyright (c) 2013, Baidu Inc.\n    * All rights reserved.\n    *\n    * LICENSE\n    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n    */\n    var useVML = !env.canvasSupported;\n    var painterCtors = {};\n    var instances = {};\n    function delInstance(id) {\n        delete instances[id];\n    }\n    function isDarkMode(backgroundColor) {\n        if (!backgroundColor) {\n            return false;\n        }\n        if (typeof backgroundColor === 'string') {\n            return lum(backgroundColor, 1) < DARK_MODE_THRESHOLD;\n        }\n        else if (backgroundColor.colorStops) {\n            var colorStops = backgroundColor.colorStops;\n            var totalLum = 0;\n            var len = colorStops.length;\n            for (var i = 0; i < len; i++) {\n                totalLum += lum(colorStops[i].color, 1);\n            }\n            totalLum /= len;\n            return totalLum < DARK_MODE_THRESHOLD;\n        }\n        return false;\n    }\n    var ZRender = (function () {\n        function ZRender(id, dom, opts) {\n            var _this = this;\n            this._sleepAfterStill = 10;\n            this._stillFrameAccum = 0;\n            this._needsRefresh = true;\n            this._needsRefreshHover = true;\n            this._darkMode = false;\n            opts = opts || {};\n            this.dom = dom;\n            this.id = id;\n            var storage = new Storage();\n            var rendererType = opts.renderer || 'canvas';\n            if (useVML) {\n                throw new Error('IE8 support has been dropped since 5.0');\n            }\n            if (!painterCtors[rendererType]) {\n                rendererType = keys(painterCtors)[0];\n            }\n            if (!painterCtors[rendererType]) {\n                throw new Error(\"Renderer '\" + rendererType + \"' is not imported. Please import it first.\");\n            }\n            opts.useDirtyRect = opts.useDirtyRect == null\n                ? false\n                : opts.useDirtyRect;\n            var painter = new painterCtors[rendererType](dom, storage, opts, id);\n            this.storage = storage;\n            this.painter = painter;\n            var handerProxy = (!env.node && !env.worker)\n                ? new HandlerDomProxy(painter.getViewportRoot(), painter.root)\n                : null;\n            this.handler = new Handler(storage, painter, handerProxy, painter.root);\n            this.animation = new Animation({\n                stage: {\n                    update: function () { return _this._flush(true); }\n                }\n            });\n            this.animation.start();\n        }\n        ZRender.prototype.add = function (el) {\n            if (!el) {\n                return;\n            }\n            this.storage.addRoot(el);\n            el.addSelfToZr(this);\n            this.refresh();\n        };\n        ZRender.prototype.remove = function (el) {\n            if (!el) {\n                return;\n            }\n            this.storage.delRoot(el);\n            el.removeSelfFromZr(this);\n            this.refresh();\n        };\n        ZRender.prototype.configLayer = function (zLevel, config) {\n            if (this.painter.configLayer) {\n                this.painter.configLayer(zLevel, config);\n            }\n            this.refresh();\n        };\n        ZRender.prototype.setBackgroundColor = function (backgroundColor) {\n            if (this.painter.setBackgroundColor) {\n                this.painter.setBackgroundColor(backgroundColor);\n            }\n            this.refresh();\n            this._backgroundColor = backgroundColor;\n            this._darkMode = isDarkMode(backgroundColor);\n        };\n        ZRender.prototype.getBackgroundColor = function () {\n            return this._backgroundColor;\n        };\n        ZRender.prototype.setDarkMode = function (darkMode) {\n            this._darkMode = darkMode;\n        };\n        ZRender.prototype.isDarkMode = function () {\n            return this._darkMode;\n        };\n        ZRender.prototype.refreshImmediately = function (fromInside) {\n            if (!fromInside) {\n                this.animation.update(true);\n            }\n            this._needsRefresh = false;\n            this.painter.refresh();\n            this._needsRefresh = false;\n        };\n        ZRender.prototype.refresh = function () {\n            this._needsRefresh = true;\n            this.animation.start();\n        };\n        ZRender.prototype.flush = function () {\n            this._flush(false);\n        };\n        ZRender.prototype._flush = function (fromInside) {\n            var triggerRendered;\n            var start = new Date().getTime();\n            if (this._needsRefresh) {\n                triggerRendered = true;\n                this.refreshImmediately(fromInside);\n            }\n            if (this._needsRefreshHover) {\n                triggerRendered = true;\n                this.refreshHoverImmediately();\n            }\n            var end = new Date().getTime();\n            if (triggerRendered) {\n                this._stillFrameAccum = 0;\n                this.trigger('rendered', {\n                    elapsedTime: end - start\n                });\n            }\n            else if (this._sleepAfterStill > 0) {\n                this._stillFrameAccum++;\n                if (this._stillFrameAccum > this._sleepAfterStill) {\n                    this.animation.stop();\n                }\n            }\n        };\n        ZRender.prototype.setSleepAfterStill = function (stillFramesCount) {\n            this._sleepAfterStill = stillFramesCount;\n        };\n        ZRender.prototype.wakeUp = function () {\n            this.animation.start();\n            this._stillFrameAccum = 0;\n        };\n        ZRender.prototype.addHover = function (el) {\n        };\n        ZRender.prototype.removeHover = function (el) {\n        };\n        ZRender.prototype.clearHover = function () {\n        };\n        ZRender.prototype.refreshHover = function () {\n            this._needsRefreshHover = true;\n        };\n        ZRender.prototype.refreshHoverImmediately = function () {\n            this._needsRefreshHover = false;\n            if (this.painter.refreshHover && this.painter.getType() === 'canvas') {\n                this.painter.refreshHover();\n            }\n        };\n        ZRender.prototype.resize = function (opts) {\n            opts = opts || {};\n            this.painter.resize(opts.width, opts.height);\n            this.handler.resize();\n        };\n        ZRender.prototype.clearAnimation = function () {\n            this.animation.clear();\n        };\n        ZRender.prototype.getWidth = function () {\n            return this.painter.getWidth();\n        };\n        ZRender.prototype.getHeight = function () {\n            return this.painter.getHeight();\n        };\n        ZRender.prototype.pathToImage = function (e, dpr) {\n            if (this.painter.pathToImage) {\n                return this.painter.pathToImage(e, dpr);\n            }\n        };\n        ZRender.prototype.setCursorStyle = function (cursorStyle) {\n            this.handler.setCursorStyle(cursorStyle);\n        };\n        ZRender.prototype.findHover = function (x, y) {\n            return this.handler.findHover(x, y);\n        };\n        ZRender.prototype.on = function (eventName, eventHandler, context) {\n            this.handler.on(eventName, eventHandler, context);\n            return this;\n        };\n        ZRender.prototype.off = function (eventName, eventHandler) {\n            this.handler.off(eventName, eventHandler);\n        };\n        ZRender.prototype.trigger = function (eventName, event) {\n            this.handler.trigger(eventName, event);\n        };\n        ZRender.prototype.clear = function () {\n            var roots = this.storage.getRoots();\n            for (var i = 0; i < roots.length; i++) {\n                if (roots[i] instanceof Group) {\n                    roots[i].removeSelfFromZr(this);\n                }\n            }\n            this.storage.delAllRoots();\n            this.painter.clear();\n        };\n        ZRender.prototype.dispose = function () {\n            this.animation.stop();\n            this.clear();\n            this.storage.dispose();\n            this.painter.dispose();\n            this.handler.dispose();\n            this.animation =\n                this.storage =\n                    this.painter =\n                        this.handler = null;\n            delInstance(this.id);\n        };\n        return ZRender;\n    }());\n    function init(dom, opts) {\n        var zr = new ZRender(guid(), dom, opts);\n        instances[zr.id] = zr;\n        return zr;\n    }\n    function dispose(zr) {\n        zr.dispose();\n    }\n    function disposeAll() {\n        for (var key in instances) {\n            if (instances.hasOwnProperty(key)) {\n                instances[key].dispose();\n            }\n        }\n        instances = {};\n    }\n    function getInstance(id) {\n        return instances[id];\n    }\n    function registerPainter(name, Ctor) {\n        painterCtors[name] = Ctor;\n    }\n    var version = '5.0.3';\n\n    var zrender = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        init: init,\n        dispose: dispose,\n        disposeAll: disposeAll,\n        getInstance: getInstance,\n        registerPainter: registerPainter,\n        version: version\n    });\n\n    var RADIAN_EPSILON = 1e-4;\n\n    function _trim(str) {\n      return str.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function linearMap(val, domain, range, clamp) {\n      var subDomain = domain[1] - domain[0];\n      var subRange = range[1] - range[0];\n\n      if (subDomain === 0) {\n        return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;\n      }\n\n      if (clamp) {\n        if (subDomain > 0) {\n          if (val <= domain[0]) {\n            return range[0];\n          } else if (val >= domain[1]) {\n            return range[1];\n          }\n        } else {\n          if (val >= domain[0]) {\n            return range[0];\n          } else if (val <= domain[1]) {\n            return range[1];\n          }\n        }\n      } else {\n        if (val === domain[0]) {\n          return range[0];\n        }\n\n        if (val === domain[1]) {\n          return range[1];\n        }\n      }\n\n      return (val - domain[0]) / subDomain * subRange + range[0];\n    }\n    function parsePercent$1(percent, all) {\n      switch (percent) {\n        case 'center':\n        case 'middle':\n          percent = '50%';\n          break;\n\n        case 'left':\n        case 'top':\n          percent = '0%';\n          break;\n\n        case 'right':\n        case 'bottom':\n          percent = '100%';\n          break;\n      }\n\n      if (typeof percent === 'string') {\n        if (_trim(percent).match(/%$/)) {\n          return parseFloat(percent) / 100 * all;\n        }\n\n        return parseFloat(percent);\n      }\n\n      return percent == null ? NaN : +percent;\n    }\n    function round(x, precision, returnStr) {\n      if (precision == null) {\n        precision = 10;\n      }\n\n      precision = Math.min(Math.max(0, precision), 20);\n      x = (+x).toFixed(precision);\n      return returnStr ? x : +x;\n    }\n    function asc(arr) {\n      arr.sort(function (a, b) {\n        return a - b;\n      });\n      return arr;\n    }\n    function getPrecision(val) {\n      val = +val;\n\n      if (isNaN(val)) {\n        return 0;\n      }\n\n      var e = 1;\n      var count = 0;\n\n      while (Math.round(val * e) / e !== val) {\n        e *= 10;\n        count++;\n      }\n\n      return count;\n    }\n    function getPrecisionSafe(val) {\n      var str = val.toString();\n      var eIndex = str.indexOf('e');\n\n      if (eIndex > 0) {\n        var precision = +str.slice(eIndex + 1);\n        return precision < 0 ? -precision : 0;\n      } else {\n        var dotIndex = str.indexOf('.');\n        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;\n      }\n    }\n    function getPixelPrecision(dataExtent, pixelExtent) {\n      var log = Math.log;\n      var LN10 = Math.LN10;\n      var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);\n      var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);\n      var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);\n      return !isFinite(precision) ? 20 : precision;\n    }\n    function getPercentWithPrecision(valueList, idx, precision) {\n      if (!valueList[idx]) {\n        return 0;\n      }\n\n      var sum = reduce(valueList, function (acc, val) {\n        return acc + (isNaN(val) ? 0 : val);\n      }, 0);\n\n      if (sum === 0) {\n        return 0;\n      }\n\n      var digits = Math.pow(10, precision);\n      var votesPerQuota = map(valueList, function (val) {\n        return (isNaN(val) ? 0 : val) / sum * digits * 100;\n      });\n      var targetSeats = digits * 100;\n      var seats = map(votesPerQuota, function (votes) {\n        return Math.floor(votes);\n      });\n      var currentSum = reduce(seats, function (acc, val) {\n        return acc + val;\n      }, 0);\n      var remainder = map(votesPerQuota, function (votes, idx) {\n        return votes - seats[idx];\n      });\n\n      while (currentSum < targetSeats) {\n        var max = Number.NEGATIVE_INFINITY;\n        var maxId = null;\n\n        for (var i = 0, len = remainder.length; i < len; ++i) {\n          if (remainder[i] > max) {\n            max = remainder[i];\n            maxId = i;\n          }\n        }\n\n        ++seats[maxId];\n        remainder[maxId] = 0;\n        ++currentSum;\n      }\n\n      return seats[idx] / digits;\n    }\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    function remRadian(radian) {\n      var pi2 = Math.PI * 2;\n      return (radian % pi2 + pi2) % pi2;\n    }\n    function isRadianAroundZero(val) {\n      return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;\n    }\n    var TIME_REG = /^(?:(\\d{4})(?:[-\\/](\\d{1,2})(?:[-\\/](\\d{1,2})(?:[T ](\\d{1,2})(?::(\\d{1,2})(?::(\\d{1,2})(?:[.,](\\d+))?)?)?(Z|[\\+\\-]\\d\\d:?\\d\\d)?)?)?)?)?$/;\n    function parseDate(value) {\n      if (value instanceof Date) {\n        return value;\n      } else if (typeof value === 'string') {\n        var match = TIME_REG.exec(value);\n\n        if (!match) {\n          return new Date(NaN);\n        }\n\n        if (!match[8]) {\n          return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);\n        } else {\n          var hour = +match[4] || 0;\n\n          if (match[8].toUpperCase() !== 'Z') {\n            hour -= +match[8].slice(0, 3);\n          }\n\n          return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));\n        }\n      } else if (value == null) {\n        return new Date(NaN);\n      }\n\n      return new Date(Math.round(value));\n    }\n    function quantity(val) {\n      return Math.pow(10, quantityExponent(val));\n    }\n    function quantityExponent(val) {\n      if (val === 0) {\n        return 0;\n      }\n\n      var exp = Math.floor(Math.log(val) / Math.LN10);\n\n      if (val / Math.pow(10, exp) >= 10) {\n        exp++;\n      }\n\n      return exp;\n    }\n    function nice(val, round) {\n      var exponent = quantityExponent(val);\n      var exp10 = Math.pow(10, exponent);\n      var f = val / exp10;\n      var nf;\n\n      if (round) {\n        if (f < 1.5) {\n          nf = 1;\n        } else if (f < 2.5) {\n          nf = 2;\n        } else if (f < 4) {\n          nf = 3;\n        } else if (f < 7) {\n          nf = 5;\n        } else {\n          nf = 10;\n        }\n      } else {\n        if (f < 1) {\n          nf = 1;\n        } else if (f < 2) {\n          nf = 2;\n        } else if (f < 3) {\n          nf = 3;\n        } else if (f < 5) {\n          nf = 5;\n        } else {\n          nf = 10;\n        }\n      }\n\n      val = nf * exp10;\n      return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;\n    }\n    function quantile(ascArr, p) {\n      var H = (ascArr.length - 1) * p + 1;\n      var h = Math.floor(H);\n      var v = +ascArr[h - 1];\n      var e = H - h;\n      return e ? v + e * (ascArr[h] - v) : v;\n    }\n    function reformIntervals(list) {\n      list.sort(function (a, b) {\n        return littleThan(a, b, 0) ? -1 : 1;\n      });\n      var curr = -Infinity;\n      var currClose = 1;\n\n      for (var i = 0; i < list.length;) {\n        var interval = list[i].interval;\n        var close_1 = list[i].close;\n\n        for (var lg = 0; lg < 2; lg++) {\n          if (interval[lg] <= curr) {\n            interval[lg] = curr;\n            close_1[lg] = !lg ? 1 - currClose : 1;\n          }\n\n          curr = interval[lg];\n          currClose = close_1[lg];\n        }\n\n        if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {\n          list.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n\n      return list;\n\n      function littleThan(a, b, lg) {\n        return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));\n      }\n    }\n    function numericToNumber(val) {\n      var valFloat = parseFloat(val);\n      return valFloat == val && (valFloat !== 0 || typeof val !== 'string' || val.indexOf('x') <= 0) ? valFloat : NaN;\n    }\n    function isNumeric(val) {\n      return !isNaN(numericToNumber(val));\n    }\n    function getRandomIdBase() {\n      return Math.round(Math.random() * 9);\n    }\n    function getGreatestCommonDividor(a, b) {\n      if (b === 0) {\n        return a;\n      }\n\n      return getGreatestCommonDividor(b, a % b);\n    }\n    function getLeastCommonMultiple(a, b) {\n      if (a == null) {\n        return b;\n      }\n\n      if (b == null) {\n        return a;\n      }\n\n      return a * b / getGreatestCommonDividor(a, b);\n    }\n\n    var ECHARTS_PREFIX = '[ECharts] ';\n    var storedLogs = {};\n    var hasConsole = typeof console !== 'undefined' && console.warn && console.log;\n    function warn(str) {\n      if (hasConsole) {\n        console.warn(ECHARTS_PREFIX + str);\n      }\n    }\n    function error(str) {\n      if (hasConsole) {\n        console.error(ECHARTS_PREFIX + str);\n      }\n    }\n    function deprecateLog(str) {\n      if (\"development\" !== 'production') {\n        if (storedLogs[str]) {\n          return;\n        }\n\n        if (hasConsole) {\n          storedLogs[str] = true;\n          console.warn(ECHARTS_PREFIX + 'DEPRECATED: ' + str);\n        }\n      }\n    }\n    function deprecateReplaceLog(oldOpt, newOpt, scope) {\n      if (\"development\" !== 'production') {\n        deprecateLog((scope ? \"[\" + scope + \"]\" : '') + (oldOpt + \" is deprecated, use \" + newOpt + \" instead.\"));\n      }\n    }\n    function consoleLog() {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (\"development\" !== 'production') {\n        if (typeof console !== 'undefined' && console.log) {\n          console.log.apply(console, args);\n        }\n      }\n    }\n    function makePrintable() {\n      var hintInfo = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        hintInfo[_i] = arguments[_i];\n      }\n\n      var msg = '';\n\n      if (\"development\" !== 'production') {\n        var makePrintableStringIfPossible_1 = function (val) {\n          return val === void 0 ? 'undefined' : val === Infinity ? 'Infinity' : val === -Infinity ? '-Infinity' : eqNaN(val) ? 'NaN' : val instanceof Date ? 'Date(' + val.toISOString() + ')' : isFunction(val) ? 'function () { ... }' : isRegExp(val) ? val + '' : null;\n        };\n\n        msg = map(hintInfo, function (arg) {\n          if (isString(arg)) {\n            return arg;\n          } else {\n            var printableStr = makePrintableStringIfPossible_1(arg);\n\n            if (printableStr != null) {\n              return printableStr;\n            } else if (typeof JSON !== 'undefined' && JSON.stringify) {\n              try {\n                return JSON.stringify(arg, function (n, val) {\n                  var printableStr = makePrintableStringIfPossible_1(val);\n                  return printableStr == null ? val : printableStr;\n                });\n              } catch (err) {\n                return '?';\n              }\n            } else {\n              return '?';\n            }\n          }\n        }).join(' ');\n      }\n\n      return msg;\n    }\n    function throwError(msg) {\n      throw new Error(msg);\n    }\n\n    var DUMMY_COMPONENT_NAME_PREFIX = 'series\\0';\n    var INTERNAL_COMPONENT_ID_PREFIX = '\\0_ec_\\0';\n    function normalizeToArray(value) {\n      return value instanceof Array ? value : value == null ? [] : [value];\n    }\n    function defaultEmphasis(opt, key, subOpts) {\n      if (opt) {\n        opt[key] = opt[key] || {};\n        opt.emphasis = opt.emphasis || {};\n        opt.emphasis[key] = opt.emphasis[key] || {};\n\n        for (var i = 0, len = subOpts.length; i < len; i++) {\n          var subOptName = subOpts[i];\n\n          if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {\n            opt.emphasis[key][subOptName] = opt[key][subOptName];\n          }\n        }\n      }\n    }\n    var TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'];\n    function getDataItemValue(dataItem) {\n      return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;\n    }\n    function isDataItemOption(dataItem) {\n      return isObject(dataItem) && !(dataItem instanceof Array);\n    }\n    function mappingToExists(existings, newCmptOptions, mode) {\n      var isNormalMergeMode = mode === 'normalMerge';\n      var isReplaceMergeMode = mode === 'replaceMerge';\n      var isReplaceAllMode = mode === 'replaceAll';\n      existings = existings || [];\n      newCmptOptions = (newCmptOptions || []).slice();\n      var existingIdIdxMap = createHashMap();\n      each(newCmptOptions, function (cmptOption, index) {\n        if (!isObject(cmptOption)) {\n          newCmptOptions[index] = null;\n          return;\n        }\n\n        if (\"development\" !== 'production') {\n          if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {\n            warnInvalidateIdOrName(cmptOption.id);\n          }\n\n          if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {\n            warnInvalidateIdOrName(cmptOption.name);\n          }\n        }\n      });\n      var result = prepareResult(existings, existingIdIdxMap, mode);\n\n      if (isNormalMergeMode || isReplaceMergeMode) {\n        mappingById(result, existings, existingIdIdxMap, newCmptOptions);\n      }\n\n      if (isNormalMergeMode) {\n        mappingByName(result, newCmptOptions);\n      }\n\n      if (isNormalMergeMode || isReplaceMergeMode) {\n        mappingByIndex(result, newCmptOptions, isReplaceMergeMode);\n      } else if (isReplaceAllMode) {\n        mappingInReplaceAllMode(result, newCmptOptions);\n      }\n\n      makeIdAndName(result);\n      return result;\n    }\n\n    function prepareResult(existings, existingIdIdxMap, mode) {\n      var result = [];\n\n      if (mode === 'replaceAll') {\n        return result;\n      }\n\n      for (var index = 0; index < existings.length; index++) {\n        var existing = existings[index];\n\n        if (existing && existing.id != null) {\n          existingIdIdxMap.set(existing.id, index);\n        }\n\n        result.push({\n          existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,\n          newOption: null,\n          keyInfo: null,\n          brandNew: null\n        });\n      }\n\n      return result;\n    }\n\n    function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {\n      each(newCmptOptions, function (cmptOption, index) {\n        if (!cmptOption || cmptOption.id == null) {\n          return;\n        }\n\n        var optionId = makeComparableKey(cmptOption.id);\n        var existingIdx = existingIdIdxMap.get(optionId);\n\n        if (existingIdx != null) {\n          var resultItem = result[existingIdx];\n          assert(!resultItem.newOption, 'Duplicated option on id \"' + optionId + '\".');\n          resultItem.newOption = cmptOption;\n          resultItem.existing = existings[existingIdx];\n          newCmptOptions[index] = null;\n        }\n      });\n    }\n\n    function mappingByName(result, newCmptOptions) {\n      each(newCmptOptions, function (cmptOption, index) {\n        if (!cmptOption || cmptOption.name == null) {\n          return;\n        }\n\n        for (var i = 0; i < result.length; i++) {\n          var existing = result[i].existing;\n\n          if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {\n            result[i].newOption = cmptOption;\n            newCmptOptions[index] = null;\n            return;\n          }\n        }\n      });\n    }\n\n    function mappingByIndex(result, newCmptOptions, brandNew) {\n      each(newCmptOptions, function (cmptOption) {\n        if (!cmptOption) {\n          return;\n        }\n\n        var resultItem;\n        var nextIdx = 0;\n\n        while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {\n          nextIdx++;\n        }\n\n        if (resultItem) {\n          resultItem.newOption = cmptOption;\n          resultItem.brandNew = brandNew;\n        } else {\n          result.push({\n            newOption: cmptOption,\n            brandNew: brandNew,\n            existing: null,\n            keyInfo: null\n          });\n        }\n\n        nextIdx++;\n      });\n    }\n\n    function mappingInReplaceAllMode(result, newCmptOptions) {\n      each(newCmptOptions, function (cmptOption) {\n        result.push({\n          newOption: cmptOption,\n          brandNew: true,\n          existing: null,\n          keyInfo: null\n        });\n      });\n    }\n\n    function makeIdAndName(mapResult) {\n      var idMap = createHashMap();\n      each(mapResult, function (item) {\n        var existing = item.existing;\n        existing && idMap.set(existing.id, item);\n      });\n      each(mapResult, function (item) {\n        var opt = item.newOption;\n        assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));\n        opt && opt.id != null && idMap.set(opt.id, item);\n        !item.keyInfo && (item.keyInfo = {});\n      });\n      each(mapResult, function (item, index) {\n        var existing = item.existing;\n        var opt = item.newOption;\n        var keyInfo = item.keyInfo;\n\n        if (!isObject(opt)) {\n          return;\n        }\n\n        keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;\n\n        if (existing) {\n          keyInfo.id = makeComparableKey(existing.id);\n        } else if (opt.id != null) {\n          keyInfo.id = makeComparableKey(opt.id);\n        } else {\n          var idNum = 0;\n\n          do {\n            keyInfo.id = '\\0' + keyInfo.name + '\\0' + idNum++;\n          } while (idMap.get(keyInfo.id));\n        }\n\n        idMap.set(keyInfo.id, item);\n      });\n    }\n\n    function keyExistAndEqual(attr, obj1, obj2) {\n      var key1 = convertOptionIdName(obj1[attr], null);\n      var key2 = convertOptionIdName(obj2[attr], null);\n      return key1 != null && key2 != null && key1 === key2;\n    }\n\n    function makeComparableKey(val) {\n      if (\"development\" !== 'production') {\n        if (val == null) {\n          throw new Error();\n        }\n      }\n\n      return convertOptionIdName(val, '');\n    }\n\n    function convertOptionIdName(idOrName, defaultValue) {\n      if (idOrName == null) {\n        return defaultValue;\n      }\n\n      var type = typeof idOrName;\n      return type === 'string' ? idOrName : type === 'number' || isStringSafe(idOrName) ? idOrName + '' : defaultValue;\n    }\n\n    function warnInvalidateIdOrName(idOrName) {\n      if (\"development\" !== 'production') {\n        warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');\n      }\n    }\n\n    function isValidIdOrName(idOrName) {\n      return isStringSafe(idOrName) || isNumeric(idOrName);\n    }\n\n    function isNameSpecified(componentModel) {\n      var name = componentModel.name;\n      return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));\n    }\n    function isComponentIdInternal(cmptOption) {\n      return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;\n    }\n    function makeInternalComponentId(idSuffix) {\n      return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;\n    }\n    function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {\n      each(mappingResult, function (item) {\n        var newOption = item.newOption;\n\n        if (isObject(newOption)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);\n        }\n      });\n    }\n\n    function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {\n      var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);\n      return subType;\n    }\n\n    function compressBatches(batchA, batchB) {\n      var mapA = {};\n      var mapB = {};\n      makeMap(batchA || [], mapA);\n      makeMap(batchB || [], mapB, mapA);\n      return [mapToArray(mapA), mapToArray(mapB)];\n\n      function makeMap(sourceBatch, map, otherMap) {\n        for (var i = 0, len = sourceBatch.length; i < len; i++) {\n          var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);\n\n          if (seriesId == null) {\n            return;\n          }\n\n          var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);\n          var otherDataIndices = otherMap && otherMap[seriesId];\n\n          for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {\n            var dataIndex = dataIndices[j];\n\n            if (otherDataIndices && otherDataIndices[dataIndex]) {\n              otherDataIndices[dataIndex] = null;\n            } else {\n              (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;\n            }\n          }\n        }\n      }\n\n      function mapToArray(map, isData) {\n        var result = [];\n\n        for (var i in map) {\n          if (map.hasOwnProperty(i) && map[i] != null) {\n            if (isData) {\n              result.push(+i);\n            } else {\n              var dataIndices = mapToArray(map[i], true);\n              dataIndices.length && result.push({\n                seriesId: i,\n                dataIndex: dataIndices\n              });\n            }\n          }\n        }\n\n        return result;\n      }\n    }\n    function queryDataIndex(data, payload) {\n      if (payload.dataIndexInside != null) {\n        return payload.dataIndexInside;\n      } else if (payload.dataIndex != null) {\n        return isArray(payload.dataIndex) ? map(payload.dataIndex, function (value) {\n          return data.indexOfRawIndex(value);\n        }) : data.indexOfRawIndex(payload.dataIndex);\n      } else if (payload.name != null) {\n        return isArray(payload.name) ? map(payload.name, function (value) {\n          return data.indexOfName(value);\n        }) : data.indexOfName(payload.name);\n      }\n    }\n    function makeInner() {\n      var key = '__ec_inner_' + innerUniqueIndex++;\n      return function (hostObj) {\n        return hostObj[key] || (hostObj[key] = {});\n      };\n    }\n    var innerUniqueIndex = getRandomIdBase();\n    function parseFinder(ecModel, finderInput, opt) {\n      var finder;\n\n      if (isString(finderInput)) {\n        var obj = {};\n        obj[finderInput + 'Index'] = 0;\n        finder = obj;\n      } else {\n        finder = finderInput;\n      }\n\n      var queryOptionMap = createHashMap();\n      var result = {};\n      var mainTypeSpecified = false;\n      each(finder, function (value, key) {\n        if (key === 'dataIndex' || key === 'dataIndexInside') {\n          result[key] = value;\n          return;\n        }\n\n        var parsedKey = key.match(/^(\\w+)(Index|Id|Name)$/) || [];\n        var mainType = parsedKey[1];\n        var queryType = (parsedKey[2] || '').toLowerCase();\n\n        if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {\n          return;\n        }\n\n        mainTypeSpecified = mainTypeSpecified || !!mainType;\n        var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});\n        queryOption[queryType] = value;\n      });\n      var defaultMainType = opt ? opt.defaultMainType : null;\n\n      if (!mainTypeSpecified && defaultMainType) {\n        queryOptionMap.set(defaultMainType, {});\n      }\n\n      queryOptionMap.each(function (queryOption, mainType) {\n        var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {\n          useDefault: defaultMainType === mainType,\n          enableAll: opt && opt.enableAll != null ? opt.enableAll : true,\n          enableNone: opt && opt.enableNone != null ? opt.enableNone : true\n        });\n        result[mainType + 'Models'] = queryResult.models;\n        result[mainType + 'Model'] = queryResult.models[0];\n      });\n      return result;\n    }\n    var SINGLE_REFERRING = {\n      useDefault: true,\n      enableAll: false,\n      enableNone: false\n    };\n    var MULTIPLE_REFERRING = {\n      useDefault: false,\n      enableAll: true,\n      enableNone: true\n    };\n    function queryReferringComponents(ecModel, mainType, userOption, opt) {\n      opt = opt || SINGLE_REFERRING;\n      var indexOption = userOption.index;\n      var idOption = userOption.id;\n      var nameOption = userOption.name;\n      var result = {\n        models: null,\n        specified: indexOption != null || idOption != null || nameOption != null\n      };\n\n      if (!result.specified) {\n        var firstCmpt = void 0;\n        result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];\n        return result;\n      }\n\n      if (indexOption === 'none' || indexOption === false) {\n        assert(opt.enableNone, '`\"none\"` or `false` is not a valid value on index option.');\n        result.models = [];\n        return result;\n      }\n\n      if (indexOption === 'all') {\n        assert(opt.enableAll, '`\"all\"` is not a valid value on index option.');\n        indexOption = idOption = nameOption = null;\n      }\n\n      result.models = ecModel.queryComponents({\n        mainType: mainType,\n        index: indexOption,\n        id: idOption,\n        name: nameOption\n      });\n      return result;\n    }\n    function setAttribute(dom, key, value) {\n      dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;\n    }\n    function getAttribute(dom, key) {\n      return dom.getAttribute ? dom.getAttribute(key) : dom[key];\n    }\n    function getTooltipRenderMode(renderModeOption) {\n      if (renderModeOption === 'auto') {\n        return env.domSupported ? 'html' : 'richText';\n      } else {\n        return renderModeOption || 'html';\n      }\n    }\n    function groupData(array, getKey) {\n      var buckets = createHashMap();\n      var keys = [];\n      each(array, function (item) {\n        var key = getKey(item);\n        (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);\n      });\n      return {\n        keys: keys,\n        buckets: buckets\n      };\n    }\n    function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {\n      var isAutoPrecision = precision == null || precision === 'auto';\n\n      if (targetValue == null) {\n        return targetValue;\n      }\n\n      if (typeof targetValue === 'number') {\n        var value = interpolateNumber(sourceValue || 0, targetValue, percent);\n        return round(value, isAutoPrecision ? Math.max(getPrecisionSafe(sourceValue || 0), getPrecisionSafe(targetValue)) : precision);\n      } else if (typeof targetValue === 'string') {\n        return percent < 1 ? sourceValue : targetValue;\n      } else {\n        var interpolated = [];\n        var leftArr = sourceValue;\n        var rightArr = targetValue;\n        var length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);\n\n        for (var i = 0; i < length_1; ++i) {\n          var info = data.getDimensionInfo(i);\n\n          if (info.type === 'ordinal') {\n            interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];\n          } else {\n            var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;\n            var rightVal = rightArr[i];\n            var value = interpolateNumber(leftVal, rightVal, percent);\n            interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecisionSafe(leftVal), getPrecisionSafe(rightVal)) : precision);\n          }\n        }\n\n        return interpolated;\n      }\n    }\n\n    var TYPE_DELIMITER = '.';\n    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';\n    var IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___';\n    function parseClassType(componentType) {\n      var ret = {\n        main: '',\n        sub: ''\n      };\n\n      if (componentType) {\n        var typeArr = componentType.split(TYPE_DELIMITER);\n        ret.main = typeArr[0] || '';\n        ret.sub = typeArr[1] || '';\n      }\n\n      return ret;\n    }\n\n    function checkClassType(componentType) {\n      assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType \"' + componentType + '\" illegal');\n    }\n\n    function isExtendedClass(clz) {\n      return !!(clz && clz[IS_EXTENDED_CLASS]);\n    }\n    function enableClassExtend(rootClz, mandatoryMethods) {\n      rootClz.$constructor = rootClz;\n\n      rootClz.extend = function (proto) {\n        if (\"development\" !== 'production') {\n          each(mandatoryMethods, function (method) {\n            if (!proto[method]) {\n              console.warn('Method `' + method + '` should be implemented' + (proto.type ? ' in ' + proto.type : '') + '.');\n            }\n          });\n        }\n\n        var superClass = this;\n\n        function ExtendedClass() {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          if (!proto.$constructor) {\n            if (!isESClass(superClass)) {\n              superClass.apply(this, arguments);\n            } else {\n              var ins = createObject(ExtendedClass.prototype, new (superClass.bind.apply(superClass, __spreadArrays([void 0], args)))());\n              return ins;\n            }\n          } else {\n            proto.$constructor.apply(this, arguments);\n          }\n        }\n\n        ExtendedClass[IS_EXTENDED_CLASS] = true;\n        extend(ExtendedClass.prototype, proto);\n        ExtendedClass.extend = this.extend;\n        ExtendedClass.superCall = superCall;\n        ExtendedClass.superApply = superApply;\n        inherits(ExtendedClass, this);\n        ExtendedClass.superClass = superClass;\n        return ExtendedClass;\n      };\n    }\n\n    function isESClass(fn) {\n      return typeof fn === 'function' && /^class\\s/.test(Function.prototype.toString.call(fn));\n    }\n\n    function mountExtend(SubClz, SupperClz) {\n      SubClz.extend = SupperClz.extend;\n    }\n    var classBase = Math.round(Math.random() * 10);\n    function enableClassCheck(target) {\n      var classAttr = ['__\\0is_clz', classBase++].join('_');\n      target.prototype[classAttr] = true;\n\n      if (\"development\" !== 'production') {\n        assert(!target.isInstance, 'The method \"is\" can not be defined.');\n      }\n\n      target.isInstance = function (obj) {\n        return !!(obj && obj[classAttr]);\n      };\n    }\n\n    function superCall(context, methodName) {\n      var args = [];\n\n      for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n      }\n\n      return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function superApply(context, methodName, args) {\n      return this.superClass.prototype[methodName].apply(context, args);\n    }\n\n    function enableClassManagement(target) {\n      var storage = {};\n\n      target.registerClass = function (clz) {\n        var componentFullType = clz.type || clz.prototype.type;\n\n        if (componentFullType) {\n          checkClassType(componentFullType);\n          clz.prototype.type = componentFullType;\n          var componentTypeInfo = parseClassType(componentFullType);\n\n          if (!componentTypeInfo.sub) {\n            if (\"development\" !== 'production') {\n              if (storage[componentTypeInfo.main]) {\n                console.warn(componentTypeInfo.main + ' exists.');\n              }\n            }\n\n            storage[componentTypeInfo.main] = clz;\n          } else if (componentTypeInfo.sub !== IS_CONTAINER) {\n            var container = makeContainer(componentTypeInfo);\n            container[componentTypeInfo.sub] = clz;\n          }\n        }\n\n        return clz;\n      };\n\n      target.getClass = function (mainType, subType, throwWhenNotFound) {\n        var clz = storage[mainType];\n\n        if (clz && clz[IS_CONTAINER]) {\n          clz = subType ? clz[subType] : null;\n        }\n\n        if (throwWhenNotFound && !clz) {\n          throw new Error(!subType ? mainType + '.' + 'type should be specified.' : 'Component ' + mainType + '.' + (subType || '') + ' not exists. Load it first.');\n        }\n\n        return clz;\n      };\n\n      target.getClassesByMainType = function (componentType) {\n        var componentTypeInfo = parseClassType(componentType);\n        var result = [];\n        var obj = storage[componentTypeInfo.main];\n\n        if (obj && obj[IS_CONTAINER]) {\n          each(obj, function (o, type) {\n            type !== IS_CONTAINER && result.push(o);\n          });\n        } else {\n          result.push(obj);\n        }\n\n        return result;\n      };\n\n      target.hasClass = function (componentType) {\n        var componentTypeInfo = parseClassType(componentType);\n        return !!storage[componentTypeInfo.main];\n      };\n\n      target.getAllClassMainTypes = function () {\n        var types = [];\n        each(storage, function (obj, type) {\n          types.push(type);\n        });\n        return types;\n      };\n\n      target.hasSubTypes = function (componentType) {\n        var componentTypeInfo = parseClassType(componentType);\n        var obj = storage[componentTypeInfo.main];\n        return obj && obj[IS_CONTAINER];\n      };\n\n      function makeContainer(componentTypeInfo) {\n        var container = storage[componentTypeInfo.main];\n\n        if (!container || !container[IS_CONTAINER]) {\n          container = storage[componentTypeInfo.main] = {};\n          container[IS_CONTAINER] = true;\n        }\n\n        return container;\n      }\n    }\n\n    function makeStyleMapper(properties, ignoreParent) {\n      for (var i = 0; i < properties.length; i++) {\n        if (!properties[i][1]) {\n          properties[i][1] = properties[i][0];\n        }\n      }\n\n      ignoreParent = ignoreParent || false;\n      return function (model, excludes, includes) {\n        var style = {};\n\n        for (var i = 0; i < properties.length; i++) {\n          var propName = properties[i][1];\n\n          if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {\n            continue;\n          }\n\n          var val = model.getShallow(propName, ignoreParent);\n\n          if (val != null) {\n            style[properties[i][0]] = val;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    var AREA_STYLE_KEY_MAP = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']];\n    var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);\n\n    var AreaStyleMixin = function () {\n      function AreaStyleMixin() {}\n\n      AreaStyleMixin.prototype.getAreaStyle = function (excludes, includes) {\n        return getAreaStyle(this, excludes, includes);\n      };\n\n      return AreaStyleMixin;\n    }();\n\n    var globalImageCache = new LRU(50);\n    function findExistImage(newImageOrSrc) {\n        if (typeof newImageOrSrc === 'string') {\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n            return cachedImgObj && cachedImgObj.image;\n        }\n        else {\n            return newImageOrSrc;\n        }\n    }\n    function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {\n        if (!newImageOrSrc) {\n            return image;\n        }\n        else if (typeof newImageOrSrc === 'string') {\n            if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {\n                return image;\n            }\n            var cachedImgObj = globalImageCache.get(newImageOrSrc);\n            var pendingWrap = { hostEl: hostEl, cb: onload, cbPayload: cbPayload };\n            if (cachedImgObj) {\n                image = cachedImgObj.image;\n                !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n            }\n            else {\n                image = new Image();\n                image.onload = image.onerror = imageOnLoad;\n                globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n                    image: image,\n                    pending: [pendingWrap]\n                });\n                image.src = image.__zrImageSrc = newImageOrSrc;\n            }\n            return image;\n        }\n        else {\n            return newImageOrSrc;\n        }\n    }\n    function imageOnLoad() {\n        var cachedImgObj = this.__cachedImgObj;\n        this.onload = this.onerror = this.__cachedImgObj = null;\n        for (var i = 0; i < cachedImgObj.pending.length; i++) {\n            var pendingWrap = cachedImgObj.pending[i];\n            var cb = pendingWrap.cb;\n            cb && cb(this, pendingWrap.cbPayload);\n            pendingWrap.hostEl.dirty();\n        }\n        cachedImgObj.pending.length = 0;\n    }\n    function isImageReady(image) {\n        return image && image.width && image.height;\n    }\n\n    var STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n    function truncateText(text, containerWidth, font, ellipsis, options) {\n        if (!containerWidth) {\n            return '';\n        }\n        var textLines = (text + '').split('\\n');\n        options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n        for (var i = 0, len = textLines.length; i < len; i++) {\n            textLines[i] = truncateSingleLine(textLines[i], options);\n        }\n        return textLines.join('\\n');\n    }\n    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n        options = options || {};\n        var preparedOpts = extend({}, options);\n        preparedOpts.font = font;\n        ellipsis = retrieve2(ellipsis, '...');\n        preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);\n        var minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);\n        preparedOpts.cnCharWidth = getWidth('', font);\n        var ascCharWidth = preparedOpts.ascCharWidth = getWidth('a', font);\n        preparedOpts.placeholder = retrieve2(options.placeholder, '');\n        var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n            contentWidth -= ascCharWidth;\n        }\n        var ellipsisWidth = getWidth(ellipsis, font);\n        if (ellipsisWidth > contentWidth) {\n            ellipsis = '';\n            ellipsisWidth = 0;\n        }\n        contentWidth = containerWidth - ellipsisWidth;\n        preparedOpts.ellipsis = ellipsis;\n        preparedOpts.ellipsisWidth = ellipsisWidth;\n        preparedOpts.contentWidth = contentWidth;\n        preparedOpts.containerWidth = containerWidth;\n        return preparedOpts;\n    }\n    function truncateSingleLine(textLine, options) {\n        var containerWidth = options.containerWidth;\n        var font = options.font;\n        var contentWidth = options.contentWidth;\n        if (!containerWidth) {\n            return '';\n        }\n        var lineWidth = getWidth(textLine, font);\n        if (lineWidth <= containerWidth) {\n            return textLine;\n        }\n        for (var j = 0;; j++) {\n            if (lineWidth <= contentWidth || j >= options.maxIterations) {\n                textLine += options.ellipsis;\n                break;\n            }\n            var subLength = j === 0\n                ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n                : lineWidth > 0\n                    ? Math.floor(textLine.length * contentWidth / lineWidth)\n                    : 0;\n            textLine = textLine.substr(0, subLength);\n            lineWidth = getWidth(textLine, font);\n        }\n        if (textLine === '') {\n            textLine = options.placeholder;\n        }\n        return textLine;\n    }\n    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n        var width = 0;\n        var i = 0;\n        for (var len = text.length; i < len && width < contentWidth; i++) {\n            var charCode = text.charCodeAt(i);\n            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n        }\n        return i;\n    }\n    function parsePlainText(text, style) {\n        text != null && (text += '');\n        var overflow = style.overflow;\n        var padding = style.padding;\n        var font = style.font;\n        var truncate = overflow === 'truncate';\n        var calculatedLineHeight = getLineHeight(font);\n        var lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);\n        var truncateLineOverflow = style.lineOverflow === 'truncate';\n        var width = style.width;\n        var lines;\n        if (width != null && overflow === 'break' || overflow === 'breakAll') {\n            lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n        }\n        else {\n            lines = text ? text.split('\\n') : [];\n        }\n        var contentHeight = lines.length * lineHeight;\n        var height = retrieve2(style.height, contentHeight);\n        if (contentHeight > height && truncateLineOverflow) {\n            var lineCount = Math.floor(height / lineHeight);\n            lines = lines.slice(0, lineCount);\n        }\n        var outerHeight = height;\n        var outerWidth = width;\n        if (padding) {\n            outerHeight += padding[0] + padding[2];\n            if (outerWidth != null) {\n                outerWidth += padding[1] + padding[3];\n            }\n        }\n        if (text && truncate && outerWidth != null) {\n            var options = prepareTruncateOptions(width, font, style.ellipsis, {\n                minChar: style.truncateMinChar,\n                placeholder: style.placeholder\n            });\n            for (var i = 0; i < lines.length; i++) {\n                lines[i] = truncateSingleLine(lines[i], options);\n            }\n        }\n        if (width == null) {\n            var maxWidth = 0;\n            for (var i = 0; i < lines.length; i++) {\n                maxWidth = Math.max(getWidth(lines[i], font), maxWidth);\n            }\n            width = maxWidth;\n        }\n        return {\n            lines: lines,\n            height: height,\n            outerHeight: outerHeight,\n            lineHeight: lineHeight,\n            calculatedLineHeight: calculatedLineHeight,\n            contentHeight: contentHeight,\n            width: width\n        };\n    }\n    var RichTextToken = (function () {\n        function RichTextToken() {\n        }\n        return RichTextToken;\n    }());\n    var RichTextLine = (function () {\n        function RichTextLine(tokens) {\n            this.tokens = [];\n            if (tokens) {\n                this.tokens = tokens;\n            }\n        }\n        return RichTextLine;\n    }());\n    var RichTextContentBlock = (function () {\n        function RichTextContentBlock() {\n            this.width = 0;\n            this.height = 0;\n            this.contentWidth = 0;\n            this.contentHeight = 0;\n            this.outerWidth = 0;\n            this.outerHeight = 0;\n            this.lines = [];\n        }\n        return RichTextContentBlock;\n    }());\n    function parseRichText(text, style) {\n        var contentBlock = new RichTextContentBlock();\n        text != null && (text += '');\n        if (!text) {\n            return contentBlock;\n        }\n        var topWidth = style.width;\n        var topHeight = style.height;\n        var overflow = style.overflow;\n        var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null\n            ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }\n            : null;\n        var lastIndex = STYLE_REG.lastIndex = 0;\n        var result;\n        while ((result = STYLE_REG.exec(text)) != null) {\n            var matchedIndex = result.index;\n            if (matchedIndex > lastIndex) {\n                pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n            }\n            pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n            lastIndex = STYLE_REG.lastIndex;\n        }\n        if (lastIndex < text.length) {\n            pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n        }\n        var pendingList = [];\n        var calculatedHeight = 0;\n        var calculatedWidth = 0;\n        var stlPadding = style.padding;\n        var truncate = overflow === 'truncate';\n        var truncateLine = style.lineOverflow === 'truncate';\n        function finishLine(line, lineWidth, lineHeight) {\n            line.width = lineWidth;\n            line.lineHeight = lineHeight;\n            calculatedHeight += lineHeight;\n            calculatedWidth = Math.max(calculatedWidth, lineWidth);\n        }\n        outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n            var line = contentBlock.lines[i];\n            var lineHeight = 0;\n            var lineWidth = 0;\n            for (var j = 0; j < line.tokens.length; j++) {\n                var token = line.tokens[j];\n                var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n                var textPadding = token.textPadding = tokenStyle.padding;\n                var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n                var font = token.font = tokenStyle.font || style.font;\n                token.contentHeight = getLineHeight(font);\n                var tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);\n                token.innerHeight = tokenHeight;\n                textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n                token.height = tokenHeight;\n                token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n                token.align = tokenStyle && tokenStyle.align || style.align;\n                token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n                if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n                    if (j > 0) {\n                        line.tokens = line.tokens.slice(0, j);\n                        finishLine(line, lineWidth, lineHeight);\n                        contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n                    }\n                    else {\n                        contentBlock.lines = contentBlock.lines.slice(0, i);\n                    }\n                    break outer;\n                }\n                var styleTokenWidth = tokenStyle.width;\n                var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n                if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n                    token.percentWidth = styleTokenWidth;\n                    pendingList.push(token);\n                    token.contentWidth = getWidth(token.text, font);\n                }\n                else {\n                    if (tokenWidthNotSpecified) {\n                        var textBackgroundColor = tokenStyle.backgroundColor;\n                        var bgImg = textBackgroundColor && textBackgroundColor.image;\n                        if (bgImg) {\n                            bgImg = findExistImage(bgImg);\n                            if (isImageReady(bgImg)) {\n                                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n                            }\n                        }\n                    }\n                    var remainTruncWidth = truncate && topWidth != null\n                        ? topWidth - lineWidth : null;\n                    if (remainTruncWidth != null && remainTruncWidth < token.width) {\n                        if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n                            token.text = '';\n                            token.width = token.contentWidth = 0;\n                        }\n                        else {\n                            token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });\n                            token.width = token.contentWidth = getWidth(token.text, font);\n                        }\n                    }\n                    else {\n                        token.contentWidth = getWidth(token.text, font);\n                    }\n                }\n                token.width += paddingH;\n                lineWidth += token.width;\n                tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            }\n            finishLine(line, lineWidth, lineHeight);\n        }\n        contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);\n        contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);\n        contentBlock.contentHeight = calculatedHeight;\n        contentBlock.contentWidth = calculatedWidth;\n        if (stlPadding) {\n            contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n            contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n        }\n        for (var i = 0; i < pendingList.length; i++) {\n            var token = pendingList[i];\n            var percentWidth = token.percentWidth;\n            token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n        }\n        return contentBlock;\n    }\n    function pushTokens(block, str, style, wrapInfo, styleName) {\n        var isEmptyStr = str === '';\n        var tokenStyle = styleName && style.rich[styleName] || {};\n        var lines = block.lines;\n        var font = tokenStyle.font || style.font;\n        var newLine = false;\n        var strLines;\n        var linesWidths;\n        if (wrapInfo) {\n            var tokenPadding = tokenStyle.padding;\n            var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n            if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n                var outerWidth_1 = parsePercent$2(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n                if (lines.length > 0) {\n                    if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n                        strLines = str.split('\\n');\n                        newLine = true;\n                    }\n                }\n                wrapInfo.accumWidth = outerWidth_1;\n            }\n            else {\n                var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n                wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n                linesWidths = res.linesWidths;\n                strLines = res.lines;\n            }\n        }\n        else {\n            strLines = str.split('\\n');\n        }\n        for (var i = 0; i < strLines.length; i++) {\n            var text = strLines[i];\n            var token = new RichTextToken();\n            token.styleName = styleName;\n            token.text = text;\n            token.isLineHolder = !text && !isEmptyStr;\n            if (typeof tokenStyle.width === 'number') {\n                token.width = tokenStyle.width;\n            }\n            else {\n                token.width = linesWidths\n                    ? linesWidths[i]\n                    : getWidth(text, font);\n            }\n            if (!i && !newLine) {\n                var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n                var tokensLen = tokens.length;\n                (tokensLen === 1 && tokens[0].isLineHolder)\n                    ? (tokens[0] = token)\n                    : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n            }\n            else {\n                lines.push(new RichTextLine([token]));\n            }\n        }\n    }\n    function isLatin(ch) {\n        var code = ch.charCodeAt(0);\n        return code >= 0x21 && code <= 0xFF;\n    }\n    var breakCharMap = reduce(',&?/;] '.split(''), function (obj, ch) {\n        obj[ch] = true;\n        return obj;\n    }, {});\n    function isWordBreakChar(ch) {\n        if (isLatin(ch)) {\n            if (breakCharMap[ch]) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n        var lines = [];\n        var linesWidths = [];\n        var line = '';\n        var currentWord = '';\n        var currentWordWidth = 0;\n        var accumWidth = 0;\n        for (var i = 0; i < text.length; i++) {\n            var ch = text.charAt(i);\n            if (ch === '\\n') {\n                if (currentWord) {\n                    line += currentWord;\n                    accumWidth += currentWordWidth;\n                }\n                lines.push(line);\n                linesWidths.push(accumWidth);\n                line = '';\n                currentWord = '';\n                currentWordWidth = 0;\n                accumWidth = 0;\n                continue;\n            }\n            var chWidth = getWidth(ch, font);\n            var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n            if (!lines.length\n                ? lastAccumWidth + accumWidth + chWidth > lineWidth\n                : accumWidth + chWidth > lineWidth) {\n                if (!accumWidth) {\n                    if (inWord) {\n                        lines.push(currentWord);\n                        linesWidths.push(currentWordWidth);\n                        currentWord = ch;\n                        currentWordWidth = chWidth;\n                    }\n                    else {\n                        lines.push(ch);\n                        linesWidths.push(chWidth);\n                    }\n                }\n                else if (line || currentWord) {\n                    if (inWord) {\n                        if (!line) {\n                            line = currentWord;\n                            currentWord = '';\n                            currentWordWidth = 0;\n                            accumWidth = currentWordWidth;\n                        }\n                        lines.push(line);\n                        linesWidths.push(accumWidth - currentWordWidth);\n                        currentWord += ch;\n                        currentWordWidth += chWidth;\n                        line = '';\n                        accumWidth = currentWordWidth;\n                    }\n                    else {\n                        if (currentWord) {\n                            line += currentWord;\n                            accumWidth += currentWordWidth;\n                            currentWord = '';\n                            currentWordWidth = 0;\n                        }\n                        lines.push(line);\n                        linesWidths.push(accumWidth);\n                        line = ch;\n                        accumWidth = chWidth;\n                    }\n                }\n                continue;\n            }\n            accumWidth += chWidth;\n            if (inWord) {\n                currentWord += ch;\n                currentWordWidth += chWidth;\n            }\n            else {\n                if (currentWord) {\n                    line += currentWord;\n                    currentWord = '';\n                    currentWordWidth = 0;\n                }\n                line += ch;\n            }\n        }\n        if (!lines.length && !line) {\n            line = text;\n            currentWord = '';\n            currentWordWidth = 0;\n        }\n        if (currentWord) {\n            line += currentWord;\n        }\n        if (line) {\n            lines.push(line);\n            linesWidths.push(accumWidth);\n        }\n        if (lines.length === 1) {\n            accumWidth += lastAccumWidth;\n        }\n        return {\n            accumWidth: accumWidth,\n            lines: lines,\n            linesWidths: linesWidths\n        };\n    }\n    function parsePercent$2(value, maxValue) {\n        if (typeof value === 'string') {\n            if (value.lastIndexOf('%') >= 0) {\n                return parseFloat(value) / 100 * maxValue;\n            }\n            return parseFloat(value);\n        }\n        return value;\n    }\n\n    var STYLE_MAGIC_KEY = '__zr_style_' + Math.round((Math.random() * 10));\n    var DEFAULT_COMMON_STYLE = {\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: '#000',\n        opacity: 1,\n        blend: 'source-over'\n    };\n    var DEFAULT_COMMON_ANIMATION_PROPS = {\n        style: {\n            shadowBlur: true,\n            shadowOffsetX: true,\n            shadowOffsetY: true,\n            shadowColor: true,\n            opacity: true\n        }\n    };\n    DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;\n    var PRIMARY_STATES_KEYS$1 = ['z', 'z2', 'invisible'];\n    var Displayable = (function (_super) {\n        __extends(Displayable, _super);\n        function Displayable(props) {\n            return _super.call(this, props) || this;\n        }\n        Displayable.prototype._init = function (props) {\n            var keysArr = keys(props);\n            for (var i = 0; i < keysArr.length; i++) {\n                var key = keysArr[i];\n                if (key === 'style') {\n                    this.useStyle(props[key]);\n                }\n                else {\n                    _super.prototype.attrKV.call(this, key, props[key]);\n                }\n            }\n            if (!this.style) {\n                this.useStyle({});\n            }\n        };\n        Displayable.prototype.beforeBrush = function () { };\n        Displayable.prototype.afterBrush = function () { };\n        Displayable.prototype.innerBeforeBrush = function () { };\n        Displayable.prototype.innerAfterBrush = function () { };\n        Displayable.prototype.shouldBePainted = function (viewWidth, viewHeight, considerClipPath, considerAncestors) {\n            var m = this.transform;\n            if (this.ignore\n                || this.invisible\n                || this.style.opacity === 0\n                || (this.culling\n                    && isDisplayableCulled(this, viewWidth, viewHeight))\n                || (m && !m[0] && !m[3])) {\n                return false;\n            }\n            if (considerClipPath && this.__clipPaths) {\n                for (var i = 0; i < this.__clipPaths.length; ++i) {\n                    if (this.__clipPaths[i].isZeroArea()) {\n                        return false;\n                    }\n                }\n            }\n            if (considerAncestors && this.parent) {\n                var parent_1 = this.parent;\n                while (parent_1) {\n                    if (parent_1.ignore) {\n                        return false;\n                    }\n                    parent_1 = parent_1.parent;\n                }\n            }\n            return true;\n        };\n        Displayable.prototype.contain = function (x, y) {\n            return this.rectContain(x, y);\n        };\n        Displayable.prototype.traverse = function (cb, context) {\n            cb.call(context, this);\n        };\n        Displayable.prototype.rectContain = function (x, y) {\n            var coord = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            return rect.contain(coord[0], coord[1]);\n        };\n        Displayable.prototype.getPaintRect = function () {\n            var rect = this._paintRect;\n            if (!this._paintRect || this.__dirty) {\n                var transform = this.transform;\n                var elRect = this.getBoundingRect();\n                var style = this.style;\n                var shadowSize = style.shadowBlur || 0;\n                var shadowOffsetX = style.shadowOffsetX || 0;\n                var shadowOffsetY = style.shadowOffsetY || 0;\n                rect = this._paintRect || (this._paintRect = new BoundingRect(0, 0, 0, 0));\n                if (transform) {\n                    BoundingRect.applyTransform(rect, elRect, transform);\n                }\n                else {\n                    rect.copy(elRect);\n                }\n                if (shadowSize || shadowOffsetX || shadowOffsetY) {\n                    rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);\n                    rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);\n                    rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);\n                    rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);\n                }\n                var tolerance = this.dirtyRectTolerance;\n                if (!rect.isZero()) {\n                    rect.x = Math.floor(rect.x - tolerance);\n                    rect.y = Math.floor(rect.y - tolerance);\n                    rect.width = Math.ceil(rect.width + 1 + tolerance * 2);\n                    rect.height = Math.ceil(rect.height + 1 + tolerance * 2);\n                }\n            }\n            return rect;\n        };\n        Displayable.prototype.setPrevPaintRect = function (paintRect) {\n            if (paintRect) {\n                this._prevPaintRect = this._prevPaintRect || new BoundingRect(0, 0, 0, 0);\n                this._prevPaintRect.copy(paintRect);\n            }\n            else {\n                this._prevPaintRect = null;\n            }\n        };\n        Displayable.prototype.getPrevPaintRect = function () {\n            return this._prevPaintRect;\n        };\n        Displayable.prototype.animateStyle = function (loop) {\n            return this.animate('style', loop);\n        };\n        Displayable.prototype.updateDuringAnimation = function (targetKey) {\n            if (targetKey === 'style') {\n                this.dirtyStyle();\n            }\n            else {\n                this.markRedraw();\n            }\n        };\n        Displayable.prototype.attrKV = function (key, value) {\n            if (key !== 'style') {\n                _super.prototype.attrKV.call(this, key, value);\n            }\n            else {\n                if (!this.style) {\n                    this.useStyle(value);\n                }\n                else {\n                    this.setStyle(value);\n                }\n            }\n        };\n        Displayable.prototype.setStyle = function (keyOrObj, value) {\n            if (typeof keyOrObj === 'string') {\n                this.style[keyOrObj] = value;\n            }\n            else {\n                extend(this.style, keyOrObj);\n            }\n            this.dirtyStyle();\n            return this;\n        };\n        Displayable.prototype.dirtyStyle = function () {\n            this.markRedraw();\n            this.__dirty |= Displayable.STYLE_CHANGED_BIT;\n            if (this._rect) {\n                this._rect = null;\n            }\n        };\n        Displayable.prototype.dirty = function () {\n            this.dirtyStyle();\n        };\n        Displayable.prototype.styleChanged = function () {\n            return !!(this.__dirty & Displayable.STYLE_CHANGED_BIT);\n        };\n        Displayable.prototype.styleUpdated = function () {\n            this.__dirty &= ~Displayable.STYLE_CHANGED_BIT;\n        };\n        Displayable.prototype.createStyle = function (obj) {\n            return createObject(DEFAULT_COMMON_STYLE, obj);\n        };\n        Displayable.prototype.useStyle = function (obj) {\n            if (!obj[STYLE_MAGIC_KEY]) {\n                obj = this.createStyle(obj);\n            }\n            if (this.__inHover) {\n                this.__hoverStyle = obj;\n            }\n            else {\n                this.style = obj;\n            }\n            this.dirtyStyle();\n        };\n        Displayable.prototype.isStyleObject = function (obj) {\n            return obj[STYLE_MAGIC_KEY];\n        };\n        Displayable.prototype._innerSaveToNormal = function (toState) {\n            _super.prototype._innerSaveToNormal.call(this, toState);\n            var normalState = this._normalState;\n            if (toState.style && !normalState.style) {\n                normalState.style = this._mergeStyle(this.createStyle(), this.style);\n            }\n            this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1);\n        };\n        Displayable.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {\n            _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);\n            var needsRestoreToNormal = !(state && keepCurrentStates);\n            var targetStyle;\n            if (state && state.style) {\n                if (transition) {\n                    if (keepCurrentStates) {\n                        targetStyle = state.style;\n                    }\n                    else {\n                        targetStyle = this._mergeStyle(this.createStyle(), normalState.style);\n                        this._mergeStyle(targetStyle, state.style);\n                    }\n                }\n                else {\n                    targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);\n                    this._mergeStyle(targetStyle, state.style);\n                }\n            }\n            else if (needsRestoreToNormal) {\n                targetStyle = normalState.style;\n            }\n            if (targetStyle) {\n                if (transition) {\n                    var sourceStyle = this.style;\n                    this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);\n                    if (needsRestoreToNormal) {\n                        var changedKeys = keys(sourceStyle);\n                        for (var i = 0; i < changedKeys.length; i++) {\n                            var key = changedKeys[i];\n                            if (key in targetStyle) {\n                                targetStyle[key] = targetStyle[key];\n                                this.style[key] = sourceStyle[key];\n                            }\n                        }\n                    }\n                    var targetKeys = keys(targetStyle);\n                    for (var i = 0; i < targetKeys.length; i++) {\n                        var key = targetKeys[i];\n                        this.style[key] = this.style[key];\n                    }\n                    this._transitionState(stateName, {\n                        style: targetStyle\n                    }, animationCfg, this.getAnimationStyleProps());\n                }\n                else {\n                    this.useStyle(targetStyle);\n                }\n            }\n            for (var i = 0; i < PRIMARY_STATES_KEYS$1.length; i++) {\n                var key = PRIMARY_STATES_KEYS$1[i];\n                if (state && state[key] != null) {\n                    this[key] = state[key];\n                }\n                else if (needsRestoreToNormal) {\n                    if (normalState[key] != null) {\n                        this[key] = normalState[key];\n                    }\n                }\n            }\n        };\n        Displayable.prototype._mergeStates = function (states) {\n            var mergedState = _super.prototype._mergeStates.call(this, states);\n            var mergedStyle;\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i];\n                if (state.style) {\n                    mergedStyle = mergedStyle || {};\n                    this._mergeStyle(mergedStyle, state.style);\n                }\n            }\n            if (mergedStyle) {\n                mergedState.style = mergedStyle;\n            }\n            return mergedState;\n        };\n        Displayable.prototype._mergeStyle = function (targetStyle, sourceStyle) {\n            extend(targetStyle, sourceStyle);\n            return targetStyle;\n        };\n        Displayable.prototype.getAnimationStyleProps = function () {\n            return DEFAULT_COMMON_ANIMATION_PROPS;\n        };\n        Displayable.STYLE_CHANGED_BIT = 2;\n        Displayable.initDefaultProps = (function () {\n            var dispProto = Displayable.prototype;\n            dispProto.type = 'displayable';\n            dispProto.invisible = false;\n            dispProto.z = 0;\n            dispProto.z2 = 0;\n            dispProto.zlevel = 0;\n            dispProto.culling = false;\n            dispProto.cursor = 'pointer';\n            dispProto.rectHover = false;\n            dispProto.incremental = false;\n            dispProto._rect = null;\n            dispProto.dirtyRectTolerance = 0;\n            dispProto.__dirty = Element.REDARAW_BIT | Displayable.STYLE_CHANGED_BIT;\n        })();\n        return Displayable;\n    }(Element));\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var viewRect = new BoundingRect(0, 0, 0, 0);\n    function isDisplayableCulled(el, width, height) {\n        tmpRect.copy(el.getBoundingRect());\n        if (el.transform) {\n            tmpRect.applyTransform(el.transform);\n        }\n        viewRect.width = width;\n        viewRect.height = height;\n        return !tmpRect.intersect(viewRect);\n    }\n\n    var mathPow = Math.pow;\n    var mathSqrt = Math.sqrt;\n    var EPSILON$1 = 1e-8;\n    var EPSILON_NUMERIC = 1e-4;\n    var THREE_SQRT = mathSqrt(3);\n    var ONE_THIRD = 1 / 3;\n    var _v0 = create();\n    var _v1 = create();\n    var _v2 = create();\n    function isAroundZero(val) {\n        return val > -EPSILON$1 && val < EPSILON$1;\n    }\n    function isNotAroundZero$1(val) {\n        return val > EPSILON$1 || val < -EPSILON$1;\n    }\n    function cubicAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return onet * onet * (onet * p0 + 3 * t * p1)\n            + t * t * (t * p3 + 3 * onet * p2);\n    }\n    function cubicDerivativeAt(p0, p1, p2, p3, t) {\n        var onet = 1 - t;\n        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet\n            + (p3 - p2) * t * t);\n    }\n    function cubicRootAt(p0, p1, p2, p3, val, roots) {\n        var a = p3 + 3 * (p1 - p2) - p0;\n        var b = 3 * (p2 - p1 * 2 + p0);\n        var c = 3 * (p1 - p0);\n        var d = p0 - val;\n        var A = b * b - 3 * a * c;\n        var B = b * c - 9 * a * d;\n        var C = c * c - 3 * b * d;\n        var n = 0;\n        if (isAroundZero(A) && isAroundZero(B)) {\n            if (isAroundZero(b)) {\n                roots[0] = 0;\n            }\n            else {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = B * B - 4 * A * C;\n            if (isAroundZero(disc)) {\n                var K = B / A;\n                var t1 = -b / a + K;\n                var t2 = -K / 2;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n                var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n                if (Y1 < 0) {\n                    Y1 = -mathPow(-Y1, ONE_THIRD);\n                }\n                else {\n                    Y1 = mathPow(Y1, ONE_THIRD);\n                }\n                if (Y2 < 0) {\n                    Y2 = -mathPow(-Y2, ONE_THIRD);\n                }\n                else {\n                    Y2 = mathPow(Y2, ONE_THIRD);\n                }\n                var t1 = (-b - (Y1 + Y2)) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else {\n                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n                var theta = Math.acos(T) / 3;\n                var ASqrt = mathSqrt(A);\n                var tmp = Math.cos(theta);\n                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n                if (t3 >= 0 && t3 <= 1) {\n                    roots[n++] = t3;\n                }\n            }\n        }\n        return n;\n    }\n    function cubicExtrema(p0, p1, p2, p3, extrema) {\n        var b = 6 * p2 - 12 * p1 + 6 * p0;\n        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n        var c = 3 * p1 - 3 * p0;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero$1(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                extrema[0] = -b / (2 * a);\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    extrema[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    extrema[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    function cubicSubdivide(p0, p1, p2, p3, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p23 = (p3 - p2) * t + p2;\n        var p012 = (p12 - p01) * t + p01;\n        var p123 = (p23 - p12) * t + p12;\n        var p0123 = (p123 - p012) * t + p012;\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p0123;\n        out[4] = p0123;\n        out[5] = p123;\n        out[6] = p23;\n        out[7] = p3;\n    }\n    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        var prev;\n        var next;\n        var d1;\n        var d2;\n        _v0[0] = x;\n        _v0[1] = y;\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n            _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n            d1 = distSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            prev = t - interval;\n            next = t + interval;\n            _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n            _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n            d1 = distSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                _v2[0] = cubicAt(x0, x1, x2, x3, next);\n                _v2[1] = cubicAt(y0, y1, y2, y3, next);\n                d2 = distSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        if (out) {\n            out[0] = cubicAt(x0, x1, x2, x3, t);\n            out[1] = cubicAt(y0, y1, y2, y3, t);\n        }\n        return mathSqrt(d);\n    }\n    function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {\n        var px = x0;\n        var py = y0;\n        var d = 0;\n        var step = 1 / iteration;\n        for (var i = 1; i <= iteration; i++) {\n            var t = i * step;\n            var x = cubicAt(x0, x1, x2, x3, t);\n            var y = cubicAt(y0, y1, y2, y3, t);\n            var dx = x - px;\n            var dy = y - py;\n            d += Math.sqrt(dx * dx + dy * dy);\n            px = x;\n            py = y;\n        }\n        return d;\n    }\n    function quadraticAt(p0, p1, p2, t) {\n        var onet = 1 - t;\n        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n    }\n    function quadraticDerivativeAt(p0, p1, p2, t) {\n        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n    }\n    function quadraticRootAt(p0, p1, p2, val, roots) {\n        var a = p0 - 2 * p1 + p2;\n        var b = 2 * (p1 - p0);\n        var c = p0 - val;\n        var n = 0;\n        if (isAroundZero(a)) {\n            if (isNotAroundZero$1(b)) {\n                var t1 = -c / b;\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n        }\n        else {\n            var disc = b * b - 4 * a * c;\n            if (isAroundZero(disc)) {\n                var t1 = -b / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n            }\n            else if (disc > 0) {\n                var discSqrt = mathSqrt(disc);\n                var t1 = (-b + discSqrt) / (2 * a);\n                var t2 = (-b - discSqrt) / (2 * a);\n                if (t1 >= 0 && t1 <= 1) {\n                    roots[n++] = t1;\n                }\n                if (t2 >= 0 && t2 <= 1) {\n                    roots[n++] = t2;\n                }\n            }\n        }\n        return n;\n    }\n    function quadraticExtremum(p0, p1, p2) {\n        var divider = p0 + p2 - 2 * p1;\n        if (divider === 0) {\n            return 0.5;\n        }\n        else {\n            return (p0 - p1) / divider;\n        }\n    }\n    function quadraticSubdivide(p0, p1, p2, t, out) {\n        var p01 = (p1 - p0) * t + p0;\n        var p12 = (p2 - p1) * t + p1;\n        var p012 = (p12 - p01) * t + p01;\n        out[0] = p0;\n        out[1] = p01;\n        out[2] = p012;\n        out[3] = p012;\n        out[4] = p12;\n        out[5] = p2;\n    }\n    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n        var t;\n        var interval = 0.005;\n        var d = Infinity;\n        _v0[0] = x;\n        _v0[1] = y;\n        for (var _t = 0; _t < 1; _t += 0.05) {\n            _v1[0] = quadraticAt(x0, x1, x2, _t);\n            _v1[1] = quadraticAt(y0, y1, y2, _t);\n            var d1 = distSquare(_v0, _v1);\n            if (d1 < d) {\n                t = _t;\n                d = d1;\n            }\n        }\n        d = Infinity;\n        for (var i = 0; i < 32; i++) {\n            if (interval < EPSILON_NUMERIC) {\n                break;\n            }\n            var prev = t - interval;\n            var next = t + interval;\n            _v1[0] = quadraticAt(x0, x1, x2, prev);\n            _v1[1] = quadraticAt(y0, y1, y2, prev);\n            var d1 = distSquare(_v1, _v0);\n            if (prev >= 0 && d1 < d) {\n                t = prev;\n                d = d1;\n            }\n            else {\n                _v2[0] = quadraticAt(x0, x1, x2, next);\n                _v2[1] = quadraticAt(y0, y1, y2, next);\n                var d2 = distSquare(_v2, _v0);\n                if (next <= 1 && d2 < d) {\n                    t = next;\n                    d = d2;\n                }\n                else {\n                    interval *= 0.5;\n                }\n            }\n        }\n        if (out) {\n            out[0] = quadraticAt(x0, x1, x2, t);\n            out[1] = quadraticAt(y0, y1, y2, t);\n        }\n        return mathSqrt(d);\n    }\n    function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {\n        var px = x0;\n        var py = y0;\n        var d = 0;\n        var step = 1 / iteration;\n        for (var i = 1; i <= iteration; i++) {\n            var t = i * step;\n            var x = quadraticAt(x0, x1, x2, t);\n            var y = quadraticAt(y0, y1, y2, t);\n            var dx = x - px;\n            var dy = y - py;\n            d += Math.sqrt(dx * dx + dy * dy);\n            px = x;\n            py = y;\n        }\n        return d;\n    }\n\n    var mathMin$1 = Math.min;\n    var mathMax$1 = Math.max;\n    var mathSin = Math.sin;\n    var mathCos = Math.cos;\n    var PI2 = Math.PI * 2;\n    var start = create();\n    var end = create();\n    var extremity = create();\n    function fromPoints(points, min, max) {\n        if (points.length === 0) {\n            return;\n        }\n        var p = points[0];\n        var left = p[0];\n        var right = p[0];\n        var top = p[1];\n        var bottom = p[1];\n        for (var i = 1; i < points.length; i++) {\n            p = points[i];\n            left = mathMin$1(left, p[0]);\n            right = mathMax$1(right, p[0]);\n            top = mathMin$1(top, p[1]);\n            bottom = mathMax$1(bottom, p[1]);\n        }\n        min[0] = left;\n        min[1] = top;\n        max[0] = right;\n        max[1] = bottom;\n    }\n    function fromLine(x0, y0, x1, y1, min, max) {\n        min[0] = mathMin$1(x0, x1);\n        min[1] = mathMin$1(y0, y1);\n        max[0] = mathMax$1(x0, x1);\n        max[1] = mathMax$1(y0, y1);\n    }\n    var xDim = [];\n    var yDim = [];\n    function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n        var cubicExtrema$1 = cubicExtrema;\n        var cubicAt$1 = cubicAt;\n        var n = cubicExtrema$1(x0, x1, x2, x3, xDim);\n        min[0] = Infinity;\n        min[1] = Infinity;\n        max[0] = -Infinity;\n        max[1] = -Infinity;\n        for (var i = 0; i < n; i++) {\n            var x = cubicAt$1(x0, x1, x2, x3, xDim[i]);\n            min[0] = mathMin$1(x, min[0]);\n            max[0] = mathMax$1(x, max[0]);\n        }\n        n = cubicExtrema$1(y0, y1, y2, y3, yDim);\n        for (var i = 0; i < n; i++) {\n            var y = cubicAt$1(y0, y1, y2, y3, yDim[i]);\n            min[1] = mathMin$1(y, min[1]);\n            max[1] = mathMax$1(y, max[1]);\n        }\n        min[0] = mathMin$1(x0, min[0]);\n        max[0] = mathMax$1(x0, max[0]);\n        min[0] = mathMin$1(x3, min[0]);\n        max[0] = mathMax$1(x3, max[0]);\n        min[1] = mathMin$1(y0, min[1]);\n        max[1] = mathMax$1(y0, max[1]);\n        min[1] = mathMin$1(y3, min[1]);\n        max[1] = mathMax$1(y3, max[1]);\n    }\n    function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n        var quadraticExtremum$1 = quadraticExtremum;\n        var quadraticAt$1 = quadraticAt;\n        var tx = mathMax$1(mathMin$1(quadraticExtremum$1(x0, x1, x2), 1), 0);\n        var ty = mathMax$1(mathMin$1(quadraticExtremum$1(y0, y1, y2), 1), 0);\n        var x = quadraticAt$1(x0, x1, x2, tx);\n        var y = quadraticAt$1(y0, y1, y2, ty);\n        min[0] = mathMin$1(x0, x2, x);\n        min[1] = mathMin$1(y0, y2, y);\n        max[0] = mathMax$1(x0, x2, x);\n        max[1] = mathMax$1(y0, y2, y);\n    }\n    function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min$1, max$1) {\n        var vec2Min = min;\n        var vec2Max = max;\n        var diff = Math.abs(startAngle - endAngle);\n        if (diff % PI2 < 1e-4 && diff > 1e-4) {\n            min$1[0] = x - rx;\n            min$1[1] = y - ry;\n            max$1[0] = x + rx;\n            max$1[1] = y + ry;\n            return;\n        }\n        start[0] = mathCos(startAngle) * rx + x;\n        start[1] = mathSin(startAngle) * ry + y;\n        end[0] = mathCos(endAngle) * rx + x;\n        end[1] = mathSin(endAngle) * ry + y;\n        vec2Min(min$1, start, end);\n        vec2Max(max$1, start, end);\n        startAngle = startAngle % (PI2);\n        if (startAngle < 0) {\n            startAngle = startAngle + PI2;\n        }\n        endAngle = endAngle % (PI2);\n        if (endAngle < 0) {\n            endAngle = endAngle + PI2;\n        }\n        if (startAngle > endAngle && !anticlockwise) {\n            endAngle += PI2;\n        }\n        else if (startAngle < endAngle && anticlockwise) {\n            startAngle += PI2;\n        }\n        if (anticlockwise) {\n            var tmp = endAngle;\n            endAngle = startAngle;\n            startAngle = tmp;\n        }\n        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n            if (angle > startAngle) {\n                extremity[0] = mathCos(angle) * rx + x;\n                extremity[1] = mathSin(angle) * ry + y;\n                vec2Min(min$1, extremity, min$1);\n                vec2Max(max$1, extremity, max$1);\n            }\n        }\n    }\n\n    var CMD = {\n        M: 1,\n        L: 2,\n        C: 3,\n        Q: 4,\n        A: 5,\n        Z: 6,\n        R: 7\n    };\n    var tmpOutX = [];\n    var tmpOutY = [];\n    var min$1 = [];\n    var max$1 = [];\n    var min2 = [];\n    var max2 = [];\n    var mathMin$2 = Math.min;\n    var mathMax$2 = Math.max;\n    var mathCos$1 = Math.cos;\n    var mathSin$1 = Math.sin;\n    var mathSqrt$1 = Math.sqrt;\n    var mathAbs = Math.abs;\n    var PI = Math.PI;\n    var PI2$1 = PI * 2;\n    var hasTypedArray = typeof Float32Array !== 'undefined';\n    var tmpAngles = [];\n    function modPI2(radian) {\n        var n = Math.round(radian / PI * 1e8) / 1e8;\n        return (n % 2) * PI;\n    }\n    function normalizeArcAngles(angles, anticlockwise) {\n        var newStartAngle = modPI2(angles[0]);\n        if (newStartAngle < 0) {\n            newStartAngle += PI2$1;\n        }\n        var delta = newStartAngle - angles[0];\n        var newEndAngle = angles[1];\n        newEndAngle += delta;\n        if (!anticlockwise && newEndAngle - newStartAngle >= PI2$1) {\n            newEndAngle = newStartAngle + PI2$1;\n        }\n        else if (anticlockwise && newStartAngle - newEndAngle >= PI2$1) {\n            newEndAngle = newStartAngle - PI2$1;\n        }\n        else if (!anticlockwise && newStartAngle > newEndAngle) {\n            newEndAngle = newStartAngle +\n                (PI2$1 - modPI2(newStartAngle - newEndAngle));\n        }\n        else if (anticlockwise && newStartAngle < newEndAngle) {\n            newEndAngle = newStartAngle -\n                (PI2$1 - modPI2(newEndAngle - newStartAngle));\n        }\n        angles[0] = newStartAngle;\n        angles[1] = newEndAngle;\n    }\n    var PathProxy = (function () {\n        function PathProxy(notSaveData) {\n            this.dpr = 1;\n            this._version = 0;\n            this._xi = 0;\n            this._yi = 0;\n            this._x0 = 0;\n            this._y0 = 0;\n            this._len = 0;\n            if (notSaveData) {\n                this._saveData = false;\n            }\n            if (this._saveData) {\n                this.data = [];\n            }\n        }\n        PathProxy.prototype.increaseVersion = function () {\n            this._version++;\n        };\n        PathProxy.prototype.getVersion = function () {\n            return this._version;\n        };\n        PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {\n            segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n            if (segmentIgnoreThreshold > 0) {\n                this._ux = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;\n                this._uy = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;\n            }\n        };\n        PathProxy.prototype.setDPR = function (dpr) {\n            this.dpr = dpr;\n        };\n        PathProxy.prototype.setContext = function (ctx) {\n            this._ctx = ctx;\n        };\n        PathProxy.prototype.getContext = function () {\n            return this._ctx;\n        };\n        PathProxy.prototype.beginPath = function () {\n            this._ctx && this._ctx.beginPath();\n            this.reset();\n            return this;\n        };\n        PathProxy.prototype.reset = function () {\n            if (this._saveData) {\n                this._len = 0;\n            }\n            if (this._lineDash) {\n                this._lineDash = null;\n                this._dashOffset = 0;\n            }\n            if (this._pathSegLen) {\n                this._pathSegLen = null;\n                this._pathLen = 0;\n            }\n            this._version++;\n        };\n        PathProxy.prototype.moveTo = function (x, y) {\n            this.addData(CMD.M, x, y);\n            this._ctx && this._ctx.moveTo(x, y);\n            this._x0 = x;\n            this._y0 = y;\n            this._xi = x;\n            this._yi = y;\n            return this;\n        };\n        PathProxy.prototype.lineTo = function (x, y) {\n            var exceedUnit = mathAbs(x - this._xi) > this._ux\n                || mathAbs(y - this._yi) > this._uy\n                || this._len < 5;\n            this.addData(CMD.L, x, y);\n            if (this._ctx && exceedUnit) {\n                this._needsDash ? this._dashedLineTo(x, y)\n                    : this._ctx.lineTo(x, y);\n            }\n            if (exceedUnit) {\n                this._xi = x;\n                this._yi = y;\n            }\n            return this;\n        };\n        PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {\n            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n            if (this._ctx) {\n                this._needsDash ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)\n                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n            }\n            this._xi = x3;\n            this._yi = y3;\n            return this;\n        };\n        PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {\n            this.addData(CMD.Q, x1, y1, x2, y2);\n            if (this._ctx) {\n                this._needsDash ? this._dashedQuadraticTo(x1, y1, x2, y2)\n                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n            }\n            this._xi = x2;\n            this._yi = y2;\n            return this;\n        };\n        PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            tmpAngles[0] = startAngle;\n            tmpAngles[1] = endAngle;\n            normalizeArcAngles(tmpAngles, anticlockwise);\n            startAngle = tmpAngles[0];\n            endAngle = tmpAngles[1];\n            var delta = endAngle - startAngle;\n            this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);\n            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n            this._xi = mathCos$1(endAngle) * r + cx;\n            this._yi = mathSin$1(endAngle) * r + cy;\n            return this;\n        };\n        PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n            if (this._ctx) {\n                this._ctx.arcTo(x1, y1, x2, y2, radius);\n            }\n            return this;\n        };\n        PathProxy.prototype.rect = function (x, y, w, h) {\n            this._ctx && this._ctx.rect(x, y, w, h);\n            this.addData(CMD.R, x, y, w, h);\n            return this;\n        };\n        PathProxy.prototype.closePath = function () {\n            this.addData(CMD.Z);\n            var ctx = this._ctx;\n            var x0 = this._x0;\n            var y0 = this._y0;\n            if (ctx) {\n                this._needsDash && this._dashedLineTo(x0, y0);\n                ctx.closePath();\n            }\n            this._xi = x0;\n            this._yi = y0;\n            return this;\n        };\n        PathProxy.prototype.fill = function (ctx) {\n            ctx && ctx.fill();\n            this.toStatic();\n        };\n        PathProxy.prototype.stroke = function (ctx) {\n            ctx && ctx.stroke();\n            this.toStatic();\n        };\n        PathProxy.prototype.setLineDash = function (lineDash) {\n            if (lineDash instanceof Array) {\n                this._lineDash = lineDash;\n                this._dashIdx = 0;\n                var lineDashSum = 0;\n                for (var i = 0; i < lineDash.length; i++) {\n                    lineDashSum += lineDash[i];\n                }\n                this._dashSum = lineDashSum;\n                this._needsDash = true;\n            }\n            else {\n                this._lineDash = null;\n                this._needsDash = false;\n            }\n            return this;\n        };\n        PathProxy.prototype.setLineDashOffset = function (offset) {\n            this._dashOffset = offset;\n            return this;\n        };\n        PathProxy.prototype.len = function () {\n            return this._len;\n        };\n        PathProxy.prototype.setData = function (data) {\n            var len = data.length;\n            if (!(this.data && this.data.length === len) && hasTypedArray) {\n                this.data = new Float32Array(len);\n            }\n            for (var i = 0; i < len; i++) {\n                this.data[i] = data[i];\n            }\n            this._len = len;\n        };\n        PathProxy.prototype.appendPath = function (path) {\n            if (!(path instanceof Array)) {\n                path = [path];\n            }\n            var len = path.length;\n            var appendSize = 0;\n            var offset = this._len;\n            for (var i = 0; i < len; i++) {\n                appendSize += path[i].len();\n            }\n            if (hasTypedArray && (this.data instanceof Float32Array)) {\n                this.data = new Float32Array(offset + appendSize);\n            }\n            for (var i = 0; i < len; i++) {\n                var appendPathData = path[i].data;\n                for (var k = 0; k < appendPathData.length; k++) {\n                    this.data[offset++] = appendPathData[k];\n                }\n            }\n            this._len = offset;\n        };\n        PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {\n            if (!this._saveData) {\n                return;\n            }\n            var data = this.data;\n            if (this._len + arguments.length > data.length) {\n                this._expandData();\n                data = this.data;\n            }\n            for (var i = 0; i < arguments.length; i++) {\n                data[this._len++] = arguments[i];\n            }\n        };\n        PathProxy.prototype._expandData = function () {\n            if (!(this.data instanceof Array)) {\n                var newData = [];\n                for (var i = 0; i < this._len; i++) {\n                    newData[i] = this.data[i];\n                }\n                this.data = newData;\n            }\n        };\n        PathProxy.prototype._dashedLineTo = function (x1, y1) {\n            var dashSum = this._dashSum;\n            var lineDash = this._lineDash;\n            var ctx = this._ctx;\n            var offset = this._dashOffset;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            var dist = mathSqrt$1(dx * dx + dy * dy);\n            var x = x0;\n            var y = y0;\n            var nDash = lineDash.length;\n            var dash;\n            var idx;\n            dx /= dist;\n            dy /= dist;\n            if (offset < 0) {\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            x -= offset * dx;\n            y -= offset * dy;\n            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)\n                || (dx === 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {\n                idx = this._dashIdx;\n                dash = lineDash[idx];\n                x += dx * dash;\n                y += dy * dash;\n                this._dashIdx = (idx + 1) % nDash;\n                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {\n                    continue;\n                }\n                ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin$2(x, x1) : mathMax$2(x, x1), dy >= 0 ? mathMin$2(y, y1) : mathMax$2(y, y1));\n            }\n            dx = x - x1;\n            dy = y - y1;\n            this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);\n        };\n        PathProxy.prototype._dashedBezierTo = function (x1, y1, x2, y2, x3, y3) {\n            var ctx = this._ctx;\n            var dashSum = this._dashSum;\n            var offset = this._dashOffset;\n            var lineDash = this._lineDash;\n            var x0 = this._xi;\n            var y0 = this._yi;\n            var bezierLen = 0;\n            var idx = this._dashIdx;\n            var nDash = lineDash.length;\n            var t;\n            var dx;\n            var dy;\n            var x;\n            var y;\n            var tmpLen = 0;\n            if (offset < 0) {\n                offset = dashSum + offset;\n            }\n            offset %= dashSum;\n            for (t = 0; t < 1; t += 0.1) {\n                dx = cubicAt(x0, x1, x2, x3, t + 0.1)\n                    - cubicAt(x0, x1, x2, x3, t);\n                dy = cubicAt(y0, y1, y2, y3, t + 0.1)\n                    - cubicAt(y0, y1, y2, y3, t);\n                bezierLen += mathSqrt$1(dx * dx + dy * dy);\n            }\n            for (; idx < nDash; idx++) {\n                tmpLen += lineDash[idx];\n                if (tmpLen > offset) {\n                    break;\n                }\n            }\n            t = (tmpLen - offset) / bezierLen;\n            while (t <= 1) {\n                x = cubicAt(x0, x1, x2, x3, t);\n                y = cubicAt(y0, y1, y2, y3, t);\n                idx % 2 ? ctx.moveTo(x, y)\n                    : ctx.lineTo(x, y);\n                t += lineDash[idx] / bezierLen;\n                idx = (idx + 1) % nDash;\n            }\n            (idx % 2 !== 0) && ctx.lineTo(x3, y3);\n            dx = x3 - x;\n            dy = y3 - y;\n            this._dashOffset = -mathSqrt$1(dx * dx + dy * dy);\n        };\n        PathProxy.prototype._dashedQuadraticTo = function (x1, y1, x2, y2) {\n            var x3 = x2;\n            var y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (this._xi + 2 * x1) / 3;\n            y1 = (this._yi + 2 * y1) / 3;\n            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n        };\n        PathProxy.prototype.toStatic = function () {\n            if (!this._saveData) {\n                return;\n            }\n            var data = this.data;\n            if (data instanceof Array) {\n                data.length = this._len;\n                if (hasTypedArray && this._len > 11) {\n                    this.data = new Float32Array(data);\n                }\n            }\n        };\n        PathProxy.prototype.getBoundingRect = function () {\n            min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n            max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n            var data = this.data;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            var i;\n            for (i = 0; i < this._len;) {\n                var cmd = data[i++];\n                var isFirst = i === 1;\n                if (isFirst) {\n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        xi = x0 = data[i++];\n                        yi = y0 = data[i++];\n                        min2[0] = x0;\n                        min2[1] = y0;\n                        max2[0] = x0;\n                        max2[1] = y0;\n                        break;\n                    case CMD.L:\n                        fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.C:\n                        fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.Q:\n                        fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n                        xi = data[i++];\n                        yi = data[i++];\n                        break;\n                    case CMD.A:\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var endAngle = data[i++] + startAngle;\n                        i += 1;\n                        var anticlockwise = !data[i++];\n                        if (isFirst) {\n                            x0 = mathCos$1(startAngle) * rx + cx;\n                            y0 = mathSin$1(startAngle) * ry + cy;\n                        }\n                        fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n                        xi = mathCos$1(endAngle) * rx + cx;\n                        yi = mathSin$1(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n                        break;\n                    case CMD.Z:\n                        xi = x0;\n                        yi = y0;\n                        break;\n                }\n                min(min$1, min$1, min2);\n                max(max$1, max$1, max2);\n            }\n            if (i === 0) {\n                min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;\n            }\n            return new BoundingRect(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);\n        };\n        PathProxy.prototype._calculateLength = function () {\n            var data = this.data;\n            var len = this._len;\n            var ux = this._ux;\n            var uy = this._uy;\n            var xi = 0;\n            var yi = 0;\n            var x0 = 0;\n            var y0 = 0;\n            if (!this._pathSegLen) {\n                this._pathSegLen = [];\n            }\n            var pathSegLen = this._pathSegLen;\n            var pathTotalLen = 0;\n            var segCount = 0;\n            for (var i = 0; i < len;) {\n                var cmd = data[i++];\n                var isFirst = i === 1;\n                if (isFirst) {\n                    xi = data[i];\n                    yi = data[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                var l = -1;\n                switch (cmd) {\n                    case CMD.M:\n                        xi = x0 = data[i++];\n                        yi = y0 = data[i++];\n                        break;\n                    case CMD.L: {\n                        var x2 = data[i++];\n                        var y2 = data[i++];\n                        var dx = x2 - xi;\n                        var dy = y2 - yi;\n                        if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len - 1) {\n                            l = Math.sqrt(dx * dx + dy * dy);\n                            xi = x2;\n                            yi = y2;\n                        }\n                        break;\n                    }\n                    case CMD.C: {\n                        var x1 = data[i++];\n                        var y1 = data[i++];\n                        var x2 = data[i++];\n                        var y2 = data[i++];\n                        var x3 = data[i++];\n                        var y3 = data[i++];\n                        l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);\n                        xi = x3;\n                        yi = y3;\n                        break;\n                    }\n                    case CMD.Q: {\n                        var x1 = data[i++];\n                        var y1 = data[i++];\n                        var x2 = data[i++];\n                        var y2 = data[i++];\n                        l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);\n                        xi = x2;\n                        yi = y2;\n                        break;\n                    }\n                    case CMD.A:\n                        var cx = data[i++];\n                        var cy = data[i++];\n                        var rx = data[i++];\n                        var ry = data[i++];\n                        var startAngle = data[i++];\n                        var delta = data[i++];\n                        var endAngle = delta + startAngle;\n                        i += 1;\n                        var anticlockwise = !data[i++];\n                        if (isFirst) {\n                            x0 = mathCos$1(startAngle) * rx + cx;\n                            y0 = mathSin$1(startAngle) * ry + cy;\n                        }\n                        l = mathMax$2(rx, ry) * mathMin$2(PI2$1, Math.abs(delta));\n                        xi = mathCos$1(endAngle) * rx + cx;\n                        yi = mathSin$1(endAngle) * ry + cy;\n                        break;\n                    case CMD.R: {\n                        x0 = xi = data[i++];\n                        y0 = yi = data[i++];\n                        var width = data[i++];\n                        var height = data[i++];\n                        l = width * 2 + height * 2;\n                        break;\n                    }\n                    case CMD.Z: {\n                        var dx = x0 - xi;\n                        var dy = y0 - yi;\n                        l = Math.sqrt(dx * dx + dy * dy);\n                        xi = x0;\n                        yi = y0;\n                        break;\n                    }\n                }\n                if (l >= 0) {\n                    pathSegLen[segCount++] = l;\n                    pathTotalLen += l;\n                }\n            }\n            this._pathLen = pathTotalLen;\n            return pathTotalLen;\n        };\n        PathProxy.prototype.rebuildPath = function (ctx, percent) {\n            var d = this.data;\n            var ux = this._ux;\n            var uy = this._uy;\n            var len = this._len;\n            var x0;\n            var y0;\n            var xi;\n            var yi;\n            var x;\n            var y;\n            var drawPart = percent < 1;\n            var pathSegLen;\n            var pathTotalLen;\n            var accumLength = 0;\n            var segCount = 0;\n            var displayedLength;\n            if (drawPart) {\n                if (!this._pathSegLen) {\n                    this._calculateLength();\n                }\n                pathSegLen = this._pathSegLen;\n                pathTotalLen = this._pathLen;\n                displayedLength = percent * pathTotalLen;\n                if (!displayedLength) {\n                    return;\n                }\n            }\n            lo: for (var i = 0; i < len;) {\n                var cmd = d[i++];\n                var isFirst = i === 1;\n                if (isFirst) {\n                    xi = d[i];\n                    yi = d[i + 1];\n                    x0 = xi;\n                    y0 = yi;\n                }\n                switch (cmd) {\n                    case CMD.M:\n                        x0 = xi = d[i++];\n                        y0 = yi = d[i++];\n                        ctx.moveTo(xi, yi);\n                        break;\n                    case CMD.L: {\n                        x = d[i++];\n                        y = d[i++];\n                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n                            if (drawPart) {\n                                var l = pathSegLen[segCount++];\n                                if (accumLength + l > displayedLength) {\n                                    var t = (displayedLength - accumLength) / l;\n                                    ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);\n                                    break lo;\n                                }\n                                accumLength += l;\n                            }\n                            ctx.lineTo(x, y);\n                            xi = x;\n                            yi = y;\n                        }\n                        break;\n                    }\n                    case CMD.C: {\n                        var x1 = d[i++];\n                        var y1 = d[i++];\n                        var x2 = d[i++];\n                        var y2 = d[i++];\n                        var x3 = d[i++];\n                        var y3 = d[i++];\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                var t = (displayedLength - accumLength) / l;\n                                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);\n                                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);\n                                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);\n                                break lo;\n                            }\n                            accumLength += l;\n                        }\n                        ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n                        xi = x3;\n                        yi = y3;\n                        break;\n                    }\n                    case CMD.Q: {\n                        var x1 = d[i++];\n                        var y1 = d[i++];\n                        var x2 = d[i++];\n                        var y2 = d[i++];\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                var t = (displayedLength - accumLength) / l;\n                                quadraticSubdivide(xi, x1, x2, t, tmpOutX);\n                                quadraticSubdivide(yi, y1, y2, t, tmpOutY);\n                                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);\n                                break lo;\n                            }\n                            accumLength += l;\n                        }\n                        ctx.quadraticCurveTo(x1, y1, x2, y2);\n                        xi = x2;\n                        yi = y2;\n                        break;\n                    }\n                    case CMD.A:\n                        var cx = d[i++];\n                        var cy = d[i++];\n                        var rx = d[i++];\n                        var ry = d[i++];\n                        var startAngle = d[i++];\n                        var delta = d[i++];\n                        var psi = d[i++];\n                        var anticlockwise = !d[i++];\n                        var r = (rx > ry) ? rx : ry;\n                        var isEllipse = mathAbs(rx - ry) > 1e-3;\n                        var endAngle = startAngle + delta;\n                        var breakBuild = false;\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                endAngle = startAngle + delta * (displayedLength - accumLength) / l;\n                                breakBuild = true;\n                            }\n                            accumLength += l;\n                        }\n                        if (isEllipse && ctx.ellipse) {\n                            ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);\n                        }\n                        else {\n                            ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n                        }\n                        if (breakBuild) {\n                            break lo;\n                        }\n                        if (isFirst) {\n                            x0 = mathCos$1(startAngle) * rx + cx;\n                            y0 = mathSin$1(startAngle) * ry + cy;\n                        }\n                        xi = mathCos$1(endAngle) * rx + cx;\n                        yi = mathSin$1(endAngle) * ry + cy;\n                        break;\n                    case CMD.R:\n                        x0 = xi = d[i];\n                        y0 = yi = d[i + 1];\n                        x = d[i++];\n                        y = d[i++];\n                        var width = d[i++];\n                        var height = d[i++];\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                var d_1 = displayedLength - accumLength;\n                                ctx.moveTo(x, y);\n                                ctx.lineTo(x + mathMin$2(d_1, width), y);\n                                d_1 -= width;\n                                if (d_1 > 0) {\n                                    ctx.lineTo(x + width, y + mathMin$2(d_1, height));\n                                }\n                                d_1 -= height;\n                                if (d_1 > 0) {\n                                    ctx.lineTo(x + mathMax$2(width - d_1, 0), y + height);\n                                }\n                                d_1 -= width;\n                                if (d_1 > 0) {\n                                    ctx.lineTo(x, y + mathMax$2(height - d_1, 0));\n                                }\n                                break lo;\n                            }\n                            accumLength += l;\n                        }\n                        ctx.rect(x, y, width, height);\n                        break;\n                    case CMD.Z:\n                        if (drawPart) {\n                            var l = pathSegLen[segCount++];\n                            if (accumLength + l > displayedLength) {\n                                var t = (displayedLength - accumLength) / l;\n                                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);\n                                break lo;\n                            }\n                            accumLength += l;\n                        }\n                        ctx.closePath();\n                        xi = x0;\n                        yi = y0;\n                }\n            }\n        };\n        PathProxy.CMD = CMD;\n        PathProxy.initDefaultProps = (function () {\n            var proto = PathProxy.prototype;\n            proto._saveData = true;\n            proto._needsDash = false;\n            proto._dashOffset = 0;\n            proto._dashIdx = 0;\n            proto._dashSum = 0;\n            proto._ux = 0;\n            proto._uy = 0;\n        })();\n        return PathProxy;\n    }());\n\n    function containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n        if (lineWidth === 0) {\n            return false;\n        }\n        var _l = lineWidth;\n        var _a = 0;\n        var _b = x0;\n        if ((y > y0 + _l && y > y1 + _l)\n            || (y < y0 - _l && y < y1 - _l)\n            || (x > x0 + _l && x > x1 + _l)\n            || (x < x0 - _l && x < x1 - _l)) {\n            return false;\n        }\n        if (x0 !== x1) {\n            _a = (y0 - y1) / (x0 - x1);\n            _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n        }\n        else {\n            return Math.abs(x - x0) <= _l / 2;\n        }\n        var tmp = _a * x - y + _b;\n        var _s = tmp * tmp / (_a * _a + 1);\n        return _s <= _l / 2 * _l / 2;\n    }\n\n    function containStroke$1(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n        if (lineWidth === 0) {\n            return false;\n        }\n        var _l = lineWidth;\n        if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)\n            || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)\n            || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)\n            || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {\n            return false;\n        }\n        var d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n        return d <= _l / 2;\n    }\n\n    function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n        if (lineWidth === 0) {\n            return false;\n        }\n        var _l = lineWidth;\n        if ((y > y0 + _l && y > y1 + _l && y > y2 + _l)\n            || (y < y0 - _l && y < y1 - _l && y < y2 - _l)\n            || (x > x0 + _l && x > x1 + _l && x > x2 + _l)\n            || (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {\n            return false;\n        }\n        var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n        return d <= _l / 2;\n    }\n\n    var PI2$2 = Math.PI * 2;\n    function normalizeRadian(angle) {\n        angle %= PI2$2;\n        if (angle < 0) {\n            angle += PI2$2;\n        }\n        return angle;\n    }\n\n    var PI2$3 = Math.PI * 2;\n    function containStroke$3(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n        if (lineWidth === 0) {\n            return false;\n        }\n        var _l = lineWidth;\n        x -= cx;\n        y -= cy;\n        var d = Math.sqrt(x * x + y * y);\n        if ((d - _l > r) || (d + _l < r)) {\n            return false;\n        }\n        if (Math.abs(startAngle - endAngle) % PI2$3 < 1e-4) {\n            return true;\n        }\n        if (anticlockwise) {\n            var tmp = startAngle;\n            startAngle = normalizeRadian(endAngle);\n            endAngle = normalizeRadian(tmp);\n        }\n        else {\n            startAngle = normalizeRadian(startAngle);\n            endAngle = normalizeRadian(endAngle);\n        }\n        if (startAngle > endAngle) {\n            endAngle += PI2$3;\n        }\n        var angle = Math.atan2(y, x);\n        if (angle < 0) {\n            angle += PI2$3;\n        }\n        return (angle >= startAngle && angle <= endAngle)\n            || (angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle);\n    }\n\n    function windingLine(x0, y0, x1, y1, x, y) {\n        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {\n            return 0;\n        }\n        if (y1 === y0) {\n            return 0;\n        }\n        var t = (y - y0) / (y1 - y0);\n        var dir = y1 < y0 ? 1 : -1;\n        if (t === 1 || t === 0) {\n            dir = y1 < y0 ? 0.5 : -0.5;\n        }\n        var x_ = t * (x1 - x0) + x0;\n        return x_ === x ? Infinity : x_ > x ? dir : 0;\n    }\n\n    var CMD$1 = PathProxy.CMD;\n    var PI2$4 = Math.PI * 2;\n    var EPSILON$2 = 1e-4;\n    function isAroundEqual(a, b) {\n        return Math.abs(a - b) < EPSILON$2;\n    }\n    var roots = [-1, -1, -1];\n    var extrema = [-1, -1];\n    function swapExtrema() {\n        var tmp = extrema[0];\n        extrema[0] = extrema[1];\n        extrema[1] = tmp;\n    }\n    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n        if ((y > y0 && y > y1 && y > y2 && y > y3)\n            || (y < y0 && y < y1 && y < y2 && y < y3)) {\n            return 0;\n        }\n        var nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var w = 0;\n            var nExtrema = -1;\n            var y0_ = void 0;\n            var y1_ = void 0;\n            for (var i = 0; i < nRoots; i++) {\n                var t = roots[i];\n                var unit = (t === 0 || t === 1) ? 0.5 : 1;\n                var x_ = cubicAt(x0, x1, x2, x3, t);\n                if (x_ < x) {\n                    continue;\n                }\n                if (nExtrema < 0) {\n                    nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);\n                    if (extrema[1] < extrema[0] && nExtrema > 1) {\n                        swapExtrema();\n                    }\n                    y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);\n                    if (nExtrema > 1) {\n                        y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);\n                    }\n                }\n                if (nExtrema === 2) {\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else if (t < extrema[1]) {\n                        w += y1_ < y0_ ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y1_ ? unit : -unit;\n                    }\n                }\n                else {\n                    if (t < extrema[0]) {\n                        w += y0_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y3 < y0_ ? unit : -unit;\n                    }\n                }\n            }\n            return w;\n        }\n    }\n    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n        if ((y > y0 && y > y1 && y > y2)\n            || (y < y0 && y < y1 && y < y2)) {\n            return 0;\n        }\n        var nRoots = quadraticRootAt(y0, y1, y2, y, roots);\n        if (nRoots === 0) {\n            return 0;\n        }\n        else {\n            var t = quadraticExtremum(y0, y1, y2);\n            if (t >= 0 && t <= 1) {\n                var w = 0;\n                var y_ = quadraticAt(y0, y1, y2, t);\n                for (var i = 0; i < nRoots; i++) {\n                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;\n                    var x_ = quadraticAt(x0, x1, x2, roots[i]);\n                    if (x_ < x) {\n                        continue;\n                    }\n                    if (roots[i] < t) {\n                        w += y_ < y0 ? unit : -unit;\n                    }\n                    else {\n                        w += y2 < y_ ? unit : -unit;\n                    }\n                }\n                return w;\n            }\n            else {\n                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;\n                var x_ = quadraticAt(x0, x1, x2, roots[0]);\n                if (x_ < x) {\n                    return 0;\n                }\n                return y2 < y0 ? unit : -unit;\n            }\n        }\n    }\n    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n        y -= cy;\n        if (y > r || y < -r) {\n            return 0;\n        }\n        var tmp = Math.sqrt(r * r - y * y);\n        roots[0] = -tmp;\n        roots[1] = tmp;\n        var dTheta = Math.abs(startAngle - endAngle);\n        if (dTheta < 1e-4) {\n            return 0;\n        }\n        if (dTheta >= PI2$4 - 1e-4) {\n            startAngle = 0;\n            endAngle = PI2$4;\n            var dir = anticlockwise ? 1 : -1;\n            if (x >= roots[0] + cx && x <= roots[1] + cx) {\n                return dir;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (startAngle > endAngle) {\n            var tmp_1 = startAngle;\n            startAngle = endAngle;\n            endAngle = tmp_1;\n        }\n        if (startAngle < 0) {\n            startAngle += PI2$4;\n            endAngle += PI2$4;\n        }\n        var w = 0;\n        for (var i = 0; i < 2; i++) {\n            var x_ = roots[i];\n            if (x_ + cx > x) {\n                var angle = Math.atan2(y, x_);\n                var dir = anticlockwise ? 1 : -1;\n                if (angle < 0) {\n                    angle = PI2$4 + angle;\n                }\n                if ((angle >= startAngle && angle <= endAngle)\n                    || (angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle)) {\n                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n                        dir = -dir;\n                    }\n                    w += dir;\n                }\n            }\n        }\n        return w;\n    }\n    function containPath(path, lineWidth, isStroke, x, y) {\n        var data = path.data;\n        var len = path.len();\n        var w = 0;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        var x1;\n        var y1;\n        for (var i = 0; i < len;) {\n            var cmd = data[i++];\n            var isFirst = i === 1;\n            if (cmd === CMD$1.M && i > 1) {\n                if (!isStroke) {\n                    w += windingLine(xi, yi, x0, y0, x, y);\n                }\n            }\n            if (isFirst) {\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n            }\n            switch (cmd) {\n                case CMD$1.M:\n                    x0 = data[i++];\n                    y0 = data[i++];\n                    xi = x0;\n                    yi = y0;\n                    break;\n                case CMD$1.L:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD$1.C:\n                    if (isStroke) {\n                        if (containStroke$1(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD$1.Q:\n                    if (isStroke) {\n                        if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n                    }\n                    xi = data[i++];\n                    yi = data[i++];\n                    break;\n                case CMD$1.A:\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var theta = data[i++];\n                    var dTheta = data[i++];\n                    i += 1;\n                    var anticlockwise = !!(1 - data[i++]);\n                    x1 = Math.cos(theta) * rx + cx;\n                    y1 = Math.sin(theta) * ry + cy;\n                    if (!isFirst) {\n                        w += windingLine(xi, yi, x1, y1, x, y);\n                    }\n                    else {\n                        x0 = x1;\n                        y0 = y1;\n                    }\n                    var _x = (x - cx) * ry / rx + cx;\n                    if (isStroke) {\n                        if (containStroke$3(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n                    }\n                    xi = Math.cos(theta + dTheta) * rx + cx;\n                    yi = Math.sin(theta + dTheta) * ry + cy;\n                    break;\n                case CMD$1.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    var width = data[i++];\n                    var height = data[i++];\n                    x1 = x0 + width;\n                    y1 = y0 + height;\n                    if (isStroke) {\n                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)\n                            || containStroke(x1, y0, x1, y1, lineWidth, x, y)\n                            || containStroke(x1, y1, x0, y1, lineWidth, x, y)\n                            || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingLine(x1, y0, x1, y1, x, y);\n                        w += windingLine(x0, y1, x0, y0, x, y);\n                    }\n                    break;\n                case CMD$1.Z:\n                    if (isStroke) {\n                        if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n                            return true;\n                        }\n                    }\n                    else {\n                        w += windingLine(xi, yi, x0, y0, x, y);\n                    }\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (!isStroke && !isAroundEqual(yi, y0)) {\n            w += windingLine(xi, yi, x0, y0, x, y) || 0;\n        }\n        return w !== 0;\n    }\n    function contain(pathProxy, x, y) {\n        return containPath(pathProxy, 0, false, x, y);\n    }\n    function containStroke$4(pathProxy, lineWidth, x, y) {\n        return containPath(pathProxy, lineWidth, true, x, y);\n    }\n\n    var DEFAULT_PATH_STYLE = defaults({\n        fill: '#000',\n        stroke: null,\n        strokePercent: 1,\n        fillOpacity: 1,\n        strokeOpacity: 1,\n        lineDashOffset: 0,\n        lineWidth: 1,\n        lineCap: 'butt',\n        miterLimit: 10,\n        strokeNoScale: false,\n        strokeFirst: false\n    }, DEFAULT_COMMON_STYLE);\n    var DEFAULT_PATH_ANIMATION_PROPS = {\n        style: defaults({\n            fill: true,\n            stroke: true,\n            strokePercent: true,\n            fillOpacity: true,\n            strokeOpacity: true,\n            lineDashOffset: true,\n            lineWidth: true,\n            miterLimit: true\n        }, DEFAULT_COMMON_ANIMATION_PROPS.style)\n    };\n    var pathCopyParams = [\n        'x', 'y', 'rotation', 'scaleX', 'scaleY', 'originX', 'originY', 'invisible',\n        'culling', 'z', 'z2', 'zlevel', 'parent'\n    ];\n    var Path = (function (_super) {\n        __extends(Path, _super);\n        function Path(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Path.prototype.update = function () {\n            var _this = this;\n            _super.prototype.update.call(this);\n            var style = this.style;\n            if (style.decal) {\n                var decalEl = this._decalEl\n                    = this._decalEl || new Path();\n                if (decalEl.buildPath === Path.prototype.buildPath) {\n                    decalEl.buildPath = function (ctx) {\n                        _this.buildPath(ctx, _this.shape);\n                    };\n                }\n                decalEl.silent = true;\n                var decalElStyle = decalEl.style;\n                for (var key in style) {\n                    if (decalElStyle[key] !== style[key]) {\n                        decalElStyle[key] = style[key];\n                    }\n                }\n                decalElStyle.fill = style.fill ? style.decal : null;\n                decalElStyle.decal = null;\n                decalElStyle.shadowColor = null;\n                style.strokeFirst && (decalElStyle.stroke = null);\n                for (var i = 0; i < pathCopyParams.length; ++i) {\n                    decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];\n                }\n                decalEl.__dirty |= Element.REDARAW_BIT;\n            }\n            else if (this._decalEl) {\n                this._decalEl = null;\n            }\n        };\n        Path.prototype.getDecalElement = function () {\n            return this._decalEl;\n        };\n        Path.prototype._init = function (props) {\n            var keysArr = keys(props);\n            this.shape = this.getDefaultShape();\n            var defaultStyle = this.getDefaultStyle();\n            if (defaultStyle) {\n                this.useStyle(defaultStyle);\n            }\n            for (var i = 0; i < keysArr.length; i++) {\n                var key = keysArr[i];\n                var value = props[key];\n                if (key === 'style') {\n                    if (!this.style) {\n                        this.useStyle(value);\n                    }\n                    else {\n                        extend(this.style, value);\n                    }\n                }\n                else if (key === 'shape') {\n                    extend(this.shape, value);\n                }\n                else {\n                    _super.prototype.attrKV.call(this, key, value);\n                }\n            }\n            if (!this.style) {\n                this.useStyle({});\n            }\n        };\n        Path.prototype.getDefaultStyle = function () {\n            return null;\n        };\n        Path.prototype.getDefaultShape = function () {\n            return {};\n        };\n        Path.prototype.canBeInsideText = function () {\n            return this.hasFill();\n        };\n        Path.prototype.getInsideTextFill = function () {\n            var pathFill = this.style.fill;\n            if (pathFill !== 'none') {\n                if (isString(pathFill)) {\n                    var fillLum = lum(pathFill, 0);\n                    if (fillLum > 0.5) {\n                        return DARK_LABEL_COLOR;\n                    }\n                    else if (fillLum > 0.2) {\n                        return LIGHTER_LABEL_COLOR;\n                    }\n                    return LIGHT_LABEL_COLOR;\n                }\n                else if (pathFill) {\n                    return LIGHT_LABEL_COLOR;\n                }\n            }\n            return DARK_LABEL_COLOR;\n        };\n        Path.prototype.getInsideTextStroke = function (textFill) {\n            var pathFill = this.style.fill;\n            if (isString(pathFill)) {\n                var zr = this.__zr;\n                var isDarkMode = !!(zr && zr.isDarkMode());\n                var isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;\n                if (isDarkMode === isDarkLabel) {\n                    return pathFill;\n                }\n            }\n        };\n        Path.prototype.buildPath = function (ctx, shapeCfg, inBundle) { };\n        Path.prototype.pathUpdated = function () {\n            this.__dirty &= ~Path.SHAPE_CHANGED_BIT;\n        };\n        Path.prototype.createPathProxy = function () {\n            this.path = new PathProxy(false);\n        };\n        Path.prototype.hasStroke = function () {\n            var style = this.style;\n            var stroke = style.stroke;\n            return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));\n        };\n        Path.prototype.hasFill = function () {\n            var style = this.style;\n            var fill = style.fill;\n            return fill != null && fill !== 'none';\n        };\n        Path.prototype.getBoundingRect = function () {\n            var rect = this._rect;\n            var style = this.style;\n            var needsUpdateRect = !rect;\n            if (needsUpdateRect) {\n                var firstInvoke = false;\n                if (!this.path) {\n                    firstInvoke = true;\n                    this.createPathProxy();\n                }\n                var path = this.path;\n                if (firstInvoke || (this.__dirty & Path.SHAPE_CHANGED_BIT)) {\n                    path.beginPath();\n                    this.buildPath(path, this.shape, false);\n                    this.pathUpdated();\n                }\n                rect = path.getBoundingRect();\n            }\n            this._rect = rect;\n            if (this.hasStroke() && this.path && this.path.len() > 0) {\n                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n                if (this.__dirty || needsUpdateRect) {\n                    rectWithStroke.copy(rect);\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    var w = style.lineWidth;\n                    if (!this.hasFill()) {\n                        var strokeContainThreshold = this.strokeContainThreshold;\n                        w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);\n                    }\n                    if (lineScale > 1e-10) {\n                        rectWithStroke.width += w / lineScale;\n                        rectWithStroke.height += w / lineScale;\n                        rectWithStroke.x -= w / lineScale / 2;\n                        rectWithStroke.y -= w / lineScale / 2;\n                    }\n                }\n                return rectWithStroke;\n            }\n            return rect;\n        };\n        Path.prototype.contain = function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            var style = this.style;\n            x = localPos[0];\n            y = localPos[1];\n            if (rect.contain(x, y)) {\n                var pathProxy = this.path;\n                if (this.hasStroke()) {\n                    var lineWidth = style.lineWidth;\n                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;\n                    if (lineScale > 1e-10) {\n                        if (!this.hasFill()) {\n                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n                        }\n                        if (containStroke$4(pathProxy, lineWidth / lineScale, x, y)) {\n                            return true;\n                        }\n                    }\n                }\n                if (this.hasFill()) {\n                    return contain(pathProxy, x, y);\n                }\n            }\n            return false;\n        };\n        Path.prototype.dirtyShape = function () {\n            this.__dirty |= Path.SHAPE_CHANGED_BIT;\n            if (this._rect) {\n                this._rect = null;\n            }\n            if (this._decalEl) {\n                this._decalEl.dirtyShape();\n            }\n            this.markRedraw();\n        };\n        Path.prototype.dirty = function () {\n            this.dirtyStyle();\n            this.dirtyShape();\n        };\n        Path.prototype.animateShape = function (loop) {\n            return this.animate('shape', loop);\n        };\n        Path.prototype.updateDuringAnimation = function (targetKey) {\n            if (targetKey === 'style') {\n                this.dirtyStyle();\n            }\n            else if (targetKey === 'shape') {\n                this.dirtyShape();\n            }\n            else {\n                this.markRedraw();\n            }\n        };\n        Path.prototype.attrKV = function (key, value) {\n            if (key === 'shape') {\n                this.setShape(value);\n            }\n            else {\n                _super.prototype.attrKV.call(this, key, value);\n            }\n        };\n        Path.prototype.setShape = function (keyOrObj, value) {\n            var shape = this.shape;\n            if (!shape) {\n                shape = this.shape = {};\n            }\n            if (typeof keyOrObj === 'string') {\n                shape[keyOrObj] = value;\n            }\n            else {\n                extend(shape, keyOrObj);\n            }\n            this.dirtyShape();\n            return this;\n        };\n        Path.prototype.shapeChanged = function () {\n            return !!(this.__dirty & Path.SHAPE_CHANGED_BIT);\n        };\n        Path.prototype.createStyle = function (obj) {\n            return createObject(DEFAULT_PATH_STYLE, obj);\n        };\n        Path.prototype._innerSaveToNormal = function (toState) {\n            _super.prototype._innerSaveToNormal.call(this, toState);\n            var normalState = this._normalState;\n            if (toState.shape && !normalState.shape) {\n                normalState.shape = extend({}, this.shape);\n            }\n        };\n        Path.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {\n            _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);\n            var needsRestoreToNormal = !(state && keepCurrentStates);\n            var targetShape;\n            if (state && state.shape) {\n                if (transition) {\n                    if (keepCurrentStates) {\n                        targetShape = state.shape;\n                    }\n                    else {\n                        targetShape = extend({}, normalState.shape);\n                        extend(targetShape, state.shape);\n                    }\n                }\n                else {\n                    targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);\n                    extend(targetShape, state.shape);\n                }\n            }\n            else if (needsRestoreToNormal) {\n                targetShape = normalState.shape;\n            }\n            if (targetShape) {\n                if (transition) {\n                    this.shape = extend({}, this.shape);\n                    var targetShapePrimaryProps = {};\n                    var shapeKeys = keys(targetShape);\n                    for (var i = 0; i < shapeKeys.length; i++) {\n                        var key = shapeKeys[i];\n                        if (typeof targetShape[key] === 'object') {\n                            this.shape[key] = targetShape[key];\n                        }\n                        else {\n                            targetShapePrimaryProps[key] = targetShape[key];\n                        }\n                    }\n                    this._transitionState(stateName, {\n                        shape: targetShapePrimaryProps\n                    }, animationCfg);\n                }\n                else {\n                    this.shape = targetShape;\n                    this.dirtyShape();\n                }\n            }\n        };\n        Path.prototype._mergeStates = function (states) {\n            var mergedState = _super.prototype._mergeStates.call(this, states);\n            var mergedShape;\n            for (var i = 0; i < states.length; i++) {\n                var state = states[i];\n                if (state.shape) {\n                    mergedShape = mergedShape || {};\n                    this._mergeStyle(mergedShape, state.shape);\n                }\n            }\n            if (mergedShape) {\n                mergedState.shape = mergedShape;\n            }\n            return mergedState;\n        };\n        Path.prototype.getAnimationStyleProps = function () {\n            return DEFAULT_PATH_ANIMATION_PROPS;\n        };\n        Path.prototype.isZeroArea = function () {\n            return false;\n        };\n        Path.extend = function (defaultProps) {\n            var Sub = (function (_super) {\n                __extends(Sub, _super);\n                function Sub(opts) {\n                    var _this = _super.call(this, opts) || this;\n                    defaultProps.init && defaultProps.init.call(_this, opts);\n                    return _this;\n                }\n                Sub.prototype.getDefaultStyle = function () {\n                    return clone(defaultProps.style);\n                };\n                Sub.prototype.getDefaultShape = function () {\n                    return clone(defaultProps.shape);\n                };\n                return Sub;\n            }(Path));\n            for (var key in defaultProps) {\n                if (typeof defaultProps[key] === 'function') {\n                    Sub.prototype[key] = defaultProps[key];\n                }\n            }\n            return Sub;\n        };\n        Path.SHAPE_CHANGED_BIT = 4;\n        Path.initDefaultProps = (function () {\n            var pathProto = Path.prototype;\n            pathProto.type = 'path';\n            pathProto.strokeContainThreshold = 5;\n            pathProto.segmentIgnoreThreshold = 0;\n            pathProto.subPixelOptimize = false;\n            pathProto.autoBatch = false;\n            pathProto.__dirty = Element.REDARAW_BIT | Displayable.STYLE_CHANGED_BIT | Path.SHAPE_CHANGED_BIT;\n        })();\n        return Path;\n    }(Displayable));\n\n    var DEFAULT_TSPAN_STYLE = defaults({\n        strokeFirst: true,\n        font: DEFAULT_FONT,\n        x: 0,\n        y: 0,\n        textAlign: 'left',\n        textBaseline: 'top',\n        miterLimit: 2\n    }, DEFAULT_PATH_STYLE);\n    var TSpan = (function (_super) {\n        __extends(TSpan, _super);\n        function TSpan() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TSpan.prototype.hasStroke = function () {\n            var style = this.style;\n            var stroke = style.stroke;\n            return stroke != null && stroke !== 'none' && style.lineWidth > 0;\n        };\n        TSpan.prototype.hasFill = function () {\n            var style = this.style;\n            var fill = style.fill;\n            return fill != null && fill !== 'none';\n        };\n        TSpan.prototype.createStyle = function (obj) {\n            return createObject(DEFAULT_TSPAN_STYLE, obj);\n        };\n        TSpan.prototype.setBoundingRect = function (rect) {\n            this._rect = rect;\n        };\n        TSpan.prototype.getBoundingRect = function () {\n            var style = this.style;\n            if (!this._rect) {\n                var text = style.text;\n                text != null ? (text += '') : (text = '');\n                var rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);\n                rect.x += style.x || 0;\n                rect.y += style.y || 0;\n                if (this.hasStroke()) {\n                    var w = style.lineWidth;\n                    rect.x -= w / 2;\n                    rect.y -= w / 2;\n                    rect.width += w;\n                    rect.height += w;\n                }\n                this._rect = rect;\n            }\n            return this._rect;\n        };\n        TSpan.initDefaultProps = (function () {\n            var tspanProto = TSpan.prototype;\n            tspanProto.dirtyRectTolerance = 10;\n        })();\n        return TSpan;\n    }(Displayable));\n    TSpan.prototype.type = 'tspan';\n\n    var DEFAULT_IMAGE_STYLE = defaults({\n        x: 0,\n        y: 0\n    }, DEFAULT_COMMON_STYLE);\n    var DEFAULT_IMAGE_ANIMATION_PROPS = {\n        style: defaults({\n            x: true,\n            y: true,\n            width: true,\n            height: true,\n            sx: true,\n            sy: true,\n            sWidth: true,\n            sHeight: true\n        }, DEFAULT_COMMON_ANIMATION_PROPS.style)\n    };\n    function isImageLike(source) {\n        return !!(source\n            && typeof source !== 'string'\n            && source.width && source.height);\n    }\n    var ZRImage = (function (_super) {\n        __extends(ZRImage, _super);\n        function ZRImage() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ZRImage.prototype.createStyle = function (obj) {\n            return createObject(DEFAULT_IMAGE_STYLE, obj);\n        };\n        ZRImage.prototype._getSize = function (dim) {\n            var style = this.style;\n            var size = style[dim];\n            if (size != null) {\n                return size;\n            }\n            var imageSource = isImageLike(style.image)\n                ? style.image : this.__image;\n            if (!imageSource) {\n                return 0;\n            }\n            var otherDim = dim === 'width' ? 'height' : 'width';\n            var otherDimSize = style[otherDim];\n            if (otherDimSize == null) {\n                return imageSource[dim];\n            }\n            else {\n                return imageSource[dim] / imageSource[otherDim] * otherDimSize;\n            }\n        };\n        ZRImage.prototype.getWidth = function () {\n            return this._getSize('width');\n        };\n        ZRImage.prototype.getHeight = function () {\n            return this._getSize('height');\n        };\n        ZRImage.prototype.getAnimationStyleProps = function () {\n            return DEFAULT_IMAGE_ANIMATION_PROPS;\n        };\n        ZRImage.prototype.getBoundingRect = function () {\n            var style = this.style;\n            if (!this._rect) {\n                this._rect = new BoundingRect(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());\n            }\n            return this._rect;\n        };\n        return ZRImage;\n    }(Displayable));\n    ZRImage.prototype.type = 'image';\n\n    function buildPath(ctx, shape) {\n        var x = shape.x;\n        var y = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        var r = shape.r;\n        var r1;\n        var r2;\n        var r3;\n        var r4;\n        if (width < 0) {\n            x = x + width;\n            width = -width;\n        }\n        if (height < 0) {\n            y = y + height;\n            height = -height;\n        }\n        if (typeof r === 'number') {\n            r1 = r2 = r3 = r4 = r;\n        }\n        else if (r instanceof Array) {\n            if (r.length === 1) {\n                r1 = r2 = r3 = r4 = r[0];\n            }\n            else if (r.length === 2) {\n                r1 = r3 = r[0];\n                r2 = r4 = r[1];\n            }\n            else if (r.length === 3) {\n                r1 = r[0];\n                r2 = r4 = r[1];\n                r3 = r[2];\n            }\n            else {\n                r1 = r[0];\n                r2 = r[1];\n                r3 = r[2];\n                r4 = r[3];\n            }\n        }\n        else {\n            r1 = r2 = r3 = r4 = 0;\n        }\n        var total;\n        if (r1 + r2 > width) {\n            total = r1 + r2;\n            r1 *= width / total;\n            r2 *= width / total;\n        }\n        if (r3 + r4 > width) {\n            total = r3 + r4;\n            r3 *= width / total;\n            r4 *= width / total;\n        }\n        if (r2 + r3 > height) {\n            total = r2 + r3;\n            r2 *= height / total;\n            r3 *= height / total;\n        }\n        if (r1 + r4 > height) {\n            total = r1 + r4;\n            r1 *= height / total;\n            r4 *= height / total;\n        }\n        ctx.moveTo(x + r1, y);\n        ctx.lineTo(x + width - r2, y);\n        r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n        ctx.lineTo(x + width, y + height - r3);\n        r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n        ctx.lineTo(x + r4, y + height);\n        r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n        ctx.lineTo(x, y + r1);\n        r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n    }\n\n    var round$1 = Math.round;\n    function subPixelOptimizeLine(outputShape, inputShape, style) {\n        if (!inputShape) {\n            return;\n        }\n        var x1 = inputShape.x1;\n        var x2 = inputShape.x2;\n        var y1 = inputShape.y1;\n        var y2 = inputShape.y2;\n        outputShape.x1 = x1;\n        outputShape.x2 = x2;\n        outputShape.y1 = y1;\n        outputShape.y2 = y2;\n        var lineWidth = style && style.lineWidth;\n        if (!lineWidth) {\n            return outputShape;\n        }\n        if (round$1(x1 * 2) === round$1(x2 * 2)) {\n            outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n        }\n        if (round$1(y1 * 2) === round$1(y2 * 2)) {\n            outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n        }\n        return outputShape;\n    }\n    function subPixelOptimizeRect(outputShape, inputShape, style) {\n        if (!inputShape) {\n            return;\n        }\n        var originX = inputShape.x;\n        var originY = inputShape.y;\n        var originWidth = inputShape.width;\n        var originHeight = inputShape.height;\n        outputShape.x = originX;\n        outputShape.y = originY;\n        outputShape.width = originWidth;\n        outputShape.height = originHeight;\n        var lineWidth = style && style.lineWidth;\n        if (!lineWidth) {\n            return outputShape;\n        }\n        outputShape.x = subPixelOptimize(originX, lineWidth, true);\n        outputShape.y = subPixelOptimize(originY, lineWidth, true);\n        outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n        outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n        return outputShape;\n    }\n    function subPixelOptimize(position, lineWidth, positiveOrNegative) {\n        if (!lineWidth) {\n            return position;\n        }\n        var doubledPosition = round$1(position * 2);\n        return (doubledPosition + round$1(lineWidth)) % 2 === 0\n            ? doubledPosition / 2\n            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n    }\n\n    var RectShape = (function () {\n        function RectShape() {\n            this.x = 0;\n            this.y = 0;\n            this.width = 0;\n            this.height = 0;\n        }\n        return RectShape;\n    }());\n    var subPixelOptimizeOutputShape = {};\n    var Rect = (function (_super) {\n        __extends(Rect, _super);\n        function Rect(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Rect.prototype.getDefaultShape = function () {\n            return new RectShape();\n        };\n        Rect.prototype.buildPath = function (ctx, shape) {\n            var x;\n            var y;\n            var width;\n            var height;\n            if (this.subPixelOptimize) {\n                var optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);\n                x = optimizedShape.x;\n                y = optimizedShape.y;\n                width = optimizedShape.width;\n                height = optimizedShape.height;\n                optimizedShape.r = shape.r;\n                shape = optimizedShape;\n            }\n            else {\n                x = shape.x;\n                y = shape.y;\n                width = shape.width;\n                height = shape.height;\n            }\n            if (!shape.r) {\n                ctx.rect(x, y, width, height);\n            }\n            else {\n                buildPath(ctx, shape);\n            }\n        };\n        Rect.prototype.isZeroArea = function () {\n            return !this.shape.width || !this.shape.height;\n        };\n        return Rect;\n    }(Path));\n    Rect.prototype.type = 'rect';\n\n    var DEFAULT_RICH_TEXT_COLOR = {\n        fill: '#000'\n    };\n    var DEFAULT_STROKE_LINE_WIDTH = 2;\n    var DEFAULT_TEXT_ANIMATION_PROPS = {\n        style: defaults({\n            fill: true,\n            stroke: true,\n            fillOpacity: true,\n            strokeOpacity: true,\n            lineWidth: true,\n            fontSize: true,\n            lineHeight: true,\n            width: true,\n            height: true,\n            textShadowColor: true,\n            textShadowBlur: true,\n            textShadowOffsetX: true,\n            textShadowOffsetY: true,\n            backgroundColor: true,\n            padding: true,\n            borderColor: true,\n            borderWidth: true,\n            borderRadius: true\n        }, DEFAULT_COMMON_ANIMATION_PROPS.style)\n    };\n    var ZRText = (function (_super) {\n        __extends(ZRText, _super);\n        function ZRText(opts) {\n            var _this = _super.call(this) || this;\n            _this.type = 'text';\n            _this._children = [];\n            _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;\n            _this.attr(opts);\n            return _this;\n        }\n        ZRText.prototype.childrenRef = function () {\n            return this._children;\n        };\n        ZRText.prototype.update = function () {\n            if (this.styleChanged()) {\n                this._updateSubTexts();\n            }\n            for (var i = 0; i < this._children.length; i++) {\n                var child = this._children[i];\n                child.zlevel = this.zlevel;\n                child.z = this.z;\n                child.z2 = this.z2;\n                child.culling = this.culling;\n                child.cursor = this.cursor;\n                child.invisible = this.invisible;\n            }\n            var attachedTransform = this.attachedTransform;\n            if (attachedTransform) {\n                attachedTransform.updateTransform();\n                var m = attachedTransform.transform;\n                if (m) {\n                    this.transform = this.transform || [];\n                    copy$1(this.transform, m);\n                }\n                else {\n                    this.transform = null;\n                }\n            }\n            else {\n                _super.prototype.update.call(this);\n            }\n        };\n        ZRText.prototype.getComputedTransform = function () {\n            if (this.__hostTarget) {\n                this.__hostTarget.getComputedTransform();\n                this.__hostTarget.updateInnerText(true);\n            }\n            return this.attachedTransform ? this.attachedTransform.getComputedTransform()\n                : _super.prototype.getComputedTransform.call(this);\n        };\n        ZRText.prototype._updateSubTexts = function () {\n            this._childCursor = 0;\n            normalizeTextStyle(this.style);\n            this.style.rich\n                ? this._updateRichTexts()\n                : this._updatePlainTexts();\n            this._children.length = this._childCursor;\n            this.styleUpdated();\n        };\n        ZRText.prototype.addSelfToZr = function (zr) {\n            _super.prototype.addSelfToZr.call(this, zr);\n            for (var i = 0; i < this._children.length; i++) {\n                this._children[i].__zr = zr;\n            }\n        };\n        ZRText.prototype.removeSelfFromZr = function (zr) {\n            _super.prototype.removeSelfFromZr.call(this, zr);\n            for (var i = 0; i < this._children.length; i++) {\n                this._children[i].__zr = null;\n            }\n        };\n        ZRText.prototype.getBoundingRect = function () {\n            if (this.styleChanged()) {\n                this._updateSubTexts();\n            }\n            if (!this._rect) {\n                var tmpRect = new BoundingRect(0, 0, 0, 0);\n                var children = this._children;\n                var tmpMat = [];\n                var rect = null;\n                for (var i = 0; i < children.length; i++) {\n                    var child = children[i];\n                    var childRect = child.getBoundingRect();\n                    var transform = child.getLocalTransform(tmpMat);\n                    if (transform) {\n                        tmpRect.copy(childRect);\n                        tmpRect.applyTransform(transform);\n                        rect = rect || tmpRect.clone();\n                        rect.union(tmpRect);\n                    }\n                    else {\n                        rect = rect || childRect.clone();\n                        rect.union(childRect);\n                    }\n                }\n                this._rect = rect || tmpRect;\n            }\n            return this._rect;\n        };\n        ZRText.prototype.setDefaultTextStyle = function (defaultTextStyle) {\n            this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;\n        };\n        ZRText.prototype.setTextContent = function (textContent) {\n            throw new Error('Can\\'t attach text on another text');\n        };\n        ZRText.prototype._mergeStyle = function (targetStyle, sourceStyle) {\n            if (!sourceStyle) {\n                return targetStyle;\n            }\n            var sourceRich = sourceStyle.rich;\n            var targetRich = targetStyle.rich || (sourceRich && {});\n            extend(targetStyle, sourceStyle);\n            if (sourceRich && targetRich) {\n                this._mergeRich(targetRich, sourceRich);\n                targetStyle.rich = targetRich;\n            }\n            else if (targetRich) {\n                targetStyle.rich = targetRich;\n            }\n            return targetStyle;\n        };\n        ZRText.prototype._mergeRich = function (targetRich, sourceRich) {\n            var richNames = keys(sourceRich);\n            for (var i = 0; i < richNames.length; i++) {\n                var richName = richNames[i];\n                targetRich[richName] = targetRich[richName] || {};\n                extend(targetRich[richName], sourceRich[richName]);\n            }\n        };\n        ZRText.prototype.getAnimationStyleProps = function () {\n            return DEFAULT_TEXT_ANIMATION_PROPS;\n        };\n        ZRText.prototype._getOrCreateChild = function (Ctor) {\n            var child = this._children[this._childCursor];\n            if (!child || !(child instanceof Ctor)) {\n                child = new Ctor();\n            }\n            this._children[this._childCursor++] = child;\n            child.__zr = this.__zr;\n            child.parent = this;\n            return child;\n        };\n        ZRText.prototype._updatePlainTexts = function () {\n            var style = this.style;\n            var textFont = style.font || DEFAULT_FONT;\n            var textPadding = style.padding;\n            var text = getStyleText(style);\n            var contentBlock = parsePlainText(text, style);\n            var needDrawBg = needDrawBackground(style);\n            var bgColorDrawn = !!(style.backgroundColor);\n            var outerHeight = contentBlock.outerHeight;\n            var textLines = contentBlock.lines;\n            var lineHeight = contentBlock.lineHeight;\n            var defaultStyle = this._defaultStyle;\n            var baseX = style.x || 0;\n            var baseY = style.y || 0;\n            var textAlign = style.align || defaultStyle.align || 'left';\n            var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || 'top';\n            var textX = baseX;\n            var textY = adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);\n            if (needDrawBg || textPadding) {\n                var outerWidth_1 = contentBlock.width;\n                textPadding && (outerWidth_1 += textPadding[1] + textPadding[3]);\n                var boxX = adjustTextX(baseX, outerWidth_1, textAlign);\n                var boxY = adjustTextY(baseY, outerHeight, verticalAlign);\n                needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth_1, outerHeight);\n            }\n            textY += lineHeight / 2;\n            if (textPadding) {\n                textX = getTextXForPadding(baseX, textAlign, textPadding);\n                if (verticalAlign === 'top') {\n                    textY += textPadding[0];\n                }\n                else if (verticalAlign === 'bottom') {\n                    textY -= textPadding[2];\n                }\n            }\n            var defaultLineWidth = 0;\n            var useDefaultFill = false;\n            var textFill = getFill('fill' in style\n                ? style.fill\n                : (useDefaultFill = true, defaultStyle.fill));\n            var textStroke = getStroke('stroke' in style\n                ? style.stroke\n                : (!bgColorDrawn\n                    && (!defaultStyle.autoStroke || useDefaultFill))\n                    ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)\n                    : null);\n            var hasShadow = style.textShadowBlur > 0;\n            var fixedBoundingRect = style.width != null\n                && (style.overflow === 'truncate' || style.overflow === 'break' || style.overflow === 'breakAll');\n            var calculatedLineHeight = contentBlock.calculatedLineHeight;\n            for (var i = 0; i < textLines.length; i++) {\n                var el = this._getOrCreateChild(TSpan);\n                var subElStyle = el.createStyle();\n                el.useStyle(subElStyle);\n                subElStyle.text = textLines[i];\n                subElStyle.x = textX;\n                subElStyle.y = textY;\n                if (textAlign) {\n                    subElStyle.textAlign = textAlign;\n                }\n                subElStyle.textBaseline = 'middle';\n                subElStyle.opacity = style.opacity;\n                subElStyle.strokeFirst = true;\n                if (hasShadow) {\n                    subElStyle.shadowBlur = style.textShadowBlur || 0;\n                    subElStyle.shadowColor = style.textShadowColor || 'transparent';\n                    subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;\n                    subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;\n                }\n                if (textStroke) {\n                    subElStyle.stroke = textStroke;\n                    subElStyle.lineWidth = style.lineWidth || defaultLineWidth;\n                    subElStyle.lineDash = style.lineDash;\n                    subElStyle.lineDashOffset = style.lineDashOffset || 0;\n                }\n                if (textFill) {\n                    subElStyle.fill = textFill;\n                }\n                subElStyle.font = textFont;\n                textY += lineHeight;\n                if (fixedBoundingRect) {\n                    el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), style.width, calculatedLineHeight));\n                }\n            }\n        };\n        ZRText.prototype._updateRichTexts = function () {\n            var style = this.style;\n            var text = getStyleText(style);\n            var contentBlock = parseRichText(text, style);\n            var contentWidth = contentBlock.width;\n            var outerWidth = contentBlock.outerWidth;\n            var outerHeight = contentBlock.outerHeight;\n            var textPadding = style.padding;\n            var baseX = style.x || 0;\n            var baseY = style.y || 0;\n            var defaultStyle = this._defaultStyle;\n            var textAlign = style.align || defaultStyle.align;\n            var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;\n            var boxX = adjustTextX(baseX, outerWidth, textAlign);\n            var boxY = adjustTextY(baseY, outerHeight, verticalAlign);\n            var xLeft = boxX;\n            var lineTop = boxY;\n            if (textPadding) {\n                xLeft += textPadding[3];\n                lineTop += textPadding[0];\n            }\n            var xRight = xLeft + contentWidth;\n            if (needDrawBackground(style)) {\n                this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);\n            }\n            var bgColorDrawn = !!(style.backgroundColor);\n            for (var i = 0; i < contentBlock.lines.length; i++) {\n                var line = contentBlock.lines[i];\n                var tokens = line.tokens;\n                var tokenCount = tokens.length;\n                var lineHeight = line.lineHeight;\n                var remainedWidth = line.width;\n                var leftIndex = 0;\n                var lineXLeft = xLeft;\n                var lineXRight = xRight;\n                var rightIndex = tokenCount - 1;\n                var token = void 0;\n                while (leftIndex < tokenCount\n                    && (token = tokens[leftIndex], !token.align || token.align === 'left')) {\n                    this._placeToken(token, style, lineHeight, lineTop, lineXLeft, 'left', bgColorDrawn);\n                    remainedWidth -= token.width;\n                    lineXLeft += token.width;\n                    leftIndex++;\n                }\n                while (rightIndex >= 0\n                    && (token = tokens[rightIndex], token.align === 'right')) {\n                    this._placeToken(token, style, lineHeight, lineTop, lineXRight, 'right', bgColorDrawn);\n                    remainedWidth -= token.width;\n                    lineXRight -= token.width;\n                    rightIndex--;\n                }\n                lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;\n                while (leftIndex <= rightIndex) {\n                    token = tokens[leftIndex];\n                    this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center', bgColorDrawn);\n                    lineXLeft += token.width;\n                    leftIndex++;\n                }\n                lineTop += lineHeight;\n            }\n        };\n        ZRText.prototype._placeToken = function (token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {\n            var tokenStyle = style.rich[token.styleName] || {};\n            tokenStyle.text = token.text;\n            var verticalAlign = token.verticalAlign;\n            var y = lineTop + lineHeight / 2;\n            if (verticalAlign === 'top') {\n                y = lineTop + token.height / 2;\n            }\n            else if (verticalAlign === 'bottom') {\n                y = lineTop + lineHeight - token.height / 2;\n            }\n            var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);\n            needDrawBg && this._renderBackground(tokenStyle, style, textAlign === 'right'\n                ? x - token.width\n                : textAlign === 'center'\n                    ? x - token.width / 2\n                    : x, y - token.height / 2, token.width, token.height);\n            var bgColorDrawn = !!tokenStyle.backgroundColor;\n            var textPadding = token.textPadding;\n            if (textPadding) {\n                x = getTextXForPadding(x, textAlign, textPadding);\n                y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;\n            }\n            var el = this._getOrCreateChild(TSpan);\n            var subElStyle = el.createStyle();\n            el.useStyle(subElStyle);\n            var defaultStyle = this._defaultStyle;\n            var useDefaultFill = false;\n            var defaultLineWidth = 0;\n            var textFill = getStroke('fill' in tokenStyle ? tokenStyle.fill\n                : 'fill' in style ? style.fill\n                    : (useDefaultFill = true, defaultStyle.fill));\n            var textStroke = getStroke('stroke' in tokenStyle ? tokenStyle.stroke\n                : 'stroke' in style ? style.stroke\n                    : (!bgColorDrawn\n                        && !parentBgColorDrawn\n                        && (!defaultStyle.autoStroke || useDefaultFill)) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)\n                        : null);\n            var hasShadow = tokenStyle.textShadowBlur > 0\n                || style.textShadowBlur > 0;\n            subElStyle.text = token.text;\n            subElStyle.x = x;\n            subElStyle.y = y;\n            if (hasShadow) {\n                subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;\n                subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || 'transparent';\n                subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;\n                subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;\n            }\n            subElStyle.textAlign = textAlign;\n            subElStyle.textBaseline = 'middle';\n            subElStyle.font = token.font || DEFAULT_FONT;\n            subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);\n            if (textStroke) {\n                subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);\n                subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);\n                subElStyle.lineDashOffset = style.lineDashOffset || 0;\n                subElStyle.stroke = textStroke;\n            }\n            if (textFill) {\n                subElStyle.fill = textFill;\n            }\n            var textWidth = token.contentWidth;\n            var textHeight = token.contentHeight;\n            el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));\n        };\n        ZRText.prototype._renderBackground = function (style, topStyle, x, y, width, height) {\n            var textBackgroundColor = style.backgroundColor;\n            var textBorderWidth = style.borderWidth;\n            var textBorderColor = style.borderColor;\n            var isPlainBg = isString(textBackgroundColor);\n            var textBorderRadius = style.borderRadius;\n            var self = this;\n            var rectEl;\n            var imgEl;\n            if (isPlainBg || (textBorderWidth && textBorderColor)) {\n                rectEl = this._getOrCreateChild(Rect);\n                rectEl.useStyle(rectEl.createStyle());\n                rectEl.style.fill = null;\n                var rectShape = rectEl.shape;\n                rectShape.x = x;\n                rectShape.y = y;\n                rectShape.width = width;\n                rectShape.height = height;\n                rectShape.r = textBorderRadius;\n                rectEl.dirtyShape();\n            }\n            if (isPlainBg) {\n                var rectStyle = rectEl.style;\n                rectStyle.fill = textBackgroundColor || null;\n                rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);\n            }\n            else if (textBackgroundColor && textBackgroundColor.image) {\n                imgEl = this._getOrCreateChild(ZRImage);\n                imgEl.onload = function () {\n                    self.dirtyStyle();\n                };\n                var imgStyle = imgEl.style;\n                imgStyle.image = textBackgroundColor.image;\n                imgStyle.x = x;\n                imgStyle.y = y;\n                imgStyle.width = width;\n                imgStyle.height = height;\n            }\n            if (textBorderWidth && textBorderColor) {\n                var rectStyle = rectEl.style;\n                rectStyle.lineWidth = textBorderWidth;\n                rectStyle.stroke = textBorderColor;\n                rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);\n                rectStyle.lineDash = style.borderDash;\n                rectStyle.lineDashOffset = style.borderDashOffset || 0;\n                rectEl.strokeContainThreshold = 0;\n                if (rectEl.hasFill() && rectEl.hasStroke()) {\n                    rectStyle.strokeFirst = true;\n                    rectStyle.lineWidth *= 2;\n                }\n            }\n            var commonStyle = (rectEl || imgEl).style;\n            commonStyle.shadowBlur = style.shadowBlur || 0;\n            commonStyle.shadowColor = style.shadowColor || 'transparent';\n            commonStyle.shadowOffsetX = style.shadowOffsetX || 0;\n            commonStyle.shadowOffsetY = style.shadowOffsetY || 0;\n            commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);\n        };\n        ZRText.makeFont = function (style) {\n            var font = '';\n            if (style.fontSize || style.fontFamily || style.fontWeight) {\n                var fontSize = '';\n                if (typeof style.fontSize === 'string'\n                    && (style.fontSize.indexOf('px') !== -1\n                        || style.fontSize.indexOf('rem') !== -1\n                        || style.fontSize.indexOf('em') !== -1)) {\n                    fontSize = style.fontSize;\n                }\n                else if (!isNaN(+style.fontSize)) {\n                    fontSize = style.fontSize + 'px';\n                }\n                else {\n                    fontSize = '12px';\n                }\n                font = [\n                    style.fontStyle,\n                    style.fontWeight,\n                    fontSize,\n                    style.fontFamily || 'sans-serif'\n                ].join(' ');\n            }\n            return font && trim(font) || style.textFont || style.font;\n        };\n        return ZRText;\n    }(Displayable));\n    var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };\n    var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };\n    function normalizeTextStyle(style) {\n        normalizeStyle(style);\n        each(style.rich, normalizeStyle);\n        return style;\n    }\n    function normalizeStyle(style) {\n        if (style) {\n            style.font = ZRText.makeFont(style);\n            var textAlign = style.align;\n            textAlign === 'middle' && (textAlign = 'center');\n            style.align = (textAlign == null || VALID_TEXT_ALIGN[textAlign]) ? textAlign : 'left';\n            var verticalAlign = style.verticalAlign;\n            verticalAlign === 'center' && (verticalAlign = 'middle');\n            style.verticalAlign = (verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign]) ? verticalAlign : 'top';\n            var textPadding = style.padding;\n            if (textPadding) {\n                style.padding = normalizeCssArray(style.padding);\n            }\n        }\n    }\n    function getStroke(stroke, lineWidth) {\n        return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')\n            ? null\n            : (stroke.image || stroke.colorStops)\n                ? '#000'\n                : stroke;\n    }\n    function getFill(fill) {\n        return (fill == null || fill === 'none')\n            ? null\n            : (fill.image || fill.colorStops)\n                ? '#000'\n                : fill;\n    }\n    function getTextXForPadding(x, textAlign, textPadding) {\n        return textAlign === 'right'\n            ? (x - textPadding[1])\n            : textAlign === 'center'\n                ? (x + textPadding[3] / 2 - textPadding[1] / 2)\n                : (x + textPadding[3]);\n    }\n    function getStyleText(style) {\n        var text = style.text;\n        text != null && (text += '');\n        return text;\n    }\n    function needDrawBackground(style) {\n        return !!(style.backgroundColor\n            || (style.borderWidth && style.borderColor));\n    }\n\n    var getECData = makeInner();\n\n    var _highlightNextDigit = 1;\n    var _highlightKeyMap = {};\n    var getSavedStates = makeInner();\n    var HOVER_STATE_NORMAL = 0;\n    var HOVER_STATE_BLUR = 1;\n    var HOVER_STATE_EMPHASIS = 2;\n    var SPECIAL_STATES = ['emphasis', 'blur', 'select'];\n    var DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select'];\n    var Z2_EMPHASIS_LIFT = 10;\n    var Z2_SELECT_LIFT = 9;\n    var HIGHLIGHT_ACTION_TYPE = 'highlight';\n    var DOWNPLAY_ACTION_TYPE = 'downplay';\n    var SELECT_ACTION_TYPE = 'select';\n    var UNSELECT_ACTION_TYPE = 'unselect';\n    var TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect';\n\n    function hasFillOrStroke(fillOrStroke) {\n      return fillOrStroke != null && fillOrStroke !== 'none';\n    }\n\n    var liftedColorCache = new LRU(100);\n\n    function liftColor(color$1) {\n      if (typeof color$1 !== 'string') {\n        return color$1;\n      }\n\n      var liftedColor = liftedColorCache.get(color$1);\n\n      if (!liftedColor) {\n        liftedColor = lift(color$1, -0.1);\n        liftedColorCache.put(color$1, liftedColor);\n      }\n\n      return liftedColor;\n    }\n\n    function doChangeHoverState(el, stateName, hoverStateEnum) {\n      if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {\n        el.onHoverStateChange(stateName);\n      }\n\n      el.hoverState = hoverStateEnum;\n    }\n\n    function singleEnterEmphasis(el) {\n      doChangeHoverState(el, 'emphasis', HOVER_STATE_EMPHASIS);\n    }\n\n    function singleLeaveEmphasis(el) {\n      if (el.hoverState === HOVER_STATE_EMPHASIS) {\n        doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);\n      }\n    }\n\n    function singleEnterBlur(el) {\n      doChangeHoverState(el, 'blur', HOVER_STATE_BLUR);\n    }\n\n    function singleLeaveBlur(el) {\n      if (el.hoverState === HOVER_STATE_BLUR) {\n        doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL);\n      }\n    }\n\n    function singleEnterSelect(el) {\n      el.selected = true;\n    }\n\n    function singleLeaveSelect(el) {\n      el.selected = false;\n    }\n\n    function updateElementState(el, updater, commonParam) {\n      updater(el, commonParam);\n    }\n\n    function traverseUpdateState(el, updater, commonParam) {\n      updateElementState(el, updater, commonParam);\n      el.isGroup && el.traverse(function (child) {\n        updateElementState(child, updater, commonParam);\n      });\n    }\n\n    function setStatesFlag(el, stateName) {\n      switch (stateName) {\n        case 'emphasis':\n          el.hoverState = HOVER_STATE_EMPHASIS;\n          break;\n\n        case 'normal':\n          el.hoverState = HOVER_STATE_NORMAL;\n          break;\n\n        case 'blur':\n          el.hoverState = HOVER_STATE_BLUR;\n          break;\n\n        case 'select':\n          el.selected = true;\n      }\n    }\n\n    function getFromStateStyle(el, props, toStateName, defaultValue) {\n      var style = el.style;\n      var fromState = {};\n\n      for (var i = 0; i < props.length; i++) {\n        var propName = props[i];\n        var val = style[propName];\n        fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;\n      }\n\n      for (var i = 0; i < el.animators.length; i++) {\n        var animator = el.animators[i];\n\n        if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === 'style') {\n          animator.saveFinalToTarget(fromState, props);\n        }\n      }\n\n      return fromState;\n    }\n\n    function createEmphasisDefaultState(el, stateName, targetStates, state) {\n      var hasSelect = targetStates && indexOf(targetStates, 'select') >= 0;\n      var cloned = false;\n\n      if (el instanceof Path) {\n        var store = getSavedStates(el);\n        var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;\n        var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;\n\n        if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {\n          state = state || {};\n          var emphasisStyle = state.style || {};\n\n          if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {\n            cloned = true;\n            state = extend({}, state);\n            emphasisStyle = extend({}, emphasisStyle);\n            emphasisStyle.fill = liftColor(fromFill);\n          } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {\n            if (!cloned) {\n              state = extend({}, state);\n              emphasisStyle = extend({}, emphasisStyle);\n            }\n\n            emphasisStyle.stroke = liftColor(fromStroke);\n          }\n\n          state.style = emphasisStyle;\n        }\n      }\n\n      if (state) {\n        if (state.z2 == null) {\n          if (!cloned) {\n            state = extend({}, state);\n          }\n\n          var z2EmphasisLift = el.z2EmphasisLift;\n          state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);\n        }\n      }\n\n      return state;\n    }\n\n    function createSelectDefaultState(el, stateName, state) {\n      if (state) {\n        if (state.z2 == null) {\n          state = extend({}, state);\n          var z2SelectLift = el.z2SelectLift;\n          state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);\n        }\n      }\n\n      return state;\n    }\n\n    function createBlurDefaultState(el, stateName, state) {\n      var hasBlur = indexOf(el.currentStates, stateName) >= 0;\n      var currentOpacity = el.style.opacity;\n      var fromState = !hasBlur ? getFromStateStyle(el, ['opacity'], stateName, {\n        opacity: 1\n      }) : null;\n      state = state || {};\n      var blurStyle = state.style || {};\n\n      if (blurStyle.opacity == null) {\n        state = extend({}, state);\n        blurStyle = extend({\n          opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1\n        }, blurStyle);\n        state.style = blurStyle;\n      }\n\n      return state;\n    }\n\n    function elementStateProxy(stateName, targetStates) {\n      var state = this.states[stateName];\n\n      if (this.style) {\n        if (stateName === 'emphasis') {\n          return createEmphasisDefaultState(this, stateName, targetStates, state);\n        } else if (stateName === 'blur') {\n          return createBlurDefaultState(this, stateName, state);\n        } else if (stateName === 'select') {\n          return createSelectDefaultState(this, stateName, state);\n        }\n      }\n\n      return state;\n    }\n\n    function setDefaultStateProxy(el) {\n      el.stateProxy = elementStateProxy;\n      var textContent = el.getTextContent();\n      var textGuide = el.getTextGuideLine();\n\n      if (textContent) {\n        textContent.stateProxy = elementStateProxy;\n      }\n\n      if (textGuide) {\n        textGuide.stateProxy = elementStateProxy;\n      }\n    }\n    function enterEmphasisWhenMouseOver(el, e) {\n      !shouldSilent(el, e) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);\n    }\n    function leaveEmphasisWhenMouseOut(el, e) {\n      !shouldSilent(el, e) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);\n    }\n    function enterEmphasis(el, highlightDigit) {\n      el.__highByOuter |= 1 << (highlightDigit || 0);\n      traverseUpdateState(el, singleEnterEmphasis);\n    }\n    function leaveEmphasis(el, highlightDigit) {\n      !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);\n    }\n    function enterBlur(el) {\n      traverseUpdateState(el, singleEnterBlur);\n    }\n    function leaveBlur(el) {\n      traverseUpdateState(el, singleLeaveBlur);\n    }\n    function enterSelect(el) {\n      traverseUpdateState(el, singleEnterSelect);\n    }\n    function leaveSelect(el) {\n      traverseUpdateState(el, singleLeaveSelect);\n    }\n\n    function shouldSilent(el, e) {\n      return el.__highDownSilentOnTouch && e.zrByTouch;\n    }\n\n    function allLeaveBlur(api) {\n      var model = api.getModel();\n      model.eachComponent(function (componentType, componentModel) {\n        var view = componentType === 'series' ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);\n        view.group.traverse(function (child) {\n          singleLeaveBlur(child);\n        });\n      });\n    }\n\n    function toggleSeriesBlurState(targetSeriesIndex, focus, blurScope, api, isBlur) {\n      var ecModel = api.getModel();\n      blurScope = blurScope || 'coordinateSystem';\n\n      function leaveBlurOfIndices(data, dataIndices) {\n        for (var i = 0; i < dataIndices.length; i++) {\n          var itemEl = data.getItemGraphicEl(dataIndices[i]);\n          itemEl && leaveBlur(itemEl);\n        }\n      }\n\n      if (!isBlur) {\n        allLeaveBlur(api);\n        return;\n      }\n\n      if (targetSeriesIndex == null) {\n        return;\n      }\n\n      if (!focus || focus === 'none') {\n        return;\n      }\n\n      var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);\n      var targetCoordSys = targetSeriesModel.coordinateSystem;\n\n      if (targetCoordSys && targetCoordSys.master) {\n        targetCoordSys = targetCoordSys.master;\n      }\n\n      var blurredSeries = [];\n      ecModel.eachSeries(function (seriesModel) {\n        var sameSeries = targetSeriesModel === seriesModel;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys && coordSys.master) {\n          coordSys = coordSys.master;\n        }\n\n        var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;\n\n        if (!(blurScope === 'series' && !sameSeries || blurScope === 'coordinateSystem' && !sameCoordSys || focus === 'series' && sameSeries)) {\n          var view = api.getViewOfSeriesModel(seriesModel);\n          view.group.traverse(function (child) {\n            singleEnterBlur(child);\n          });\n\n          if (isArrayLike(focus)) {\n            leaveBlurOfIndices(seriesModel.getData(), focus);\n          } else if (isObject(focus)) {\n            var dataTypes = keys(focus);\n\n            for (var d = 0; d < dataTypes.length; d++) {\n              leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);\n            }\n          }\n\n          blurredSeries.push(seriesModel);\n        }\n      });\n      ecModel.eachComponent(function (componentType, componentModel) {\n        if (componentType === 'series') {\n          return;\n        }\n\n        var view = api.getViewOfComponentModel(componentModel);\n\n        if (view && view.blurSeries) {\n          view.blurSeries(blurredSeries, ecModel);\n        }\n      });\n    }\n    function toggleSeriesBlurStateFromPayload(seriesModel, payload, api) {\n      if (!isHighDownPayload(payload)) {\n        return;\n      }\n\n      var isHighlight = payload.type === HIGHLIGHT_ACTION_TYPE;\n      var seriesIndex = seriesModel.seriesIndex;\n      var data = seriesModel.getData(payload.dataType);\n      var dataIndex = queryDataIndex(data, payload);\n      dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;\n      var el = data.getItemGraphicEl(dataIndex);\n\n      if (!el) {\n        var count = data.count();\n        var current = 0;\n\n        while (!el && current < count) {\n          el = data.getItemGraphicEl(current++);\n        }\n      }\n\n      if (el) {\n        var ecData = getECData(el);\n        toggleSeriesBlurState(seriesIndex, ecData.focus, ecData.blurScope, api, isHighlight);\n      } else {\n        var focus_1 = seriesModel.get(['emphasis', 'focus']);\n        var blurScope = seriesModel.get(['emphasis', 'blurScope']);\n\n        if (focus_1 != null) {\n          toggleSeriesBlurState(seriesIndex, focus_1, blurScope, api, isHighlight);\n        }\n      }\n    }\n    function toggleSelectionFromPayload(seriesModel, payload, api) {\n      if (!isSelectChangePayload(payload)) {\n        return;\n      }\n\n      var dataType = payload.dataType;\n      var data = seriesModel.getData(dataType);\n      var dataIndex = queryDataIndex(data, payload);\n\n      if (!isArray(dataIndex)) {\n        dataIndex = [dataIndex];\n      }\n\n      seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? 'toggleSelect' : payload.type === SELECT_ACTION_TYPE ? 'select' : 'unselect'](dataIndex, dataType);\n    }\n    function updateSeriesElementSelection(seriesModel) {\n      var allData = seriesModel.getAllData();\n      each(allData, function (_a) {\n        var data = _a.data,\n            type = _a.type;\n        data.eachItemGraphicEl(function (el, idx) {\n          seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);\n        });\n      });\n    }\n    function getAllSelectedIndices(ecModel) {\n      var ret = [];\n      ecModel.eachSeries(function (seriesModel) {\n        var allData = seriesModel.getAllData();\n        each(allData, function (_a) {\n          var data = _a.data,\n              type = _a.type;\n          var dataIndices = seriesModel.getSelectedDataIndices();\n\n          if (dataIndices.length > 0) {\n            var item = {\n              dataIndex: dataIndices,\n              seriesIndex: seriesModel.seriesIndex\n            };\n\n            if (type != null) {\n              item.dataType = type;\n            }\n\n            ret.push(item);\n          }\n        });\n      });\n      return ret;\n    }\n    function enableHoverEmphasis(el, focus, blurScope) {\n      setAsHighDownDispatcher(el, true);\n      traverseUpdateState(el, setDefaultStateProxy);\n      enableHoverFocus(el, focus, blurScope);\n    }\n    function enableHoverFocus(el, focus, blurScope) {\n      var ecData = getECData(el);\n\n      if (focus != null) {\n        ecData.focus = focus;\n        ecData.blurScope = blurScope;\n      } else if (ecData.focus) {\n        ecData.focus = null;\n      }\n    }\n    var OTHER_STATES = ['emphasis', 'blur', 'select'];\n    var defaultStyleGetterMap = {\n      itemStyle: 'getItemStyle',\n      lineStyle: 'getLineStyle',\n      areaStyle: 'getAreaStyle'\n    };\n    function setStatesStylesFromModel(el, itemModel, styleType, getter) {\n      styleType = styleType || 'itemStyle';\n\n      for (var i = 0; i < OTHER_STATES.length; i++) {\n        var stateName = OTHER_STATES[i];\n        var model = itemModel.getModel([stateName, styleType]);\n        var state = el.ensureState(stateName);\n        state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();\n      }\n    }\n    function setAsHighDownDispatcher(el, asDispatcher) {\n      var disable = asDispatcher === false;\n      var extendedEl = el;\n\n      if (el.highDownSilentOnTouch) {\n        extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;\n      }\n\n      if (!disable || extendedEl.__highDownDispatcher) {\n        extendedEl.__highByOuter = extendedEl.__highByOuter || 0;\n        extendedEl.__highDownDispatcher = !disable;\n      }\n    }\n    function isHighDownDispatcher(el) {\n      return !!(el && el.__highDownDispatcher);\n    }\n    function getHighlightDigit(highlightKey) {\n      var highlightDigit = _highlightKeyMap[highlightKey];\n\n      if (highlightDigit == null && _highlightNextDigit <= 32) {\n        highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;\n      }\n\n      return highlightDigit;\n    }\n    function isSelectChangePayload(payload) {\n      var payloadType = payload.type;\n      return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;\n    }\n    function isHighDownPayload(payload) {\n      var payloadType = payload.type;\n      return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;\n    }\n    function savePathStates(el) {\n      var store = getSavedStates(el);\n      store.normalFill = el.style.fill;\n      store.normalStroke = el.style.stroke;\n      var selectState = el.states.select || {};\n      store.selectFill = selectState.style && selectState.style.fill || null;\n      store.selectStroke = selectState.style && selectState.style.stroke || null;\n    }\n\n    var CMD$2 = PathProxy.CMD;\n    var points = [[], [], []];\n    var mathSqrt$2 = Math.sqrt;\n    var mathAtan2 = Math.atan2;\n    function transformPath(path, m) {\n        var data = path.data;\n        var len = path.len();\n        var cmd;\n        var nPoint;\n        var i;\n        var j;\n        var k;\n        var p;\n        var M = CMD$2.M;\n        var C = CMD$2.C;\n        var L = CMD$2.L;\n        var R = CMD$2.R;\n        var A = CMD$2.A;\n        var Q = CMD$2.Q;\n        for (i = 0, j = 0; i < len;) {\n            cmd = data[i++];\n            j = i;\n            nPoint = 0;\n            switch (cmd) {\n                case M:\n                    nPoint = 1;\n                    break;\n                case L:\n                    nPoint = 1;\n                    break;\n                case C:\n                    nPoint = 3;\n                    break;\n                case Q:\n                    nPoint = 2;\n                    break;\n                case A:\n                    var x = m[4];\n                    var y = m[5];\n                    var sx = mathSqrt$2(m[0] * m[0] + m[1] * m[1]);\n                    var sy = mathSqrt$2(m[2] * m[2] + m[3] * m[3]);\n                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);\n                    data[i] *= sx;\n                    data[i++] += x;\n                    data[i] *= sy;\n                    data[i++] += y;\n                    data[i++] *= sx;\n                    data[i++] *= sy;\n                    data[i++] += angle;\n                    data[i++] += angle;\n                    i += 2;\n                    j = i;\n                    break;\n                case R:\n                    p[0] = data[i++];\n                    p[1] = data[i++];\n                    applyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n                    p[0] += data[i++];\n                    p[1] += data[i++];\n                    applyTransform(p, p, m);\n                    data[j++] = p[0];\n                    data[j++] = p[1];\n            }\n            for (k = 0; k < nPoint; k++) {\n                var p_1 = points[k];\n                p_1[0] = data[i++];\n                p_1[1] = data[i++];\n                applyTransform(p_1, p_1, m);\n                data[j++] = p_1[0];\n                data[j++] = p_1[1];\n            }\n        }\n        path.increaseVersion();\n    }\n\n    var mathSqrt$3 = Math.sqrt;\n    var mathSin$2 = Math.sin;\n    var mathCos$2 = Math.cos;\n    var PI$1 = Math.PI;\n    function vMag(v) {\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n    }\n    function vRatio(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n    }\n    function vAngle(u, v) {\n        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)\n            * Math.acos(vRatio(u, v));\n    }\n    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n        var psi = psiDeg * (PI$1 / 180.0);\n        var xp = mathCos$2(psi) * (x1 - x2) / 2.0\n            + mathSin$2(psi) * (y1 - y2) / 2.0;\n        var yp = -1 * mathSin$2(psi) * (x1 - x2) / 2.0\n            + mathCos$2(psi) * (y1 - y2) / 2.0;\n        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);\n        if (lambda > 1) {\n            rx *= mathSqrt$3(lambda);\n            ry *= mathSqrt$3(lambda);\n        }\n        var f = (fa === fs ? -1 : 1)\n            * mathSqrt$3((((rx * rx) * (ry * ry))\n                - ((rx * rx) * (yp * yp))\n                - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)\n                + (ry * ry) * (xp * xp))) || 0;\n        var cxp = f * rx * yp / ry;\n        var cyp = f * -ry * xp / rx;\n        var cx = (x1 + x2) / 2.0\n            + mathCos$2(psi) * cxp\n            - mathSin$2(psi) * cyp;\n        var cy = (y1 + y2) / 2.0\n            + mathSin$2(psi) * cxp\n            + mathCos$2(psi) * cyp;\n        var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n        var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n        var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n        var dTheta = vAngle(u, v);\n        if (vRatio(u, v) <= -1) {\n            dTheta = PI$1;\n        }\n        if (vRatio(u, v) >= 1) {\n            dTheta = 0;\n        }\n        if (dTheta < 0) {\n            var n = Math.round(dTheta / PI$1 * 1e6) / 1e6;\n            dTheta = PI$1 * 2 + (n % 2) * PI$1;\n        }\n        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n    }\n    var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;\n    var numberReg = /-?([0-9]*\\.)?[0-9]+([eE]-?[0-9]+)?/g;\n    function createPathProxyFromString(data) {\n        var path = new PathProxy();\n        if (!data) {\n            return path;\n        }\n        var cpx = 0;\n        var cpy = 0;\n        var subpathX = cpx;\n        var subpathY = cpy;\n        var prevCmd;\n        var CMD = PathProxy.CMD;\n        var cmdList = data.match(commandReg);\n        if (!cmdList) {\n            return path;\n        }\n        for (var l = 0; l < cmdList.length; l++) {\n            var cmdText = cmdList[l];\n            var cmdStr = cmdText.charAt(0);\n            var cmd = void 0;\n            var p = cmdText.match(numberReg) || [];\n            var pLen = p.length;\n            for (var i = 0; i < pLen; i++) {\n                p[i] = parseFloat(p[i]);\n            }\n            var off = 0;\n            while (off < pLen) {\n                var ctlPtx = void 0;\n                var ctlPty = void 0;\n                var rx = void 0;\n                var ry = void 0;\n                var psi = void 0;\n                var fa = void 0;\n                var fs = void 0;\n                var x1 = cpx;\n                var y1 = cpy;\n                var len = void 0;\n                var pathData = void 0;\n                switch (cmdStr) {\n                    case 'l':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'L':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'm':\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        subpathX = cpx;\n                        subpathY = cpy;\n                        cmdStr = 'l';\n                        break;\n                    case 'M':\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.M;\n                        path.addData(cmd, cpx, cpy);\n                        subpathX = cpx;\n                        subpathY = cpy;\n                        cmdStr = 'L';\n                        break;\n                    case 'h':\n                        cpx += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'H':\n                        cpx = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'v':\n                        cpy += p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'V':\n                        cpy = p[off++];\n                        cmd = CMD.L;\n                        path.addData(cmd, cpx, cpy);\n                        break;\n                    case 'C':\n                        cmd = CMD.C;\n                        path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n                        cpx = p[off - 2];\n                        cpy = p[off - 1];\n                        break;\n                    case 'c':\n                        cmd = CMD.C;\n                        path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n                        cpx += p[off - 2];\n                        cpy += p[off - 1];\n                        break;\n                    case 'S':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        len = path.len();\n                        pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 's':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        len = path.len();\n                        pathData = path.data;\n                        if (prevCmd === CMD.C) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cmd = CMD.C;\n                        x1 = cpx + p[off++];\n                        y1 = cpy + p[off++];\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n                        break;\n                    case 'Q':\n                        x1 = p[off++];\n                        y1 = p[off++];\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'q':\n                        x1 = p[off++] + cpx;\n                        y1 = p[off++] + cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, x1, y1, cpx, cpy);\n                        break;\n                    case 'T':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        len = path.len();\n                        pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 't':\n                        ctlPtx = cpx;\n                        ctlPty = cpy;\n                        len = path.len();\n                        pathData = path.data;\n                        if (prevCmd === CMD.Q) {\n                            ctlPtx += cpx - pathData[len - 4];\n                            ctlPty += cpy - pathData[len - 3];\n                        }\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.Q;\n                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n                        break;\n                    case 'A':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n                        x1 = cpx, y1 = cpy;\n                        cpx = p[off++];\n                        cpy = p[off++];\n                        cmd = CMD.A;\n                        processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                        break;\n                    case 'a':\n                        rx = p[off++];\n                        ry = p[off++];\n                        psi = p[off++];\n                        fa = p[off++];\n                        fs = p[off++];\n                        x1 = cpx, y1 = cpy;\n                        cpx += p[off++];\n                        cpy += p[off++];\n                        cmd = CMD.A;\n                        processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n                        break;\n                }\n            }\n            if (cmdStr === 'z' || cmdStr === 'Z') {\n                cmd = CMD.Z;\n                path.addData(cmd);\n                cpx = subpathX;\n                cpy = subpathY;\n            }\n            prevCmd = cmd;\n        }\n        path.toStatic();\n        return path;\n    }\n    var SVGPath = (function (_super) {\n        __extends(SVGPath, _super);\n        function SVGPath() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        SVGPath.prototype.applyTransform = function (m) { };\n        return SVGPath;\n    }(Path));\n    function isPathProxy(path) {\n        return path.setData != null;\n    }\n    function createPathOptions(str, opts) {\n        var pathProxy = createPathProxyFromString(str);\n        var innerOpts = extend({}, opts);\n        innerOpts.buildPath = function (path) {\n            if (isPathProxy(path)) {\n                path.setData(pathProxy.data);\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx, 1);\n                }\n            }\n            else {\n                var ctx = path;\n                pathProxy.rebuildPath(ctx, 1);\n            }\n        };\n        innerOpts.applyTransform = function (m) {\n            transformPath(pathProxy, m);\n            this.dirtyShape();\n        };\n        return innerOpts;\n    }\n    function createFromString(str, opts) {\n        return new SVGPath(createPathOptions(str, opts));\n    }\n    function extendFromString(str, defaultOpts) {\n        var innerOpts = createPathOptions(str, defaultOpts);\n        var Sub = (function (_super) {\n            __extends(Sub, _super);\n            function Sub(opts) {\n                var _this = _super.call(this, opts) || this;\n                _this.applyTransform = innerOpts.applyTransform;\n                _this.buildPath = innerOpts.buildPath;\n                return _this;\n            }\n            return Sub;\n        }(SVGPath));\n        return Sub;\n    }\n    function mergePath(pathEls, opts) {\n        var pathList = [];\n        var len = pathEls.length;\n        for (var i = 0; i < len; i++) {\n            var pathEl = pathEls[i];\n            if (!pathEl.path) {\n                pathEl.createPathProxy();\n            }\n            if (pathEl.shapeChanged()) {\n                pathEl.buildPath(pathEl.path, pathEl.shape, true);\n            }\n            pathList.push(pathEl.path);\n        }\n        var pathBundle = new Path(opts);\n        pathBundle.createPathProxy();\n        pathBundle.buildPath = function (path) {\n            if (isPathProxy(path)) {\n                path.appendPath(pathList);\n                var ctx = path.getContext();\n                if (ctx) {\n                    path.rebuildPath(ctx, 1);\n                }\n            }\n        };\n        return pathBundle;\n    }\n\n    var CircleShape = (function () {\n        function CircleShape() {\n            this.cx = 0;\n            this.cy = 0;\n            this.r = 0;\n        }\n        return CircleShape;\n    }());\n    var Circle = (function (_super) {\n        __extends(Circle, _super);\n        function Circle(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Circle.prototype.getDefaultShape = function () {\n            return new CircleShape();\n        };\n        Circle.prototype.buildPath = function (ctx, shape, inBundle) {\n            if (inBundle) {\n                ctx.moveTo(shape.cx + shape.r, shape.cy);\n            }\n            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);\n        };\n        return Circle;\n    }(Path));\n    Circle.prototype.type = 'circle';\n\n    var EllipseShape = (function () {\n        function EllipseShape() {\n            this.cx = 0;\n            this.cy = 0;\n            this.rx = 0;\n            this.ry = 0;\n        }\n        return EllipseShape;\n    }());\n    var Ellipse = (function (_super) {\n        __extends(Ellipse, _super);\n        function Ellipse(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Ellipse.prototype.getDefaultShape = function () {\n            return new EllipseShape();\n        };\n        Ellipse.prototype.buildPath = function (ctx, shape) {\n            var k = 0.5522848;\n            var x = shape.cx;\n            var y = shape.cy;\n            var a = shape.rx;\n            var b = shape.ry;\n            var ox = a * k;\n            var oy = b * k;\n            ctx.moveTo(x - a, y);\n            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n            ctx.closePath();\n        };\n        return Ellipse;\n    }(Path));\n    Ellipse.prototype.type = 'ellipse';\n\n    var PI$2 = Math.PI;\n    var PI2$5 = PI$2 * 2;\n    var mathSin$3 = Math.sin;\n    var mathCos$3 = Math.cos;\n    var mathACos = Math.acos;\n    var mathATan2 = Math.atan2;\n    var mathAbs$1 = Math.abs;\n    var mathSqrt$4 = Math.sqrt;\n    var mathMax$3 = Math.max;\n    var mathMin$3 = Math.min;\n    var e = 1e-4;\n    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var x10 = x1 - x0;\n        var y10 = y1 - y0;\n        var x32 = x3 - x2;\n        var y32 = y3 - y2;\n        var t = y32 * x10 - x32 * y10;\n        if (t * t < e) {\n            return;\n        }\n        t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n        return [x0 + t * x10, y0 + t * y10];\n    }\n    function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {\n        var x01 = x0 - x1;\n        var y01 = y0 - y1;\n        var lo = (clockwise ? cr : -cr) / mathSqrt$4(x01 * x01 + y01 * y01);\n        var ox = lo * y01;\n        var oy = -lo * x01;\n        var x11 = x0 + ox;\n        var y11 = y0 + oy;\n        var x10 = x1 + ox;\n        var y10 = y1 + oy;\n        var x00 = (x11 + x10) / 2;\n        var y00 = (y11 + y10) / 2;\n        var dx = x10 - x11;\n        var dy = y10 - y11;\n        var d2 = dx * dx + dy * dy;\n        var r = radius - cr;\n        var s = x11 * y10 - x10 * y11;\n        var d = (dy < 0 ? -1 : 1) * mathSqrt$4(mathMax$3(0, r * r * d2 - s * s));\n        var cx0 = (s * dy - dx * d) / d2;\n        var cy0 = (-s * dx - dy * d) / d2;\n        var cx1 = (s * dy + dx * d) / d2;\n        var cy1 = (-s * dx + dy * d) / d2;\n        var dx0 = cx0 - x00;\n        var dy0 = cy0 - y00;\n        var dx1 = cx1 - x00;\n        var dy1 = cy1 - y00;\n        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {\n            cx0 = cx1;\n            cy0 = cy1;\n        }\n        return {\n            cx: cx0,\n            cy: cy0,\n            x01: -ox,\n            y01: -oy,\n            x11: cx0 * (radius / r - 1),\n            y11: cy0 * (radius / r - 1)\n        };\n    }\n    function buildPath$1(ctx, shape) {\n        var radius = mathMax$3(shape.r, 0);\n        var innerRadius = mathMax$3(shape.r0 || 0, 0);\n        var hasRadius = radius > 0;\n        var hasInnerRadius = innerRadius > 0;\n        if (!hasRadius && !hasInnerRadius) {\n            return;\n        }\n        if (!hasRadius) {\n            radius = innerRadius;\n            innerRadius = 0;\n        }\n        if (innerRadius > radius) {\n            var tmp = radius;\n            radius = innerRadius;\n            innerRadius = tmp;\n        }\n        var clockwise = !!shape.clockwise;\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var tmpAngles = [startAngle, endAngle];\n        normalizeArcAngles(tmpAngles, !clockwise);\n        var arc = mathAbs$1(tmpAngles[0] - tmpAngles[1]);\n        var x = shape.cx;\n        var y = shape.cy;\n        var cornerRadius = shape.cornerRadius || 0;\n        var innerCornerRadius = shape.innerCornerRadius || 0;\n        if (!(radius > e)) {\n            ctx.moveTo(x, y);\n        }\n        else if (arc > PI2$5 - e) {\n            ctx.moveTo(x + radius * mathCos$3(startAngle), y + radius * mathSin$3(startAngle));\n            ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);\n            if (innerRadius > e) {\n                ctx.moveTo(x + innerRadius * mathCos$3(endAngle), y + innerRadius * mathSin$3(endAngle));\n                ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);\n            }\n        }\n        else {\n            var halfRd = mathAbs$1(radius - innerRadius) / 2;\n            var cr = mathMin$3(halfRd, cornerRadius);\n            var icr = mathMin$3(halfRd, innerCornerRadius);\n            var cr0 = icr;\n            var cr1 = cr;\n            var xrs = radius * mathCos$3(startAngle);\n            var yrs = radius * mathSin$3(startAngle);\n            var xire = innerRadius * mathCos$3(endAngle);\n            var yire = innerRadius * mathSin$3(endAngle);\n            var xre = void 0;\n            var yre = void 0;\n            var xirs = void 0;\n            var yirs = void 0;\n            if (cr > e || icr > e) {\n                xre = radius * mathCos$3(endAngle);\n                yre = radius * mathSin$3(endAngle);\n                xirs = innerRadius * mathCos$3(startAngle);\n                yirs = innerRadius * mathSin$3(startAngle);\n                if (arc < PI$2) {\n                    var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);\n                    if (it_1) {\n                        var x0 = xrs - it_1[0];\n                        var y0 = yrs - it_1[1];\n                        var x1 = xre - it_1[0];\n                        var y1 = yre - it_1[1];\n                        var a = 1 / mathSin$3(mathACos((x0 * x1 + y0 * y1) / (mathSqrt$4(x0 * x0 + y0 * y0) * mathSqrt$4(x1 * x1 + y1 * y1))) / 2);\n                        var b = mathSqrt$4(it_1[0] * it_1[0] + it_1[1] * it_1[1]);\n                        cr0 = mathMin$3(icr, (innerRadius - b) / (a - 1));\n                        cr1 = mathMin$3(cr, (radius - b) / (a + 1));\n                    }\n                }\n            }\n            if (!(arc > e)) {\n                ctx.moveTo(x + xrs, y + yrs);\n            }\n            else if (cr1 > e) {\n                var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, cr1, clockwise);\n                var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, cr1, clockwise);\n                ctx.moveTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);\n                if (cr1 < cr) {\n                    ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);\n                }\n                else {\n                    ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);\n                    ctx.arc(x, y, radius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), !clockwise);\n                    ctx.arc(x + ct1.cx, y + ct1.cy, cr1, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);\n                }\n            }\n            else {\n                ctx.moveTo(x + xrs, y + yrs);\n                ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);\n            }\n            if (!(innerRadius > e) || !(arc > e)) {\n                ctx.lineTo(x + xire, y + yire);\n            }\n            else if (cr0 > e) {\n                var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -cr0, clockwise);\n                var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -cr0, clockwise);\n                ctx.lineTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);\n                if (cr0 < icr) {\n                    ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);\n                }\n                else {\n                    ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);\n                    ctx.arc(x, y, innerRadius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), clockwise);\n                    ctx.arc(x + ct1.cx, y + ct1.cy, cr0, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);\n                }\n            }\n            else {\n                ctx.lineTo(x + xire, y + yire);\n                ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);\n            }\n        }\n        ctx.closePath();\n    }\n\n    var SectorShape = (function () {\n        function SectorShape() {\n            this.cx = 0;\n            this.cy = 0;\n            this.r0 = 0;\n            this.r = 0;\n            this.startAngle = 0;\n            this.endAngle = Math.PI * 2;\n            this.clockwise = true;\n            this.cornerRadius = 0;\n            this.innerCornerRadius = 0;\n        }\n        return SectorShape;\n    }());\n    var Sector = (function (_super) {\n        __extends(Sector, _super);\n        function Sector(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Sector.prototype.getDefaultShape = function () {\n            return new SectorShape();\n        };\n        Sector.prototype.buildPath = function (ctx, shape) {\n            buildPath$1(ctx, shape);\n        };\n        Sector.prototype.isZeroArea = function () {\n            return this.shape.startAngle === this.shape.endAngle\n                || this.shape.r === this.shape.r0;\n        };\n        return Sector;\n    }(Path));\n    Sector.prototype.type = 'sector';\n\n    var RingShape = (function () {\n        function RingShape() {\n            this.cx = 0;\n            this.cy = 0;\n            this.r = 0;\n            this.r0 = 0;\n        }\n        return RingShape;\n    }());\n    var Ring = (function (_super) {\n        __extends(Ring, _super);\n        function Ring(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Ring.prototype.getDefaultShape = function () {\n            return new RingShape();\n        };\n        Ring.prototype.buildPath = function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var PI2 = Math.PI * 2;\n            ctx.moveTo(x + shape.r, y);\n            ctx.arc(x, y, shape.r, 0, PI2, false);\n            ctx.moveTo(x + shape.r0, y);\n            ctx.arc(x, y, shape.r0, 0, PI2, true);\n        };\n        return Ring;\n    }(Path));\n    Ring.prototype.type = 'ring';\n\n    function interpolate(p0, p1, p2, p3, t, t2, t3) {\n        var v0 = (p2 - p0) * 0.5;\n        var v1 = (p3 - p1) * 0.5;\n        return (2 * (p1 - p2) + v0 + v1) * t3\n            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2\n            + v0 * t + p1;\n    }\n    function smoothSpline(points, isLoop) {\n        var len = points.length;\n        var ret = [];\n        var distance$1 = 0;\n        for (var i = 1; i < len; i++) {\n            distance$1 += distance(points[i - 1], points[i]);\n        }\n        var segs = distance$1 / 2;\n        segs = segs < len ? len : segs;\n        for (var i = 0; i < segs; i++) {\n            var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n            var idx = Math.floor(pos);\n            var w = pos - idx;\n            var p0 = void 0;\n            var p1 = points[idx % len];\n            var p2 = void 0;\n            var p3 = void 0;\n            if (!isLoop) {\n                p0 = points[idx === 0 ? idx : idx - 1];\n                p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n                p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n            }\n            else {\n                p0 = points[(idx - 1 + len) % len];\n                p2 = points[(idx + 1) % len];\n                p3 = points[(idx + 2) % len];\n            }\n            var w2 = w * w;\n            var w3 = w * w2;\n            ret.push([\n                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),\n                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)\n            ]);\n        }\n        return ret;\n    }\n\n    function smoothBezier(points, smooth, isLoop, constraint) {\n        var cps = [];\n        var v = [];\n        var v1 = [];\n        var v2 = [];\n        var prevPoint;\n        var nextPoint;\n        var min$1;\n        var max$1;\n        if (constraint) {\n            min$1 = [Infinity, Infinity];\n            max$1 = [-Infinity, -Infinity];\n            for (var i = 0, len = points.length; i < len; i++) {\n                min(min$1, min$1, points[i]);\n                max(max$1, max$1, points[i]);\n            }\n            min(min$1, min$1, constraint[0]);\n            max(max$1, max$1, constraint[1]);\n        }\n        for (var i = 0, len = points.length; i < len; i++) {\n            var point = points[i];\n            if (isLoop) {\n                prevPoint = points[i ? i - 1 : len - 1];\n                nextPoint = points[(i + 1) % len];\n            }\n            else {\n                if (i === 0 || i === len - 1) {\n                    cps.push(clone$1(points[i]));\n                    continue;\n                }\n                else {\n                    prevPoint = points[i - 1];\n                    nextPoint = points[i + 1];\n                }\n            }\n            sub(v, nextPoint, prevPoint);\n            scale(v, v, smooth);\n            var d0 = distance(point, prevPoint);\n            var d1 = distance(point, nextPoint);\n            var sum = d0 + d1;\n            if (sum !== 0) {\n                d0 /= sum;\n                d1 /= sum;\n            }\n            scale(v1, v, -d0);\n            scale(v2, v, d1);\n            var cp0 = add([], point, v1);\n            var cp1 = add([], point, v2);\n            if (constraint) {\n                max(cp0, cp0, min$1);\n                min(cp0, cp0, max$1);\n                max(cp1, cp1, min$1);\n                min(cp1, cp1, max$1);\n            }\n            cps.push(cp0);\n            cps.push(cp1);\n        }\n        if (isLoop) {\n            cps.push(cps.shift());\n        }\n        return cps;\n    }\n\n    function buildPath$2(ctx, shape, closePath) {\n        var smooth = shape.smooth;\n        var points = shape.points;\n        if (points && points.length >= 2) {\n            if (smooth && smooth !== 'spline') {\n                var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n                ctx.moveTo(points[0][0], points[0][1]);\n                var len = points.length;\n                for (var i = 0; i < (closePath ? len : len - 1); i++) {\n                    var cp1 = controlPoints[i * 2];\n                    var cp2 = controlPoints[i * 2 + 1];\n                    var p = points[(i + 1) % len];\n                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n                }\n            }\n            else {\n                if (smooth === 'spline') {\n                    points = smoothSpline(points, closePath);\n                }\n                ctx.moveTo(points[0][0], points[0][1]);\n                for (var i = 1, l = points.length; i < l; i++) {\n                    ctx.lineTo(points[i][0], points[i][1]);\n                }\n            }\n            closePath && ctx.closePath();\n        }\n    }\n\n    var PolygonShape = (function () {\n        function PolygonShape() {\n            this.points = null;\n            this.smooth = 0;\n            this.smoothConstraint = null;\n        }\n        return PolygonShape;\n    }());\n    var Polygon = (function (_super) {\n        __extends(Polygon, _super);\n        function Polygon(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Polygon.prototype.getDefaultShape = function () {\n            return new PolygonShape();\n        };\n        Polygon.prototype.buildPath = function (ctx, shape) {\n            buildPath$2(ctx, shape, true);\n        };\n        return Polygon;\n    }(Path));\n    Polygon.prototype.type = 'polygon';\n\n    var PolylineShape = (function () {\n        function PolylineShape() {\n            this.points = null;\n            this.percent = 1;\n            this.smooth = 0;\n            this.smoothConstraint = null;\n        }\n        return PolylineShape;\n    }());\n    var Polyline = (function (_super) {\n        __extends(Polyline, _super);\n        function Polyline(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Polyline.prototype.getDefaultStyle = function () {\n            return {\n                stroke: '#000',\n                fill: null\n            };\n        };\n        Polyline.prototype.getDefaultShape = function () {\n            return new PolylineShape();\n        };\n        Polyline.prototype.buildPath = function (ctx, shape) {\n            buildPath$2(ctx, shape, false);\n        };\n        return Polyline;\n    }(Path));\n    Polyline.prototype.type = 'polyline';\n\n    var subPixelOptimizeOutputShape$1 = {};\n    var LineShape = (function () {\n        function LineShape() {\n            this.x1 = 0;\n            this.y1 = 0;\n            this.x2 = 0;\n            this.y2 = 0;\n            this.percent = 1;\n        }\n        return LineShape;\n    }());\n    var Line = (function (_super) {\n        __extends(Line, _super);\n        function Line(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Line.prototype.getDefaultStyle = function () {\n            return {\n                stroke: '#000',\n                fill: null\n            };\n        };\n        Line.prototype.getDefaultShape = function () {\n            return new LineShape();\n        };\n        Line.prototype.buildPath = function (ctx, shape) {\n            var x1;\n            var y1;\n            var x2;\n            var y2;\n            if (this.subPixelOptimize) {\n                var optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape$1, shape, this.style);\n                x1 = optimizedShape.x1;\n                y1 = optimizedShape.y1;\n                x2 = optimizedShape.x2;\n                y2 = optimizedShape.y2;\n            }\n            else {\n                x1 = shape.x1;\n                y1 = shape.y1;\n                x2 = shape.x2;\n                y2 = shape.y2;\n            }\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (percent < 1) {\n                x2 = x1 * (1 - percent) + x2 * percent;\n                y2 = y1 * (1 - percent) + y2 * percent;\n            }\n            ctx.lineTo(x2, y2);\n        };\n        Line.prototype.pointAt = function (p) {\n            var shape = this.shape;\n            return [\n                shape.x1 * (1 - p) + shape.x2 * p,\n                shape.y1 * (1 - p) + shape.y2 * p\n            ];\n        };\n        return Line;\n    }(Path));\n    Line.prototype.type = 'line';\n\n    var out = [];\n    var BezierCurveShape = (function () {\n        function BezierCurveShape() {\n            this.x1 = 0;\n            this.y1 = 0;\n            this.x2 = 0;\n            this.y2 = 0;\n            this.cpx1 = 0;\n            this.cpy1 = 0;\n            this.percent = 1;\n        }\n        return BezierCurveShape;\n    }());\n    function someVectorAt(shape, t, isTangent) {\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        if (cpx2 === null || cpy2 === null) {\n            return [\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n            ];\n        }\n        else {\n            return [\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n            ];\n        }\n    }\n    var BezierCurve = (function (_super) {\n        __extends(BezierCurve, _super);\n        function BezierCurve(opts) {\n            return _super.call(this, opts) || this;\n        }\n        BezierCurve.prototype.getDefaultStyle = function () {\n            return {\n                stroke: '#000',\n                fill: null\n            };\n        };\n        BezierCurve.prototype.getDefaultShape = function () {\n            return new BezierCurveShape();\n        };\n        BezierCurve.prototype.buildPath = function (ctx, shape) {\n            var x1 = shape.x1;\n            var y1 = shape.y1;\n            var x2 = shape.x2;\n            var y2 = shape.y2;\n            var cpx1 = shape.cpx1;\n            var cpy1 = shape.cpy1;\n            var cpx2 = shape.cpx2;\n            var cpy2 = shape.cpy2;\n            var percent = shape.percent;\n            if (percent === 0) {\n                return;\n            }\n            ctx.moveTo(x1, y1);\n            if (cpx2 == null || cpy2 == null) {\n                if (percent < 1) {\n                    quadraticSubdivide(x1, cpx1, x2, percent, out);\n                    cpx1 = out[1];\n                    x2 = out[2];\n                    quadraticSubdivide(y1, cpy1, y2, percent, out);\n                    cpy1 = out[1];\n                    y2 = out[2];\n                }\n                ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n            }\n            else {\n                if (percent < 1) {\n                    cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                    cpx1 = out[1];\n                    cpx2 = out[2];\n                    x2 = out[3];\n                    cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                    cpy1 = out[1];\n                    cpy2 = out[2];\n                    y2 = out[3];\n                }\n                ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n            }\n        };\n        BezierCurve.prototype.pointAt = function (t) {\n            return someVectorAt(this.shape, t, false);\n        };\n        BezierCurve.prototype.tangentAt = function (t) {\n            var p = someVectorAt(this.shape, t, true);\n            return normalize(p, p);\n        };\n        return BezierCurve;\n    }(Path));\n    BezierCurve.prototype.type = 'bezier-curve';\n\n    var ArcShape = (function () {\n        function ArcShape() {\n            this.cx = 0;\n            this.cy = 0;\n            this.r = 0;\n            this.startAngle = 0;\n            this.endAngle = Math.PI * 2;\n            this.clockwise = true;\n        }\n        return ArcShape;\n    }());\n    var Arc = (function (_super) {\n        __extends(Arc, _super);\n        function Arc(opts) {\n            return _super.call(this, opts) || this;\n        }\n        Arc.prototype.getDefaultStyle = function () {\n            return {\n                stroke: '#000',\n                fill: null\n            };\n        };\n        Arc.prototype.getDefaultShape = function () {\n            return new ArcShape();\n        };\n        Arc.prototype.buildPath = function (ctx, shape) {\n            var x = shape.cx;\n            var y = shape.cy;\n            var r = Math.max(shape.r, 0);\n            var startAngle = shape.startAngle;\n            var endAngle = shape.endAngle;\n            var clockwise = shape.clockwise;\n            var unitX = Math.cos(startAngle);\n            var unitY = Math.sin(startAngle);\n            ctx.moveTo(unitX * r + x, unitY * r + y);\n            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        };\n        return Arc;\n    }(Path));\n    Arc.prototype.type = 'arc';\n\n    var CompoundPath = (function (_super) {\n        __extends(CompoundPath, _super);\n        function CompoundPath() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.type = 'compound';\n            return _this;\n        }\n        CompoundPath.prototype._updatePathDirty = function () {\n            var paths = this.shape.paths;\n            var dirtyPath = this.shapeChanged();\n            for (var i = 0; i < paths.length; i++) {\n                dirtyPath = dirtyPath || paths[i].shapeChanged();\n            }\n            if (dirtyPath) {\n                this.dirtyShape();\n            }\n        };\n        CompoundPath.prototype.beforeBrush = function () {\n            this._updatePathDirty();\n            var paths = this.shape.paths || [];\n            var scale = this.getGlobalScale();\n            for (var i = 0; i < paths.length; i++) {\n                if (!paths[i].path) {\n                    paths[i].createPathProxy();\n                }\n                paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);\n            }\n        };\n        CompoundPath.prototype.buildPath = function (ctx, shape) {\n            var paths = shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].buildPath(ctx, paths[i].shape, true);\n            }\n        };\n        CompoundPath.prototype.afterBrush = function () {\n            var paths = this.shape.paths || [];\n            for (var i = 0; i < paths.length; i++) {\n                paths[i].pathUpdated();\n            }\n        };\n        CompoundPath.prototype.getBoundingRect = function () {\n            this._updatePathDirty.call(this);\n            return Path.prototype.getBoundingRect.call(this);\n        };\n        return CompoundPath;\n    }(Path));\n\n    var Gradient = (function () {\n        function Gradient(colorStops) {\n            this.colorStops = colorStops || [];\n        }\n        Gradient.prototype.addColorStop = function (offset, color) {\n            this.colorStops.push({\n                offset: offset,\n                color: color\n            });\n        };\n        return Gradient;\n    }());\n\n    var LinearGradient = (function (_super) {\n        __extends(LinearGradient, _super);\n        function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {\n            var _this = _super.call(this, colorStops) || this;\n            _this.x = x == null ? 0 : x;\n            _this.y = y == null ? 0 : y;\n            _this.x2 = x2 == null ? 1 : x2;\n            _this.y2 = y2 == null ? 0 : y2;\n            _this.type = 'linear';\n            _this.global = globalCoord || false;\n            return _this;\n        }\n        return LinearGradient;\n    }(Gradient));\n\n    var RadialGradient = (function (_super) {\n        __extends(RadialGradient, _super);\n        function RadialGradient(x, y, r, colorStops, globalCoord) {\n            var _this = _super.call(this, colorStops) || this;\n            _this.x = x == null ? 0.5 : x;\n            _this.y = y == null ? 0.5 : y;\n            _this.r = r == null ? 0.5 : r;\n            _this.type = 'radial';\n            _this.global = globalCoord || false;\n            return _this;\n        }\n        return RadialGradient;\n    }(Gradient));\n\n    var extent = [0, 0];\n    var extent2 = [0, 0];\n    var minTv$1 = new Point();\n    var maxTv$1 = new Point();\n    var OrientedBoundingRect = (function () {\n        function OrientedBoundingRect(rect, transform) {\n            this._corners = [];\n            this._axes = [];\n            this._origin = [0, 0];\n            for (var i = 0; i < 4; i++) {\n                this._corners[i] = new Point();\n            }\n            for (var i = 0; i < 2; i++) {\n                this._axes[i] = new Point();\n            }\n            if (rect) {\n                this.fromBoundingRect(rect, transform);\n            }\n        }\n        OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {\n            var corners = this._corners;\n            var axes = this._axes;\n            var x = rect.x;\n            var y = rect.y;\n            var x2 = x + rect.width;\n            var y2 = y + rect.height;\n            corners[0].set(x, y);\n            corners[1].set(x2, y);\n            corners[2].set(x2, y2);\n            corners[3].set(x, y2);\n            if (transform) {\n                for (var i = 0; i < 4; i++) {\n                    corners[i].transform(transform);\n                }\n            }\n            Point.sub(axes[0], corners[1], corners[0]);\n            Point.sub(axes[1], corners[3], corners[0]);\n            axes[0].normalize();\n            axes[1].normalize();\n            for (var i = 0; i < 2; i++) {\n                this._origin[i] = axes[i].dot(corners[0]);\n            }\n        };\n        OrientedBoundingRect.prototype.intersect = function (other, mtv) {\n            var overlapped = true;\n            var noMtv = !mtv;\n            minTv$1.set(Infinity, Infinity);\n            maxTv$1.set(0, 0);\n            if (!this._intersectCheckOneSide(this, other, minTv$1, maxTv$1, noMtv, 1)) {\n                overlapped = false;\n                if (noMtv) {\n                    return overlapped;\n                }\n            }\n            if (!this._intersectCheckOneSide(other, this, minTv$1, maxTv$1, noMtv, -1)) {\n                overlapped = false;\n                if (noMtv) {\n                    return overlapped;\n                }\n            }\n            if (!noMtv) {\n                Point.copy(mtv, overlapped ? minTv$1 : maxTv$1);\n            }\n            return overlapped;\n        };\n        OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {\n            var overlapped = true;\n            for (var i = 0; i < 2; i++) {\n                var axis = this._axes[i];\n                this._getProjMinMaxOnAxis(i, self._corners, extent);\n                this._getProjMinMaxOnAxis(i, other._corners, extent2);\n                if (extent[1] < extent2[0] || extent[0] > extent2[1]) {\n                    overlapped = false;\n                    if (noMtv) {\n                        return overlapped;\n                    }\n                    var dist0 = Math.abs(extent2[0] - extent[1]);\n                    var dist1 = Math.abs(extent[0] - extent2[1]);\n                    if (Math.min(dist0, dist1) > maxTv.len()) {\n                        if (dist0 < dist1) {\n                            Point.scale(maxTv, axis, -dist0 * inverse);\n                        }\n                        else {\n                            Point.scale(maxTv, axis, dist1 * inverse);\n                        }\n                    }\n                }\n                else if (minTv) {\n                    var dist0 = Math.abs(extent2[0] - extent[1]);\n                    var dist1 = Math.abs(extent[0] - extent2[1]);\n                    if (Math.min(dist0, dist1) < minTv.len()) {\n                        if (dist0 < dist1) {\n                            Point.scale(minTv, axis, dist0 * inverse);\n                        }\n                        else {\n                            Point.scale(minTv, axis, -dist1 * inverse);\n                        }\n                    }\n                }\n            }\n            return overlapped;\n        };\n        OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {\n            var axis = this._axes[dim];\n            var origin = this._origin;\n            var proj = corners[0].dot(axis) + origin[dim];\n            var min = proj;\n            var max = proj;\n            for (var i = 1; i < corners.length; i++) {\n                var proj_1 = corners[i].dot(axis) + origin[dim];\n                min = Math.min(proj_1, min);\n                max = Math.max(proj_1, max);\n            }\n            out[0] = min;\n            out[1] = max;\n        };\n        return OrientedBoundingRect;\n    }());\n\n    var m = [];\n    var IncrementalDisplayable = (function (_super) {\n        __extends(IncrementalDisplayable, _super);\n        function IncrementalDisplayable() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.notClear = true;\n            _this.incremental = true;\n            _this._displayables = [];\n            _this._temporaryDisplayables = [];\n            _this._cursor = 0;\n            return _this;\n        }\n        IncrementalDisplayable.prototype.traverse = function (cb, context) {\n            cb.call(context, this);\n        };\n        IncrementalDisplayable.prototype.useStyle = function () {\n            this.style = {};\n        };\n        IncrementalDisplayable.prototype.getCursor = function () {\n            return this._cursor;\n        };\n        IncrementalDisplayable.prototype.innerAfterBrush = function () {\n            this._cursor = this._displayables.length;\n        };\n        IncrementalDisplayable.prototype.clearDisplaybles = function () {\n            this._displayables = [];\n            this._temporaryDisplayables = [];\n            this._cursor = 0;\n            this.markRedraw();\n            this.notClear = false;\n        };\n        IncrementalDisplayable.prototype.clearTemporalDisplayables = function () {\n            this._temporaryDisplayables = [];\n        };\n        IncrementalDisplayable.prototype.addDisplayable = function (displayable, notPersistent) {\n            if (notPersistent) {\n                this._temporaryDisplayables.push(displayable);\n            }\n            else {\n                this._displayables.push(displayable);\n            }\n            this.markRedraw();\n        };\n        IncrementalDisplayable.prototype.addDisplayables = function (displayables, notPersistent) {\n            notPersistent = notPersistent || false;\n            for (var i = 0; i < displayables.length; i++) {\n                this.addDisplayable(displayables[i], notPersistent);\n            }\n        };\n        IncrementalDisplayable.prototype.getDisplayables = function () {\n            return this._displayables;\n        };\n        IncrementalDisplayable.prototype.getTemporalDisplayables = function () {\n            return this._temporaryDisplayables;\n        };\n        IncrementalDisplayable.prototype.eachPendingDisplayable = function (cb) {\n            for (var i = this._cursor; i < this._displayables.length; i++) {\n                cb && cb(this._displayables[i]);\n            }\n            for (var i = 0; i < this._temporaryDisplayables.length; i++) {\n                cb && cb(this._temporaryDisplayables[i]);\n            }\n        };\n        IncrementalDisplayable.prototype.update = function () {\n            this.updateTransform();\n            for (var i = this._cursor; i < this._displayables.length; i++) {\n                var displayable = this._displayables[i];\n                displayable.parent = this;\n                displayable.update();\n                displayable.parent = null;\n            }\n            for (var i = 0; i < this._temporaryDisplayables.length; i++) {\n                var displayable = this._temporaryDisplayables[i];\n                displayable.parent = this;\n                displayable.update();\n                displayable.parent = null;\n            }\n        };\n        IncrementalDisplayable.prototype.getBoundingRect = function () {\n            if (!this._rect) {\n                var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);\n                for (var i = 0; i < this._displayables.length; i++) {\n                    var displayable = this._displayables[i];\n                    var childRect = displayable.getBoundingRect().clone();\n                    if (displayable.needLocalTransform()) {\n                        childRect.applyTransform(displayable.getLocalTransform(m));\n                    }\n                    rect.union(childRect);\n                }\n                this._rect = rect;\n            }\n            return this._rect;\n        };\n        IncrementalDisplayable.prototype.contain = function (x, y) {\n            var localPos = this.transformCoordToLocal(x, y);\n            var rect = this.getBoundingRect();\n            if (rect.contain(localPos[0], localPos[1])) {\n                for (var i = 0; i < this._displayables.length; i++) {\n                    var displayable = this._displayables[i];\n                    if (displayable.contain(x, y)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        return IncrementalDisplayable;\n    }(Displayable));\n\n    var mathMax$4 = Math.max;\n    var mathMin$4 = Math.min;\n    var _customShapeMap = {};\n    function extendShape(opts) {\n      return Path.extend(opts);\n    }\n    var extendPathFromString = extendFromString;\n    function extendPath(pathData, opts) {\n      return extendPathFromString(pathData, opts);\n    }\n    function registerShape(name, ShapeClass) {\n      _customShapeMap[name] = ShapeClass;\n    }\n    function getShapeClass(name) {\n      if (_customShapeMap.hasOwnProperty(name)) {\n        return _customShapeMap[name];\n      }\n    }\n    function makePath(pathData, opts, rect, layout) {\n      var path = createFromString(pathData, opts);\n\n      if (rect) {\n        if (layout === 'center') {\n          rect = centerGraphic(rect, path.getBoundingRect());\n        }\n\n        resizePath(path, rect);\n      }\n\n      return path;\n    }\n    function makeImage(imageUrl, rect, layout) {\n      var zrImg = new ZRImage({\n        style: {\n          image: imageUrl,\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        },\n        onload: function (img) {\n          if (layout === 'center') {\n            var boundingRect = {\n              width: img.width,\n              height: img.height\n            };\n            zrImg.setStyle(centerGraphic(rect, boundingRect));\n          }\n        }\n      });\n      return zrImg;\n    }\n\n    function centerGraphic(rect, boundingRect) {\n      var aspect = boundingRect.width / boundingRect.height;\n      var width = rect.height * aspect;\n      var height;\n\n      if (width <= rect.width) {\n        height = rect.height;\n      } else {\n        width = rect.width;\n        height = width / aspect;\n      }\n\n      var cx = rect.x + rect.width / 2;\n      var cy = rect.y + rect.height / 2;\n      return {\n        x: cx - width / 2,\n        y: cy - height / 2,\n        width: width,\n        height: height\n      };\n    }\n\n    var mergePath$1 = mergePath;\n    function resizePath(path, rect) {\n      if (!path.applyTransform) {\n        return;\n      }\n\n      var pathRect = path.getBoundingRect();\n      var m = pathRect.calculateTransform(rect);\n      path.applyTransform(m);\n    }\n    function subPixelOptimizeLine$1(param) {\n      subPixelOptimizeLine(param.shape, param.shape, param.style);\n      return param;\n    }\n    function subPixelOptimizeRect$1(param) {\n      subPixelOptimizeRect(param.shape, param.shape, param.style);\n      return param;\n    }\n    var subPixelOptimize$1 = subPixelOptimize;\n\n    function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {\n      var isFrom = false;\n      var removeOpt;\n\n      if (typeof dataIndex === 'function') {\n        during = cb;\n        cb = dataIndex;\n        dataIndex = null;\n      } else if (isObject(dataIndex)) {\n        cb = dataIndex.cb;\n        during = dataIndex.during;\n        isFrom = dataIndex.isFrom;\n        removeOpt = dataIndex.removeOpt;\n        dataIndex = dataIndex.dataIndex;\n      }\n\n      var isUpdate = animationType === 'update';\n      var isRemove = animationType === 'remove';\n      var animationPayload;\n\n      if (animatableModel && animatableModel.ecModel) {\n        var updatePayload = animatableModel.ecModel.getUpdatePayload();\n        animationPayload = updatePayload && updatePayload.animation;\n      }\n\n      var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n      if (!isRemove) {\n        el.stopAnimation('remove');\n      }\n\n      if (animationEnabled) {\n        var duration = void 0;\n        var animationEasing = void 0;\n        var animationDelay = void 0;\n\n        if (animationPayload) {\n          duration = animationPayload.duration || 0;\n          animationEasing = animationPayload.easing || 'cubicOut';\n          animationDelay = animationPayload.delay || 0;\n        } else if (isRemove) {\n          removeOpt = removeOpt || {};\n          duration = retrieve2(removeOpt.duration, 200);\n          animationEasing = retrieve2(removeOpt.easing, 'cubicOut');\n          animationDelay = 0;\n        } else {\n          duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');\n          animationEasing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');\n          animationDelay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');\n        }\n\n        if (typeof animationDelay === 'function') {\n          animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n        }\n\n        if (typeof duration === 'function') {\n          duration = duration(dataIndex);\n        }\n\n        duration > 0 ? isFrom ? el.animateFrom(props, {\n          duration: duration,\n          delay: animationDelay || 0,\n          easing: animationEasing,\n          done: cb,\n          force: !!cb || !!during,\n          scope: animationType,\n          during: during\n        }) : el.animateTo(props, {\n          duration: duration,\n          delay: animationDelay || 0,\n          easing: animationEasing,\n          done: cb,\n          force: !!cb || !!during,\n          setToFinal: true,\n          scope: animationType,\n          during: during\n        }) : (el.stopAnimation(), !isFrom && el.attr(props), cb && cb());\n      } else {\n        el.stopAnimation();\n        !isFrom && el.attr(props);\n        during && during(1);\n        cb && cb();\n      }\n    }\n\n    function updateProps(el, props, animatableModel, dataIndex, cb, during) {\n      animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);\n    }\n    function initProps(el, props, animatableModel, dataIndex, cb, during) {\n      animateOrSetProps('init', el, props, animatableModel, dataIndex, cb, during);\n    }\n    function removeElement(el, props, animatableModel, dataIndex, cb, during) {\n      if (isElementRemoved(el)) {\n        return;\n      }\n\n      animateOrSetProps('remove', el, props, animatableModel, dataIndex, cb, during);\n    }\n\n    function fadeOutDisplayable(el, animatableModel, dataIndex, done) {\n      el.removeTextContent();\n      el.removeTextGuideLine();\n      removeElement(el, {\n        style: {\n          opacity: 0\n        }\n      }, animatableModel, dataIndex, done);\n    }\n\n    function removeElementWithFadeOut(el, animatableModel, dataIndex) {\n      function doRemove() {\n        el.parent && el.parent.remove(el);\n      }\n\n      if (!el.isGroup) {\n        fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);\n      } else {\n        el.traverse(function (disp) {\n          if (!disp.isGroup) {\n            fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);\n          }\n        });\n      }\n    }\n    function isElementRemoved(el) {\n      if (!el.__zr) {\n        return true;\n      }\n\n      for (var i = 0; i < el.animators.length; i++) {\n        var animator = el.animators[i];\n\n        if (animator.scope === 'remove') {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    function getTransform(target, ancestor) {\n      var mat = identity([]);\n\n      while (target && target !== ancestor) {\n        mul$1(mat, target.getLocalTransform(), mat);\n        target = target.parent;\n      }\n\n      return mat;\n    }\n    function applyTransform$1(target, transform, invert$1) {\n      if (transform && !isArrayLike(transform)) {\n        transform = Transformable.getLocalTransform(transform);\n      }\n\n      if (invert$1) {\n        transform = invert([], transform);\n      }\n\n      return applyTransform([], target, transform);\n    }\n    function transformDirection(direction, transform, invert) {\n      var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n      var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n      var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n      vertex = applyTransform$1(vertex, transform, invert);\n      return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n    }\n\n    function isNotGroup(el) {\n      return !el.isGroup;\n    }\n\n    function isPath(el) {\n      return el.shape != null;\n    }\n\n    function groupTransition(g1, g2, animatableModel) {\n      if (!g1 || !g2) {\n        return;\n      }\n\n      function getElMap(g) {\n        var elMap = {};\n        g.traverse(function (el) {\n          if (isNotGroup(el) && el.anid) {\n            elMap[el.anid] = el;\n          }\n        });\n        return elMap;\n      }\n\n      function getAnimatableProps(el) {\n        var obj = {\n          x: el.x,\n          y: el.y,\n          rotation: el.rotation\n        };\n\n        if (isPath(el)) {\n          obj.shape = extend({}, el.shape);\n        }\n\n        return obj;\n      }\n\n      var elMap1 = getElMap(g1);\n      g2.traverse(function (el) {\n        if (isNotGroup(el) && el.anid) {\n          var oldEl = elMap1[el.anid];\n\n          if (oldEl) {\n            var newProp = getAnimatableProps(el);\n            el.attr(getAnimatableProps(oldEl));\n            updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n          }\n        }\n      });\n    }\n    function clipPointsByRect(points, rect) {\n      return map(points, function (point) {\n        var x = point[0];\n        x = mathMax$4(x, rect.x);\n        x = mathMin$4(x, rect.x + rect.width);\n        var y = point[1];\n        y = mathMax$4(y, rect.y);\n        y = mathMin$4(y, rect.y + rect.height);\n        return [x, y];\n      });\n    }\n    function clipRectByRect(targetRect, rect) {\n      var x = mathMax$4(targetRect.x, rect.x);\n      var x2 = mathMin$4(targetRect.x + targetRect.width, rect.x + rect.width);\n      var y = mathMax$4(targetRect.y, rect.y);\n      var y2 = mathMin$4(targetRect.y + targetRect.height, rect.y + rect.height);\n\n      if (x2 >= x && y2 >= y) {\n        return {\n          x: x,\n          y: y,\n          width: x2 - x,\n          height: y2 - y\n        };\n      }\n    }\n    function createIcon(iconStr, opt, rect) {\n      var innerOpts = extend({\n        rectHover: true\n      }, opt);\n      var style = innerOpts.style = {\n        strokeNoScale: true\n      };\n      rect = rect || {\n        x: -1,\n        y: -1,\n        width: 2,\n        height: 2\n      };\n\n      if (iconStr) {\n        return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n      }\n    }\n    function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n      for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n        var p = points[i];\n\n        if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n          return true;\n        }\n\n        p2 = p;\n      }\n    }\n    function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n      var mx = a2x - a1x;\n      var my = a2y - a1y;\n      var nx = b2x - b1x;\n      var ny = b2y - b1y;\n      var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n      if (nearZero(nmCrossProduct)) {\n        return false;\n      }\n\n      var b1a1x = a1x - b1x;\n      var b1a1y = a1y - b1y;\n      var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n\n      if (q < 0 || q > 1) {\n        return false;\n      }\n\n      var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n      if (p < 0 || p > 1) {\n        return false;\n      }\n\n      return true;\n    }\n\n    function crossProduct2d(x1, y1, x2, y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    function nearZero(val) {\n      return val <= 1e-6 && val >= -1e-6;\n    }\n\n    registerShape('circle', Circle);\n    registerShape('ellipse', Ellipse);\n    registerShape('sector', Sector);\n    registerShape('ring', Ring);\n    registerShape('polygon', Polygon);\n    registerShape('polyline', Polyline);\n    registerShape('rect', Rect);\n    registerShape('line', Line);\n    registerShape('bezierCurve', BezierCurve);\n    registerShape('arc', Arc);\n\n    var graphic = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        extendShape: extendShape,\n        extendPath: extendPath,\n        registerShape: registerShape,\n        getShapeClass: getShapeClass,\n        makePath: makePath,\n        makeImage: makeImage,\n        mergePath: mergePath$1,\n        resizePath: resizePath,\n        subPixelOptimizeLine: subPixelOptimizeLine$1,\n        subPixelOptimizeRect: subPixelOptimizeRect$1,\n        subPixelOptimize: subPixelOptimize$1,\n        updateProps: updateProps,\n        initProps: initProps,\n        removeElement: removeElement,\n        removeElementWithFadeOut: removeElementWithFadeOut,\n        isElementRemoved: isElementRemoved,\n        getTransform: getTransform,\n        applyTransform: applyTransform$1,\n        transformDirection: transformDirection,\n        groupTransition: groupTransition,\n        clipPointsByRect: clipPointsByRect,\n        clipRectByRect: clipRectByRect,\n        createIcon: createIcon,\n        linePolygonIntersect: linePolygonIntersect,\n        lineLineIntersect: lineLineIntersect,\n        Group: Group,\n        Image: ZRImage,\n        Text: ZRText,\n        Circle: Circle,\n        Ellipse: Ellipse,\n        Sector: Sector,\n        Ring: Ring,\n        Polygon: Polygon,\n        Polyline: Polyline,\n        Rect: Rect,\n        Line: Line,\n        BezierCurve: BezierCurve,\n        Arc: Arc,\n        IncrementalDisplayable: IncrementalDisplayable,\n        CompoundPath: CompoundPath,\n        LinearGradient: LinearGradient,\n        RadialGradient: RadialGradient,\n        BoundingRect: BoundingRect,\n        OrientedBoundingRect: OrientedBoundingRect,\n        Point: Point,\n        Path: Path\n    });\n\n    var EMPTY_OBJ = {};\n    function setLabelText(label, labelTexts) {\n      for (var i = 0; i < SPECIAL_STATES.length; i++) {\n        var stateName = SPECIAL_STATES[i];\n        var text = labelTexts[stateName];\n        var state = label.ensureState(stateName);\n        state.style = state.style || {};\n        state.style.text = text;\n      }\n\n      var oldStates = label.currentStates.slice();\n      label.clearStates(true);\n      label.setStyle({\n        text: labelTexts.normal\n      });\n      label.useStates(oldStates, true);\n    }\n\n    function getLabelText(opt, stateModels, interpolatedValue) {\n      var labelFetcher = opt.labelFetcher;\n      var labelDataIndex = opt.labelDataIndex;\n      var labelDimIndex = opt.labelDimIndex;\n      var normalModel = stateModels.normal;\n      var baseText;\n\n      if (labelFetcher) {\n        baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, normalModel && normalModel.get('formatter'), interpolatedValue != null ? {\n          interpolatedValue: interpolatedValue\n        } : null);\n      }\n\n      if (baseText == null) {\n        baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;\n      }\n\n      var statesText = {\n        normal: baseText\n      };\n\n      for (var i = 0; i < SPECIAL_STATES.length; i++) {\n        var stateName = SPECIAL_STATES[i];\n        var stateModel = stateModels[stateName];\n        statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get('formatter')) : null, baseText);\n      }\n\n      return statesText;\n    }\n\n    function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {\n      opt = opt || EMPTY_OBJ;\n      var isSetOnText = targetEl instanceof ZRText;\n      var needsCreateText = false;\n\n      for (var i = 0; i < DISPLAY_STATES.length; i++) {\n        var stateModel = labelStatesModels[DISPLAY_STATES[i]];\n\n        if (stateModel && stateModel.getShallow('show')) {\n          needsCreateText = true;\n          break;\n        }\n      }\n\n      var textContent = isSetOnText ? targetEl : targetEl.getTextContent();\n\n      if (needsCreateText) {\n        if (!isSetOnText) {\n          if (!textContent) {\n            textContent = new ZRText();\n            targetEl.setTextContent(textContent);\n          }\n\n          if (targetEl.stateProxy) {\n            textContent.stateProxy = targetEl.stateProxy;\n          }\n        }\n\n        var labelStatesTexts = getLabelText(opt, labelStatesModels);\n        var normalModel = labelStatesModels.normal;\n        var showNormal = !!normalModel.getShallow('show');\n        var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);\n        normalStyle.text = labelStatesTexts.normal;\n\n        if (!isSetOnText) {\n          targetEl.setTextConfig(createTextConfig(normalModel, opt, false));\n        }\n\n        for (var i = 0; i < SPECIAL_STATES.length; i++) {\n          var stateName = SPECIAL_STATES[i];\n          var stateModel = labelStatesModels[stateName];\n\n          if (stateModel) {\n            var stateObj = textContent.ensureState(stateName);\n            var stateShow = !!retrieve2(stateModel.getShallow('show'), showNormal);\n\n            if (stateShow !== showNormal) {\n              stateObj.ignore = !stateShow;\n            }\n\n            stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);\n            stateObj.style.text = labelStatesTexts[stateName];\n\n            if (!isSetOnText) {\n              var targetElEmphasisState = targetEl.ensureState(stateName);\n              targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);\n            }\n          }\n        }\n\n        textContent.silent = !!normalModel.getShallow('silent');\n\n        if (textContent.style.x != null) {\n          normalStyle.x = textContent.style.x;\n        }\n\n        if (textContent.style.y != null) {\n          normalStyle.y = textContent.style.y;\n        }\n\n        textContent.ignore = !showNormal;\n        textContent.useStyle(normalStyle);\n        textContent.dirty();\n\n        if (opt.enableTextSetter) {\n          labelInner(textContent).setLabelText = function (interpolatedValue) {\n            var labelStatesTexts = getLabelText(opt, labelStatesModels, interpolatedValue);\n            setLabelText(textContent, labelStatesTexts);\n          };\n        }\n      } else if (textContent) {\n        textContent.ignore = true;\n      }\n\n      targetEl.dirty();\n    }\n    function getLabelStatesModels(itemModel, labelName) {\n      labelName = labelName || 'label';\n      var statesModels = {\n        normal: itemModel.getModel(labelName)\n      };\n\n      for (var i = 0; i < SPECIAL_STATES.length; i++) {\n        var stateName = SPECIAL_STATES[i];\n        statesModels[stateName] = itemModel.getModel([stateName, labelName]);\n      }\n\n      return statesModels;\n    }\n    function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {\n      var textStyle = {};\n      setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);\n      specifiedTextStyle && extend(textStyle, specifiedTextStyle);\n      return textStyle;\n    }\n    function createTextConfig(textStyleModel, opt, isNotNormal) {\n      opt = opt || {};\n      var textConfig = {};\n      var labelPosition;\n      var labelRotate = textStyleModel.getShallow('rotate');\n      var labelDistance = retrieve2(textStyleModel.getShallow('distance'), isNotNormal ? null : 5);\n      var labelOffset = textStyleModel.getShallow('offset');\n      labelPosition = textStyleModel.getShallow('position') || (isNotNormal ? null : 'inside');\n      labelPosition === 'outside' && (labelPosition = opt.defaultOutsidePosition || 'top');\n\n      if (labelPosition != null) {\n        textConfig.position = labelPosition;\n      }\n\n      if (labelOffset != null) {\n        textConfig.offset = labelOffset;\n      }\n\n      if (labelRotate != null) {\n        labelRotate *= Math.PI / 180;\n        textConfig.rotation = labelRotate;\n      }\n\n      if (labelDistance != null) {\n        textConfig.distance = labelDistance;\n      }\n\n      textConfig.outsideFill = textStyleModel.get('color') === 'inherit' ? opt.inheritColor || null : 'auto';\n      return textConfig;\n    }\n\n    function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {\n      opt = opt || EMPTY_OBJ;\n      var ecModel = textStyleModel.ecModel;\n      var globalTextStyle = ecModel && ecModel.option.textStyle;\n      var richItemNames = getRichItemNames(textStyleModel);\n      var richResult;\n\n      if (richItemNames) {\n        richResult = {};\n\n        for (var name_1 in richItemNames) {\n          if (richItemNames.hasOwnProperty(name_1)) {\n            var richTextStyle = textStyleModel.getModel(['rich', name_1]);\n            setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);\n          }\n        }\n      }\n\n      if (richResult) {\n        textStyle.rich = richResult;\n      }\n\n      var overflow = textStyleModel.get('overflow');\n\n      if (overflow) {\n        textStyle.overflow = overflow;\n      }\n\n      var margin = textStyleModel.get('minMargin');\n\n      if (margin != null) {\n        textStyle.margin = margin;\n      }\n\n      setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);\n    }\n\n    function getRichItemNames(textStyleModel) {\n      var richItemNameMap;\n\n      while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {\n        var rich = (textStyleModel.option || EMPTY_OBJ).rich;\n\n        if (rich) {\n          richItemNameMap = richItemNameMap || {};\n          var richKeys = keys(rich);\n\n          for (var i = 0; i < richKeys.length; i++) {\n            var richKey = richKeys[i];\n            richItemNameMap[richKey] = 1;\n          }\n        }\n\n        textStyleModel = textStyleModel.parentModel;\n      }\n\n      return richItemNameMap;\n    }\n\n    var TEXT_PROPS_WITH_GLOBAL = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'];\n    var TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign'];\n    var TEXT_PROPS_BOX = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n\n    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {\n      globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;\n      var inheritColor = opt && opt.inheritColor;\n      var fillColor = textStyleModel.getShallow('color');\n      var strokeColor = textStyleModel.getShallow('textBorderColor');\n      var opacity = retrieve2(textStyleModel.getShallow('opacity'), globalTextStyle.opacity);\n\n      if (fillColor === 'inherit' || fillColor === 'auto') {\n        if (\"development\" !== 'production') {\n          if (fillColor === 'auto') {\n            deprecateReplaceLog('color: \\'auto\\'', 'color: \\'inherit\\'');\n          }\n        }\n\n        if (inheritColor) {\n          fillColor = inheritColor;\n        } else {\n          fillColor = null;\n        }\n      }\n\n      if (strokeColor === 'inherit' || strokeColor === 'auto') {\n        if (\"development\" !== 'production') {\n          if (strokeColor === 'auto') {\n            deprecateReplaceLog('color: \\'auto\\'', 'color: \\'inherit\\'');\n          }\n        }\n\n        if (inheritColor) {\n          strokeColor = inheritColor;\n        } else {\n          strokeColor = null;\n        }\n      }\n\n      if (!isAttached) {\n        fillColor = fillColor || globalTextStyle.color;\n        strokeColor = strokeColor || globalTextStyle.textBorderColor;\n      }\n\n      if (fillColor != null) {\n        textStyle.fill = fillColor;\n      }\n\n      if (strokeColor != null) {\n        textStyle.stroke = strokeColor;\n      }\n\n      var textBorderWidth = retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);\n\n      if (textBorderWidth != null) {\n        textStyle.lineWidth = textBorderWidth;\n      }\n\n      var textBorderType = retrieve2(textStyleModel.getShallow('textBorderType'), globalTextStyle.textBorderType);\n\n      if (textBorderType != null) {\n        textStyle.lineDash = textBorderType;\n      }\n\n      var textBorderDashOffset = retrieve2(textStyleModel.getShallow('textBorderDashOffset'), globalTextStyle.textBorderDashOffset);\n\n      if (textBorderDashOffset != null) {\n        textStyle.lineDashOffset = textBorderDashOffset;\n      }\n\n      if (!isNotNormal && opacity == null && !inRich) {\n        opacity = opt && opt.defaultOpacity;\n      }\n\n      if (opacity != null) {\n        textStyle.opacity = opacity;\n      }\n\n      if (!isNotNormal && !isAttached) {\n        if (textStyle.fill == null && opt.inheritColor) {\n          textStyle.fill = opt.inheritColor;\n        }\n      }\n\n      for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {\n        var key = TEXT_PROPS_WITH_GLOBAL[i];\n        var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);\n\n        if (val != null) {\n          textStyle[key] = val;\n        }\n      }\n\n      for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {\n        var key = TEXT_PROPS_SELF[i];\n        var val = textStyleModel.getShallow(key);\n\n        if (val != null) {\n          textStyle[key] = val;\n        }\n      }\n\n      if (textStyle.verticalAlign == null) {\n        var baseline = textStyleModel.getShallow('baseline');\n\n        if (baseline != null) {\n          textStyle.verticalAlign = baseline;\n        }\n      }\n\n      if (!isBlock || !opt.disableBox) {\n        for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {\n          var key = TEXT_PROPS_BOX[i];\n          var val = textStyleModel.getShallow(key);\n\n          if (val != null) {\n            textStyle[key] = val;\n          }\n        }\n\n        var borderType = textStyleModel.getShallow('borderType');\n\n        if (borderType != null) {\n          textStyle.borderDash = borderType;\n        }\n\n        if ((textStyle.backgroundColor === 'auto' || textStyle.backgroundColor === 'inherit') && inheritColor) {\n          if (\"development\" !== 'production') {\n            if (textStyle.backgroundColor === 'auto') {\n              deprecateReplaceLog('backgroundColor: \\'auto\\'', 'backgroundColor: \\'inherit\\'');\n            }\n          }\n\n          textStyle.backgroundColor = inheritColor;\n        }\n\n        if ((textStyle.borderColor === 'auto' || textStyle.borderColor === 'inherit') && inheritColor) {\n          if (\"development\" !== 'production') {\n            if (textStyle.borderColor === 'auto') {\n              deprecateReplaceLog('borderColor: \\'auto\\'', 'borderColor: \\'inherit\\'');\n            }\n          }\n\n          textStyle.borderColor = inheritColor;\n        }\n      }\n    }\n\n    function getFont(opt, ecModel) {\n      var gTextStyleModel = ecModel && ecModel.getModel('textStyle');\n      return trim([opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));\n    }\n    var labelInner = makeInner();\n    function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {\n      if (!label) {\n        return;\n      }\n\n      var obj = labelInner(label);\n      obj.prevValue = obj.value;\n      obj.value = value;\n      var normalLabelModel = labelStatesModels.normal;\n      obj.valueAnimation = normalLabelModel.get('valueAnimation');\n\n      if (obj.valueAnimation) {\n        obj.precision = normalLabelModel.get('precision');\n        obj.defaultInterpolatedText = getDefaultText;\n        obj.statesModels = labelStatesModels;\n      }\n    }\n    function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {\n      var labelInnerStore = labelInner(textEl);\n\n      if (!labelInnerStore.valueAnimation) {\n        return;\n      }\n\n      var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;\n      var currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);\n      var targetValue = labelInnerStore.value;\n\n      function during(percent) {\n        var interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);\n        labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;\n        var labelText = getLabelText({\n          labelDataIndex: dataIndex,\n          labelFetcher: labelFetcher,\n          defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ''\n        }, labelInnerStore.statesModels, interpolated);\n        setLabelText(textEl, labelText);\n      }\n\n      (currValue == null ? initProps : updateProps)(textEl, {}, animatableModel, dataIndex, null, during);\n    }\n\n    var PATH_COLOR = ['textStyle', 'color'];\n    var tmpRichText = new ZRText();\n\n    var TextStyleMixin = function () {\n      function TextStyleMixin() {}\n\n      TextStyleMixin.prototype.getTextColor = function (isEmphasis) {\n        var ecModel = this.ecModel;\n        return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);\n      };\n\n      TextStyleMixin.prototype.getFont = function () {\n        return getFont({\n          fontStyle: this.getShallow('fontStyle'),\n          fontWeight: this.getShallow('fontWeight'),\n          fontSize: this.getShallow('fontSize'),\n          fontFamily: this.getShallow('fontFamily')\n        }, this.ecModel);\n      };\n\n      TextStyleMixin.prototype.getTextRect = function (text) {\n        tmpRichText.useStyle({\n          text: text,\n          fontStyle: this.getShallow('fontStyle'),\n          fontWeight: this.getShallow('fontWeight'),\n          fontSize: this.getShallow('fontSize'),\n          fontFamily: this.getShallow('fontFamily'),\n          verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline'),\n          padding: this.getShallow('padding'),\n          lineHeight: this.getShallow('lineHeight'),\n          rich: this.getShallow('rich')\n        });\n        tmpRichText.update();\n        return tmpRichText.getBoundingRect();\n      };\n\n      return TextStyleMixin;\n    }();\n\n    var LINE_STYLE_KEY_MAP = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit']];\n    var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);\n\n    var LineStyleMixin = function () {\n      function LineStyleMixin() {}\n\n      LineStyleMixin.prototype.getLineStyle = function (excludes) {\n        return getLineStyle(this, excludes);\n      };\n\n      return LineStyleMixin;\n    }();\n\n    var ITEM_STYLE_KEY_MAP = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit']];\n    var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);\n\n    var ItemStyleMixin = function () {\n      function ItemStyleMixin() {}\n\n      ItemStyleMixin.prototype.getItemStyle = function (excludes, includes) {\n        return getItemStyle(this, excludes, includes);\n      };\n\n      return ItemStyleMixin;\n    }();\n\n    var Model = function () {\n      function Model(option, parentModel, ecModel) {\n        this.parentModel = parentModel;\n        this.ecModel = ecModel;\n        this.option = option;\n      }\n\n      Model.prototype.init = function (option, parentModel, ecModel) {\n        var rest = [];\n\n        for (var _i = 3; _i < arguments.length; _i++) {\n          rest[_i - 3] = arguments[_i];\n        }\n      };\n\n      Model.prototype.mergeOption = function (option, ecModel) {\n        merge(this.option, option, true);\n      };\n\n      Model.prototype.get = function (path, ignoreParent) {\n        if (path == null) {\n          return this.option;\n        }\n\n        return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);\n      };\n\n      Model.prototype.getShallow = function (key, ignoreParent) {\n        var option = this.option;\n        var val = option == null ? option : option[key];\n\n        if (val == null && !ignoreParent) {\n          var parentModel = this.parentModel;\n\n          if (parentModel) {\n            val = parentModel.getShallow(key);\n          }\n        }\n\n        return val;\n      };\n\n      Model.prototype.getModel = function (path, parentModel) {\n        var hasPath = path != null;\n        var pathFinal = hasPath ? this.parsePath(path) : null;\n        var obj = hasPath ? this._doGet(pathFinal) : this.option;\n        parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));\n        return new Model(obj, parentModel, this.ecModel);\n      };\n\n      Model.prototype.isEmpty = function () {\n        return this.option == null;\n      };\n\n      Model.prototype.restoreData = function () {};\n\n      Model.prototype.clone = function () {\n        var Ctor = this.constructor;\n        return new Ctor(clone(this.option));\n      };\n\n      Model.prototype.parsePath = function (path) {\n        if (typeof path === 'string') {\n          return path.split('.');\n        }\n\n        return path;\n      };\n\n      Model.prototype.resolveParentPath = function (path) {\n        return path;\n      };\n\n      Model.prototype.isAnimationEnabled = function () {\n        if (!env.node && this.option) {\n          if (this.option.animation != null) {\n            return !!this.option.animation;\n          } else if (this.parentModel) {\n            return this.parentModel.isAnimationEnabled();\n          }\n        }\n      };\n\n      Model.prototype._doGet = function (pathArr, parentModel) {\n        var obj = this.option;\n\n        if (!pathArr) {\n          return obj;\n        }\n\n        for (var i = 0; i < pathArr.length; i++) {\n          if (!pathArr[i]) {\n            continue;\n          }\n\n          obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;\n\n          if (obj == null) {\n            break;\n          }\n        }\n\n        if (obj == null && parentModel) {\n          obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);\n        }\n\n        return obj;\n      };\n\n      return Model;\n    }();\n    enableClassExtend(Model);\n    enableClassCheck(Model);\n    mixin(Model, LineStyleMixin);\n    mixin(Model, ItemStyleMixin);\n    mixin(Model, AreaStyleMixin);\n    mixin(Model, TextStyleMixin);\n\n    var base = Math.round(Math.random() * 10);\n    function getUID(type) {\n      return [type || '', base++].join('_');\n    }\n    function enableSubTypeDefaulter(target) {\n      var subTypeDefaulters = {};\n\n      target.registerSubTypeDefaulter = function (componentType, defaulter) {\n        var componentTypeInfo = parseClassType(componentType);\n        subTypeDefaulters[componentTypeInfo.main] = defaulter;\n      };\n\n      target.determineSubType = function (componentType, option) {\n        var type = option.type;\n\n        if (!type) {\n          var componentTypeMain = parseClassType(componentType).main;\n\n          if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {\n            type = subTypeDefaulters[componentTypeMain](option);\n          }\n        }\n\n        return type;\n      };\n    }\n    function enableTopologicalTravel(entity, dependencyGetter) {\n      entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {\n        if (!targetNameList.length) {\n          return;\n        }\n\n        var result = makeDepndencyGraph(fullNameList);\n        var graph = result.graph;\n        var noEntryList = result.noEntryList;\n        var targetNameSet = {};\n        each(targetNameList, function (name) {\n          targetNameSet[name] = true;\n        });\n\n        while (noEntryList.length) {\n          var currComponentType = noEntryList.pop();\n          var currVertex = graph[currComponentType];\n          var isInTargetNameSet = !!targetNameSet[currComponentType];\n\n          if (isInTargetNameSet) {\n            callback.call(context, currComponentType, currVertex.originalDeps.slice());\n            delete targetNameSet[currComponentType];\n          }\n\n          each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);\n        }\n\n        each(targetNameSet, function () {\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = makePrintable('Circle dependency may exists: ', targetNameSet, targetNameList, fullNameList);\n          }\n\n          throw new Error(errMsg);\n        });\n\n        function removeEdge(succComponentType) {\n          graph[succComponentType].entryCount--;\n\n          if (graph[succComponentType].entryCount === 0) {\n            noEntryList.push(succComponentType);\n          }\n        }\n\n        function removeEdgeAndAdd(succComponentType) {\n          targetNameSet[succComponentType] = true;\n          removeEdge(succComponentType);\n        }\n      };\n\n      function makeDepndencyGraph(fullNameList) {\n        var graph = {};\n        var noEntryList = [];\n        each(fullNameList, function (name) {\n          var thisItem = createDependencyGraphItem(graph, name);\n          var originalDeps = thisItem.originalDeps = dependencyGetter(name);\n          var availableDeps = getAvailableDependencies(originalDeps, fullNameList);\n          thisItem.entryCount = availableDeps.length;\n\n          if (thisItem.entryCount === 0) {\n            noEntryList.push(name);\n          }\n\n          each(availableDeps, function (dependentName) {\n            if (indexOf(thisItem.predecessor, dependentName) < 0) {\n              thisItem.predecessor.push(dependentName);\n            }\n\n            var thatItem = createDependencyGraphItem(graph, dependentName);\n\n            if (indexOf(thatItem.successor, dependentName) < 0) {\n              thatItem.successor.push(name);\n            }\n          });\n        });\n        return {\n          graph: graph,\n          noEntryList: noEntryList\n        };\n      }\n\n      function createDependencyGraphItem(graph, name) {\n        if (!graph[name]) {\n          graph[name] = {\n            predecessor: [],\n            successor: []\n          };\n        }\n\n        return graph[name];\n      }\n\n      function getAvailableDependencies(originalDeps, fullNameList) {\n        var availableDeps = [];\n        each(originalDeps, function (dep) {\n          indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);\n        });\n        return availableDeps;\n      }\n    }\n    function inheritDefaultOption(superOption, subOption) {\n      return merge(merge({}, superOption, true), subOption, true);\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var langEN = {\n      time: {\n        month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n      },\n      legend: {\n        selector: {\n          all: 'All',\n          inverse: 'Inv'\n        }\n      },\n      toolbox: {\n        brush: {\n          title: {\n            rect: 'Box Select',\n            polygon: 'Lasso Select',\n            lineX: 'Horizontally Select',\n            lineY: 'Vertically Select',\n            keep: 'Keep Selections',\n            clear: 'Clear Selections'\n          }\n        },\n        dataView: {\n          title: 'Data View',\n          lang: ['Data View', 'Close', 'Refresh']\n        },\n        dataZoom: {\n          title: {\n            zoom: 'Zoom',\n            back: 'Zoom Reset'\n          }\n        },\n        magicType: {\n          title: {\n            line: 'Switch to Line Chart',\n            bar: 'Switch to Bar Chart',\n            stack: 'Stack',\n            tiled: 'Tile'\n          }\n        },\n        restore: {\n          title: 'Restore'\n        },\n        saveAsImage: {\n          title: 'Save as Image',\n          lang: ['Right Click to Save Image']\n        }\n      },\n      series: {\n        typeNames: {\n          pie: 'Pie chart',\n          bar: 'Bar chart',\n          line: 'Line chart',\n          scatter: 'Scatter plot',\n          effectScatter: 'Ripple scatter plot',\n          radar: 'Radar chart',\n          tree: 'Tree',\n          treemap: 'Treemap',\n          boxplot: 'Boxplot',\n          candlestick: 'Candlestick',\n          k: 'K line chart',\n          heatmap: 'Heat map',\n          map: 'Map',\n          parallel: 'Parallel coordinate map',\n          lines: 'Line graph',\n          graph: 'Relationship graph',\n          sankey: 'Sankey diagram',\n          funnel: 'Funnel chart',\n          gauge: 'Guage',\n          pictorialBar: 'Pictorial bar',\n          themeRiver: 'Theme River Map',\n          sunburst: 'Sunburst'\n        }\n      },\n      aria: {\n        general: {\n          withTitle: 'This is a chart about \"{title}\"',\n          withoutTitle: 'This is a chart'\n        },\n        series: {\n          single: {\n            prefix: '',\n            withName: ' with type {seriesType} named {seriesName}.',\n            withoutName: ' with type {seriesType}.'\n          },\n          multiple: {\n            prefix: '. It consists of {seriesCount} series count.',\n            withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',\n            withoutName: ' The {seriesId} series is a {seriesType}.',\n            separator: {\n              middle: '',\n              end: ''\n            }\n          }\n        },\n        data: {\n          allData: 'The data is as follows: ',\n          partialData: 'The first {displayCnt} items are: ',\n          withName: 'the data for {name} is {value}',\n          withoutName: '{value}',\n          separator: {\n            middle: ', ',\n            end: '. '\n          }\n        }\n      }\n    };\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var langZH = {\n      time: {\n        month: ['', '', '', '', '', '', '', '', '', '', '', ''],\n        monthAbbr: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'],\n        dayOfWeek: ['', '', '', '', '', '', ''],\n        dayOfWeekAbbr: ['', '', '', '', '', '', '']\n      },\n      legend: {\n        selector: {\n          all: '',\n          inverse: ''\n        }\n      },\n      toolbox: {\n        brush: {\n          title: {\n            rect: '',\n            polygon: '',\n            lineX: '',\n            lineY: '',\n            keep: '',\n            clear: ''\n          }\n        },\n        dataView: {\n          title: '',\n          lang: ['', '', '']\n        },\n        dataZoom: {\n          title: {\n            zoom: '',\n            back: ''\n          }\n        },\n        magicType: {\n          title: {\n            line: '',\n            bar: '',\n            stack: '',\n            tiled: ''\n          }\n        },\n        restore: {\n          title: ''\n        },\n        saveAsImage: {\n          title: '',\n          lang: ['']\n        }\n      },\n      series: {\n        typeNames: {\n          pie: '',\n          bar: '',\n          line: '',\n          scatter: '',\n          effectScatter: '',\n          radar: '',\n          tree: '',\n          treemap: '',\n          boxplot: '',\n          candlestick: 'K',\n          k: 'K',\n          heatmap: '',\n          map: '',\n          parallel: '',\n          lines: '',\n          graph: '',\n          sankey: '',\n          funnel: '',\n          gauge: '',\n          pictorialBar: '',\n          themeRiver: '',\n          sunburst: ''\n        }\n      },\n      aria: {\n        general: {\n          withTitle: '{title}',\n          withoutTitle: ''\n        },\n        series: {\n          single: {\n            prefix: '',\n            withName: '{seriesType}{seriesName}',\n            withoutName: '{seriesType}'\n          },\n          multiple: {\n            prefix: '{seriesCount}',\n            withName: '{seriesId}{seriesName}{seriesType}',\n            withoutName: '{seriesId}{seriesType}',\n            separator: {\n              middle: '',\n              end: ''\n            }\n          }\n        },\n        data: {\n          allData: '',\n          partialData: '{displayCnt}',\n          withName: '{name}{value}',\n          withoutName: '{value}',\n          separator: {\n            middle: '',\n            end: ''\n          }\n        }\n      }\n    };\n\n    var LOCALE_ZH = 'ZH';\n    var LOCALE_EN = 'EN';\n    var DEFAULT_LOCALE = LOCALE_EN;\n    var localeStorage = {};\n    var localeModels = {};\n    var SYSTEM_LANG = !env.domSupported ? DEFAULT_LOCALE : function () {\n      var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();\n      return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;\n    }();\n    function registerLocale(locale, localeObj) {\n      locale = locale.toUpperCase();\n      localeModels[locale] = new Model(localeObj);\n      localeStorage[locale] = localeObj;\n    }\n    function createLocaleObject(locale) {\n      if (isString(locale)) {\n        var localeObj = localeStorage[locale.toUpperCase()] || {};\n\n        if (locale === LOCALE_ZH || locale === LOCALE_EN) {\n          return clone(localeObj);\n        } else {\n          return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);\n        }\n      } else {\n        return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);\n      }\n    }\n    function getLocaleModel(lang) {\n      return localeModels[lang];\n    }\n    function getDefaultLocaleModel() {\n      return localeModels[DEFAULT_LOCALE];\n    }\n    registerLocale(LOCALE_EN, langEN);\n    registerLocale(LOCALE_ZH, langZH);\n\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n    var ONE_YEAR = ONE_DAY * 365;\n    var defaultLeveledFormatter = {\n      year: '{yyyy}',\n      month: '{MMM}',\n      day: '{d}',\n      hour: '{HH}:{mm}',\n      minute: '{HH}:{mm}',\n      second: '{HH}:{mm}:{ss}',\n      millisecond: '{hh}:{mm}:{ss} {SSS}',\n      none: '{yyyy}-{MM}-{dd} {hh}:{mm}:{ss} {SSS}'\n    };\n    var fullDayFormatter = '{yyyy}-{MM}-{dd}';\n    var fullLeveledFormatter = {\n      year: '{yyyy}',\n      month: '{yyyy}-{MM}',\n      day: fullDayFormatter,\n      hour: fullDayFormatter + ' ' + defaultLeveledFormatter.hour,\n      minute: fullDayFormatter + ' ' + defaultLeveledFormatter.minute,\n      second: fullDayFormatter + ' ' + defaultLeveledFormatter.second,\n      millisecond: defaultLeveledFormatter.none\n    };\n    var primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];\n    var timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond'];\n    function pad(str, len) {\n      str += '';\n      return '0000'.substr(0, len - str.length) + str;\n    }\n    function getPrimaryTimeUnit(timeUnit) {\n      switch (timeUnit) {\n        case 'half-year':\n        case 'quarter':\n          return 'month';\n\n        case 'week':\n        case 'half-week':\n          return 'day';\n\n        case 'half-day':\n        case 'quarter-day':\n          return 'hour';\n\n        default:\n          return timeUnit;\n      }\n    }\n    function isPrimaryTimeUnit(timeUnit) {\n      return timeUnit === getPrimaryTimeUnit(timeUnit);\n    }\n    function getDefaultFormatPrecisionOfInterval(timeUnit) {\n      switch (timeUnit) {\n        case 'year':\n        case 'month':\n          return 'day';\n\n        case 'millisecond':\n          return 'millisecond';\n\n        default:\n          return 'second';\n      }\n    }\n    function format(time, template, isUTC, lang) {\n      var date = parseDate(time);\n      var y = date[fullYearGetterName(isUTC)]();\n      var M = date[monthGetterName(isUTC)]() + 1;\n      var q = Math.floor((M - 1) / 4) + 1;\n      var d = date[dateGetterName(isUTC)]();\n      var e = date['get' + (isUTC ? 'UTC' : '') + 'Day']();\n      var H = date[hoursGetterName(isUTC)]();\n      var h = (H - 1) % 12 + 1;\n      var m = date[minutesGetterName(isUTC)]();\n      var s = date[secondsGetterName(isUTC)]();\n      var S = date[millisecondsGetterName(isUTC)]();\n      var localeModel = lang instanceof Model ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();\n      var timeModel = localeModel.getModel('time');\n      var month = timeModel.get('month');\n      var monthAbbr = timeModel.get('monthAbbr');\n      var dayOfWeek = timeModel.get('dayOfWeek');\n      var dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr');\n      return (template || '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, y % 100 + '').replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '');\n    }\n    function leveledFormat(tick, idx, formatter, lang, isUTC) {\n      var template = null;\n\n      if (typeof formatter === 'string') {\n        template = formatter;\n      } else if (typeof formatter === 'function') {\n        template = formatter(tick.value, idx, {\n          level: tick.level\n        });\n      } else {\n        var defaults$1 = extend({}, defaultLeveledFormatter);\n\n        if (tick.level > 0) {\n          for (var i = 0; i < primaryTimeUnits.length; ++i) {\n            defaults$1[primaryTimeUnits[i]] = \"{primary|\" + defaults$1[primaryTimeUnits[i]] + \"}\";\n          }\n        }\n\n        var mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults$1) : defaults$1;\n        var unit = getUnitFromValue(tick.value, isUTC);\n\n        if (mergedFormatter[unit]) {\n          template = mergedFormatter[unit];\n        } else if (mergedFormatter.inherit) {\n          var targetId = timeUnits.indexOf(unit);\n\n          for (var i = targetId - 1; i >= 0; --i) {\n            if (mergedFormatter[unit]) {\n              template = mergedFormatter[unit];\n              break;\n            }\n          }\n\n          template = template || defaults$1.none;\n        }\n\n        if (isArray(template)) {\n          var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;\n          levelId = Math.min(levelId, template.length - 1);\n          template = template[levelId];\n        }\n      }\n\n      return format(new Date(tick.value), template, isUTC, lang);\n    }\n    function getUnitFromValue(value, isUTC) {\n      var date = parseDate(value);\n      var M = date[monthGetterName(isUTC)]() + 1;\n      var d = date[dateGetterName(isUTC)]();\n      var h = date[hoursGetterName(isUTC)]();\n      var m = date[minutesGetterName(isUTC)]();\n      var s = date[secondsGetterName(isUTC)]();\n      var S = date[millisecondsGetterName(isUTC)]();\n      var isSecond = S === 0;\n      var isMinute = isSecond && s === 0;\n      var isHour = isMinute && m === 0;\n      var isDay = isHour && h === 0;\n      var isMonth = isDay && d === 1;\n      var isYear = isMonth && M === 1;\n\n      if (isYear) {\n        return 'year';\n      } else if (isMonth) {\n        return 'month';\n      } else if (isDay) {\n        return 'day';\n      } else if (isHour) {\n        return 'hour';\n      } else if (isMinute) {\n        return 'minute';\n      } else if (isSecond) {\n        return 'second';\n      } else {\n        return 'millisecond';\n      }\n    }\n    function getUnitValue(value, unit, isUTC) {\n      var date = typeof value === 'number' ? parseDate(value) : value;\n      unit = unit || getUnitFromValue(value, isUTC);\n\n      switch (unit) {\n        case 'year':\n          return date[fullYearGetterName(isUTC)]();\n\n        case 'half-year':\n          return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;\n\n        case 'quarter':\n          return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);\n\n        case 'month':\n          return date[monthGetterName(isUTC)]();\n\n        case 'day':\n          return date[dateGetterName(isUTC)]();\n\n        case 'half-day':\n          return date[hoursGetterName(isUTC)]() / 24;\n\n        case 'hour':\n          return date[hoursGetterName(isUTC)]();\n\n        case 'minute':\n          return date[minutesGetterName(isUTC)]();\n\n        case 'second':\n          return date[secondsGetterName(isUTC)]();\n\n        case 'millisecond':\n          return date[millisecondsGetterName(isUTC)]();\n      }\n    }\n    function fullYearGetterName(isUTC) {\n      return isUTC ? 'getUTCFullYear' : 'getFullYear';\n    }\n    function monthGetterName(isUTC) {\n      return isUTC ? 'getUTCMonth' : 'getMonth';\n    }\n    function dateGetterName(isUTC) {\n      return isUTC ? 'getUTCDate' : 'getDate';\n    }\n    function hoursGetterName(isUTC) {\n      return isUTC ? 'getUTCHours' : 'getHours';\n    }\n    function minutesGetterName(isUTC) {\n      return isUTC ? 'getUTCMinutes' : 'getMinutes';\n    }\n    function secondsGetterName(isUTC) {\n      return isUTC ? 'getUTCSeconds' : 'getSeconds';\n    }\n    function millisecondsGetterName(isUTC) {\n      return isUTC ? 'getUTCSeconds' : 'getSeconds';\n    }\n    function fullYearSetterName(isUTC) {\n      return isUTC ? 'setUTCFullYear' : 'setFullYear';\n    }\n    function monthSetterName(isUTC) {\n      return isUTC ? 'setUTCMonth' : 'setMonth';\n    }\n    function dateSetterName(isUTC) {\n      return isUTC ? 'setUTCDate' : 'setDate';\n    }\n    function hoursSetterName(isUTC) {\n      return isUTC ? 'setUTCHours' : 'setHours';\n    }\n    function minutesSetterName(isUTC) {\n      return isUTC ? 'setUTCMinutes' : 'setMinutes';\n    }\n    function secondsSetterName(isUTC) {\n      return isUTC ? 'setUTCSeconds' : 'setSeconds';\n    }\n    function millisecondsSetterName(isUTC) {\n      return isUTC ? 'setUTCSeconds' : 'setSeconds';\n    }\n\n    function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {\n      deprecateLog('getTextRect is deprecated.');\n      var textEl = new ZRText({\n        style: {\n          text: text,\n          font: font,\n          align: align,\n          verticalAlign: verticalAlign,\n          padding: padding,\n          rich: rich,\n          overflow: truncate ? 'truncate' : null,\n          lineHeight: lineHeight\n        }\n      });\n      return textEl.getBoundingRect();\n    }\n\n    function addCommas(x) {\n      if (!isNumeric(x)) {\n        return isString(x) ? x : '-';\n      }\n\n      var parts = (x + '').split('.');\n      return parts[0].replace(/(\\d{1,3})(?=(?:\\d{3})+(?!\\d))/g, '$1,') + (parts.length > 1 ? '.' + parts[1] : '');\n    }\n    function toCamelCase(str, upperCaseFirst) {\n      str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {\n        return group1.toUpperCase();\n      });\n\n      if (upperCaseFirst && str) {\n        str = str.charAt(0).toUpperCase() + str.slice(1);\n      }\n\n      return str;\n    }\n    var normalizeCssArray$1 = normalizeCssArray;\n    var replaceReg = /([&<>\"'])/g;\n    var replaceMap = {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      '\\'': '&#39;'\n    };\n    function encodeHTML(source) {\n      return source == null ? '' : (source + '').replace(replaceReg, function (str, c) {\n        return replaceMap[c];\n      });\n    }\n    function makeValueReadable(value, valueType, useUTC) {\n      var USER_READABLE_DEFUALT_TIME_PATTERN = 'yyyy-MM-dd hh:mm:ss';\n\n      function stringToUserReadable(str) {\n        return str && trim(str) ? str : '-';\n      }\n\n      function isNumberUserReadable(num) {\n        return !!(num != null && !isNaN(num) && isFinite(num));\n      }\n\n      var isTypeTime = valueType === 'time';\n      var isValueDate = value instanceof Date;\n\n      if (isTypeTime || isValueDate) {\n        var date = isTypeTime ? parseDate(value) : value;\n\n        if (!isNaN(+date)) {\n          return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);\n        } else if (isValueDate) {\n          return '-';\n        }\n      }\n\n      if (valueType === 'ordinal') {\n        return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + '' : '-' : '-';\n      }\n\n      var numericResult = numericToNumber(value);\n      return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : '-';\n    }\n    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n\n    var wrapVar = function (varName, seriesIdx) {\n      return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';\n    };\n\n    function formatTpl(tpl, paramsList, encode) {\n      if (!isArray(paramsList)) {\n        paramsList = [paramsList];\n      }\n\n      var seriesLen = paramsList.length;\n\n      if (!seriesLen) {\n        return '';\n      }\n\n      var $vars = paramsList[0].$vars || [];\n\n      for (var i = 0; i < $vars.length; i++) {\n        var alias = TPL_VAR_ALIAS[i];\n        tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));\n      }\n\n      for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {\n        for (var k = 0; k < $vars.length; k++) {\n          var val = paramsList[seriesIdx][$vars[k]];\n          tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);\n        }\n      }\n\n      return tpl;\n    }\n    function formatTplSimple(tpl, param, encode) {\n      each(param, function (value, key) {\n        tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);\n      });\n      return tpl;\n    }\n    function getTooltipMarker(inOpt, extraCssText) {\n      var opt = isString(inOpt) ? {\n        color: inOpt,\n        extraCssText: extraCssText\n      } : inOpt || {};\n      var color = opt.color;\n      var type = opt.type;\n      extraCssText = opt.extraCssText;\n      var renderMode = opt.renderMode || 'html';\n\n      if (!color) {\n        return '';\n      }\n\n      if (renderMode === 'html') {\n        return type === 'subItem' ? '<span style=\"display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>' : '<span style=\"display:inline-block;margin-right:4px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '\"></span>';\n      } else {\n        var markerId = opt.markerId || 'markerX';\n        return {\n          renderMode: renderMode,\n          content: '{' + markerId + '|}  ',\n          style: type === 'subItem' ? {\n            width: 4,\n            height: 4,\n            borderRadius: 2,\n            backgroundColor: color\n          } : {\n            width: 10,\n            height: 10,\n            borderRadius: 5,\n            backgroundColor: color\n          }\n        };\n      }\n    }\n    function formatTime(tpl, value, isUTC) {\n      if (\"development\" !== 'production') {\n        deprecateReplaceLog('echarts.format.formatTime', 'echarts.time.format');\n      }\n\n      if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {\n        tpl = 'MM-dd\\nyyyy';\n      }\n\n      var date = parseDate(value);\n      var utc = isUTC ? 'UTC' : '';\n      var y = date['get' + utc + 'FullYear']();\n      var M = date['get' + utc + 'Month']() + 1;\n      var d = date['get' + utc + 'Date']();\n      var h = date['get' + utc + 'Hours']();\n      var m = date['get' + utc + 'Minutes']();\n      var s = date['get' + utc + 'Seconds']();\n      var S = date['get' + utc + 'Milliseconds']();\n      tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', y % 100 + '').replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3));\n      return tpl;\n    }\n    function capitalFirst(str) {\n      return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;\n    }\n    function convertToColorString(color, defaultColor) {\n      defaultColor = defaultColor || 'transparent';\n      return isString(color) ? color : isObject(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;\n    }\n    function windowOpen(link, target) {\n      if (target === '_blank' || target === 'blank') {\n        var blank = window.open();\n        blank.opener = null;\n        blank.location.href = link;\n      } else {\n        window.open(link, target);\n      }\n    }\n\n    var each$1 = each;\n    var LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];\n    var HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];\n\n    function boxLayout(orient, group, gap, maxWidth, maxHeight) {\n      var x = 0;\n      var y = 0;\n\n      if (maxWidth == null) {\n        maxWidth = Infinity;\n      }\n\n      if (maxHeight == null) {\n        maxHeight = Infinity;\n      }\n\n      var currentLineMaxSize = 0;\n      group.eachChild(function (child, idx) {\n        var rect = child.getBoundingRect();\n        var nextChild = group.childAt(idx + 1);\n        var nextChildRect = nextChild && nextChild.getBoundingRect();\n        var nextX;\n        var nextY;\n\n        if (orient === 'horizontal') {\n          var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);\n          nextX = x + moveX;\n\n          if (nextX > maxWidth || child.newline) {\n            x = 0;\n            nextX = moveX;\n            y += currentLineMaxSize + gap;\n            currentLineMaxSize = rect.height;\n          } else {\n            currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);\n          }\n        } else {\n          var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);\n          nextY = y + moveY;\n\n          if (nextY > maxHeight || child.newline) {\n            x += currentLineMaxSize + gap;\n            y = 0;\n            nextY = moveY;\n            currentLineMaxSize = rect.width;\n          } else {\n            currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);\n          }\n        }\n\n        if (child.newline) {\n          return;\n        }\n\n        child.x = x;\n        child.y = y;\n        child.markRedraw();\n        orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;\n      });\n    }\n\n    var box = boxLayout;\n    var vbox = curry(boxLayout, 'vertical');\n    var hbox = curry(boxLayout, 'horizontal');\n    function getAvailableSize(positionInfo, containerRect, margin) {\n      var containerWidth = containerRect.width;\n      var containerHeight = containerRect.height;\n      var x = parsePercent$1(positionInfo.left, containerWidth);\n      var y = parsePercent$1(positionInfo.top, containerHeight);\n      var x2 = parsePercent$1(positionInfo.right, containerWidth);\n      var y2 = parsePercent$1(positionInfo.bottom, containerHeight);\n      (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);\n      (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);\n      (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);\n      (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);\n      margin = normalizeCssArray$1(margin || 0);\n      return {\n        width: Math.max(x2 - x - margin[1] - margin[3], 0),\n        height: Math.max(y2 - y - margin[0] - margin[2], 0)\n      };\n    }\n    function getLayoutRect(positionInfo, containerRect, margin) {\n      margin = normalizeCssArray$1(margin || 0);\n      var containerWidth = containerRect.width;\n      var containerHeight = containerRect.height;\n      var left = parsePercent$1(positionInfo.left, containerWidth);\n      var top = parsePercent$1(positionInfo.top, containerHeight);\n      var right = parsePercent$1(positionInfo.right, containerWidth);\n      var bottom = parsePercent$1(positionInfo.bottom, containerHeight);\n      var width = parsePercent$1(positionInfo.width, containerWidth);\n      var height = parsePercent$1(positionInfo.height, containerHeight);\n      var verticalMargin = margin[2] + margin[0];\n      var horizontalMargin = margin[1] + margin[3];\n      var aspect = positionInfo.aspect;\n\n      if (isNaN(width)) {\n        width = containerWidth - right - horizontalMargin - left;\n      }\n\n      if (isNaN(height)) {\n        height = containerHeight - bottom - verticalMargin - top;\n      }\n\n      if (aspect != null) {\n        if (isNaN(width) && isNaN(height)) {\n          if (aspect > containerWidth / containerHeight) {\n            width = containerWidth * 0.8;\n          } else {\n            height = containerHeight * 0.8;\n          }\n        }\n\n        if (isNaN(width)) {\n          width = aspect * height;\n        }\n\n        if (isNaN(height)) {\n          height = width / aspect;\n        }\n      }\n\n      if (isNaN(left)) {\n        left = containerWidth - right - width - horizontalMargin;\n      }\n\n      if (isNaN(top)) {\n        top = containerHeight - bottom - height - verticalMargin;\n      }\n\n      switch (positionInfo.left || positionInfo.right) {\n        case 'center':\n          left = containerWidth / 2 - width / 2 - margin[3];\n          break;\n\n        case 'right':\n          left = containerWidth - width - horizontalMargin;\n          break;\n      }\n\n      switch (positionInfo.top || positionInfo.bottom) {\n        case 'middle':\n        case 'center':\n          top = containerHeight / 2 - height / 2 - margin[0];\n          break;\n\n        case 'bottom':\n          top = containerHeight - height - verticalMargin;\n          break;\n      }\n\n      left = left || 0;\n      top = top || 0;\n\n      if (isNaN(width)) {\n        width = containerWidth - horizontalMargin - left - (right || 0);\n      }\n\n      if (isNaN(height)) {\n        height = containerHeight - verticalMargin - top - (bottom || 0);\n      }\n\n      var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);\n      rect.margin = margin;\n      return rect;\n    }\n    function positionElement(el, positionInfo, containerRect, margin, opt) {\n      var h = !opt || !opt.hv || opt.hv[0];\n      var v = !opt || !opt.hv || opt.hv[1];\n      var boundingMode = opt && opt.boundingMode || 'all';\n\n      if (!h && !v) {\n        return;\n      }\n\n      var rect;\n\n      if (boundingMode === 'raw') {\n        rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();\n      } else {\n        rect = el.getBoundingRect();\n\n        if (el.needLocalTransform()) {\n          var transform = el.getLocalTransform();\n          rect = rect.clone();\n          rect.applyTransform(transform);\n        }\n      }\n\n      var layoutRect = getLayoutRect(defaults({\n        width: rect.width,\n        height: rect.height\n      }, positionInfo), containerRect, margin);\n      var dx = h ? layoutRect.x - rect.x : 0;\n      var dy = v ? layoutRect.y - rect.y : 0;\n\n      if (boundingMode === 'raw') {\n        el.x = dx;\n        el.y = dy;\n      } else {\n        el.x += dx;\n        el.y += dy;\n      }\n\n      el.markRedraw();\n    }\n    function sizeCalculable(option, hvIdx) {\n      return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;\n    }\n    function fetchLayoutMode(ins) {\n      var layoutMode = ins.layoutMode || ins.constructor.layoutMode;\n      return isObject(layoutMode) ? layoutMode : layoutMode ? {\n        type: layoutMode\n      } : null;\n    }\n    function mergeLayoutParam(targetOption, newOption, opt) {\n      var ignoreSize = opt && opt.ignoreSize;\n      !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);\n      var hResult = merge(HV_NAMES[0], 0);\n      var vResult = merge(HV_NAMES[1], 1);\n      copy(HV_NAMES[0], targetOption, hResult);\n      copy(HV_NAMES[1], targetOption, vResult);\n\n      function merge(names, hvIdx) {\n        var newParams = {};\n        var newValueCount = 0;\n        var merged = {};\n        var mergedValueCount = 0;\n        var enoughParamNumber = 2;\n        each$1(names, function (name) {\n          merged[name] = targetOption[name];\n        });\n        each$1(names, function (name) {\n          hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);\n          hasValue(newParams, name) && newValueCount++;\n          hasValue(merged, name) && mergedValueCount++;\n        });\n\n        if (ignoreSize[hvIdx]) {\n          if (hasValue(newOption, names[1])) {\n            merged[names[2]] = null;\n          } else if (hasValue(newOption, names[2])) {\n            merged[names[1]] = null;\n          }\n\n          return merged;\n        }\n\n        if (mergedValueCount === enoughParamNumber || !newValueCount) {\n          return merged;\n        } else if (newValueCount >= enoughParamNumber) {\n          return newParams;\n        } else {\n          for (var i = 0; i < names.length; i++) {\n            var name_1 = names[i];\n\n            if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {\n              newParams[name_1] = targetOption[name_1];\n              break;\n            }\n          }\n\n          return newParams;\n        }\n      }\n\n      function hasProp(obj, name) {\n        return obj.hasOwnProperty(name);\n      }\n\n      function hasValue(obj, name) {\n        return obj[name] != null && obj[name] !== 'auto';\n      }\n\n      function copy(names, target, source) {\n        each$1(names, function (name) {\n          target[name] = source[name];\n        });\n      }\n    }\n    function getLayoutParams(source) {\n      return copyLayoutParams({}, source);\n    }\n    function copyLayoutParams(target, source) {\n      source && target && each$1(LOCATION_PARAMS, function (name) {\n        source.hasOwnProperty(name) && (target[name] = source[name]);\n      });\n      return target;\n    }\n\n    var inner = makeInner();\n\n    var ComponentModel = function (_super) {\n      __extends(ComponentModel, _super);\n\n      function ComponentModel(option, parentModel, ecModel) {\n        var _this = _super.call(this, option, parentModel, ecModel) || this;\n\n        _this.uid = getUID('ec_cpt_model');\n        return _this;\n      }\n\n      ComponentModel.prototype.init = function (option, parentModel, ecModel) {\n        this.mergeDefaultAndTheme(option, ecModel);\n      };\n\n      ComponentModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n        var layoutMode = fetchLayoutMode(this);\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        merge(option, themeModel.get(this.mainType));\n        merge(option, this.getDefaultOption());\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      };\n\n      ComponentModel.prototype.mergeOption = function (option, ecModel) {\n        merge(this.option, option, true);\n        var layoutMode = fetchLayoutMode(this);\n\n        if (layoutMode) {\n          mergeLayoutParam(this.option, option, layoutMode);\n        }\n      };\n\n      ComponentModel.prototype.optionUpdated = function (newCptOption, isInit) {};\n\n      ComponentModel.prototype.getDefaultOption = function () {\n        var ctor = this.constructor;\n\n        if (!isExtendedClass(ctor)) {\n          return ctor.defaultOption;\n        }\n\n        var fields = inner(this);\n\n        if (!fields.defaultOption) {\n          var optList = [];\n          var clz = ctor;\n\n          while (clz) {\n            var opt = clz.prototype.defaultOption;\n            opt && optList.push(opt);\n            clz = clz.superClass;\n          }\n\n          var defaultOption = {};\n\n          for (var i = optList.length - 1; i >= 0; i--) {\n            defaultOption = merge(defaultOption, optList[i], true);\n          }\n\n          fields.defaultOption = defaultOption;\n        }\n\n        return fields.defaultOption;\n      };\n\n      ComponentModel.prototype.getReferringComponents = function (mainType, opt) {\n        var indexKey = mainType + 'Index';\n        var idKey = mainType + 'Id';\n        return queryReferringComponents(this.ecModel, mainType, {\n          index: this.get(indexKey, true),\n          id: this.get(idKey, true)\n        }, opt);\n      };\n\n      ComponentModel.prototype.getBoxLayoutParams = function () {\n        var boxLayoutModel = this;\n        return {\n          left: boxLayoutModel.get('left'),\n          top: boxLayoutModel.get('top'),\n          right: boxLayoutModel.get('right'),\n          bottom: boxLayoutModel.get('bottom'),\n          width: boxLayoutModel.get('width'),\n          height: boxLayoutModel.get('height')\n        };\n      };\n\n      ComponentModel.protoInitialize = function () {\n        var proto = ComponentModel.prototype;\n        proto.type = 'component';\n        proto.id = '';\n        proto.name = '';\n        proto.mainType = '';\n        proto.subType = '';\n        proto.componentIndex = 0;\n      }();\n\n      return ComponentModel;\n    }(Model);\n\n    mountExtend(ComponentModel, Model);\n    enableClassManagement(ComponentModel);\n    enableSubTypeDefaulter(ComponentModel);\n    enableTopologicalTravel(ComponentModel, getDependencies);\n\n    function getDependencies(componentType) {\n      var deps = [];\n      each(ComponentModel.getClassesByMainType(componentType), function (clz) {\n        deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);\n      });\n      deps = map(deps, function (type) {\n        return parseClassType(type).main;\n      });\n\n      if (componentType !== 'dataset' && indexOf(deps, 'dataset') <= 0) {\n        deps.unshift('dataset');\n      }\n\n      return deps;\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var platform = '';\n\n    if (typeof navigator !== 'undefined') {\n      platform = navigator.platform || '';\n    }\n\n    var decalColor = 'rgba(0, 0, 0, 0.2)';\n    var globalDefault = {\n      darkMode: 'auto',\n      color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],\n      gradientColor: ['#f6efa6', '#d88273', '#bf444c'],\n      aria: {\n        decal: {\n          decals: [{\n            color: decalColor,\n            dashArrayX: [1, 0],\n            dashArrayY: [2, 5],\n            symbolSize: 1,\n            rotation: Math.PI / 6\n          }, {\n            color: decalColor,\n            symbol: 'circle',\n            dashArrayX: [[8, 8], [0, 8, 8, 0]],\n            dashArrayY: [6, 0],\n            symbolSize: 0.8\n          }, {\n            color: decalColor,\n            dashArrayX: [1, 0],\n            dashArrayY: [4, 3],\n            rotation: -Math.PI / 4\n          }, {\n            color: decalColor,\n            dashArrayX: [[6, 6], [0, 6, 6, 0]],\n            dashArrayY: [6, 0]\n          }, {\n            color: decalColor,\n            dashArrayX: [[1, 0], [1, 6]],\n            dashArrayY: [1, 0, 6, 0],\n            rotation: Math.PI / 4\n          }, {\n            color: decalColor,\n            symbol: 'triangle',\n            dashArrayX: [[9, 9], [0, 9, 9, 0]],\n            dashArrayY: [7, 2],\n            symbolSize: 0.75\n          }]\n        }\n      },\n      textStyle: {\n        fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',\n        fontSize: 12,\n        fontStyle: 'normal',\n        fontWeight: 'normal'\n      },\n      blendMode: null,\n      stateAnimation: {\n        duration: 300,\n        easing: 'cubicOut'\n      },\n      animation: 'auto',\n      animationDuration: 1000,\n      animationDurationUpdate: 500,\n      animationEasing: 'cubicInOut',\n      animationEasingUpdate: 'cubicInOut',\n      animationThreshold: 2000,\n      progressiveThreshold: 3000,\n      progressive: 400,\n      hoverLayerThreshold: 3000,\n      useUTC: false\n    };\n\n    var VISUAL_DIMENSIONS = createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);\n    var SOURCE_FORMAT_ORIGINAL = 'original';\n    var SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';\n    var SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';\n    var SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';\n    var SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';\n    var SOURCE_FORMAT_UNKNOWN = 'unknown';\n    var SERIES_LAYOUT_BY_COLUMN = 'column';\n    var SERIES_LAYOUT_BY_ROW = 'row';\n\n    var BE_ORDINAL = {\n      Must: 1,\n      Might: 2,\n      Not: 3\n    };\n    var innerGlobalModel = makeInner();\n    function resetSourceDefaulter(ecModel) {\n      innerGlobalModel(ecModel).datasetMap = createHashMap();\n    }\n    function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {\n      var encode = {};\n      var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n\n      if (!datasetModel || !coordDimensions) {\n        return encode;\n      }\n\n      var encodeItemName = [];\n      var encodeSeriesName = [];\n      var ecModel = seriesModel.ecModel;\n      var datasetMap = innerGlobalModel(ecModel).datasetMap;\n      var key = datasetModel.uid + '_' + source.seriesLayoutBy;\n      var baseCategoryDimIndex;\n      var categoryWayValueDimStart;\n      coordDimensions = coordDimensions.slice();\n      each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {\n        var coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {\n          name: coordDimInfoLoose\n        };\n\n        if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {\n          baseCategoryDimIndex = coordDimIdx;\n          categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);\n        }\n\n        encode[coordDimInfo.name] = [];\n      });\n      var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n        categoryWayDim: categoryWayValueDimStart,\n        valueWayDim: 0\n      });\n      each(coordDimensions, function (coordDimInfo, coordDimIdx) {\n        var coordDimName = coordDimInfo.name;\n        var count = getDataDimCountOnCoordDim(coordDimInfo);\n\n        if (baseCategoryDimIndex == null) {\n          var start = datasetRecord.valueWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.valueWayDim += count;\n        } else if (baseCategoryDimIndex === coordDimIdx) {\n          pushDim(encode[coordDimName], 0, count);\n          pushDim(encodeItemName, 0, count);\n        } else {\n          var start = datasetRecord.categoryWayDim;\n          pushDim(encode[coordDimName], start, count);\n          pushDim(encodeSeriesName, start, count);\n          datasetRecord.categoryWayDim += count;\n        }\n      });\n\n      function pushDim(dimIdxArr, idxFrom, idxCount) {\n        for (var i = 0; i < idxCount; i++) {\n          dimIdxArr.push(idxFrom + i);\n        }\n      }\n\n      function getDataDimCountOnCoordDim(coordDimInfo) {\n        var dimsDef = coordDimInfo.dimsDef;\n        return dimsDef ? dimsDef.length : 1;\n      }\n\n      encodeItemName.length && (encode.itemName = encodeItemName);\n      encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n      return encode;\n    }\n    function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {\n      var encode = {};\n      var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);\n\n      if (!datasetModel) {\n        return encode;\n      }\n\n      var sourceFormat = source.sourceFormat;\n      var dimensionsDefine = source.dimensionsDefine;\n      var potentialNameDimIndex;\n\n      if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n        each(dimensionsDefine, function (dim, idx) {\n          if ((isObject(dim) ? dim.name : dim) === 'name') {\n            potentialNameDimIndex = idx;\n          }\n        });\n      }\n\n      var idxResult = function () {\n        var idxRes0 = {};\n        var idxRes1 = {};\n        var guessRecords = [];\n\n        for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {\n          var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);\n          guessRecords.push(guessResult);\n          var isPureNumber = guessResult === BE_ORDINAL.Not;\n\n          if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {\n            idxRes0.v = i;\n          }\n\n          if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {\n            idxRes0.n = i;\n          }\n\n          if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {\n            return idxRes0;\n          }\n\n          if (!isPureNumber) {\n            if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {\n              idxRes1.v = i;\n            }\n\n            if (idxRes1.n == null || idxRes1.n === idxRes1.v) {\n              idxRes1.n = i;\n            }\n          }\n        }\n\n        function fulfilled(idxResult) {\n          return idxResult.v != null && idxResult.n != null;\n        }\n\n        return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;\n      }();\n\n      if (idxResult) {\n        encode.value = [idxResult.v];\n        var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;\n        encode.itemName = [nameDimIndex];\n        encode.seriesName = [nameDimIndex];\n      }\n\n      return encode;\n    }\n    function querySeriesUpstreamDatasetModel(seriesModel) {\n      var thisData = seriesModel.get('data', true);\n\n      if (!thisData) {\n        return queryReferringComponents(seriesModel.ecModel, 'dataset', {\n          index: seriesModel.get('datasetIndex', true),\n          id: seriesModel.get('datasetId', true)\n        }, SINGLE_REFERRING).models[0];\n      }\n    }\n    function queryDatasetUpstreamDatasetModels(datasetModel) {\n      if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {\n        return [];\n      }\n\n      return queryReferringComponents(datasetModel.ecModel, 'dataset', {\n        index: datasetModel.get('fromDatasetIndex', true),\n        id: datasetModel.get('fromDatasetId', true)\n      }, SINGLE_REFERRING).models;\n    }\n    function guessOrdinal(source, dimIndex) {\n      return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n    }\n\n    function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n      var result;\n      var maxLoop = 5;\n\n      if (isTypedArray(data)) {\n        return BE_ORDINAL.Not;\n      }\n\n      var dimName;\n      var dimType;\n\n      if (dimensionsDefine) {\n        var dimDefItem = dimensionsDefine[dimIndex];\n\n        if (isObject(dimDefItem)) {\n          dimName = dimDefItem.name;\n          dimType = dimDefItem.type;\n        } else if (isString(dimDefItem)) {\n          dimName = dimDefItem;\n        }\n      }\n\n      if (dimType != null) {\n        return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not;\n      }\n\n      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n        var dataArrayRows = data;\n\n        if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n          var sample = dataArrayRows[dimIndex];\n\n          for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n            if ((result = detectValue(sample[startIndex + i])) != null) {\n              return result;\n            }\n          }\n        } else {\n          for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {\n            var row = dataArrayRows[startIndex + i];\n\n            if (row && (result = detectValue(row[dimIndex])) != null) {\n              return result;\n            }\n          }\n        }\n      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n        var dataObjectRows = data;\n\n        if (!dimName) {\n          return BE_ORDINAL.Not;\n        }\n\n        for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {\n          var item = dataObjectRows[i];\n\n          if (item && (result = detectValue(item[dimName])) != null) {\n            return result;\n          }\n        }\n      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n        var dataKeyedColumns = data;\n\n        if (!dimName) {\n          return BE_ORDINAL.Not;\n        }\n\n        var sample = dataKeyedColumns[dimName];\n\n        if (!sample || isTypedArray(sample)) {\n          return BE_ORDINAL.Not;\n        }\n\n        for (var i = 0; i < sample.length && i < maxLoop; i++) {\n          if ((result = detectValue(sample[i])) != null) {\n            return result;\n          }\n        }\n      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n        var dataOriginal = data;\n\n        for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {\n          var item = dataOriginal[i];\n          var val = getDataItemValue(item);\n\n          if (!isArray(val)) {\n            return BE_ORDINAL.Not;\n          }\n\n          if ((result = detectValue(val[dimIndex])) != null) {\n            return result;\n          }\n        }\n      }\n\n      function detectValue(val) {\n        var beStr = isString(val);\n\n        if (val != null && isFinite(val) && val !== '') {\n          return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;\n        } else if (beStr && val !== '-') {\n          return BE_ORDINAL.Must;\n        }\n      }\n\n      return BE_ORDINAL.Not;\n    }\n\n    var internalOptionCreatorMap = createHashMap();\n    function registerInternalOptionCreator(mainType, creator) {\n      assert(internalOptionCreatorMap.get(mainType) == null && creator);\n      internalOptionCreatorMap.set(mainType, creator);\n    }\n    function concatInternalOptions(ecModel, mainType, newCmptOptionList) {\n      var internalOptionCreator = internalOptionCreatorMap.get(mainType);\n\n      if (!internalOptionCreator) {\n        return newCmptOptionList;\n      }\n\n      var internalOptions = internalOptionCreator(ecModel);\n\n      if (!internalOptions) {\n        return newCmptOptionList;\n      }\n\n      if (\"development\" !== 'production') {\n        for (var i = 0; i < internalOptions.length; i++) {\n          assert(isComponentIdInternal(internalOptions[i]));\n        }\n      }\n\n      return newCmptOptionList.concat(internalOptions);\n    }\n\n    var innerColor = makeInner();\n    var innerDecal = makeInner();\n\n    var PaletteMixin = function () {\n      function PaletteMixin() {}\n\n      PaletteMixin.prototype.getColorFromPalette = function (name, scope, requestNum) {\n        var defaultPalette = normalizeToArray(this.get('color', true));\n        var layeredPalette = this.get('colorLayer', true);\n        return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);\n      };\n\n      PaletteMixin.prototype.clearColorPalette = function () {\n        clearPalette(this, innerColor);\n      };\n\n      return PaletteMixin;\n    }();\n\n    function getDecalFromPalette(ecModel, name, scope, requestNum) {\n      var defaultDecals = normalizeToArray(ecModel.get(['aria', 'decal', 'decals']));\n      return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);\n    }\n\n    function getNearestPalette(palettes, requestColorNum) {\n      var paletteNum = palettes.length;\n\n      for (var i = 0; i < paletteNum; i++) {\n        if (palettes[i].length > requestColorNum) {\n          return palettes[i];\n        }\n      }\n\n      return palettes[paletteNum - 1];\n    }\n\n    function getFromPalette(that, inner, defaultPalette, layeredPalette, name, scope, requestNum) {\n      scope = scope || that;\n      var scopeFields = inner(scope);\n      var paletteIdx = scopeFields.paletteIdx || 0;\n      var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};\n\n      if (paletteNameMap.hasOwnProperty(name)) {\n        return paletteNameMap[name];\n      }\n\n      var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);\n      palette = palette || defaultPalette;\n\n      if (!palette || !palette.length) {\n        return;\n      }\n\n      var pickedPaletteItem = palette[paletteIdx];\n\n      if (name) {\n        paletteNameMap[name] = pickedPaletteItem;\n      }\n\n      scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;\n      return pickedPaletteItem;\n    }\n\n    function clearPalette(that, inner) {\n      inner(that).paletteIdx = 0;\n      inner(that).paletteNameMap = {};\n    }\n\n    var reCreateSeriesIndices;\n    var assertSeriesInitialized;\n    var initBase;\n    var OPTION_INNER_KEY = '\\0_ec_inner';\n    var OPTION_INNER_VALUE = 1;\n\n    var GlobalModel = function (_super) {\n      __extends(GlobalModel, _super);\n\n      function GlobalModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {\n        theme = theme || {};\n        this.option = null;\n        this._theme = new Model(theme);\n        this._locale = new Model(locale);\n        this._optionManager = optionManager;\n      };\n\n      GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {\n        if (\"development\" !== 'production') {\n          assert(option != null, 'option is null/undefined');\n          assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()');\n        }\n\n        var innerOpt = normalizeSetOptionInput(opts);\n\n        this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);\n\n        this._resetOption(null, innerOpt);\n      };\n\n      GlobalModel.prototype.resetOption = function (type, opt) {\n        return this._resetOption(type, normalizeSetOptionInput(opt));\n      };\n\n      GlobalModel.prototype._resetOption = function (type, opt) {\n        var optionChanged = false;\n        var optionManager = this._optionManager;\n\n        if (!type || type === 'recreate') {\n          var baseOption = optionManager.mountOption(type === 'recreate');\n\n          if (!this.option || type === 'recreate') {\n            initBase(this, baseOption);\n          } else {\n            this.restoreData();\n\n            this._mergeOption(baseOption, opt);\n          }\n\n          optionChanged = true;\n        }\n\n        if (type === 'timeline' || type === 'media') {\n          this.restoreData();\n        }\n\n        if (!type || type === 'recreate' || type === 'timeline') {\n          var timelineOption = optionManager.getTimelineOption(this);\n\n          if (timelineOption) {\n            optionChanged = true;\n\n            this._mergeOption(timelineOption, opt);\n          }\n        }\n\n        if (!type || type === 'recreate' || type === 'media') {\n          var mediaOptions = optionManager.getMediaOption(this);\n\n          if (mediaOptions.length) {\n            each(mediaOptions, function (mediaOption) {\n              optionChanged = true;\n\n              this._mergeOption(mediaOption, opt);\n            }, this);\n          }\n        }\n\n        return optionChanged;\n      };\n\n      GlobalModel.prototype.mergeOption = function (option) {\n        this._mergeOption(option, null);\n      };\n\n      GlobalModel.prototype._mergeOption = function (newOption, opt) {\n        var option = this.option;\n        var componentsMap = this._componentsMap;\n        var componentsCount = this._componentsCount;\n        var newCmptTypes = [];\n        var newCmptTypeMap = createHashMap();\n        var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;\n        resetSourceDefaulter(this);\n        each(newOption, function (componentOption, mainType) {\n          if (componentOption == null) {\n            return;\n          }\n\n          if (!ComponentModel.hasClass(mainType)) {\n            option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n          } else if (mainType) {\n            newCmptTypes.push(mainType);\n            newCmptTypeMap.set(mainType, true);\n          }\n        });\n\n        if (replaceMergeMainTypeMap) {\n          replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {\n            if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {\n              newCmptTypes.push(mainTypeInReplaceMerge);\n              newCmptTypeMap.set(mainTypeInReplaceMerge, true);\n            }\n          });\n        }\n\n        ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n        function visitComponent(mainType) {\n          var newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));\n          var oldCmptList = componentsMap.get(mainType);\n          var mergeMode = !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';\n          var mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);\n          setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel);\n          option[mainType] = null;\n          componentsMap.set(mainType, null);\n          componentsCount.set(mainType, 0);\n          var optionsByMainType = [];\n          var cmptsByMainType = [];\n          var cmptsCountByMainType = 0;\n          each(mappingResult, function (resultItem, index) {\n            var componentModel = resultItem.existing;\n            var newCmptOption = resultItem.newOption;\n\n            if (!newCmptOption) {\n              if (componentModel) {\n                componentModel.mergeOption({}, this);\n                componentModel.optionUpdated({}, false);\n              }\n            } else {\n              var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n              if (componentModel && componentModel.constructor === ComponentModelClass) {\n                componentModel.name = resultItem.keyInfo.name;\n                componentModel.mergeOption(newCmptOption, this);\n                componentModel.optionUpdated(newCmptOption, false);\n              } else {\n                var extraOpt = extend({\n                  componentIndex: index\n                }, resultItem.keyInfo);\n                componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);\n                extend(componentModel, extraOpt);\n\n                if (resultItem.brandNew) {\n                  componentModel.__requireNewView = true;\n                }\n\n                componentModel.init(newCmptOption, this, this);\n                componentModel.optionUpdated(null, true);\n              }\n            }\n\n            if (componentModel) {\n              optionsByMainType.push(componentModel.option);\n              cmptsByMainType.push(componentModel);\n              cmptsCountByMainType++;\n            } else {\n              optionsByMainType.push(void 0);\n              cmptsByMainType.push(void 0);\n            }\n          }, this);\n          option[mainType] = optionsByMainType;\n          componentsMap.set(mainType, cmptsByMainType);\n          componentsCount.set(mainType, cmptsCountByMainType);\n\n          if (mainType === 'series') {\n            reCreateSeriesIndices(this);\n          }\n        }\n\n        if (!this._seriesIndices) {\n          reCreateSeriesIndices(this);\n        }\n      };\n\n      GlobalModel.prototype.getOption = function () {\n        var option = clone(this.option);\n        each(option, function (optInMainType, mainType) {\n          if (ComponentModel.hasClass(mainType)) {\n            var opts = normalizeToArray(optInMainType);\n            var realLen = opts.length;\n            var metNonInner = false;\n\n            for (var i = realLen - 1; i >= 0; i--) {\n              if (opts[i] && !isComponentIdInternal(opts[i])) {\n                metNonInner = true;\n              } else {\n                opts[i] = null;\n                !metNonInner && realLen--;\n              }\n            }\n\n            opts.length = realLen;\n            option[mainType] = opts;\n          }\n        });\n        delete option[OPTION_INNER_KEY];\n        return option;\n      };\n\n      GlobalModel.prototype.getTheme = function () {\n        return this._theme;\n      };\n\n      GlobalModel.prototype.getLocaleModel = function () {\n        return this._locale;\n      };\n\n      GlobalModel.prototype.getLocale = function (localePosition) {\n        var locale = this.getLocaleModel();\n        return locale.get(localePosition);\n      };\n\n      GlobalModel.prototype.setUpdatePayload = function (payload) {\n        this._payload = payload;\n      };\n\n      GlobalModel.prototype.getUpdatePayload = function () {\n        return this._payload;\n      };\n\n      GlobalModel.prototype.getComponent = function (mainType, idx) {\n        var list = this._componentsMap.get(mainType);\n\n        if (list) {\n          var cmpt = list[idx || 0];\n\n          if (cmpt) {\n            return cmpt;\n          } else if (idx == null) {\n            for (var i = 0; i < list.length; i++) {\n              if (list[i]) {\n                return list[i];\n              }\n            }\n          }\n        }\n      };\n\n      GlobalModel.prototype.queryComponents = function (condition) {\n        var mainType = condition.mainType;\n\n        if (!mainType) {\n          return [];\n        }\n\n        var index = condition.index;\n        var id = condition.id;\n        var name = condition.name;\n\n        var cmpts = this._componentsMap.get(mainType);\n\n        if (!cmpts || !cmpts.length) {\n          return [];\n        }\n\n        var result;\n\n        if (index != null) {\n          result = [];\n          each(normalizeToArray(index), function (idx) {\n            cmpts[idx] && result.push(cmpts[idx]);\n          });\n        } else if (id != null) {\n          result = queryByIdOrName('id', id, cmpts);\n        } else if (name != null) {\n          result = queryByIdOrName('name', name, cmpts);\n        } else {\n          result = filter(cmpts, function (cmpt) {\n            return !!cmpt;\n          });\n        }\n\n        return filterBySubType(result, condition);\n      };\n\n      GlobalModel.prototype.findComponents = function (condition) {\n        var query = condition.query;\n        var mainType = condition.mainType;\n        var queryCond = getQueryCond(query);\n        var result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), function (cmpt) {\n          return !!cmpt;\n        });\n        return doFilter(filterBySubType(result, condition));\n\n        function getQueryCond(q) {\n          var indexAttr = mainType + 'Index';\n          var idAttr = mainType + 'Id';\n          var nameAttr = mainType + 'Name';\n          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n            mainType: mainType,\n            index: q[indexAttr],\n            id: q[idAttr],\n            name: q[nameAttr]\n          } : null;\n        }\n\n        function doFilter(res) {\n          return condition.filter ? filter(res, condition.filter) : res;\n        }\n      };\n\n      GlobalModel.prototype.eachComponent = function (mainType, cb, context) {\n        var componentsMap = this._componentsMap;\n\n        if (isFunction(mainType)) {\n          var ctxForAll_1 = cb;\n          var cbForAll_1 = mainType;\n          componentsMap.each(function (cmpts, componentType) {\n            for (var i = 0; cmpts && i < cmpts.length; i++) {\n              var cmpt = cmpts[i];\n              cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);\n            }\n          });\n        } else {\n          var cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;\n\n          for (var i = 0; cmpts && i < cmpts.length; i++) {\n            var cmpt = cmpts[i];\n            cmpt && cb.call(context, cmpt, cmpt.componentIndex);\n          }\n        }\n      };\n\n      GlobalModel.prototype.getSeriesByName = function (name) {\n        var nameStr = convertOptionIdName(name, null);\n        return filter(this._componentsMap.get('series'), function (oneSeries) {\n          return !!oneSeries && nameStr != null && oneSeries.name === nameStr;\n        });\n      };\n\n      GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {\n        return this._componentsMap.get('series')[seriesIndex];\n      };\n\n      GlobalModel.prototype.getSeriesByType = function (subType) {\n        return filter(this._componentsMap.get('series'), function (oneSeries) {\n          return !!oneSeries && oneSeries.subType === subType;\n        });\n      };\n\n      GlobalModel.prototype.getSeries = function () {\n        return filter(this._componentsMap.get('series').slice(), function (oneSeries) {\n          return !!oneSeries;\n        });\n      };\n\n      GlobalModel.prototype.getSeriesCount = function () {\n        return this._componentsCount.get('series');\n      };\n\n      GlobalModel.prototype.eachSeries = function (cb, context) {\n        assertSeriesInitialized(this);\n        each(this._seriesIndices, function (rawSeriesIndex) {\n          var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n          cb.call(context, series, rawSeriesIndex);\n        }, this);\n      };\n\n      GlobalModel.prototype.eachRawSeries = function (cb, context) {\n        each(this._componentsMap.get('series'), function (series) {\n          series && cb.call(context, series, series.componentIndex);\n        });\n      };\n\n      GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {\n        assertSeriesInitialized(this);\n        each(this._seriesIndices, function (rawSeriesIndex) {\n          var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n          if (series.subType === subType) {\n            cb.call(context, series, rawSeriesIndex);\n          }\n        }, this);\n      };\n\n      GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {\n        return each(this.getSeriesByType(subType), cb, context);\n      };\n\n      GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {\n        assertSeriesInitialized(this);\n        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n      };\n\n      GlobalModel.prototype.getCurrentSeriesIndices = function () {\n        return (this._seriesIndices || []).slice();\n      };\n\n      GlobalModel.prototype.filterSeries = function (cb, context) {\n        assertSeriesInitialized(this);\n        var newSeriesIndices = [];\n        each(this._seriesIndices, function (seriesRawIdx) {\n          var series = this._componentsMap.get('series')[seriesRawIdx];\n\n          cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);\n        }, this);\n        this._seriesIndices = newSeriesIndices;\n        this._seriesIndicesMap = createHashMap(newSeriesIndices);\n      };\n\n      GlobalModel.prototype.restoreData = function (payload) {\n        reCreateSeriesIndices(this);\n        var componentsMap = this._componentsMap;\n        var componentTypes = [];\n        componentsMap.each(function (components, componentType) {\n          if (ComponentModel.hasClass(componentType)) {\n            componentTypes.push(componentType);\n          }\n        });\n        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {\n          each(componentsMap.get(componentType), function (component) {\n            if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {\n              component.restoreData();\n            }\n          });\n        });\n      };\n\n      GlobalModel.internalField = function () {\n        reCreateSeriesIndices = function (ecModel) {\n          var seriesIndices = ecModel._seriesIndices = [];\n          each(ecModel._componentsMap.get('series'), function (series) {\n            series && seriesIndices.push(series.componentIndex);\n          });\n          ecModel._seriesIndicesMap = createHashMap(seriesIndices);\n        };\n\n        assertSeriesInitialized = function (ecModel) {\n          if (\"development\" !== 'production') {\n            if (!ecModel._seriesIndices) {\n              throw new Error('Option should contains series.');\n            }\n          }\n        };\n\n        initBase = function (ecModel, baseOption) {\n          ecModel.option = {};\n          ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;\n          ecModel._componentsMap = createHashMap({\n            series: []\n          });\n          ecModel._componentsCount = createHashMap();\n          var airaOption = baseOption.aria;\n\n          if (isObject(airaOption) && airaOption.enabled == null) {\n            airaOption.enabled = true;\n          }\n\n          mergeTheme(baseOption, ecModel._theme.option);\n          merge(baseOption, globalDefault, false);\n\n          ecModel._mergeOption(baseOption, null);\n        };\n      }();\n\n      return GlobalModel;\n    }(Model);\n\n    function isNotTargetSeries(seriesModel, payload) {\n      if (payload) {\n        var index = payload.seriesIndex;\n        var id = payload.seriesId;\n        var name_1 = payload.seriesName;\n        return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;\n      }\n    }\n\n    function mergeTheme(option, theme) {\n      var notMergeColorLayer = option.color && !option.colorLayer;\n      each(theme, function (themeItem, name) {\n        if (name === 'colorLayer' && notMergeColorLayer) {\n          return;\n        }\n\n        if (!ComponentModel.hasClass(name)) {\n          if (typeof themeItem === 'object') {\n            option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n          } else {\n            if (option[name] == null) {\n              option[name] = themeItem;\n            }\n          }\n        }\n      });\n    }\n\n    function queryByIdOrName(attr, idOrName, cmpts) {\n      if (isArray(idOrName)) {\n        var keyMap_1 = createHashMap();\n        each(idOrName, function (idOrNameItem) {\n          if (idOrNameItem != null) {\n            var idName = convertOptionIdName(idOrNameItem, null);\n            idName != null && keyMap_1.set(idOrNameItem, true);\n          }\n        });\n        return filter(cmpts, function (cmpt) {\n          return cmpt && keyMap_1.get(cmpt[attr]);\n        });\n      } else {\n        var idName_1 = convertOptionIdName(idOrName, null);\n        return filter(cmpts, function (cmpt) {\n          return cmpt && idName_1 != null && cmpt[attr] === idName_1;\n        });\n      }\n    }\n\n    function filterBySubType(components, condition) {\n      return condition.hasOwnProperty('subType') ? filter(components, function (cmpt) {\n        return cmpt && cmpt.subType === condition.subType;\n      }) : components;\n    }\n\n    function normalizeSetOptionInput(opts) {\n      var replaceMergeMainTypeMap = createHashMap();\n      opts && each(normalizeToArray(opts.replaceMerge), function (mainType) {\n        if (\"development\" !== 'production') {\n          assert(ComponentModel.hasClass(mainType), '\"' + mainType + '\" is not valid component main type in \"replaceMerge\"');\n        }\n\n        replaceMergeMainTypeMap.set(mainType, true);\n      });\n      return {\n        replaceMergeMainTypeMap: replaceMergeMainTypeMap\n      };\n    }\n\n    mixin(GlobalModel, PaletteMixin);\n\n    var availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getOption', 'getId', 'updateLabelLayout'];\n\n    var ExtensionAPI = function () {\n      function ExtensionAPI(ecInstance) {\n        each(availableMethods, function (methodName) {\n          this[methodName] = bind(ecInstance[methodName], ecInstance);\n        }, this);\n      }\n\n      return ExtensionAPI;\n    }();\n\n    var coordinateSystemCreators = {};\n\n    var CoordinateSystemManager = function () {\n      function CoordinateSystemManager() {\n        this._coordinateSystems = [];\n      }\n\n      CoordinateSystemManager.prototype.create = function (ecModel, api) {\n        var coordinateSystems = [];\n        each(coordinateSystemCreators, function (creater, type) {\n          var list = creater.create(ecModel, api);\n          coordinateSystems = coordinateSystems.concat(list || []);\n        });\n        this._coordinateSystems = coordinateSystems;\n      };\n\n      CoordinateSystemManager.prototype.update = function (ecModel, api) {\n        each(this._coordinateSystems, function (coordSys) {\n          coordSys.update && coordSys.update(ecModel, api);\n        });\n      };\n\n      CoordinateSystemManager.prototype.getCoordinateSystems = function () {\n        return this._coordinateSystems.slice();\n      };\n\n      CoordinateSystemManager.register = function (type, creator) {\n        coordinateSystemCreators[type] = creator;\n      };\n\n      CoordinateSystemManager.get = function (type) {\n        return coordinateSystemCreators[type];\n      };\n\n      return CoordinateSystemManager;\n    }();\n\n    var QUERY_REG = /^(min|max)?(.+)$/;\n\n    var OptionManager = function () {\n      function OptionManager(api) {\n        this._timelineOptions = [];\n        this._mediaList = [];\n        this._currentMediaIndices = [];\n        this._api = api;\n      }\n\n      OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {\n        if (rawOption) {\n          each(normalizeToArray(rawOption.series), function (series) {\n            series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);\n          });\n          each(normalizeToArray(rawOption.dataset), function (dataset) {\n            dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);\n          });\n        }\n\n        rawOption = clone(rawOption);\n        var optionBackup = this._optionBackup;\n        var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);\n        this._newBaseOption = newParsedOption.baseOption;\n\n        if (optionBackup) {\n          if (newParsedOption.timelineOptions.length) {\n            optionBackup.timelineOptions = newParsedOption.timelineOptions;\n          }\n\n          if (newParsedOption.mediaList.length) {\n            optionBackup.mediaList = newParsedOption.mediaList;\n          }\n\n          if (newParsedOption.mediaDefault) {\n            optionBackup.mediaDefault = newParsedOption.mediaDefault;\n          }\n        } else {\n          this._optionBackup = newParsedOption;\n        }\n      };\n\n      OptionManager.prototype.mountOption = function (isRecreate) {\n        var optionBackup = this._optionBackup;\n        this._timelineOptions = optionBackup.timelineOptions;\n        this._mediaList = optionBackup.mediaList;\n        this._mediaDefault = optionBackup.mediaDefault;\n        this._currentMediaIndices = [];\n        return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);\n      };\n\n      OptionManager.prototype.getTimelineOption = function (ecModel) {\n        var option;\n        var timelineOptions = this._timelineOptions;\n\n        if (timelineOptions.length) {\n          var timelineModel = ecModel.getComponent('timeline');\n\n          if (timelineModel) {\n            option = clone(timelineOptions[timelineModel.getCurrentIndex()]);\n          }\n        }\n\n        return option;\n      };\n\n      OptionManager.prototype.getMediaOption = function (ecModel) {\n        var ecWidth = this._api.getWidth();\n\n        var ecHeight = this._api.getHeight();\n\n        var mediaList = this._mediaList;\n        var mediaDefault = this._mediaDefault;\n        var indices = [];\n        var result = [];\n\n        if (!mediaList.length && !mediaDefault) {\n          return result;\n        }\n\n        for (var i = 0, len = mediaList.length; i < len; i++) {\n          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n            indices.push(i);\n          }\n        }\n\n        if (!indices.length && mediaDefault) {\n          indices = [-1];\n        }\n\n        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n          result = map(indices, function (index) {\n            return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n          });\n        }\n\n        this._currentMediaIndices = indices;\n        return result;\n      };\n\n      return OptionManager;\n    }();\n\n    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n      var mediaList = [];\n      var mediaDefault;\n      var baseOption;\n      var declaredBaseOption = rawOption.baseOption;\n      var timelineOnRoot = rawOption.timeline;\n      var timelineOptionsOnRoot = rawOption.options;\n      var mediaOnRoot = rawOption.media;\n      var hasMedia = !!rawOption.media;\n      var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);\n\n      if (declaredBaseOption) {\n        baseOption = declaredBaseOption;\n\n        if (!baseOption.timeline) {\n          baseOption.timeline = timelineOnRoot;\n        }\n      } else {\n        if (hasTimeline || hasMedia) {\n          rawOption.options = rawOption.media = null;\n        }\n\n        baseOption = rawOption;\n      }\n\n      if (hasMedia) {\n        if (isArray(mediaOnRoot)) {\n          each(mediaOnRoot, function (singleMedia) {\n            if (\"development\" !== 'production') {\n              if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {\n                error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');\n              }\n            }\n\n            if (singleMedia && singleMedia.option) {\n              if (singleMedia.query) {\n                mediaList.push(singleMedia);\n              } else if (!mediaDefault) {\n                mediaDefault = singleMedia;\n              }\n            }\n          });\n        } else {\n          if (\"development\" !== 'production') {\n            error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');\n          }\n        }\n      }\n\n      doPreprocess(baseOption);\n      each(timelineOptionsOnRoot, function (option) {\n        return doPreprocess(option);\n      });\n      each(mediaList, function (media) {\n        return doPreprocess(media.option);\n      });\n\n      function doPreprocess(option) {\n        each(optionPreprocessorFuncs, function (preProcess) {\n          preProcess(option, isNew);\n        });\n      }\n\n      return {\n        baseOption: baseOption,\n        timelineOptions: timelineOptionsOnRoot || [],\n        mediaDefault: mediaDefault,\n        mediaList: mediaList\n      };\n    }\n\n    function applyMediaQuery(query, ecWidth, ecHeight) {\n      var realMap = {\n        width: ecWidth,\n        height: ecHeight,\n        aspectratio: ecWidth / ecHeight\n      };\n      var applicatable = true;\n      each(query, function (value, attr) {\n        var matched = attr.match(QUERY_REG);\n\n        if (!matched || !matched[1] || !matched[2]) {\n          return;\n        }\n\n        var operator = matched[1];\n        var realAttr = matched[2].toLowerCase();\n\n        if (!compare(realMap[realAttr], value, operator)) {\n          applicatable = false;\n        }\n      });\n      return applicatable;\n    }\n\n    function compare(real, expect, operator) {\n      if (operator === 'min') {\n        return real >= expect;\n      } else if (operator === 'max') {\n        return real <= expect;\n      } else {\n        return real === expect;\n      }\n    }\n\n    function indicesEquals(indices1, indices2) {\n      return indices1.join(',') === indices2.join(',');\n    }\n\n    var each$2 = each;\n    var isObject$1 = isObject;\n    var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];\n\n    function compatEC2ItemStyle(opt) {\n      var itemStyleOpt = opt && opt.itemStyle;\n\n      if (!itemStyleOpt) {\n        return;\n      }\n\n      for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {\n        var styleName = POSSIBLE_STYLES[i];\n        var normalItemStyleOpt = itemStyleOpt.normal;\n        var emphasisItemStyleOpt = itemStyleOpt.emphasis;\n\n        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {\n          if (\"development\" !== 'production') {\n            deprecateReplaceLog(\"itemStyle.normal.\" + styleName, styleName);\n          }\n\n          opt[styleName] = opt[styleName] || {};\n\n          if (!opt[styleName].normal) {\n            opt[styleName].normal = normalItemStyleOpt[styleName];\n          } else {\n            merge(opt[styleName].normal, normalItemStyleOpt[styleName]);\n          }\n\n          normalItemStyleOpt[styleName] = null;\n        }\n\n        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {\n          if (\"development\" !== 'production') {\n            deprecateReplaceLog(\"itemStyle.emphasis.\" + styleName, \"emphasis.\" + styleName);\n          }\n\n          opt[styleName] = opt[styleName] || {};\n\n          if (!opt[styleName].emphasis) {\n            opt[styleName].emphasis = emphasisItemStyleOpt[styleName];\n          } else {\n            merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);\n          }\n\n          emphasisItemStyleOpt[styleName] = null;\n        }\n      }\n    }\n\n    function convertNormalEmphasis(opt, optType, useExtend) {\n      if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {\n        var normalOpt = opt[optType].normal;\n        var emphasisOpt = opt[optType].emphasis;\n\n        if (normalOpt) {\n          if (\"development\" !== 'production') {\n            deprecateLog(\"'normal' hierarchy in \" + optType + \" has been removed since 4.0. All style properties are configured in \" + optType + \" directly now.\");\n          }\n\n          if (useExtend) {\n            opt[optType].normal = opt[optType].emphasis = null;\n            defaults(opt[optType], normalOpt);\n          } else {\n            opt[optType] = normalOpt;\n          }\n        }\n\n        if (emphasisOpt) {\n          if (\"development\" !== 'production') {\n            deprecateLog(optType + \".emphasis has been changed to emphasis.\" + optType + \" since 4.0\");\n          }\n\n          opt.emphasis = opt.emphasis || {};\n          opt.emphasis[optType] = emphasisOpt;\n\n          if (emphasisOpt.focus) {\n            opt.emphasis.focus = emphasisOpt.focus;\n          }\n\n          if (emphasisOpt.blurScope) {\n            opt.emphasis.blurScope = emphasisOpt.blurScope;\n          }\n        }\n      }\n    }\n\n    function removeEC3NormalStatus(opt) {\n      convertNormalEmphasis(opt, 'itemStyle');\n      convertNormalEmphasis(opt, 'lineStyle');\n      convertNormalEmphasis(opt, 'areaStyle');\n      convertNormalEmphasis(opt, 'label');\n      convertNormalEmphasis(opt, 'labelLine');\n      convertNormalEmphasis(opt, 'upperLabel');\n      convertNormalEmphasis(opt, 'edgeLabel');\n    }\n\n    function compatTextStyle(opt, propName) {\n      var labelOptSingle = isObject$1(opt) && opt[propName];\n      var textStyle = isObject$1(labelOptSingle) && labelOptSingle.textStyle;\n\n      if (textStyle) {\n        if (\"development\" !== 'production') {\n          deprecateLog(\"textStyle hierarchy in \" + propName + \" has been removed since 4.0. All textStyle properties are configured in \" + propName + \" directly now.\");\n        }\n\n        for (var i = 0, len = TEXT_STYLE_OPTIONS.length; i < len; i++) {\n          var textPropName = TEXT_STYLE_OPTIONS[i];\n\n          if (textStyle.hasOwnProperty(textPropName)) {\n            labelOptSingle[textPropName] = textStyle[textPropName];\n          }\n        }\n      }\n    }\n\n    function compatEC3CommonStyles(opt) {\n      if (opt) {\n        removeEC3NormalStatus(opt);\n        compatTextStyle(opt, 'label');\n        opt.emphasis && compatTextStyle(opt.emphasis, 'label');\n      }\n    }\n\n    function processSeries(seriesOpt) {\n      if (!isObject$1(seriesOpt)) {\n        return;\n      }\n\n      compatEC2ItemStyle(seriesOpt);\n      removeEC3NormalStatus(seriesOpt);\n      compatTextStyle(seriesOpt, 'label');\n      compatTextStyle(seriesOpt, 'upperLabel');\n      compatTextStyle(seriesOpt, 'edgeLabel');\n\n      if (seriesOpt.emphasis) {\n        compatTextStyle(seriesOpt.emphasis, 'label');\n        compatTextStyle(seriesOpt.emphasis, 'upperLabel');\n        compatTextStyle(seriesOpt.emphasis, 'edgeLabel');\n      }\n\n      var markPoint = seriesOpt.markPoint;\n\n      if (markPoint) {\n        compatEC2ItemStyle(markPoint);\n        compatEC3CommonStyles(markPoint);\n      }\n\n      var markLine = seriesOpt.markLine;\n\n      if (markLine) {\n        compatEC2ItemStyle(markLine);\n        compatEC3CommonStyles(markLine);\n      }\n\n      var markArea = seriesOpt.markArea;\n\n      if (markArea) {\n        compatEC3CommonStyles(markArea);\n      }\n\n      var data = seriesOpt.data;\n\n      if (seriesOpt.type === 'graph') {\n        data = data || seriesOpt.nodes;\n        var edgeData = seriesOpt.links || seriesOpt.edges;\n\n        if (edgeData && !isTypedArray(edgeData)) {\n          for (var i = 0; i < edgeData.length; i++) {\n            compatEC3CommonStyles(edgeData[i]);\n          }\n        }\n\n        each(seriesOpt.categories, function (opt) {\n          removeEC3NormalStatus(opt);\n        });\n      }\n\n      if (data && !isTypedArray(data)) {\n        for (var i = 0; i < data.length; i++) {\n          compatEC3CommonStyles(data[i]);\n        }\n      }\n\n      markPoint = seriesOpt.markPoint;\n\n      if (markPoint && markPoint.data) {\n        var mpData = markPoint.data;\n\n        for (var i = 0; i < mpData.length; i++) {\n          compatEC3CommonStyles(mpData[i]);\n        }\n      }\n\n      markLine = seriesOpt.markLine;\n\n      if (markLine && markLine.data) {\n        var mlData = markLine.data;\n\n        for (var i = 0; i < mlData.length; i++) {\n          if (isArray(mlData[i])) {\n            compatEC3CommonStyles(mlData[i][0]);\n            compatEC3CommonStyles(mlData[i][1]);\n          } else {\n            compatEC3CommonStyles(mlData[i]);\n          }\n        }\n      }\n\n      if (seriesOpt.type === 'gauge') {\n        compatTextStyle(seriesOpt, 'axisLabel');\n        compatTextStyle(seriesOpt, 'title');\n        compatTextStyle(seriesOpt, 'detail');\n      } else if (seriesOpt.type === 'treemap') {\n        convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');\n        each(seriesOpt.levels, function (opt) {\n          removeEC3NormalStatus(opt);\n        });\n      } else if (seriesOpt.type === 'tree') {\n        removeEC3NormalStatus(seriesOpt.leaves);\n      }\n    }\n\n    function toArr(o) {\n      return isArray(o) ? o : o ? [o] : [];\n    }\n\n    function toObj(o) {\n      return (isArray(o) ? o[0] : o) || {};\n    }\n\n    function globalCompatStyle(option, isTheme) {\n      each$2(toArr(option.series), function (seriesOpt) {\n        isObject$1(seriesOpt) && processSeries(seriesOpt);\n      });\n      var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];\n      isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');\n      each$2(axes, function (axisName) {\n        each$2(toArr(option[axisName]), function (axisOpt) {\n          if (axisOpt) {\n            compatTextStyle(axisOpt, 'axisLabel');\n            compatTextStyle(axisOpt.axisPointer, 'label');\n          }\n        });\n      });\n      each$2(toArr(option.parallel), function (parallelOpt) {\n        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;\n        compatTextStyle(parallelAxisDefault, 'axisLabel');\n        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');\n      });\n      each$2(toArr(option.calendar), function (calendarOpt) {\n        convertNormalEmphasis(calendarOpt, 'itemStyle');\n        compatTextStyle(calendarOpt, 'dayLabel');\n        compatTextStyle(calendarOpt, 'monthLabel');\n        compatTextStyle(calendarOpt, 'yearLabel');\n      });\n      each$2(toArr(option.radar), function (radarOpt) {\n        compatTextStyle(radarOpt, 'name');\n\n        if (radarOpt.name && radarOpt.axisName == null) {\n          radarOpt.axisName = radarOpt.name;\n          delete radarOpt.name;\n\n          if (\"development\" !== 'production') {\n            deprecateLog('name property in radar component has been changed to axisName');\n          }\n        }\n\n        if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {\n          radarOpt.axisNameGap = radarOpt.nameGap;\n          delete radarOpt.nameGap;\n\n          if (\"development\" !== 'production') {\n            deprecateLog('nameGap property in radar component has been changed to axisNameGap');\n          }\n        }\n      });\n      each$2(toArr(option.geo), function (geoOpt) {\n        if (isObject$1(geoOpt)) {\n          compatEC3CommonStyles(geoOpt);\n          each$2(toArr(geoOpt.regions), function (regionObj) {\n            compatEC3CommonStyles(regionObj);\n          });\n        }\n      });\n      each$2(toArr(option.timeline), function (timelineOpt) {\n        compatEC3CommonStyles(timelineOpt);\n        convertNormalEmphasis(timelineOpt, 'label');\n        convertNormalEmphasis(timelineOpt, 'itemStyle');\n        convertNormalEmphasis(timelineOpt, 'controlStyle', true);\n        var data = timelineOpt.data;\n        isArray(data) && each(data, function (item) {\n          if (isObject(item)) {\n            convertNormalEmphasis(item, 'label');\n            convertNormalEmphasis(item, 'itemStyle');\n          }\n        });\n      });\n      each$2(toArr(option.toolbox), function (toolboxOpt) {\n        convertNormalEmphasis(toolboxOpt, 'iconStyle');\n        each$2(toolboxOpt.feature, function (featureOpt) {\n          convertNormalEmphasis(featureOpt, 'iconStyle');\n        });\n      });\n      compatTextStyle(toObj(option.axisPointer), 'label');\n      compatTextStyle(toObj(option.tooltip).axisPointer, 'label');\n    }\n\n    function get(opt, path) {\n      var pathArr = path.split(',');\n      var obj = opt;\n\n      for (var i = 0; i < pathArr.length; i++) {\n        obj = obj && obj[pathArr[i]];\n\n        if (obj == null) {\n          break;\n        }\n      }\n\n      return obj;\n    }\n\n    function set$1(opt, path, val, overwrite) {\n      var pathArr = path.split(',');\n      var obj = opt;\n      var key;\n      var i = 0;\n\n      for (; i < pathArr.length - 1; i++) {\n        key = pathArr[i];\n\n        if (obj[key] == null) {\n          obj[key] = {};\n        }\n\n        obj = obj[key];\n      }\n\n      if (overwrite || obj[pathArr[i]] == null) {\n        obj[pathArr[i]] = val;\n      }\n    }\n\n    function compatLayoutProperties(option) {\n      option && each(LAYOUT_PROPERTIES, function (prop) {\n        if (prop[0] in option && !(prop[1] in option)) {\n          option[prop[1]] = option[prop[0]];\n        }\n      });\n    }\n\n    var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];\n    var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];\n    var BAR_ITEM_STYLE_MAP = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']];\n\n    function compatBarItemStyle(option) {\n      var itemStyle = option && option.itemStyle;\n\n      if (itemStyle) {\n        for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {\n          var oldName = BAR_ITEM_STYLE_MAP[i][1];\n          var newName = BAR_ITEM_STYLE_MAP[i][0];\n\n          if (itemStyle[oldName] != null) {\n            itemStyle[newName] = itemStyle[oldName];\n\n            if (\"development\" !== 'production') {\n              deprecateReplaceLog(oldName, newName);\n            }\n          }\n        }\n      }\n    }\n\n    function compatPieLabel(option) {\n      if (!option) {\n        return;\n      }\n\n      if (option.alignTo === 'edge' && option.margin != null && option.edgeDistance == null) {\n        if (\"development\" !== 'production') {\n          deprecateReplaceLog('label.margin', 'label.edgeDistance', 'pie');\n        }\n\n        option.edgeDistance = option.margin;\n      }\n    }\n\n    function compatSunburstState(option) {\n      if (!option) {\n        return;\n      }\n\n      if (option.downplay && !option.blur) {\n        option.blur = option.downplay;\n\n        if (\"development\" !== 'production') {\n          deprecateReplaceLog('downplay', 'blur', 'sunburst');\n        }\n      }\n    }\n\n    function compatGraphFocus(option) {\n      if (!option) {\n        return;\n      }\n\n      if (option.focusNodeAdjacency != null) {\n        option.emphasis = option.emphasis || {};\n\n        if (option.emphasis.focus == null) {\n          if (\"development\" !== 'production') {\n            deprecateReplaceLog('focusNodeAdjacency', 'emphasis: { focus: \\'adjacency\\'}', 'graph/sankey');\n          }\n\n          option.emphasis.focus = 'adjacency';\n        }\n      }\n    }\n\n    function traverseTree(data, cb) {\n      if (data) {\n        for (var i = 0; i < data.length; i++) {\n          cb(data[i]);\n          data[i] && traverseTree(data[i].children, cb);\n        }\n      }\n    }\n\n    function globalBackwardCompat(option, isTheme) {\n      globalCompatStyle(option, isTheme);\n      option.series = normalizeToArray(option.series);\n      each(option.series, function (seriesOpt) {\n        if (!isObject(seriesOpt)) {\n          return;\n        }\n\n        var seriesType = seriesOpt.type;\n\n        if (seriesType === 'line') {\n          if (seriesOpt.clipOverflow != null) {\n            seriesOpt.clip = seriesOpt.clipOverflow;\n\n            if (\"development\" !== 'production') {\n              deprecateReplaceLog('clipOverflow', 'clip', 'line');\n            }\n          }\n        } else if (seriesType === 'pie' || seriesType === 'gauge') {\n          if (seriesOpt.clockWise != null) {\n            seriesOpt.clockwise = seriesOpt.clockWise;\n\n            if (\"development\" !== 'production') {\n              deprecateReplaceLog('clockWise', 'clockwise');\n            }\n          }\n\n          compatPieLabel(seriesOpt.label);\n          var data = seriesOpt.data;\n\n          if (data && !isTypedArray(data)) {\n            for (var i = 0; i < data.length; i++) {\n              compatPieLabel(data[i]);\n            }\n          }\n\n          if (seriesOpt.hoverOffset != null) {\n            seriesOpt.emphasis = seriesOpt.emphasis || {};\n\n            if (seriesOpt.emphasis.scaleSize = null) {\n              if (\"development\" !== 'production') {\n                deprecateReplaceLog('hoverOffset', 'emphasis.scaleSize');\n              }\n\n              seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;\n            }\n          }\n        } else if (seriesType === 'gauge') {\n          var pointerColor = get(seriesOpt, 'pointer.color');\n          pointerColor != null && set$1(seriesOpt, 'itemStyle.color', pointerColor);\n        } else if (seriesType === 'bar') {\n          compatBarItemStyle(seriesOpt);\n          compatBarItemStyle(seriesOpt.backgroundStyle);\n          compatBarItemStyle(seriesOpt.emphasis);\n          var data = seriesOpt.data;\n\n          if (data && !isTypedArray(data)) {\n            for (var i = 0; i < data.length; i++) {\n              if (typeof data[i] === 'object') {\n                compatBarItemStyle(data[i]);\n                compatBarItemStyle(data[i] && data[i].emphasis);\n              }\n            }\n          }\n        } else if (seriesType === 'sunburst') {\n          var highlightPolicy = seriesOpt.highlightPolicy;\n\n          if (highlightPolicy) {\n            seriesOpt.emphasis = seriesOpt.emphasis || {};\n\n            if (!seriesOpt.emphasis.focus) {\n              seriesOpt.emphasis.focus = highlightPolicy;\n\n              if (\"development\" !== 'production') {\n                deprecateReplaceLog('highlightPolicy', 'emphasis.focus', 'sunburst');\n              }\n            }\n          }\n\n          compatSunburstState(seriesOpt);\n          traverseTree(seriesOpt.data, compatSunburstState);\n        } else if (seriesType === 'graph' || seriesType === 'sankey') {\n          compatGraphFocus(seriesOpt);\n        } else if (seriesType === 'map') {\n          if (seriesOpt.mapType && !seriesOpt.map) {\n            if (\"development\" !== 'production') {\n              deprecateReplaceLog('mapType', 'map', 'map');\n            }\n\n            seriesOpt.map = seriesOpt.mapType;\n          }\n\n          if (seriesOpt.mapLocation) {\n            if (\"development\" !== 'production') {\n              deprecateLog('`mapLocation` is not used anymore.');\n            }\n\n            defaults(seriesOpt, seriesOpt.mapLocation);\n          }\n        }\n\n        if (seriesOpt.hoverAnimation != null) {\n          seriesOpt.emphasis = seriesOpt.emphasis || {};\n\n          if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {\n            if (\"development\" !== 'production') {\n              deprecateReplaceLog('hoverAnimation', 'emphasis.scale');\n            }\n\n            seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;\n          }\n        }\n\n        compatLayoutProperties(seriesOpt);\n      });\n\n      if (option.dataRange) {\n        option.visualMap = option.dataRange;\n      }\n\n      each(COMPATITABLE_COMPONENTS, function (componentName) {\n        var options = option[componentName];\n\n        if (options) {\n          if (!isArray(options)) {\n            options = [options];\n          }\n\n          each(options, function (option) {\n            compatLayoutProperties(option);\n          });\n        }\n      });\n    }\n\n    function dataStack(ecModel) {\n      var stackInfoMap = createHashMap();\n      ecModel.eachSeries(function (seriesModel) {\n        var stack = seriesModel.get('stack');\n\n        if (stack) {\n          var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);\n          var data = seriesModel.getData();\n          var stackInfo = {\n            stackResultDimension: data.getCalculationInfo('stackResultDimension'),\n            stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),\n            stackedDimension: data.getCalculationInfo('stackedDimension'),\n            stackedByDimension: data.getCalculationInfo('stackedByDimension'),\n            isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),\n            data: data,\n            seriesModel: seriesModel\n          };\n\n          if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {\n            return;\n          }\n\n          stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);\n          stackInfoList.push(stackInfo);\n        }\n      });\n      stackInfoMap.each(calculateStack);\n    }\n\n    function calculateStack(stackInfoList) {\n      each(stackInfoList, function (targetStackInfo, idxInStack) {\n        var resultVal = [];\n        var resultNaN = [NaN, NaN];\n        var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];\n        var targetData = targetStackInfo.data;\n        var isStackedByIndex = targetStackInfo.isStackedByIndex;\n        var newData = targetData.map(dims, function (v0, v1, dataIndex) {\n          var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);\n\n          if (isNaN(sum)) {\n            return resultNaN;\n          }\n\n          var byValue;\n          var stackedDataRawIndex;\n\n          if (isStackedByIndex) {\n            stackedDataRawIndex = targetData.getRawIndex(dataIndex);\n          } else {\n            byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);\n          }\n\n          var stackedOver = NaN;\n\n          for (var j = idxInStack - 1; j >= 0; j--) {\n            var stackInfo = stackInfoList[j];\n\n            if (!isStackedByIndex) {\n              stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);\n            }\n\n            if (stackedDataRawIndex >= 0) {\n              var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);\n\n              if (sum >= 0 && val > 0 || sum <= 0 && val < 0) {\n                sum += val;\n                stackedOver = val;\n                break;\n              }\n            }\n          }\n\n          resultVal[0] = sum;\n          resultVal[1] = stackedOver;\n          return resultVal;\n        });\n        targetData.hostModel.setData(newData);\n        targetStackInfo.data = newData;\n      });\n    }\n\n    var SourceImpl = function () {\n      function SourceImpl(fields) {\n        this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);\n        this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;\n        this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;\n        this.startIndex = fields.startIndex || 0;\n        this.dimensionsDefine = fields.dimensionsDefine;\n        this.dimensionsDetectedCount = fields.dimensionsDetectedCount;\n        this.encodeDefine = fields.encodeDefine;\n        this.metaRawOption = fields.metaRawOption;\n      }\n\n      return SourceImpl;\n    }();\n\n    function isSourceInstance(val) {\n      return val instanceof SourceImpl;\n    }\n    function createSource(sourceData, thisMetaRawOption, sourceFormat, encodeDefine) {\n      sourceFormat = sourceFormat || detectSourceFormat(sourceData);\n      var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;\n      var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);\n      var source = new SourceImpl({\n        data: sourceData,\n        sourceFormat: sourceFormat,\n        seriesLayoutBy: seriesLayoutBy,\n        dimensionsDefine: determined.dimensionsDefine,\n        startIndex: determined.startIndex,\n        dimensionsDetectedCount: determined.dimensionsDetectedCount,\n        encodeDefine: makeEncodeDefine(encodeDefine),\n        metaRawOption: clone(thisMetaRawOption)\n      });\n      return source;\n    }\n    function createSourceFromSeriesDataOption(data) {\n      return new SourceImpl({\n        data: data,\n        sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL\n      });\n    }\n    function cloneSourceShallow(source) {\n      return new SourceImpl({\n        data: source.data,\n        sourceFormat: source.sourceFormat,\n        seriesLayoutBy: source.seriesLayoutBy,\n        dimensionsDefine: clone(source.dimensionsDefine),\n        startIndex: source.startIndex,\n        dimensionsDetectedCount: source.dimensionsDetectedCount,\n        encodeDefine: makeEncodeDefine(source.encodeDefine)\n      });\n    }\n\n    function makeEncodeDefine(encodeDefine) {\n      return encodeDefine ? createHashMap(encodeDefine) : null;\n    }\n\n    function detectSourceFormat(data) {\n      var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n      if (isTypedArray(data)) {\n        sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n      } else if (isArray(data)) {\n        if (data.length === 0) {\n          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        }\n\n        for (var i = 0, len = data.length; i < len; i++) {\n          var item = data[i];\n\n          if (item == null) {\n            continue;\n          } else if (isArray(item)) {\n            sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n            break;\n          } else if (isObject(item)) {\n            sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n            break;\n          }\n        }\n      } else if (isObject(data)) {\n        for (var key in data) {\n          if (hasOwn(data, key) && isArrayLike(data[key])) {\n            sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n            break;\n          }\n        }\n      }\n\n      return sourceFormat;\n    }\n\n    function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n      var dimensionsDetectedCount;\n      var startIndex;\n\n      if (!data) {\n        return {\n          dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n          startIndex: startIndex,\n          dimensionsDetectedCount: dimensionsDetectedCount\n        };\n      }\n\n      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n        var dataArrayRows = data;\n\n        if (sourceHeader === 'auto' || sourceHeader == null) {\n          arrayRowsTravelFirst(function (val) {\n            if (val != null && val !== '-') {\n              if (isString(val)) {\n                startIndex == null && (startIndex = 1);\n              } else {\n                startIndex = 0;\n              }\n            }\n          }, seriesLayoutBy, dataArrayRows, 10);\n        } else {\n          startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;\n        }\n\n        if (!dimensionsDefine && startIndex === 1) {\n          dimensionsDefine = [];\n          arrayRowsTravelFirst(function (val, index) {\n            dimensionsDefine[index] = val != null ? val + '' : '';\n          }, seriesLayoutBy, dataArrayRows, Infinity);\n        }\n\n        dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;\n      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n        if (!dimensionsDefine) {\n          dimensionsDefine = objectRowsCollectDimensions(data);\n        }\n      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n        if (!dimensionsDefine) {\n          dimensionsDefine = [];\n          each(data, function (colArr, key) {\n            dimensionsDefine.push(key);\n          });\n        }\n      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n        var value0 = getDataItemValue(data[0]);\n        dimensionsDetectedCount = isArray(value0) && value0.length || 1;\n      } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n        if (\"development\" !== 'production') {\n          assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');\n        }\n      }\n\n      return {\n        startIndex: startIndex,\n        dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),\n        dimensionsDetectedCount: dimensionsDetectedCount\n      };\n    }\n\n    function objectRowsCollectDimensions(data) {\n      var firstIndex = 0;\n      var obj;\n\n      while (firstIndex < data.length && !(obj = data[firstIndex++])) {}\n\n      if (obj) {\n        var dimensions_1 = [];\n        each(obj, function (value, key) {\n          dimensions_1.push(key);\n        });\n        return dimensions_1;\n      }\n    }\n\n    function normalizeDimensionsOption(dimensionsDefine) {\n      if (!dimensionsDefine) {\n        return;\n      }\n\n      var nameMap = createHashMap();\n      return map(dimensionsDefine, function (rawItem, index) {\n        rawItem = isObject(rawItem) ? rawItem : {\n          name: rawItem\n        };\n        var item = {\n          name: rawItem.name,\n          displayName: rawItem.displayName,\n          type: rawItem.type\n        };\n\n        if (item.name == null) {\n          return item;\n        }\n\n        item.name += '';\n\n        if (item.displayName == null) {\n          item.displayName = item.name;\n        }\n\n        var exist = nameMap.get(item.name);\n\n        if (!exist) {\n          nameMap.set(item.name, {\n            count: 1\n          });\n        } else {\n          item.name += '-' + exist.count++;\n        }\n\n        return item;\n      });\n    }\n\n    function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n        for (var i = 0; i < data.length && i < maxLoop; i++) {\n          cb(data[i] ? data[i][0] : null, i);\n        }\n      } else {\n        var value0 = data[0] || [];\n\n        for (var i = 0; i < value0.length && i < maxLoop; i++) {\n          cb(value0[i], i);\n        }\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var _a, _b, _c;\n    var providerMethods;\n    var mountMethods;\n\n    var DefaultDataProvider = function () {\n      function DefaultDataProvider(sourceParam, dimSize) {\n        var source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;\n        this._source = source;\n        var data = this._data = source.data;\n\n        if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n          if (\"development\" !== 'production') {\n            if (dimSize == null) {\n              throw new Error('Typed array data must specify dimension size');\n            }\n          }\n\n          this._offset = 0;\n          this._dimSize = dimSize;\n          this._data = data;\n        }\n\n        mountMethods(this, data, source);\n      }\n\n      DefaultDataProvider.prototype.getSource = function () {\n        return this._source;\n      };\n\n      DefaultDataProvider.prototype.count = function () {\n        return 0;\n      };\n\n      DefaultDataProvider.prototype.getItem = function (idx, out) {\n        return;\n      };\n\n      DefaultDataProvider.prototype.appendData = function (newData) {};\n\n      DefaultDataProvider.prototype.clean = function () {};\n\n      DefaultDataProvider.protoInitialize = function () {\n        var proto = DefaultDataProvider.prototype;\n        proto.pure = false;\n        proto.persistent = true;\n      }();\n\n      DefaultDataProvider.internalField = function () {\n        var _a;\n\n        mountMethods = function (provider, data, source) {\n          var sourceFormat = source.sourceFormat;\n          var seriesLayoutBy = source.seriesLayoutBy;\n          var startIndex = source.startIndex;\n          var dimsDef = source.dimensionsDefine;\n          var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n          if (\"development\" !== 'production') {\n            assert(methods, 'Invalide sourceFormat: ' + sourceFormat);\n          }\n\n          extend(provider, methods);\n\n          if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {\n            provider.getItem = getItemForTypedArray;\n            provider.count = countForTypedArray;\n            provider.fillStorage = fillStorageForTypedArray;\n          } else {\n            var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);\n            provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);\n            var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);\n            provider.count = bind(rawCounter, null, data, startIndex, dimsDef);\n          }\n        };\n\n        var getItemForTypedArray = function (idx, out) {\n          idx = idx - this._offset;\n          out = out || [];\n          var data = this._data;\n          var dimSize = this._dimSize;\n          var offset = dimSize * idx;\n\n          for (var i = 0; i < dimSize; i++) {\n            out[i] = data[offset + i];\n          }\n\n          return out;\n        };\n\n        var fillStorageForTypedArray = function (start, end, storage, extent) {\n          var data = this._data;\n          var dimSize = this._dimSize;\n\n          for (var dim = 0; dim < dimSize; dim++) {\n            var dimExtent = extent[dim];\n            var min = dimExtent[0] == null ? Infinity : dimExtent[0];\n            var max = dimExtent[1] == null ? -Infinity : dimExtent[1];\n            var count = end - start;\n            var arr = storage[dim];\n\n            for (var i = 0; i < count; i++) {\n              var val = data[i * dimSize + dim];\n              arr[start + i] = val;\n              val < min && (min = val);\n              val > max && (max = val);\n            }\n\n            dimExtent[0] = min;\n            dimExtent[1] = max;\n          }\n        };\n\n        var countForTypedArray = function () {\n          return this._data ? this._data.length / this._dimSize : 0;\n        };\n\n        providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {\n          pure: true,\n          appendData: appendDataSimply\n        }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {\n          pure: true,\n          appendData: function () {\n            throw new Error('Do not support appendData when set seriesLayoutBy: \"row\".');\n          }\n        }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {\n          pure: true,\n          appendData: appendDataSimply\n        }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {\n          pure: true,\n          appendData: function (newData) {\n            var data = this._data;\n            each(newData, function (newCol, key) {\n              var oldCol = data[key] || (data[key] = []);\n\n              for (var i = 0; i < (newCol || []).length; i++) {\n                oldCol.push(newCol[i]);\n              }\n            });\n          }\n        }, _a[SOURCE_FORMAT_ORIGINAL] = {\n          appendData: appendDataSimply\n        }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {\n          persistent: false,\n          pure: true,\n          appendData: function (newData) {\n            if (\"development\" !== 'production') {\n              assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');\n            }\n\n            this._data = newData;\n          },\n          clean: function () {\n            this._offset += this.count();\n            this._data = null;\n          }\n        }, _a);\n\n        function appendDataSimply(newData) {\n          for (var i = 0; i < newData.length; i++) {\n            this._data.push(newData[i]);\n          }\n        }\n      }();\n\n      return DefaultDataProvider;\n    }();\n\n    var getItemSimply = function (rawData, startIndex, dimsDef, idx) {\n      return rawData[idx];\n    };\n\n    var rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {\n      return rawData[idx + startIndex];\n    }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx) {\n      idx += startIndex;\n      var item = [];\n      var data = rawData;\n\n      for (var i = 0; i < data.length; i++) {\n        var row = data[i];\n        item.push(row ? row[idx] : null);\n      }\n\n      return item;\n    }, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx) {\n      var item = [];\n\n      for (var i = 0; i < dimsDef.length; i++) {\n        var dimName = dimsDef[i].name;\n\n        if (\"development\" !== 'production') {\n          if (dimName == null) {\n            throw new Error();\n          }\n        }\n\n        var col = rawData[dimName];\n        item.push(col ? col[idx] : null);\n      }\n\n      return item;\n    }, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);\n    function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {\n      var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (\"development\" !== 'production') {\n        assert(method, 'Do not suppport get item on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n      }\n\n      return method;\n    }\n\n    var countSimply = function (rawData, startIndex, dimsDef) {\n      return rawData.length;\n    };\n\n    var rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {\n      return Math.max(0, rawData.length - startIndex);\n    }, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {\n      var row = rawData[0];\n      return row ? Math.max(0, row.length - startIndex) : 0;\n    }, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {\n      var dimName = dimsDef[0].name;\n\n      if (\"development\" !== 'production') {\n        if (dimName == null) {\n          throw new Error();\n        }\n      }\n\n      var col = rawData[dimName];\n      return col ? col.length : 0;\n    }, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b);\n    function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {\n      var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];\n\n      if (\"development\" !== 'production') {\n        assert(method, 'Do not suppport count on \"' + sourceFormat + '\", \"' + seriesLayoutBy + '\".');\n      }\n\n      return method;\n    }\n\n    var getRawValueSimply = function (dataItem, dimIndex, dimName) {\n      return dimIndex != null ? dataItem[dimIndex] : dataItem;\n    };\n\n    var rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, dimName) {\n      return dimIndex != null ? dataItem[dimName] : dataItem;\n    }, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, dimName) {\n      var value = getDataItemValue(dataItem);\n      return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];\n    }, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);\n    function getRawSourceValueGetter(sourceFormat) {\n      var method = rawSourceValueGetterMap[sourceFormat];\n\n      if (\"development\" !== 'production') {\n        assert(method, 'Do not suppport get value on \"' + sourceFormat + '\".');\n      }\n\n      return method;\n    }\n\n    function getMethodMapKey(sourceFormat, seriesLayoutBy) {\n      return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;\n    }\n\n    function retrieveRawValue(data, dataIndex, dim) {\n      if (!data) {\n        return;\n      }\n\n      var dataItem = data.getRawDataItem(dataIndex);\n\n      if (dataItem == null) {\n        return;\n      }\n\n      var sourceFormat = data.getProvider().getSource().sourceFormat;\n      var dimName;\n      var dimIndex;\n      var dimInfo = data.getDimensionInfo(dim);\n\n      if (dimInfo) {\n        dimName = dimInfo.name;\n        dimIndex = dimInfo.index;\n      }\n\n      return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, dimName);\n    }\n\n    var DIMENSION_LABEL_REG = /\\{@(.+?)\\}/g;\n\n    var DataFormatMixin = function () {\n      function DataFormatMixin() {}\n\n      DataFormatMixin.prototype.getDataParams = function (dataIndex, dataType) {\n        var data = this.getData(dataType);\n        var rawValue = this.getRawValue(dataIndex, dataType);\n        var rawDataIndex = data.getRawIndex(dataIndex);\n        var name = data.getName(dataIndex);\n        var itemOpt = data.getRawDataItem(dataIndex);\n        var style = data.getItemVisual(dataIndex, 'style');\n        var color = style && style[data.getItemVisual(dataIndex, 'drawType') || 'fill'];\n        var borderColor = style && style.stroke;\n        var mainType = this.mainType;\n        var isSeries = mainType === 'series';\n        var userOutput = data.userOutput;\n        return {\n          componentType: mainType,\n          componentSubType: this.subType,\n          componentIndex: this.componentIndex,\n          seriesType: isSeries ? this.subType : null,\n          seriesIndex: this.seriesIndex,\n          seriesId: isSeries ? this.id : null,\n          seriesName: isSeries ? this.name : null,\n          name: name,\n          dataIndex: rawDataIndex,\n          data: itemOpt,\n          dataType: dataType,\n          value: rawValue,\n          color: color,\n          borderColor: borderColor,\n          dimensionNames: userOutput ? userOutput.dimensionNames : null,\n          encode: userOutput ? userOutput.encode : null,\n          $vars: ['seriesName', 'name', 'value']\n        };\n      };\n\n      DataFormatMixin.prototype.getFormattedLabel = function (dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {\n        status = status || 'normal';\n        var data = this.getData(dataType);\n        var params = this.getDataParams(dataIndex, dataType);\n\n        if (extendParams) {\n          params.value = extendParams.interpolatedValue;\n        }\n\n        if (labelDimIndex != null && isArray(params.value)) {\n          params.value = params.value[labelDimIndex];\n        }\n\n        if (!formatter) {\n          var itemModel = data.getItemModel(dataIndex);\n          formatter = itemModel.get(status === 'normal' ? ['label', 'formatter'] : [status, 'label', 'formatter']);\n        }\n\n        if (typeof formatter === 'function') {\n          params.status = status;\n          params.dimensionIndex = labelDimIndex;\n          return formatter(params);\n        } else if (typeof formatter === 'string') {\n          var str = formatTpl(formatter, params);\n          return str.replace(DIMENSION_LABEL_REG, function (origin, dimStr) {\n            var len = dimStr.length;\n            var dimLoose = dimStr.charAt(0) === '[' && dimStr.charAt(len - 1) === ']' ? +dimStr.slice(1, len - 1) : dimStr;\n            var val = retrieveRawValue(data, dataIndex, dimLoose);\n\n            if (extendParams && isArray(extendParams.interpolatedValue)) {\n              var dimInfo = data.getDimensionInfo(dimLoose);\n\n              if (dimInfo) {\n                val = extendParams.interpolatedValue[dimInfo.index];\n              }\n            }\n\n            return val != null ? val + '' : '';\n          });\n        }\n      };\n\n      DataFormatMixin.prototype.getRawValue = function (idx, dataType) {\n        return retrieveRawValue(this.getData(dataType), idx);\n      };\n\n      DataFormatMixin.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        return;\n      };\n\n      return DataFormatMixin;\n    }();\n    function normalizeTooltipFormatResult(result) {\n      var markupText;\n      var markupFragment;\n\n      if (isObject(result)) {\n        if (result.type) {\n          markupFragment = result;\n        } else {\n          if (\"development\" !== 'production') {\n            console.warn('The return type of `formatTooltip` is not supported: ' + makePrintable(result));\n          }\n        }\n      } else {\n        markupText = result;\n      }\n\n      return {\n        markupText: markupText,\n        markupFragment: markupFragment\n      };\n    }\n\n    function createTask(define) {\n      return new Task(define);\n    }\n\n    var Task = function () {\n      function Task(define) {\n        define = define || {};\n        this._reset = define.reset;\n        this._plan = define.plan;\n        this._count = define.count;\n        this._onDirty = define.onDirty;\n        this._dirty = true;\n      }\n\n      Task.prototype.perform = function (performArgs) {\n        var upTask = this._upstream;\n        var skip = performArgs && performArgs.skip;\n\n        if (this._dirty && upTask) {\n          var context = this.context;\n          context.data = context.outputData = upTask.context.outputData;\n        }\n\n        if (this.__pipeline) {\n          this.__pipeline.currentTask = this;\n        }\n\n        var planResult;\n\n        if (this._plan && !skip) {\n          planResult = this._plan(this.context);\n        }\n\n        var lastModBy = normalizeModBy(this._modBy);\n        var lastModDataCount = this._modDataCount || 0;\n        var modBy = normalizeModBy(performArgs && performArgs.modBy);\n        var modDataCount = performArgs && performArgs.modDataCount || 0;\n\n        if (lastModBy !== modBy || lastModDataCount !== modDataCount) {\n          planResult = 'reset';\n        }\n\n        function normalizeModBy(val) {\n          !(val >= 1) && (val = 1);\n          return val;\n        }\n\n        var forceFirstProgress;\n\n        if (this._dirty || planResult === 'reset') {\n          this._dirty = false;\n          forceFirstProgress = this._doReset(skip);\n        }\n\n        this._modBy = modBy;\n        this._modDataCount = modDataCount;\n        var step = performArgs && performArgs.step;\n\n        if (upTask) {\n          if (\"development\" !== 'production') {\n            assert(upTask._outputDueEnd != null);\n          }\n\n          this._dueEnd = upTask._outputDueEnd;\n        } else {\n          if (\"development\" !== 'production') {\n            assert(!this._progress || this._count);\n          }\n\n          this._dueEnd = this._count ? this._count(this.context) : Infinity;\n        }\n\n        if (this._progress) {\n          var start = this._dueIndex;\n          var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);\n\n          if (!skip && (forceFirstProgress || start < end)) {\n            var progress = this._progress;\n\n            if (isArray(progress)) {\n              for (var i = 0; i < progress.length; i++) {\n                this._doProgress(progress[i], start, end, modBy, modDataCount);\n              }\n            } else {\n              this._doProgress(progress, start, end, modBy, modDataCount);\n            }\n          }\n\n          this._dueIndex = end;\n          var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;\n\n          if (\"development\" !== 'production') {\n            assert(outputDueEnd >= this._outputDueEnd);\n          }\n\n          this._outputDueEnd = outputDueEnd;\n        } else {\n          this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;\n        }\n\n        return this.unfinished();\n      };\n\n      Task.prototype.dirty = function () {\n        this._dirty = true;\n        this._onDirty && this._onDirty(this.context);\n      };\n\n      Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {\n        iterator.reset(start, end, modBy, modDataCount);\n        this._callingProgress = progress;\n\n        this._callingProgress({\n          start: start,\n          end: end,\n          count: end - start,\n          next: iterator.next\n        }, this.context);\n      };\n\n      Task.prototype._doReset = function (skip) {\n        this._dueIndex = this._outputDueEnd = this._dueEnd = 0;\n        this._settedOutputEnd = null;\n        var progress;\n        var forceFirstProgress;\n\n        if (!skip && this._reset) {\n          progress = this._reset(this.context);\n\n          if (progress && progress.progress) {\n            forceFirstProgress = progress.forceFirstProgress;\n            progress = progress.progress;\n          }\n\n          if (isArray(progress) && !progress.length) {\n            progress = null;\n          }\n        }\n\n        this._progress = progress;\n        this._modBy = this._modDataCount = null;\n        var downstream = this._downstream;\n        downstream && downstream.dirty();\n        return forceFirstProgress;\n      };\n\n      Task.prototype.unfinished = function () {\n        return this._progress && this._dueIndex < this._dueEnd;\n      };\n\n      Task.prototype.pipe = function (downTask) {\n        if (\"development\" !== 'production') {\n          assert(downTask && !downTask._disposed && downTask !== this);\n        }\n\n        if (this._downstream !== downTask || this._dirty) {\n          this._downstream = downTask;\n          downTask._upstream = this;\n          downTask.dirty();\n        }\n      };\n\n      Task.prototype.dispose = function () {\n        if (this._disposed) {\n          return;\n        }\n\n        this._upstream && (this._upstream._downstream = null);\n        this._downstream && (this._downstream._upstream = null);\n        this._dirty = false;\n        this._disposed = true;\n      };\n\n      Task.prototype.getUpstream = function () {\n        return this._upstream;\n      };\n\n      Task.prototype.getDownstream = function () {\n        return this._downstream;\n      };\n\n      Task.prototype.setOutputEnd = function (end) {\n        this._outputDueEnd = this._settedOutputEnd = end;\n      };\n\n      return Task;\n    }();\n\n    var iterator = function () {\n      var end;\n      var current;\n      var modBy;\n      var modDataCount;\n      var winCount;\n      var it = {\n        reset: function (s, e, sStep, sCount) {\n          current = s;\n          end = e;\n          modBy = sStep;\n          modDataCount = sCount;\n          winCount = Math.ceil(modDataCount / modBy);\n          it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;\n        }\n      };\n      return it;\n\n      function sequentialNext() {\n        return current < end ? current++ : null;\n      }\n\n      function modNext() {\n        var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);\n        var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;\n        current++;\n        return result;\n      }\n    }();\n\n    function parseDataValue(value, opt) {\n      var dimType = opt && opt.type;\n\n      if (dimType === 'ordinal') {\n        var ordinalMeta = opt && opt.ordinalMeta;\n        return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;\n      }\n\n      if (dimType === 'time' && typeof value !== 'number' && value != null && value !== '-') {\n        value = +parseDate(value);\n      }\n\n      return value == null || value === '' ? NaN : +value;\n    }\n    var valueParserMap = createHashMap({\n      'number': function (val) {\n        return parseFloat(val);\n      },\n      'time': function (val) {\n        return +parseDate(val);\n      },\n      'trim': function (val) {\n        return typeof val === 'string' ? trim(val) : val;\n      }\n    });\n    function getRawValueParser(type) {\n      return valueParserMap.get(type);\n    }\n    var ORDER_COMPARISON_OP_MAP = {\n      lt: function (lval, rval) {\n        return lval < rval;\n      },\n      lte: function (lval, rval) {\n        return lval <= rval;\n      },\n      gt: function (lval, rval) {\n        return lval > rval;\n      },\n      gte: function (lval, rval) {\n        return lval >= rval;\n      }\n    };\n\n    var FilterOrderComparator = function () {\n      function FilterOrderComparator(op, rval) {\n        if (typeof rval !== 'number') {\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = 'rvalue of \"<\", \">\", \"<=\", \">=\" can only be number in filter.';\n          }\n\n          throwError(errMsg);\n        }\n\n        this._opFn = ORDER_COMPARISON_OP_MAP[op];\n        this._rvalFloat = numericToNumber(rval);\n      }\n\n      FilterOrderComparator.prototype.evaluate = function (lval) {\n        return typeof lval === 'number' ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);\n      };\n\n      return FilterOrderComparator;\n    }();\n\n    var SortOrderComparator = function () {\n      function SortOrderComparator(order, incomparable) {\n        var isDesc = order === 'desc';\n        this._resultLT = isDesc ? 1 : -1;\n\n        if (incomparable == null) {\n          incomparable = isDesc ? 'min' : 'max';\n        }\n\n        this._incomparable = incomparable === 'min' ? -Infinity : Infinity;\n      }\n\n      SortOrderComparator.prototype.evaluate = function (lval, rval) {\n        var lvalTypeof = typeof lval;\n        var rvalTypeof = typeof rval;\n        var lvalFloat = lvalTypeof === 'number' ? lval : numericToNumber(lval);\n        var rvalFloat = rvalTypeof === 'number' ? rval : numericToNumber(rval);\n        var lvalNotNumeric = isNaN(lvalFloat);\n        var rvalNotNumeric = isNaN(rvalFloat);\n\n        if (lvalNotNumeric) {\n          lvalFloat = this._incomparable;\n        }\n\n        if (rvalNotNumeric) {\n          rvalFloat = this._incomparable;\n        }\n\n        if (lvalNotNumeric && rvalNotNumeric) {\n          var lvalIsStr = lvalTypeof === 'string';\n          var rvalIsStr = rvalTypeof === 'string';\n\n          if (lvalIsStr) {\n            lvalFloat = rvalIsStr ? lval : 0;\n          }\n\n          if (rvalIsStr) {\n            rvalFloat = lvalIsStr ? rval : 0;\n          }\n        }\n\n        return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;\n      };\n\n      return SortOrderComparator;\n    }();\n\n    var FilterEqualityComparator = function () {\n      function FilterEqualityComparator(isEq, rval) {\n        this._rval = rval;\n        this._isEQ = isEq;\n        this._rvalTypeof = typeof rval;\n        this._rvalFloat = numericToNumber(rval);\n      }\n\n      FilterEqualityComparator.prototype.evaluate = function (lval) {\n        var eqResult = lval === this._rval;\n\n        if (!eqResult) {\n          var lvalTypeof = typeof lval;\n\n          if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === 'number' || this._rvalTypeof === 'number')) {\n            eqResult = numericToNumber(lval) === this._rvalFloat;\n          }\n        }\n\n        return this._isEQ ? eqResult : !eqResult;\n      };\n\n      return FilterEqualityComparator;\n    }();\n\n    function createFilterComparator(op, rval) {\n      return op === 'eq' || op === 'ne' ? new FilterEqualityComparator(op === 'eq', rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;\n    }\n\n    var ExternalSource = function () {\n      function ExternalSource() {}\n\n      ExternalSource.prototype.getRawData = function () {\n        throw new Error('not supported');\n      };\n\n      ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n        throw new Error('not supported');\n      };\n\n      ExternalSource.prototype.cloneRawData = function () {\n        return;\n      };\n\n      ExternalSource.prototype.getDimensionInfo = function (dim) {\n        return;\n      };\n\n      ExternalSource.prototype.cloneAllDimensionInfo = function () {\n        return;\n      };\n\n      ExternalSource.prototype.count = function () {\n        return;\n      };\n\n      ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n        return;\n      };\n\n      ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n        return;\n      };\n\n      ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n        return parseDataValue(rawVal, dimInfo);\n      };\n\n      return ExternalSource;\n    }();\n\n    function createExternalSource(internalSource, externalTransform) {\n      var extSource = new ExternalSource();\n      var data = internalSource.data;\n      var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n      var sourceHeaderCount = internalSource.startIndex;\n      var errMsg = '';\n\n      if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {\n        if (\"development\" !== 'production') {\n          errMsg = '`seriesLayoutBy` of upstream dataset can only be \"column\" in data transform.';\n        }\n\n        throwError(errMsg);\n      }\n\n      var dimensions = [];\n      var dimsByName = {};\n      var dimsDef = internalSource.dimensionsDefine;\n\n      if (dimsDef) {\n        each(dimsDef, function (dimDef, idx) {\n          var name = dimDef.name;\n          var dimDefExt = {\n            index: idx,\n            name: name,\n            displayName: dimDef.displayName\n          };\n          dimensions.push(dimDefExt);\n\n          if (name != null) {\n            var errMsg_1 = '';\n\n            if (hasOwn(dimsByName, name)) {\n              if (\"development\" !== 'production') {\n                errMsg_1 = 'dimension name \"' + name + '\" duplicated.';\n              }\n\n              throwError(errMsg_1);\n            }\n\n            dimsByName[name] = dimDefExt;\n          }\n        });\n      } else {\n        for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n          dimensions.push({\n            index: i\n          });\n        }\n      }\n\n      var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n      if (externalTransform.__isBuiltIn) {\n        extSource.getRawDataItem = function (dataIndex) {\n          return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n        };\n\n        extSource.getRawData = bind(getRawData, null, internalSource);\n      }\n\n      extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n      var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n      extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n      var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n      extSource.retrieveValue = function (dataIndex, dimIndex) {\n        var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n        return retrieveValueFromItem(rawItem, dimIndex);\n      };\n\n      var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n        if (dataItem == null) {\n          return;\n        }\n\n        var dimDef = dimensions[dimIndex];\n\n        if (dimDef) {\n          return rawValueGetter(dataItem, dimIndex, dimDef.name);\n        }\n      };\n\n      extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n      extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n      return extSource;\n    }\n\n    function getRawData(upstream) {\n      var sourceFormat = upstream.sourceFormat;\n\n      if (!isSupportedSourceFormat(sourceFormat)) {\n        var errMsg = '';\n\n        if (\"development\" !== 'production') {\n          errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n        }\n\n        throwError(errMsg);\n      }\n\n      return upstream.data;\n    }\n\n    function cloneRawData(upstream) {\n      var sourceFormat = upstream.sourceFormat;\n      var data = upstream.data;\n\n      if (!isSupportedSourceFormat(sourceFormat)) {\n        var errMsg = '';\n\n        if (\"development\" !== 'production') {\n          errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat;\n        }\n\n        throwError(errMsg);\n      }\n\n      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n        var result = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n          result.push(data[i].slice());\n        }\n\n        return result;\n      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n        var result = [];\n\n        for (var i = 0, len = data.length; i < len; i++) {\n          result.push(extend({}, data[i]));\n        }\n\n        return result;\n      }\n    }\n\n    function getDimensionInfo(dimensions, dimsByName, dim) {\n      if (dim == null) {\n        return;\n      }\n\n      if (typeof dim === 'number' || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n        return dimensions[dim];\n      } else if (hasOwn(dimsByName, dim)) {\n        return dimsByName[dim];\n      }\n    }\n\n    function cloneAllDimensionInfo(dimensions) {\n      return clone(dimensions);\n    }\n\n    var externalTransformMap = createHashMap();\n    function registerExternalTransform(externalTransform) {\n      externalTransform = clone(externalTransform);\n      var type = externalTransform.type;\n      var errMsg = '';\n\n      if (!type) {\n        if (\"development\" !== 'production') {\n          errMsg = 'Must have a `type` when `registerTransform`.';\n        }\n\n        throwError(errMsg);\n      }\n\n      var typeParsed = type.split(':');\n\n      if (typeParsed.length !== 2) {\n        if (\"development\" !== 'production') {\n          errMsg = 'Name must include namespace like \"ns:regression\".';\n        }\n\n        throwError(errMsg);\n      }\n\n      var isBuiltIn = false;\n\n      if (typeParsed[0] === 'echarts') {\n        type = typeParsed[1];\n        isBuiltIn = true;\n      }\n\n      externalTransform.__isBuiltIn = isBuiltIn;\n      externalTransformMap.set(type, externalTransform);\n    }\n    function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n      var pipedTransOption = normalizeToArray(rawTransOption);\n      var pipeLen = pipedTransOption.length;\n      var errMsg = '';\n\n      if (!pipeLen) {\n        if (\"development\" !== 'production') {\n          errMsg = 'If `transform` declared, it should at least contain one transform.';\n        }\n\n        throwError(errMsg);\n      }\n\n      for (var i = 0, len = pipeLen; i < len; i++) {\n        var transOption = pipedTransOption[i];\n        sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n        if (i !== len - 1) {\n          sourceList.length = Math.max(sourceList.length, 1);\n        }\n      }\n\n      return sourceList;\n    }\n\n    function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n      var errMsg = '';\n\n      if (!upSourceList.length) {\n        if (\"development\" !== 'production') {\n          errMsg = 'Must have at least one upstream dataset.';\n        }\n\n        throwError(errMsg);\n      }\n\n      if (!isObject(transOption)) {\n        if (\"development\" !== 'production') {\n          errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n        }\n\n        throwError(errMsg);\n      }\n\n      var transType = transOption.type;\n      var externalTransform = externalTransformMap.get(transType);\n\n      if (!externalTransform) {\n        if (\"development\" !== 'production') {\n          errMsg = 'Can not find transform on type \"' + transType + '\".';\n        }\n\n        throwError(errMsg);\n      }\n\n      var extUpSourceList = map(upSourceList, function (upSource) {\n        return createExternalSource(upSource, externalTransform);\n      });\n      var resultList = normalizeToArray(externalTransform.transform({\n        upstream: extUpSourceList[0],\n        upstreamList: extUpSourceList,\n        config: clone(transOption.config)\n      }));\n\n      if (\"development\" !== 'production') {\n        if (transOption.print) {\n          var printStrArr = map(resultList, function (extSource) {\n            var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n            return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n          }).join('\\n');\n          consoleLog(printStrArr);\n        }\n      }\n\n      return map(resultList, function (result, resultIndex) {\n        var errMsg = '';\n\n        if (!isObject(result)) {\n          if (\"development\" !== 'production') {\n            errMsg = 'A transform should not return some empty results.';\n          }\n\n          throwError(errMsg);\n        }\n\n        if (!result.data) {\n          if (\"development\" !== 'production') {\n            errMsg = 'Transform result data should be not be null or undefined';\n          }\n\n          throwError(errMsg);\n        }\n\n        var sourceFormat = detectSourceFormat(result.data);\n\n        if (!isSupportedSourceFormat(sourceFormat)) {\n          if (\"development\" !== 'production') {\n            errMsg = 'Transform result data should be array rows or object rows.';\n          }\n\n          throwError(errMsg);\n        }\n\n        var resultMetaRawOption;\n        var firstUpSource = upSourceList[0];\n\n        if (firstUpSource && resultIndex === 0 && !result.dimensions) {\n          var startIndex = firstUpSource.startIndex;\n\n          if (startIndex) {\n            result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);\n          }\n\n          resultMetaRawOption = {\n            seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n            sourceHeader: startIndex,\n            dimensions: firstUpSource.metaRawOption.dimensions\n          };\n        } else {\n          resultMetaRawOption = {\n            seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n            sourceHeader: 0,\n            dimensions: result.dimensions\n          };\n        }\n\n        return createSource(result.data, resultMetaRawOption, null, null);\n      });\n    }\n\n    function isSupportedSourceFormat(sourceFormat) {\n      return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;\n    }\n\n    var SourceManager = function () {\n      function SourceManager(sourceHost) {\n        this._sourceList = [];\n        this._upstreamSignList = [];\n        this._versionSignBase = 0;\n        this._sourceHost = sourceHost;\n      }\n\n      SourceManager.prototype.dirty = function () {\n        this._setLocalSource([], []);\n      };\n\n      SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {\n        this._sourceList = sourceList;\n        this._upstreamSignList = upstreamSignList;\n        this._versionSignBase++;\n\n        if (this._versionSignBase > 9e10) {\n          this._versionSignBase = 0;\n        }\n      };\n\n      SourceManager.prototype._getVersionSign = function () {\n        return this._sourceHost.uid + '_' + this._versionSignBase;\n      };\n\n      SourceManager.prototype.prepareSource = function () {\n        if (this._isDirty()) {\n          this._createSource();\n        }\n      };\n\n      SourceManager.prototype._createSource = function () {\n        this._setLocalSource([], []);\n\n        var sourceHost = this._sourceHost;\n\n        var upSourceMgrList = this._getUpstreamSourceManagers();\n\n        var hasUpstream = !!upSourceMgrList.length;\n        var resultSourceList;\n        var upstreamSignList;\n\n        if (isSeries(sourceHost)) {\n          var seriesModel = sourceHost;\n          var data = void 0;\n          var sourceFormat = void 0;\n          var upSource = void 0;\n\n          if (hasUpstream) {\n            var upSourceMgr = upSourceMgrList[0];\n            upSourceMgr.prepareSource();\n            upSource = upSourceMgr.getSource();\n            data = upSource.data;\n            sourceFormat = upSource.sourceFormat;\n            upstreamSignList = [upSourceMgr._getVersionSign()];\n          } else {\n            data = seriesModel.get('data', true);\n            sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n            upstreamSignList = [];\n          }\n\n          var newMetaRawOption = this._getSourceMetaRawOption();\n\n          var upMetaRawOption = upSource ? upSource.metaRawOption : null;\n          var seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption ? upMetaRawOption.seriesLayoutBy : null);\n          var sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption ? upMetaRawOption.sourceHeader : null);\n          var dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption ? upMetaRawOption.dimensions : null);\n          resultSourceList = [createSource(data, {\n            seriesLayoutBy: seriesLayoutBy,\n            sourceHeader: sourceHeader,\n            dimensions: dimensions\n          }, sourceFormat, seriesModel.get('encode', true))];\n        } else {\n          var datasetModel = sourceHost;\n\n          if (hasUpstream) {\n            var result = this._applyTransform(upSourceMgrList);\n\n            resultSourceList = result.sourceList;\n            upstreamSignList = result.upstreamSignList;\n          } else {\n            var sourceData = datasetModel.get('source', true);\n            resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null, null)];\n            upstreamSignList = [];\n          }\n        }\n\n        if (\"development\" !== 'production') {\n          assert(resultSourceList && upstreamSignList);\n        }\n\n        this._setLocalSource(resultSourceList, upstreamSignList);\n      };\n\n      SourceManager.prototype._applyTransform = function (upMgrList) {\n        var datasetModel = this._sourceHost;\n        var transformOption = datasetModel.get('transform', true);\n        var fromTransformResult = datasetModel.get('fromTransformResult', true);\n\n        if (\"development\" !== 'production') {\n          assert(fromTransformResult != null || transformOption != null);\n        }\n\n        if (fromTransformResult != null) {\n          var errMsg = '';\n\n          if (upMgrList.length !== 1) {\n            if (\"development\" !== 'production') {\n              errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';\n            }\n\n            doThrow(errMsg);\n          }\n        }\n\n        var sourceList;\n        var upSourceList = [];\n        var upstreamSignList = [];\n        each(upMgrList, function (upMgr) {\n          upMgr.prepareSource();\n          var upSource = upMgr.getSource(fromTransformResult || 0);\n          var errMsg = '';\n\n          if (fromTransformResult != null && !upSource) {\n            if (\"development\" !== 'production') {\n              errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;\n            }\n\n            doThrow(errMsg);\n          }\n\n          upSourceList.push(upSource);\n          upstreamSignList.push(upMgr._getVersionSign());\n        });\n\n        if (transformOption) {\n          sourceList = applyDataTransform(transformOption, upSourceList, {\n            datasetIndex: datasetModel.componentIndex\n          });\n        } else if (fromTransformResult != null) {\n          sourceList = [cloneSourceShallow(upSourceList[0])];\n        }\n\n        return {\n          sourceList: sourceList,\n          upstreamSignList: upstreamSignList\n        };\n      };\n\n      SourceManager.prototype._isDirty = function () {\n        var sourceList = this._sourceList;\n\n        if (!sourceList.length) {\n          return true;\n        }\n\n        var upSourceMgrList = this._getUpstreamSourceManagers();\n\n        for (var i = 0; i < upSourceMgrList.length; i++) {\n          var upSrcMgr = upSourceMgrList[i];\n\n          if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {\n            return true;\n          }\n        }\n      };\n\n      SourceManager.prototype.getSource = function (sourceIndex) {\n        return this._sourceList[sourceIndex || 0];\n      };\n\n      SourceManager.prototype._getUpstreamSourceManagers = function () {\n        var sourceHost = this._sourceHost;\n\n        if (isSeries(sourceHost)) {\n          var datasetModel = querySeriesUpstreamDatasetModel(sourceHost);\n          return !datasetModel ? [] : [datasetModel.getSourceManager()];\n        } else {\n          return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {\n            return datasetModel.getSourceManager();\n          });\n        }\n      };\n\n      SourceManager.prototype._getSourceMetaRawOption = function () {\n        var sourceHost = this._sourceHost;\n        var seriesLayoutBy;\n        var sourceHeader;\n        var dimensions;\n\n        if (isSeries(sourceHost)) {\n          seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);\n          sourceHeader = sourceHost.get('sourceHeader', true);\n          dimensions = sourceHost.get('dimensions', true);\n        } else if (!this._getUpstreamSourceManagers().length) {\n          var model = sourceHost;\n          seriesLayoutBy = model.get('seriesLayoutBy', true);\n          sourceHeader = model.get('sourceHeader', true);\n          dimensions = model.get('dimensions', true);\n        }\n\n        return {\n          seriesLayoutBy: seriesLayoutBy,\n          sourceHeader: sourceHeader,\n          dimensions: dimensions\n        };\n      };\n\n      return SourceManager;\n    }();\n    function disableTransformOptionMerge(datasetModel) {\n      var transformOption = datasetModel.option.transform;\n      transformOption && setAsPrimitive(datasetModel.option.transform);\n    }\n\n    function isSeries(sourceHost) {\n      return sourceHost.mainType === 'series';\n    }\n\n    function doThrow(errMsg) {\n      throw new Error(errMsg);\n    }\n\n    var TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1';\n\n    function getTooltipTextStyle(textStyle, renderMode) {\n      var nameFontColor = textStyle.color || '#6e7079';\n      var nameFontSize = textStyle.fontSize || 12;\n      var nameFontWeight = textStyle.fontWeight || '400';\n      var valueFontColor = textStyle.color || '#464646';\n      var valueFontSize = textStyle.fontSize || 14;\n      var valueFontWeight = textStyle.fontWeight || '900';\n\n      if (renderMode === 'html') {\n        return {\n          nameStyle: \"font-size:\" + nameFontSize + \"px;color:\" + nameFontColor + \";font-weight:\" + nameFontWeight,\n          valueStyle: \"font-size:\" + valueFontSize + \"px;color:\" + valueFontColor + \";font-weight:\" + valueFontWeight\n        };\n      } else {\n        return {\n          nameStyle: {\n            fontSize: nameFontSize,\n            fill: nameFontColor,\n            fontWeight: nameFontWeight\n          },\n          valueStyle: {\n            fontSize: valueFontSize,\n            fill: valueFontColor,\n            fontWeight: valueFontWeight\n          }\n        };\n      }\n    }\n\n    var HTML_GAPS = [0, 10, 20, 30];\n    var RICH_TEXT_GAPS = ['', '\\n', '\\n\\n', '\\n\\n\\n'];\n    function createTooltipMarkup(type, option) {\n      option.type = type;\n      return option;\n    }\n\n    function getBuilder(fragment) {\n      return hasOwn(builderMap, fragment.type) && builderMap[fragment.type];\n    }\n\n    var builderMap = {\n      section: {\n        planLayout: function (fragment) {\n          var subBlockLen = fragment.blocks.length;\n          var thisBlockHasInnerGap = subBlockLen > 1 || subBlockLen > 0 && !fragment.noHeader;\n          var thisGapLevelBetweenSubBlocks = 0;\n          each(fragment.blocks, function (subBlock) {\n            getBuilder(subBlock).planLayout(subBlock);\n            var subGapLevel = subBlock.__gapLevelBetweenSubBlocks;\n\n            if (subGapLevel >= thisGapLevelBetweenSubBlocks) {\n              thisGapLevelBetweenSubBlocks = subGapLevel + (thisBlockHasInnerGap && (!subGapLevel || subBlock.type === 'section' && !subBlock.noHeader) ? 1 : 0);\n            }\n          });\n          fragment.__gapLevelBetweenSubBlocks = thisGapLevelBetweenSubBlocks;\n        },\n        build: function (ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {\n          var noHeader = fragment.noHeader;\n          var gaps = getGap(fragment);\n          var subMarkupText = buildSubBlocks(ctx, fragment, noHeader ? topMarginForOuterGap : gaps.html, toolTipTextStyle);\n\n          if (noHeader) {\n            return subMarkupText;\n          }\n\n          var displayableHeader = makeValueReadable(fragment.header, 'ordinal', ctx.useUTC);\n          var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;\n\n          if (ctx.renderMode === 'richText') {\n            return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;\n          } else {\n            return wrapBlockHTML(\"<div style=\\\"\" + nameStyle + \";\" + TOOLTIP_LINE_HEIGHT_CSS + \";\\\">\" + encodeHTML(displayableHeader) + '</div>' + subMarkupText, topMarginForOuterGap);\n          }\n        }\n      },\n      nameValue: {\n        planLayout: function (fragment) {\n          fragment.__gapLevelBetweenSubBlocks = 0;\n        },\n        build: function (ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {\n          var renderMode = ctx.renderMode;\n          var noName = fragment.noName;\n          var noValue = fragment.noValue;\n          var noMarker = !fragment.markerType;\n          var name = fragment.name;\n          var value = fragment.value;\n          var useUTC = ctx.useUTC;\n\n          if (noName && noValue) {\n            return;\n          }\n\n          var markerStr = noMarker ? '' : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || '#333', renderMode);\n          var readableName = noName ? '' : makeValueReadable(name, 'ordinal', useUTC);\n          var valueTypeOption = fragment.valueType;\n          var readableValueList = noValue ? [] : isArray(value) ? map(value, function (val, idx) {\n            return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);\n          }) : [makeValueReadable(value, isArray(valueTypeOption) ? valueTypeOption[0] : valueTypeOption, useUTC)];\n          var valueAlignRight = !noMarker || !noName;\n          var valueCloseToMarker = !noMarker && noName;\n\n          var _a = getTooltipTextStyle(toolTipTextStyle, renderMode),\n              nameStyle = _a.nameStyle,\n              valueStyle = _a.valueStyle;\n\n          return renderMode === 'richText' ? (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? '' : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? '' : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);\n        }\n      }\n    };\n\n    function buildSubBlocks(ctx, fragment, topMarginForOuterGap, tooltipTextStyle) {\n      var subMarkupTextList = [];\n      var subBlocks = fragment.blocks || [];\n      assert(!subBlocks || isArray(subBlocks));\n      subBlocks = subBlocks || [];\n      var orderMode = ctx.orderMode;\n\n      if (fragment.sortBlocks && orderMode) {\n        subBlocks = subBlocks.slice();\n        var orderMap = {\n          valueAsc: 'asc',\n          valueDesc: 'desc'\n        };\n\n        if (hasOwn(orderMap, orderMode)) {\n          var comparator_1 = new SortOrderComparator(orderMap[orderMode], null);\n          subBlocks.sort(function (a, b) {\n            return comparator_1.evaluate(a.sortParam, b.sortParam);\n          });\n        } else if (orderMode === 'seriesDesc') {\n          subBlocks.reverse();\n        }\n      }\n\n      var gaps = getGap(fragment);\n      each(subBlocks, function (subBlock, idx) {\n        var subMarkupText = getBuilder(subBlock).build(ctx, subBlock, idx > 0 ? gaps.html : 0, tooltipTextStyle);\n        subMarkupText != null && subMarkupTextList.push(subMarkupText);\n      });\n\n      if (!subMarkupTextList.length) {\n        return;\n      }\n\n      return ctx.renderMode === 'richText' ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(''), topMarginForOuterGap);\n    }\n\n    function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {\n      if (!fragment) {\n        return;\n      }\n\n      var builder = getBuilder(fragment);\n      builder.planLayout(fragment);\n      var ctx = {\n        useUTC: useUTC,\n        renderMode: renderMode,\n        orderMode: orderMode,\n        markupStyleCreator: markupStyleCreator\n      };\n      return builder.build(ctx, fragment, 0, toolTipTextStyle);\n    }\n\n    function getGap(fragment) {\n      var gapLevelBetweenSubBlocks = fragment.__gapLevelBetweenSubBlocks;\n      return {\n        html: HTML_GAPS[gapLevelBetweenSubBlocks],\n        richText: RICH_TEXT_GAPS[gapLevelBetweenSubBlocks]\n      };\n    }\n\n    function wrapBlockHTML(encodedContent, topGap) {\n      var clearfix = '<div style=\"clear:both\"></div>';\n      var marginCSS = \"margin: \" + topGap + \"px 0 0\";\n      return \"<div style=\\\"\" + marginCSS + \";\" + TOOLTIP_LINE_HEIGHT_CSS + \";\\\">\" + encodedContent + clearfix + '</div>';\n    }\n\n    function wrapInlineNameHTML(name, leftHasMarker, style) {\n      var marginCss = leftHasMarker ? 'margin-left:2px' : '';\n      return \"<span style=\\\"\" + style + \";\" + marginCss + \"\\\">\" + encodeHTML(name) + '</span>';\n    }\n\n    function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {\n      var paddingStr = valueCloseToMarker ? '10px' : '20px';\n      var alignCSS = alignRight ? \"float:right;margin-left:\" + paddingStr : '';\n      return \"<span style=\\\"\" + alignCSS + \";\" + style + \"\\\">\" + map(valueList, function (value) {\n        return encodeHTML(value);\n      }).join('&nbsp;&nbsp;') + '</span>';\n    }\n\n    function wrapInlineNameRichText(ctx, name, style) {\n      return ctx.markupStyleCreator.wrapRichTextStyle(name, style);\n    }\n\n    function wrapInlineValueRichText(ctx, valueList, alignRight, valueCloseToMarker, style) {\n      var styles = [style];\n      var paddingLeft = valueCloseToMarker ? 10 : 20;\n      alignRight && styles.push({\n        padding: [0, 0, 0, paddingLeft],\n        align: 'right'\n      });\n      return ctx.markupStyleCreator.wrapRichTextStyle(valueList.join('  '), styles);\n    }\n\n    function retrieveVisualColorForTooltipMarker(series, dataIndex) {\n      var style = series.getData().getItemVisual(dataIndex, 'style');\n      var color = style[series.visualDrawType];\n      return convertToColorString(color);\n    }\n    function getPaddingFromTooltipModel(model, renderMode) {\n      var padding = model.get('padding');\n      return padding != null ? padding : renderMode === 'richText' ? [8, 10] : 10;\n    }\n\n    var TooltipMarkupStyleCreator = function () {\n      function TooltipMarkupStyleCreator() {\n        this.richTextStyles = {};\n        this._nextStyleNameId = getRandomIdBase();\n      }\n\n      TooltipMarkupStyleCreator.prototype._generateStyleName = function () {\n        return '__EC_aUTo_' + this._nextStyleNameId++;\n      };\n\n      TooltipMarkupStyleCreator.prototype.makeTooltipMarker = function (markerType, colorStr, renderMode) {\n        var markerId = renderMode === 'richText' ? this._generateStyleName() : null;\n        var marker = getTooltipMarker({\n          color: colorStr,\n          type: markerType,\n          renderMode: renderMode,\n          markerId: markerId\n        });\n\n        if (isString(marker)) {\n          return marker;\n        } else {\n          if (\"development\" !== 'production') {\n            assert(markerId);\n          }\n\n          this.richTextStyles[markerId] = marker.style;\n          return marker.content;\n        }\n      };\n\n      TooltipMarkupStyleCreator.prototype.wrapRichTextStyle = function (text, styles) {\n        var finalStl = {};\n\n        if (isArray(styles)) {\n          each(styles, function (stl) {\n            return extend(finalStl, stl);\n          });\n        } else {\n          extend(finalStl, styles);\n        }\n\n        var styleName = this._generateStyleName();\n\n        this.richTextStyles[styleName] = finalStl;\n        return \"{\" + styleName + \"|\" + text + \"}\";\n      };\n\n      return TooltipMarkupStyleCreator;\n    }();\n\n    function defaultSeriesFormatTooltip(opt) {\n      var series = opt.series;\n      var dataIndex = opt.dataIndex;\n      var multipleSeries = opt.multipleSeries;\n      var data = series.getData();\n      var tooltipDims = data.mapDimensionsAll('defaultedTooltip');\n      var tooltipDimLen = tooltipDims.length;\n      var value = series.getRawValue(dataIndex);\n      var isValueArr = isArray(value);\n      var markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);\n      var inlineValue;\n      var inlineValueType;\n      var subBlocks;\n      var sortParam;\n\n      if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {\n        var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);\n        inlineValue = formatArrResult.inlineValues;\n        inlineValueType = formatArrResult.inlineValueTypes;\n        subBlocks = formatArrResult.blocks;\n        sortParam = formatArrResult.inlineValues[0];\n      } else if (tooltipDimLen) {\n        var dimInfo = data.getDimensionInfo(tooltipDims[0]);\n        sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);\n        inlineValueType = dimInfo.type;\n      } else {\n        sortParam = inlineValue = isValueArr ? value[0] : value;\n      }\n\n      var seriesNameSpecified = isNameSpecified(series);\n      var seriesName = seriesNameSpecified && series.name || '';\n      var itemName = data.getName(dataIndex);\n      var inlineName = multipleSeries ? seriesName : itemName;\n      return createTooltipMarkup('section', {\n        header: seriesName,\n        noHeader: multipleSeries || !seriesNameSpecified,\n        sortParam: sortParam,\n        blocks: [createTooltipMarkup('nameValue', {\n          markerType: 'item',\n          markerColor: markerColor,\n          name: inlineName,\n          noName: !trim(inlineName),\n          value: inlineValue,\n          valueType: inlineValueType\n        })].concat(subBlocks || [])\n      });\n    }\n\n    function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {\n      var data = series.getData();\n      var isValueMultipleLine = reduce(value, function (isValueMultipleLine, val, idx) {\n        var dimItem = data.getDimensionInfo(idx);\n        return isValueMultipleLine = isValueMultipleLine || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;\n      }, false);\n      var inlineValues = [];\n      var inlineValueTypes = [];\n      var blocks = [];\n      tooltipDims.length ? each(tooltipDims, function (dim) {\n        setEachItem(retrieveRawValue(data, dataIndex, dim), dim);\n      }) : each(value, setEachItem);\n\n      function setEachItem(val, dim) {\n        var dimInfo = data.getDimensionInfo(dim);\n\n        if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n          return;\n        }\n\n        if (isValueMultipleLine) {\n          blocks.push(createTooltipMarkup('nameValue', {\n            markerType: 'subItem',\n            markerColor: colorStr,\n            name: dimInfo.displayName,\n            value: val,\n            valueType: dimInfo.type\n          }));\n        } else {\n          inlineValues.push(val);\n          inlineValueTypes.push(dimInfo.type);\n        }\n      }\n\n      return {\n        inlineValues: inlineValues,\n        inlineValueTypes: inlineValueTypes,\n        blocks: blocks\n      };\n    }\n\n    var inner$1 = makeInner();\n\n    function getSelectionKey(data, dataIndex) {\n      return data.getName(dataIndex) || data.getId(dataIndex);\n    }\n\n    var SeriesModel = function (_super) {\n      __extends(SeriesModel, _super);\n\n      function SeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this._selectedDataIndicesMap = {};\n        return _this;\n      }\n\n      SeriesModel.prototype.init = function (option, parentModel, ecModel) {\n        this.seriesIndex = this.componentIndex;\n        this.dataTask = createTask({\n          count: dataTaskCount,\n          reset: dataTaskReset\n        });\n        this.dataTask.context = {\n          model: this\n        };\n        this.mergeDefaultAndTheme(option, ecModel);\n        var sourceManager = inner$1(this).sourceManager = new SourceManager(this);\n        sourceManager.prepareSource();\n        var data = this.getInitialData(option, ecModel);\n        wrapData(data, this);\n        this.dataTask.context.data = data;\n\n        if (\"development\" !== 'production') {\n          assert(data, 'getInitialData returned invalid data.');\n        }\n\n        inner$1(this).dataBeforeProcessed = data;\n        autoSeriesName(this);\n\n        this._initSelectedMapFromData(data);\n      };\n\n      SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n        var layoutMode = fetchLayoutMode(this);\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeSubType = this.subType;\n\n        if (ComponentModel.hasClass(themeSubType)) {\n          themeSubType += 'Series';\n        }\n\n        merge(option, ecModel.getTheme().get(this.subType));\n        merge(option, this.getDefaultOption());\n        defaultEmphasis(option, 'label', ['show']);\n        this.fillDataTextStyle(option.data);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      };\n\n      SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {\n        newSeriesOption = merge(this.option, newSeriesOption, true);\n        this.fillDataTextStyle(newSeriesOption.data);\n        var layoutMode = fetchLayoutMode(this);\n\n        if (layoutMode) {\n          mergeLayoutParam(this.option, newSeriesOption, layoutMode);\n        }\n\n        var sourceManager = inner$1(this).sourceManager;\n        sourceManager.dirty();\n        sourceManager.prepareSource();\n        var data = this.getInitialData(newSeriesOption, ecModel);\n        wrapData(data, this);\n        this.dataTask.dirty();\n        this.dataTask.context.data = data;\n        inner$1(this).dataBeforeProcessed = data;\n        autoSeriesName(this);\n\n        this._initSelectedMapFromData(data);\n      };\n\n      SeriesModel.prototype.fillDataTextStyle = function (data) {\n        if (data && !isTypedArray(data)) {\n          var props = ['show'];\n\n          for (var i = 0; i < data.length; i++) {\n            if (data[i] && data[i].label) {\n              defaultEmphasis(data[i], 'label', props);\n            }\n          }\n        }\n      };\n\n      SeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return;\n      };\n\n      SeriesModel.prototype.appendData = function (params) {\n        var data = this.getRawData();\n        data.appendData(params.data);\n      };\n\n      SeriesModel.prototype.getData = function (dataType) {\n        var task = getCurrentTask(this);\n\n        if (task) {\n          var data = task.context.data;\n          return dataType == null ? data : data.getLinkedData(dataType);\n        } else {\n          return inner$1(this).data;\n        }\n      };\n\n      SeriesModel.prototype.getAllData = function () {\n        var mainData = this.getData();\n        return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{\n          data: mainData\n        }];\n      };\n\n      SeriesModel.prototype.setData = function (data) {\n        var task = getCurrentTask(this);\n\n        if (task) {\n          var context = task.context;\n          context.outputData = data;\n\n          if (task !== this.dataTask) {\n            context.data = data;\n          }\n        }\n\n        inner$1(this).data = data;\n      };\n\n      SeriesModel.prototype.getSource = function () {\n        return inner$1(this).sourceManager.getSource();\n      };\n\n      SeriesModel.prototype.getRawData = function () {\n        return inner$1(this).dataBeforeProcessed;\n      };\n\n      SeriesModel.prototype.getBaseAxis = function () {\n        var coordSys = this.coordinateSystem;\n        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();\n      };\n\n      SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        return defaultSeriesFormatTooltip({\n          series: this,\n          dataIndex: dataIndex,\n          multipleSeries: multipleSeries\n        });\n      };\n\n      SeriesModel.prototype.isAnimationEnabled = function () {\n        if (env.node) {\n          return false;\n        }\n\n        var animationEnabled = this.getShallow('animation');\n\n        if (animationEnabled) {\n          if (this.getData().count() > this.getShallow('animationThreshold')) {\n            animationEnabled = false;\n          }\n        }\n\n        return !!animationEnabled;\n      };\n\n      SeriesModel.prototype.restoreData = function () {\n        this.dataTask.dirty();\n      };\n\n      SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {\n        var ecModel = this.ecModel;\n        var color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);\n\n        if (!color) {\n          color = ecModel.getColorFromPalette(name, scope, requestColorNum);\n        }\n\n        return color;\n      };\n\n      SeriesModel.prototype.coordDimToDataDim = function (coordDim) {\n        return this.getRawData().mapDimensionsAll(coordDim);\n      };\n\n      SeriesModel.prototype.getProgressive = function () {\n        return this.get('progressive');\n      };\n\n      SeriesModel.prototype.getProgressiveThreshold = function () {\n        return this.get('progressiveThreshold');\n      };\n\n      SeriesModel.prototype.select = function (innerDataIndices, dataType) {\n        this._innerSelect(this.getData(dataType), innerDataIndices);\n      };\n\n      SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {\n        var selectedMap = this.option.selectedMap;\n\n        if (!selectedMap) {\n          return;\n        }\n\n        var data = this.getData(dataType);\n\n        for (var i = 0; i < innerDataIndices.length; i++) {\n          var dataIndex = innerDataIndices[i];\n          var nameOrId = getSelectionKey(data, dataIndex);\n          selectedMap[nameOrId] = false;\n          this._selectedDataIndicesMap[nameOrId] = -1;\n        }\n      };\n\n      SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {\n        var tmpArr = [];\n\n        for (var i = 0; i < innerDataIndices.length; i++) {\n          tmpArr[0] = innerDataIndices[i];\n          this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);\n        }\n      };\n\n      SeriesModel.prototype.getSelectedDataIndices = function () {\n        var selectedDataIndicesMap = this._selectedDataIndicesMap;\n        var nameOrIds = keys(selectedDataIndicesMap);\n        var dataIndices = [];\n\n        for (var i = 0; i < nameOrIds.length; i++) {\n          var dataIndex = selectedDataIndicesMap[nameOrIds[i]];\n\n          if (dataIndex >= 0) {\n            dataIndices.push(dataIndex);\n          }\n        }\n\n        return dataIndices;\n      };\n\n      SeriesModel.prototype.isSelected = function (dataIndex, dataType) {\n        var selectedMap = this.option.selectedMap;\n\n        if (!selectedMap) {\n          return false;\n        }\n\n        var data = this.getData(dataType);\n        var nameOrId = getSelectionKey(data, dataIndex);\n        return selectedMap[nameOrId] || false;\n      };\n\n      SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {\n        var _a, _b;\n\n        var selectedMode = this.option.selectedMode;\n        var len = innerDataIndices.length;\n\n        if (!selectedMode || !len) {\n          return;\n        }\n\n        if (selectedMode === 'multiple') {\n          var selectedMap = this.option.selectedMap || (this.option.selectedMap = {});\n\n          for (var i = 0; i < len; i++) {\n            var dataIndex = innerDataIndices[i];\n            var nameOrId = getSelectionKey(data, dataIndex);\n            selectedMap[nameOrId] = true;\n            this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);\n          }\n        } else if (selectedMode === 'single' || selectedMode === true) {\n          var lastDataIndex = innerDataIndices[len - 1];\n          var nameOrId = getSelectionKey(data, lastDataIndex);\n          this.option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);\n          this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);\n        }\n      };\n\n      SeriesModel.prototype._initSelectedMapFromData = function (data) {\n        if (this.option.selectedMap) {\n          return;\n        }\n\n        var dataIndices = [];\n\n        if (data.hasItemOption) {\n          data.each(function (idx) {\n            var rawItem = data.getRawDataItem(idx);\n\n            if (typeof rawItem === 'object' && rawItem.selected) {\n              dataIndices.push(idx);\n            }\n          });\n        }\n\n        if (dataIndices.length > 0) {\n          this._innerSelect(data, dataIndices);\n        }\n      };\n\n      SeriesModel.registerClass = function (clz) {\n        return ComponentModel.registerClass(clz);\n      };\n\n      SeriesModel.protoInitialize = function () {\n        var proto = SeriesModel.prototype;\n        proto.type = 'series.__base__';\n        proto.seriesIndex = 0;\n        proto.useColorPaletteOnData = false;\n        proto.ignoreStyleOnData = false;\n        proto.hasSymbolVisual = false;\n        proto.defaultSymbol = 'circle';\n        proto.visualStyleAccessPath = 'itemStyle';\n        proto.visualDrawType = 'fill';\n      }();\n\n      return SeriesModel;\n    }(ComponentModel);\n\n    mixin(SeriesModel, DataFormatMixin);\n    mixin(SeriesModel, PaletteMixin);\n    mountExtend(SeriesModel, ComponentModel);\n\n    function autoSeriesName(seriesModel) {\n      var name = seriesModel.name;\n\n      if (!isNameSpecified(seriesModel)) {\n        seriesModel.name = getSeriesAutoName(seriesModel) || name;\n      }\n    }\n\n    function getSeriesAutoName(seriesModel) {\n      var data = seriesModel.getRawData();\n      var dataDims = data.mapDimensionsAll('seriesName');\n      var nameArr = [];\n      each(dataDims, function (dataDim) {\n        var dimInfo = data.getDimensionInfo(dataDim);\n        dimInfo.displayName && nameArr.push(dimInfo.displayName);\n      });\n      return nameArr.join(' ');\n    }\n\n    function dataTaskCount(context) {\n      return context.model.getRawData().count();\n    }\n\n    function dataTaskReset(context) {\n      var seriesModel = context.model;\n      seriesModel.setData(seriesModel.getRawData().cloneShallow());\n      return dataTaskProgress;\n    }\n\n    function dataTaskProgress(param, context) {\n      if (context.outputData && param.end > context.outputData.count()) {\n        context.model.getRawData().cloneShallow(context.outputData);\n      }\n    }\n\n    function wrapData(data, seriesModel) {\n      each(__spreadArrays(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {\n        data.wrapMethod(methodName, curry(onDataChange, seriesModel));\n      });\n    }\n\n    function onDataChange(seriesModel, newList) {\n      var task = getCurrentTask(seriesModel);\n\n      if (task) {\n        task.setOutputEnd((newList || this).count());\n      }\n\n      return newList;\n    }\n\n    function getCurrentTask(seriesModel) {\n      var scheduler = (seriesModel.ecModel || {}).scheduler;\n      var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);\n\n      if (pipeline) {\n        var task = pipeline.currentTask;\n\n        if (task) {\n          var agentStubMap = task.agentStubMap;\n\n          if (agentStubMap) {\n            task = agentStubMap.get(seriesModel.uid);\n          }\n        }\n\n        return task;\n      }\n    }\n\n    var ComponentView = function () {\n      function ComponentView() {\n        this.group = new Group();\n        this.uid = getUID('viewComponent');\n      }\n\n      ComponentView.prototype.init = function (ecModel, api) {};\n\n      ComponentView.prototype.render = function (model, ecModel, api, payload) {};\n\n      ComponentView.prototype.dispose = function (ecModel, api) {};\n\n      ComponentView.prototype.updateView = function (model, ecModel, api, payload) {};\n\n      ComponentView.prototype.updateLayout = function (model, ecModel, api, payload) {};\n\n      ComponentView.prototype.updateVisual = function (model, ecModel, api, payload) {};\n\n      ComponentView.prototype.blurSeries = function (seriesModels, ecModel) {};\n\n      return ComponentView;\n    }();\n    enableClassExtend(ComponentView);\n    enableClassManagement(ComponentView);\n\n    function createRenderPlanner() {\n      var inner = makeInner();\n      return function (seriesModel) {\n        var fields = inner(seriesModel);\n        var pipelineContext = seriesModel.pipelineContext;\n        var originalLarge = !!fields.large;\n        var originalProgressive = !!fields.progressiveRender;\n        var large = fields.large = !!(pipelineContext && pipelineContext.large);\n        var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);\n        return !!(originalLarge !== large || originalProgressive !== progressive) && 'reset';\n      };\n    }\n\n    var inner$2 = makeInner();\n    var renderPlanner = createRenderPlanner();\n\n    var ChartView = function () {\n      function ChartView() {\n        this.group = new Group();\n        this.uid = getUID('viewChart');\n        this.renderTask = createTask({\n          plan: renderTaskPlan,\n          reset: renderTaskReset\n        });\n        this.renderTask.context = {\n          view: this\n        };\n      }\n\n      ChartView.prototype.init = function (ecModel, api) {};\n\n      ChartView.prototype.render = function (seriesModel, ecModel, api, payload) {};\n\n      ChartView.prototype.highlight = function (seriesModel, ecModel, api, payload) {\n        toggleHighlight(seriesModel.getData(), payload, 'emphasis');\n      };\n\n      ChartView.prototype.downplay = function (seriesModel, ecModel, api, payload) {\n        toggleHighlight(seriesModel.getData(), payload, 'normal');\n      };\n\n      ChartView.prototype.remove = function (ecModel, api) {\n        this.group.removeAll();\n      };\n\n      ChartView.prototype.dispose = function (ecModel, api) {};\n\n      ChartView.prototype.updateView = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n      };\n\n      ChartView.prototype.updateLayout = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n      };\n\n      ChartView.prototype.updateVisual = function (seriesModel, ecModel, api, payload) {\n        this.render(seriesModel, ecModel, api, payload);\n      };\n\n      ChartView.markUpdateMethod = function (payload, methodName) {\n        inner$2(payload).updateMethod = methodName;\n      };\n\n      ChartView.protoInitialize = function () {\n        var proto = ChartView.prototype;\n        proto.type = 'chart';\n      }();\n\n      return ChartView;\n    }();\n\n    function elSetState(el, state, highlightDigit) {\n      if (el) {\n        (state === 'emphasis' ? enterEmphasis : leaveEmphasis)(el, highlightDigit);\n      }\n    }\n\n    function toggleHighlight(data, payload, state) {\n      var dataIndex = queryDataIndex(data, payload);\n      var highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;\n\n      if (dataIndex != null) {\n        each(normalizeToArray(dataIndex), function (dataIdx) {\n          elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);\n        });\n      } else {\n        data.eachItemGraphicEl(function (el) {\n          elSetState(el, state, highlightDigit);\n        });\n      }\n    }\n\n    enableClassExtend(ChartView, ['dispose']);\n    enableClassManagement(ChartView);\n\n    function renderTaskPlan(context) {\n      return renderPlanner(context.model);\n    }\n\n    function renderTaskReset(context) {\n      var seriesModel = context.model;\n      var ecModel = context.ecModel;\n      var api = context.api;\n      var payload = context.payload;\n      var progressiveRender = seriesModel.pipelineContext.progressiveRender;\n      var view = context.view;\n      var updateMethod = payload && inner$2(payload).updateMethod;\n      var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod : 'render';\n\n      if (methodName !== 'render') {\n        view[methodName](seriesModel, ecModel, api, payload);\n      }\n\n      return progressMethodMap[methodName];\n    }\n\n    var progressMethodMap = {\n      incrementalPrepareRender: {\n        progress: function (params, context) {\n          context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);\n        }\n      },\n      render: {\n        forceFirstProgress: true,\n        progress: function (params, context) {\n          context.view.render(context.model, context.ecModel, context.api, context.payload);\n        }\n      }\n    };\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var ORIGIN_METHOD = '\\0__throttleOriginMethod';\n    var RATE = '\\0__throttleRate';\n    var THROTTLE_TYPE = '\\0__throttleType';\n    function throttle(fn, delay, debounce) {\n      var currCall;\n      var lastCall = 0;\n      var lastExec = 0;\n      var timer = null;\n      var diff;\n      var scope;\n      var args;\n      var debounceNextCall;\n      delay = delay || 0;\n\n      function exec() {\n        lastExec = new Date().getTime();\n        timer = null;\n        fn.apply(scope, args || []);\n      }\n\n      var cb = function () {\n        var cbArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          cbArgs[_i] = arguments[_i];\n        }\n\n        currCall = new Date().getTime();\n        scope = this;\n        args = cbArgs;\n        var thisDelay = debounceNextCall || delay;\n        var thisDebounce = debounceNextCall || debounce;\n        debounceNextCall = null;\n        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;\n        clearTimeout(timer);\n\n        if (thisDebounce) {\n          timer = setTimeout(exec, thisDelay);\n        } else {\n          if (diff >= 0) {\n            exec();\n          } else {\n            timer = setTimeout(exec, -diff);\n          }\n        }\n\n        lastCall = currCall;\n      };\n\n      cb.clear = function () {\n        if (timer) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n\n      cb.debounceNextCall = function (debounceDelay) {\n        debounceNextCall = debounceDelay;\n      };\n\n      return cb;\n    }\n    function createOrUpdate(obj, fnAttr, rate, throttleType) {\n      var fn = obj[fnAttr];\n\n      if (!fn) {\n        return;\n      }\n\n      var originFn = fn[ORIGIN_METHOD] || fn;\n      var lastThrottleType = fn[THROTTLE_TYPE];\n      var lastRate = fn[RATE];\n\n      if (lastRate !== rate || lastThrottleType !== throttleType) {\n        if (rate == null || !throttleType) {\n          return obj[fnAttr] = originFn;\n        }\n\n        fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');\n        fn[ORIGIN_METHOD] = originFn;\n        fn[THROTTLE_TYPE] = throttleType;\n        fn[RATE] = rate;\n      }\n\n      return fn;\n    }\n    function clear(obj, fnAttr) {\n      var fn = obj[fnAttr];\n\n      if (fn && fn[ORIGIN_METHOD]) {\n        obj[fnAttr] = fn[ORIGIN_METHOD];\n      }\n    }\n\n    var inner$3 = makeInner();\n    var defaultStyleMappers = {\n      itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),\n      lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)\n    };\n    var defaultColorKey = {\n      lineStyle: 'stroke',\n      itemStyle: 'fill'\n    };\n\n    function getStyleMapper(seriesModel, stylePath) {\n      var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];\n\n      if (!styleMapper) {\n        console.warn(\"Unkown style type '\" + stylePath + \"'.\");\n        return defaultStyleMappers.itemStyle;\n      }\n\n      return styleMapper;\n    }\n\n    function getDefaultColorKey(seriesModel, stylePath) {\n      var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];\n\n      if (!colorKey) {\n        console.warn(\"Unkown style type '\" + stylePath + \"'.\");\n        return 'fill';\n      }\n\n      return colorKey;\n    }\n\n    var seriesStyleTask = {\n      createOnAllSeries: true,\n      performRawSeries: true,\n      reset: function (seriesModel, ecModel) {\n        var data = seriesModel.getData();\n        var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';\n        var styleModel = seriesModel.getModel(stylePath);\n        var getStyle = getStyleMapper(seriesModel, stylePath);\n        var globalStyle = getStyle(styleModel);\n        var decalOption = styleModel.getShallow('decal');\n\n        if (decalOption) {\n          data.setVisual('decal', decalOption);\n          decalOption.dirty = true;\n        }\n\n        var colorKey = getDefaultColorKey(seriesModel, stylePath);\n        var color = globalStyle[colorKey];\n        var colorCallback = isFunction(color) ? color : null;\n\n        if (!globalStyle[colorKey] || colorCallback) {\n          globalStyle[colorKey] = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());\n          data.setVisual('colorFromPalette', true);\n        }\n\n        data.setVisual('style', globalStyle);\n        data.setVisual('drawType', colorKey);\n\n        if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {\n          data.setVisual('colorFromPalette', false);\n          return {\n            dataEach: function (data, idx) {\n              var dataParams = seriesModel.getDataParams(idx);\n              var itemStyle = extend({}, globalStyle);\n              itemStyle[colorKey] = colorCallback(dataParams);\n              data.setItemVisual(idx, 'style', itemStyle);\n            }\n          };\n        }\n      }\n    };\n    var sharedModel = new Model();\n    var dataStyleTask = {\n      createOnAllSeries: true,\n      performRawSeries: true,\n      reset: function (seriesModel, ecModel) {\n        if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {\n          return;\n        }\n\n        var data = seriesModel.getData();\n        var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';\n        var getStyle = getStyleMapper(seriesModel, stylePath);\n        var colorKey = data.getVisual('drawType');\n        return {\n          dataEach: data.hasItemOption ? function (data, idx) {\n            var rawItem = data.getRawDataItem(idx);\n\n            if (rawItem && rawItem[stylePath]) {\n              sharedModel.option = rawItem[stylePath];\n              var style = getStyle(sharedModel);\n              var existsStyle = data.ensureUniqueItemVisual(idx, 'style');\n              extend(existsStyle, style);\n\n              if (sharedModel.option.decal) {\n                data.setItemVisual(idx, 'decal', sharedModel.option.decal);\n                sharedModel.option.decal.dirty = true;\n              }\n\n              if (colorKey in style) {\n                data.setItemVisual(idx, 'colorFromPalette', false);\n              }\n            }\n          } : null\n        };\n      }\n    };\n    var dataColorPaletteTask = {\n      performRawSeries: true,\n      overallReset: function (ecModel) {\n        var paletteScopeGroupByType = createHashMap();\n        ecModel.eachSeries(function (seriesModel) {\n          if (!seriesModel.useColorPaletteOnData) {\n            return;\n          }\n\n          var colorScope = paletteScopeGroupByType.get(seriesModel.type);\n\n          if (!colorScope) {\n            colorScope = {};\n            paletteScopeGroupByType.set(seriesModel.type, colorScope);\n          }\n\n          inner$3(seriesModel).scope = colorScope;\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          if (!seriesModel.useColorPaletteOnData || ecModel.isSeriesFiltered(seriesModel)) {\n            return;\n          }\n\n          var dataAll = seriesModel.getRawData();\n          var idxMap = {};\n          var data = seriesModel.getData();\n          var colorScope = inner$3(seriesModel).scope;\n          var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';\n          var colorKey = getDefaultColorKey(seriesModel, stylePath);\n          data.each(function (idx) {\n            var rawIdx = data.getRawIndex(idx);\n            idxMap[rawIdx] = idx;\n          });\n          dataAll.each(function (rawIdx) {\n            var idx = idxMap[rawIdx];\n            var fromPalette = data.getItemVisual(idx, 'colorFromPalette');\n\n            if (fromPalette) {\n              var itemStyle = data.ensureUniqueItemVisual(idx, 'style');\n              var name_1 = dataAll.getName(rawIdx) || rawIdx + '';\n              var dataCount = dataAll.count();\n              itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);\n            }\n          });\n        });\n      }\n    };\n\n    var PI$3 = Math.PI;\n    function defaultLoading(api, opts) {\n      opts = opts || {};\n      defaults(opts, {\n        text: 'loading',\n        textColor: '#000',\n        fontSize: 12,\n        fontWeight: 'normal',\n        fontStyle: 'normal',\n        fontFamily: 'sans-serif',\n        maskColor: 'rgba(255, 255, 255, 0.8)',\n        showSpinner: true,\n        color: '#5470c6',\n        spinnerRadius: 10,\n        lineWidth: 5,\n        zlevel: 0\n      });\n      var group = new Group();\n      var mask = new Rect({\n        style: {\n          fill: opts.maskColor\n        },\n        zlevel: opts.zlevel,\n        z: 10000\n      });\n      group.add(mask);\n      var textContent = new ZRText({\n        style: {\n          text: opts.text,\n          fill: opts.textColor,\n          fontSize: opts.fontSize,\n          fontWeight: opts.fontWeight,\n          fontStyle: opts.fontStyle,\n          fontFamily: opts.fontFamily\n        }\n      });\n      var labelRect = new Rect({\n        style: {\n          fill: 'none'\n        },\n        textContent: textContent,\n        textConfig: {\n          position: 'right',\n          distance: 10\n        },\n        zlevel: opts.zlevel,\n        z: 10001\n      });\n      group.add(labelRect);\n      var arc;\n\n      if (opts.showSpinner) {\n        arc = new Arc({\n          shape: {\n            startAngle: -PI$3 / 2,\n            endAngle: -PI$3 / 2 + 0.1,\n            r: opts.spinnerRadius\n          },\n          style: {\n            stroke: opts.color,\n            lineCap: 'round',\n            lineWidth: opts.lineWidth\n          },\n          zlevel: opts.zlevel,\n          z: 10001\n        });\n        arc.animateShape(true).when(1000, {\n          endAngle: PI$3 * 3 / 2\n        }).start('circularInOut');\n        arc.animateShape(true).when(1000, {\n          startAngle: PI$3 * 3 / 2\n        }).delay(300).start('circularInOut');\n        group.add(arc);\n      }\n\n      group.resize = function () {\n        var textWidth = textContent.getBoundingRect().width;\n        var r = opts.showSpinner ? opts.spinnerRadius : 0;\n        var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);\n        var cy = api.getHeight() / 2;\n        opts.showSpinner && arc.setShape({\n          cx: cx,\n          cy: cy\n        });\n        labelRect.setShape({\n          x: cx - r,\n          y: cy - r,\n          width: r * 2,\n          height: r * 2\n        });\n        mask.setShape({\n          x: 0,\n          y: 0,\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n      };\n\n      group.resize();\n      return group;\n    }\n\n    var Scheduler = function () {\n      function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n        this._stageTaskMap = createHashMap();\n        this.ecInstance = ecInstance;\n        this.api = api;\n        dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n        visualHandlers = this._visualHandlers = visualHandlers.slice();\n        this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n      }\n\n      Scheduler.prototype.restoreData = function (ecModel, payload) {\n        ecModel.restoreData(payload);\n\n        this._stageTaskMap.each(function (taskRecord) {\n          var overallTask = taskRecord.overallTask;\n          overallTask && overallTask.dirty();\n        });\n      };\n\n      Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n        if (!task.__pipeline) {\n          return;\n        }\n\n        var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n        var pCtx = pipeline.context;\n        var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n        var step = incremental ? pipeline.step : null;\n        var modDataCount = pCtx && pCtx.modDataCount;\n        var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n        return {\n          step: step,\n          modBy: modBy,\n          modDataCount: modDataCount\n        };\n      };\n\n      Scheduler.prototype.getPipeline = function (pipelineId) {\n        return this._pipelineMap.get(pipelineId);\n      };\n\n      Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n        var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n        var data = seriesModel.getData();\n        var dataLen = data.count();\n        var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n        var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n        var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n        seriesModel.pipelineContext = pipeline.context = {\n          progressiveRender: progressiveRender,\n          modDataCount: modDataCount,\n          large: large\n        };\n      };\n\n      Scheduler.prototype.restorePipelines = function (ecModel) {\n        var scheduler = this;\n        var pipelineMap = scheduler._pipelineMap = createHashMap();\n        ecModel.eachSeries(function (seriesModel) {\n          var progressive = seriesModel.getProgressive();\n          var pipelineId = seriesModel.uid;\n          pipelineMap.set(pipelineId, {\n            id: pipelineId,\n            head: null,\n            tail: null,\n            threshold: seriesModel.getProgressiveThreshold(),\n            progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n            blockIndex: -1,\n            step: Math.round(progressive || 700),\n            count: 0\n          });\n\n          scheduler._pipe(seriesModel, seriesModel.dataTask);\n        });\n      };\n\n      Scheduler.prototype.prepareStageTasks = function () {\n        var stageTaskMap = this._stageTaskMap;\n        var ecModel = this.api.getModel();\n        var api = this.api;\n        each(this._allHandlers, function (handler) {\n          var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n          }\n\n          assert(!(handler.reset && handler.overallReset), errMsg);\n          handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n          handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n        }, this);\n      };\n\n      Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n        var renderTask = view.renderTask;\n        var context = renderTask.context;\n        context.model = model;\n        context.ecModel = ecModel;\n        context.api = api;\n        renderTask.__block = !view.incrementalPrepareRender;\n\n        this._pipe(model, renderTask);\n      };\n\n      Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n        this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n          block: true\n        });\n      };\n\n      Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n        this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n      };\n\n      Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n        opt = opt || {};\n        var unfinished = false;\n        var scheduler = this;\n        each(stageHandlers, function (stageHandler, idx) {\n          if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n            return;\n          }\n\n          var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n          var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n          var overallTask = stageHandlerRecord.overallTask;\n\n          if (overallTask) {\n            var overallNeedDirty_1;\n            var agentStubMap = overallTask.agentStubMap;\n            agentStubMap.each(function (stub) {\n              if (needSetDirty(opt, stub)) {\n                stub.dirty();\n                overallNeedDirty_1 = true;\n              }\n            });\n            overallNeedDirty_1 && overallTask.dirty();\n            scheduler.updatePayload(overallTask, payload);\n            var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n            agentStubMap.each(function (stub) {\n              stub.perform(performArgs_1);\n            });\n\n            if (overallTask.perform(performArgs_1)) {\n              unfinished = true;\n            }\n          } else if (seriesTaskMap) {\n            seriesTaskMap.each(function (task, pipelineId) {\n              if (needSetDirty(opt, task)) {\n                task.dirty();\n              }\n\n              var performArgs = scheduler.getPerformArgs(task, opt.block);\n              performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n              scheduler.updatePayload(task, payload);\n\n              if (task.perform(performArgs)) {\n                unfinished = true;\n              }\n            });\n          }\n        });\n\n        function needSetDirty(opt, task) {\n          return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n        }\n\n        this.unfinished = unfinished || this.unfinished;\n      };\n\n      Scheduler.prototype.performSeriesTasks = function (ecModel) {\n        var unfinished;\n        ecModel.eachSeries(function (seriesModel) {\n          unfinished = seriesModel.dataTask.perform() || unfinished;\n        });\n        this.unfinished = unfinished || this.unfinished;\n      };\n\n      Scheduler.prototype.plan = function () {\n        this._pipelineMap.each(function (pipeline) {\n          var task = pipeline.tail;\n\n          do {\n            if (task.__block) {\n              pipeline.blockIndex = task.__idxInPipeline;\n              break;\n            }\n\n            task = task.getUpstream();\n          } while (task);\n        });\n      };\n\n      Scheduler.prototype.updatePayload = function (task, payload) {\n        payload !== 'remain' && (task.context.payload = payload);\n      };\n\n      Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n        var scheduler = this;\n        var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n        var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();\n        var seriesType = stageHandler.seriesType;\n        var getTargetSeries = stageHandler.getTargetSeries;\n\n        if (stageHandler.createOnAllSeries) {\n          ecModel.eachRawSeries(create);\n        } else if (seriesType) {\n          ecModel.eachRawSeriesByType(seriesType, create);\n        } else if (getTargetSeries) {\n          getTargetSeries(ecModel, api).each(create);\n        }\n\n        function create(seriesModel) {\n          var pipelineId = seriesModel.uid;\n          var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({\n            plan: seriesTaskPlan,\n            reset: seriesTaskReset,\n            count: seriesTaskCount\n          }));\n          task.context = {\n            model: seriesModel,\n            ecModel: ecModel,\n            api: api,\n            useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n            plan: stageHandler.plan,\n            reset: stageHandler.reset,\n            scheduler: scheduler\n          };\n\n          scheduler._pipe(seriesModel, task);\n        }\n      };\n\n      Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n        var scheduler = this;\n        var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({\n          reset: overallTaskReset\n        });\n        overallTask.context = {\n          ecModel: ecModel,\n          api: api,\n          overallReset: stageHandler.overallReset,\n          scheduler: scheduler\n        };\n        var oldAgentStubMap = overallTask.agentStubMap;\n        var newAgentStubMap = overallTask.agentStubMap = createHashMap();\n        var seriesType = stageHandler.seriesType;\n        var getTargetSeries = stageHandler.getTargetSeries;\n        var overallProgress = true;\n        var shouldOverallTaskDirty = false;\n        var errMsg = '';\n\n        if (\"development\" !== 'production') {\n          errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n        }\n\n        assert(!stageHandler.createOnAllSeries, errMsg);\n\n        if (seriesType) {\n          ecModel.eachRawSeriesByType(seriesType, createStub);\n        } else if (getTargetSeries) {\n          getTargetSeries(ecModel, api).each(createStub);\n        } else {\n          overallProgress = false;\n          each(ecModel.getSeries(), createStub);\n        }\n\n        function createStub(seriesModel) {\n          var pipelineId = seriesModel.uid;\n          var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({\n            reset: stubReset,\n            onDirty: stubOnDirty\n          })));\n          stub.context = {\n            model: seriesModel,\n            overallProgress: overallProgress\n          };\n          stub.agent = overallTask;\n          stub.__block = overallProgress;\n\n          scheduler._pipe(seriesModel, stub);\n        }\n\n        if (shouldOverallTaskDirty) {\n          overallTask.dirty();\n        }\n      };\n\n      Scheduler.prototype._pipe = function (seriesModel, task) {\n        var pipelineId = seriesModel.uid;\n\n        var pipeline = this._pipelineMap.get(pipelineId);\n\n        !pipeline.head && (pipeline.head = task);\n        pipeline.tail && pipeline.tail.pipe(task);\n        pipeline.tail = task;\n        task.__idxInPipeline = pipeline.count++;\n        task.__pipeline = pipeline;\n      };\n\n      Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n        if (isFunction(stageHandler)) {\n          stageHandler = {\n            overallReset: stageHandler,\n            seriesType: detectSeriseType(stageHandler)\n          };\n        }\n\n        stageHandler.uid = getUID('stageHandler');\n        visualType && (stageHandler.visualType = visualType);\n        return stageHandler;\n      };\n      return Scheduler;\n    }();\n\n    function overallTaskReset(context) {\n      context.overallReset(context.ecModel, context.api, context.payload);\n    }\n\n    function stubReset(context) {\n      return context.overallProgress && stubProgress;\n    }\n\n    function stubProgress() {\n      this.agent.dirty();\n      this.getDownstream().dirty();\n    }\n\n    function stubOnDirty() {\n      this.agent && this.agent.dirty();\n    }\n\n    function seriesTaskPlan(context) {\n      return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n    }\n\n    function seriesTaskReset(context) {\n      if (context.useClearVisual) {\n        context.data.clearAllVisual();\n      }\n\n      var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n      return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n        return makeSeriesTaskProgress(idx);\n      }) : singleSeriesTaskProgress;\n    }\n\n    var singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\n    function makeSeriesTaskProgress(resetDefineIdx) {\n      return function (params, context) {\n        var data = context.data;\n        var resetDefine = context.resetDefines[resetDefineIdx];\n\n        if (resetDefine && resetDefine.dataEach) {\n          for (var i = params.start; i < params.end; i++) {\n            resetDefine.dataEach(data, i);\n          }\n        } else if (resetDefine && resetDefine.progress) {\n          resetDefine.progress(params, data);\n        }\n      };\n    }\n\n    function seriesTaskCount(context) {\n      return context.data.count();\n    }\n\n    function detectSeriseType(legacyFunc) {\n      seriesType = null;\n\n      try {\n        legacyFunc(ecModelMock, apiMock);\n      } catch (e) {}\n\n      return seriesType;\n    }\n\n    var ecModelMock = {};\n    var apiMock = {};\n    var seriesType;\n    mockMethods(ecModelMock, GlobalModel);\n    mockMethods(apiMock, ExtensionAPI);\n\n    ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n      seriesType = type;\n    };\n\n    ecModelMock.eachComponent = function (cond) {\n      if (cond.mainType === 'series' && cond.subType) {\n        seriesType = cond.subType;\n      }\n    };\n\n    function mockMethods(target, Clz) {\n      for (var name_1 in Clz.prototype) {\n        target[name_1] = noop;\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];\n    var lightTheme = {\n      color: colorAll,\n      colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]\n    };\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var contrastColor = '#B9B8CE';\n    var backgroundColor = '#100C2A';\n\n    var axisCommon = function () {\n      return {\n        axisLine: {\n          lineStyle: {\n            color: contrastColor\n          }\n        },\n        splitLine: {\n          lineStyle: {\n            color: '#484753'\n          }\n        },\n        splitArea: {\n          areaStyle: {\n            color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']\n          }\n        },\n        minorSplitLine: {\n          lineStyle: {\n            color: '#20203B'\n          }\n        }\n      };\n    };\n\n    var colorPalette = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff'];\n    var theme = {\n      darkMode: true,\n      color: colorPalette,\n      backgroundColor: backgroundColor,\n      axisPointer: {\n        lineStyle: {\n          color: '#817f91'\n        },\n        crossStyle: {\n          color: '#817f91'\n        },\n        label: {\n          color: '#fff'\n        }\n      },\n      legend: {\n        textStyle: {\n          color: contrastColor\n        }\n      },\n      textStyle: {\n        color: contrastColor\n      },\n      title: {\n        textStyle: {\n          color: '#EEF1FA'\n        },\n        subtextStyle: {\n          color: '#B9B8CE'\n        }\n      },\n      toolbox: {\n        iconStyle: {\n          borderColor: contrastColor\n        }\n      },\n      dataZoom: {\n        borderColor: '#71708A',\n        textStyle: {\n          color: contrastColor\n        },\n        brushStyle: {\n          color: 'rgba(135,163,206,0.3)'\n        },\n        handleStyle: {\n          color: '#353450',\n          borderColor: '#C5CBE3'\n        },\n        moveHandleStyle: {\n          color: '#B0B6C3',\n          opacity: 0.3\n        },\n        fillerColor: 'rgba(135,163,206,0.2)',\n        emphasis: {\n          handleStyle: {\n            borderColor: '#91B7F2',\n            color: '#4D587D'\n          },\n          moveHandleStyle: {\n            color: '#636D9A',\n            opacity: 0.7\n          }\n        },\n        dataBackground: {\n          lineStyle: {\n            color: '#71708A',\n            width: 1\n          },\n          areaStyle: {\n            color: '#71708A'\n          }\n        },\n        selectedDataBackground: {\n          lineStyle: {\n            color: '#87A3CE'\n          },\n          areaStyle: {\n            color: '#87A3CE'\n          }\n        }\n      },\n      visualMap: {\n        textStyle: {\n          color: contrastColor\n        }\n      },\n      timeline: {\n        lineStyle: {\n          color: contrastColor\n        },\n        label: {\n          color: contrastColor\n        },\n        controlStyle: {\n          color: contrastColor,\n          borderColor: contrastColor\n        }\n      },\n      calendar: {\n        itemStyle: {\n          color: backgroundColor\n        },\n        dayLabel: {\n          color: contrastColor\n        },\n        monthLabel: {\n          color: contrastColor\n        },\n        yearLabel: {\n          color: contrastColor\n        }\n      },\n      timeAxis: axisCommon(),\n      logAxis: axisCommon(),\n      valueAxis: axisCommon(),\n      categoryAxis: axisCommon(),\n      line: {\n        symbol: 'circle'\n      },\n      graph: {\n        color: colorPalette\n      },\n      gauge: {\n        title: {\n          color: contrastColor\n        },\n        axisLine: {\n          lineStyle: {\n            color: [[1, 'rgba(207,212,219,0.2)']]\n          }\n        },\n        axisLabel: {\n          color: contrastColor\n        },\n        detail: {\n          color: '#EEF1FA'\n        }\n      },\n      candlestick: {\n        itemStyle: {\n          color: '#f64e56',\n          color0: '#54ea92',\n          borderColor: '#f64e56',\n          borderColor0: '#54ea92'\n        }\n      }\n    };\n    theme.categoryAxis.splitLine.show = false;\n\n    function parseXML(svg) {\n        if (isString(svg)) {\n            var parser = new DOMParser();\n            svg = parser.parseFromString(svg, 'text/xml');\n        }\n        var svgNode = svg;\n        if (svgNode.nodeType === 9) {\n            svgNode = svgNode.firstChild;\n        }\n        while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n            svgNode = svgNode.nextSibling;\n        }\n        return svgNode;\n    }\n\n    var storage = createHashMap();\n    var mapDataStorage = {\n      registerMap: function (mapName, rawDef, rawSpecialAreas) {\n        var records;\n\n        if (isArray(rawDef)) {\n          records = rawDef;\n        } else if (rawDef.svg) {\n          records = [{\n            type: 'svg',\n            source: rawDef.svg,\n            specialAreas: rawDef.specialAreas\n          }];\n        } else {\n          var geoSource = rawDef.geoJson || rawDef.geoJSON;\n\n          if (geoSource && !rawDef.features) {\n            rawSpecialAreas = rawDef.specialAreas;\n            rawDef = geoSource;\n          }\n\n          records = [{\n            type: 'geoJSON',\n            source: rawDef,\n            specialAreas: rawSpecialAreas\n          }];\n        }\n\n        each(records, function (record) {\n          var type = record.type;\n          type === 'geoJson' && (type = record.type = 'geoJSON');\n          var parse = parsers[type];\n\n          if (\"development\" !== 'production') {\n            assert(parse, 'Illegal map type: ' + type);\n          }\n\n          parse(record);\n        });\n        return storage.set(mapName, records);\n      },\n      retrieveMap: function (mapName) {\n        return storage.get(mapName);\n      }\n    };\n    var parsers = {\n      geoJSON: function (record) {\n        var source = record.source;\n        record.geoJSON = !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n      },\n      svg: function (record) {\n        record.svgXML = parseXML(record.source);\n      }\n    };\n\n    var ECEventProcessor = function () {\n      function ECEventProcessor() {}\n\n      ECEventProcessor.prototype.normalizeQuery = function (query) {\n        var cptQuery = {};\n        var dataQuery = {};\n        var otherQuery = {};\n\n        if (isString(query)) {\n          var condCptType = parseClassType(query);\n          cptQuery.mainType = condCptType.main || null;\n          cptQuery.subType = condCptType.sub || null;\n        } else {\n          var suffixes_1 = ['Index', 'Name', 'Id'];\n          var dataKeys_1 = {\n            name: 1,\n            dataIndex: 1,\n            dataType: 1\n          };\n          each(query, function (val, key) {\n            var reserved = false;\n\n            for (var i = 0; i < suffixes_1.length; i++) {\n              var propSuffix = suffixes_1[i];\n              var suffixPos = key.lastIndexOf(propSuffix);\n\n              if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {\n                var mainType = key.slice(0, suffixPos);\n\n                if (mainType !== 'data') {\n                  cptQuery.mainType = mainType;\n                  cptQuery[propSuffix.toLowerCase()] = val;\n                  reserved = true;\n                }\n              }\n            }\n\n            if (dataKeys_1.hasOwnProperty(key)) {\n              dataQuery[key] = val;\n              reserved = true;\n            }\n\n            if (!reserved) {\n              otherQuery[key] = val;\n            }\n          });\n        }\n\n        return {\n          cptQuery: cptQuery,\n          dataQuery: dataQuery,\n          otherQuery: otherQuery\n        };\n      };\n\n      ECEventProcessor.prototype.filter = function (eventType, query) {\n        var eventInfo = this.eventInfo;\n\n        if (!eventInfo) {\n          return true;\n        }\n\n        var targetEl = eventInfo.targetEl;\n        var packedEvent = eventInfo.packedEvent;\n        var model = eventInfo.model;\n        var view = eventInfo.view;\n\n        if (!model || !view) {\n          return true;\n        }\n\n        var cptQuery = query.cptQuery;\n        var dataQuery = query.dataQuery;\n        return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));\n\n        function check(query, host, prop, propOnHost) {\n          return query[prop] == null || host[propOnHost || prop] === query[prop];\n        }\n      };\n\n      ECEventProcessor.prototype.afterTrigger = function () {\n        this.eventInfo = null;\n      };\n\n      return ECEventProcessor;\n    }();\n\n    var seriesSymbolTask = {\n      createOnAllSeries: true,\n      performRawSeries: true,\n      reset: function (seriesModel, ecModel) {\n        var data = seriesModel.getData();\n\n        if (seriesModel.legendSymbol) {\n          data.setVisual('legendSymbol', seriesModel.legendSymbol);\n        }\n\n        if (!seriesModel.hasSymbolVisual) {\n          return;\n        }\n\n        var symbolType = seriesModel.get('symbol');\n        var symbolSize = seriesModel.get('symbolSize');\n        var keepAspect = seriesModel.get('symbolKeepAspect');\n        var symbolRotate = seriesModel.get('symbolRotate');\n        var hasSymbolTypeCallback = isFunction(symbolType);\n        var hasSymbolSizeCallback = isFunction(symbolSize);\n        var hasSymbolRotateCallback = isFunction(symbolRotate);\n        var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;\n        var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : seriesModel.defaultSymbol;\n        var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;\n        var seriesSymbolRotate = !hasSymbolRotateCallback ? symbolRotate : null;\n        data.setVisual({\n          legendSymbol: seriesModel.legendSymbol || seriesSymbol,\n          symbol: seriesSymbol,\n          symbolSize: seriesSymbolSize,\n          symbolKeepAspect: keepAspect,\n          symbolRotate: seriesSymbolRotate\n        });\n\n        if (ecModel.isSeriesFiltered(seriesModel)) {\n          return;\n        }\n\n        function dataEach(data, idx) {\n          var rawValue = seriesModel.getRawValue(idx);\n          var params = seriesModel.getDataParams(idx);\n          hasSymbolTypeCallback && data.setItemVisual(idx, 'symbol', symbolType(rawValue, params));\n          hasSymbolSizeCallback && data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n          hasSymbolRotateCallback && data.setItemVisual(idx, 'symbolRotate', symbolRotate(rawValue, params));\n        }\n\n        return {\n          dataEach: hasCallback ? dataEach : null\n        };\n      }\n    };\n    var dataSymbolTask = {\n      createOnAllSeries: true,\n      performRawSeries: true,\n      reset: function (seriesModel, ecModel) {\n        if (!seriesModel.hasSymbolVisual) {\n          return;\n        }\n\n        if (ecModel.isSeriesFiltered(seriesModel)) {\n          return;\n        }\n\n        var data = seriesModel.getData();\n\n        function dataEach(data, idx) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolRotate = itemModel.getShallow('symbolRotate', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true);\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolRotate != null) {\n            data.setItemVisual(idx, 'symbolRotate', itemSymbolRotate);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n\n        return {\n          dataEach: data.hasItemOption ? dataEach : null\n        };\n      }\n    };\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function getItemVisualFromData(data, dataIndex, key) {\n      switch (key) {\n        case 'color':\n          var style = data.getItemVisual(dataIndex, 'style');\n          return style[data.getVisual('drawType')];\n\n        case 'opacity':\n          return data.getItemVisual(dataIndex, 'style').opacity;\n\n        case 'symbol':\n        case 'symbolSize':\n        case 'liftZ':\n          return data.getItemVisual(dataIndex, key);\n\n        default:\n          if (\"development\" !== 'production') {\n            console.warn(\"Unknown visual type \" + key);\n          }\n\n      }\n    }\n    function getVisualFromData(data, key) {\n      switch (key) {\n        case 'color':\n          var style = data.getVisual('style');\n          return style[data.getVisual('drawType')];\n\n        case 'opacity':\n          return data.getVisual('style').opacity;\n\n        case 'symbol':\n        case 'symbolSize':\n        case 'liftZ':\n          return data.getVisual(key);\n\n        default:\n          if (\"development\" !== 'production') {\n            console.warn(\"Unknown visual type \" + key);\n          }\n\n      }\n    }\n    function setItemVisualFromData(data, dataIndex, key, value) {\n      switch (key) {\n        case 'color':\n          var style = data.ensureUniqueItemVisual(dataIndex, 'style');\n          style[data.getVisual('drawType')] = value;\n          data.setItemVisual(dataIndex, 'colorFromPalette', false);\n          break;\n\n        case 'opacity':\n          data.ensureUniqueItemVisual(dataIndex, 'style').opacity = value;\n          break;\n\n        case 'symbol':\n        case 'symbolSize':\n        case 'liftZ':\n          data.setItemVisual(dataIndex, key, value);\n          break;\n\n        default:\n          if (\"development\" !== 'production') {\n            console.warn(\"Unknown visual type \" + key);\n          }\n\n      }\n    }\n\n    var PI2$6 = Math.PI * 2;\n    var CMD$3 = PathProxy.CMD;\n    var DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\n    function getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n      var width = rect.width;\n      var height = rect.height;\n\n      switch (pos) {\n        case 'top':\n          outPt.set(rect.x + width / 2, rect.y - distance);\n          outDir.set(0, -1);\n          break;\n\n        case 'bottom':\n          outPt.set(rect.x + width / 2, rect.y + height + distance);\n          outDir.set(0, 1);\n          break;\n\n        case 'left':\n          outPt.set(rect.x - distance, rect.y + height / 2);\n          outDir.set(-1, 0);\n          break;\n\n        case 'right':\n          outPt.set(rect.x + width + distance, rect.y + height / 2);\n          outDir.set(1, 0);\n          break;\n      }\n    }\n\n    function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n      x -= cx;\n      y -= cy;\n      var d = Math.sqrt(x * x + y * y);\n      x /= d;\n      y /= d;\n      var ox = x * r + cx;\n      var oy = y * r + cy;\n\n      if (Math.abs(startAngle - endAngle) % PI2$6 < 1e-4) {\n        out[0] = ox;\n        out[1] = oy;\n        return d - r;\n      }\n\n      if (anticlockwise) {\n        var tmp = startAngle;\n        startAngle = normalizeRadian(endAngle);\n        endAngle = normalizeRadian(tmp);\n      } else {\n        startAngle = normalizeRadian(startAngle);\n        endAngle = normalizeRadian(endAngle);\n      }\n\n      if (startAngle > endAngle) {\n        endAngle += PI2$6;\n      }\n\n      var angle = Math.atan2(y, x);\n\n      if (angle < 0) {\n        angle += PI2$6;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2$6 >= startAngle && angle + PI2$6 <= endAngle) {\n        out[0] = ox;\n        out[1] = oy;\n        return d - r;\n      }\n\n      var x1 = r * Math.cos(startAngle) + cx;\n      var y1 = r * Math.sin(startAngle) + cy;\n      var x2 = r * Math.cos(endAngle) + cx;\n      var y2 = r * Math.sin(endAngle) + cy;\n      var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n      var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n      if (d1 < d2) {\n        out[0] = x1;\n        out[1] = y1;\n        return Math.sqrt(d1);\n      } else {\n        out[0] = x2;\n        out[1] = y2;\n        return Math.sqrt(d2);\n      }\n    }\n\n    function projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n      var dx = x - x1;\n      var dy = y - y1;\n      var dx1 = x2 - x1;\n      var dy1 = y2 - y1;\n      var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n      dx1 /= lineLen;\n      dy1 /= lineLen;\n      var projectedLen = dx * dx1 + dy * dy1;\n      var t = projectedLen / lineLen;\n\n      if (limitToEnds) {\n        t = Math.min(Math.max(t, 0), 1);\n      }\n\n      t *= lineLen;\n      var ox = out[0] = x1 + t * dx1;\n      var oy = out[1] = y1 + t * dy1;\n      return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n    }\n\n    function projectPointToRect(x1, y1, width, height, x, y, out) {\n      if (width < 0) {\n        x1 = x1 + width;\n        width = -width;\n      }\n\n      if (height < 0) {\n        y1 = y1 + height;\n        height = -height;\n      }\n\n      var x2 = x1 + width;\n      var y2 = y1 + height;\n      var ox = out[0] = Math.min(Math.max(x, x1), x2);\n      var oy = out[1] = Math.min(Math.max(y, y1), y2);\n      return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n    }\n\n    var tmpPt = [];\n\n    function nearestPointOnRect(pt, rect, out) {\n      var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n      out.set(tmpPt[0], tmpPt[1]);\n      return dist;\n    }\n\n    function nearestPointOnPath(pt, path, out) {\n      var xi = 0;\n      var yi = 0;\n      var x0 = 0;\n      var y0 = 0;\n      var x1;\n      var y1;\n      var minDist = Infinity;\n      var data = path.data;\n      var x = pt.x;\n      var y = pt.y;\n\n      for (var i = 0; i < data.length;) {\n        var cmd = data[i++];\n\n        if (i === 1) {\n          xi = data[i];\n          yi = data[i + 1];\n          x0 = xi;\n          y0 = yi;\n        }\n\n        var d = minDist;\n\n        switch (cmd) {\n          case CMD$3.M:\n            x0 = data[i++];\n            y0 = data[i++];\n            xi = x0;\n            yi = y0;\n            break;\n\n          case CMD$3.L:\n            d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n            xi = data[i++];\n            yi = data[i++];\n            break;\n\n          case CMD$3.C:\n            d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n            xi = data[i++];\n            yi = data[i++];\n            break;\n\n          case CMD$3.Q:\n            d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n            xi = data[i++];\n            yi = data[i++];\n            break;\n\n          case CMD$3.A:\n            var cx = data[i++];\n            var cy = data[i++];\n            var rx = data[i++];\n            var ry = data[i++];\n            var theta = data[i++];\n            var dTheta = data[i++];\n            i += 1;\n            var anticlockwise = !!(1 - data[i++]);\n            x1 = Math.cos(theta) * rx + cx;\n            y1 = Math.sin(theta) * ry + cy;\n\n            if (i <= 1) {\n              x0 = x1;\n              y0 = y1;\n            }\n\n            var _x = (x - cx) * ry / rx + cx;\n\n            d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n            xi = Math.cos(theta + dTheta) * rx + cx;\n            yi = Math.sin(theta + dTheta) * ry + cy;\n            break;\n\n          case CMD$3.R:\n            x0 = xi = data[i++];\n            y0 = yi = data[i++];\n            var width = data[i++];\n            var height = data[i++];\n            d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n            break;\n\n          case CMD$3.Z:\n            d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n            xi = x0;\n            yi = y0;\n            break;\n        }\n\n        if (d < minDist) {\n          minDist = d;\n          out.set(tmpPt[0], tmpPt[1]);\n        }\n      }\n\n      return minDist;\n    }\n\n    var pt0 = new Point();\n    var pt1 = new Point();\n    var pt2 = new Point();\n    var dir = new Point();\n    var dir2 = new Point();\n    function updateLabelLinePoints(target, labelLineModel) {\n      if (!target) {\n        return;\n      }\n\n      var labelLine = target.getTextGuideLine();\n      var label = target.getTextContent();\n\n      if (!(label && labelLine)) {\n        return;\n      }\n\n      var labelGuideConfig = target.textGuideLineConfig || {};\n      var points = [[0, 0], [0, 0], [0, 0]];\n      var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n      var labelRect = label.getBoundingRect().clone();\n      labelRect.applyTransform(label.getComputedTransform());\n      var minDist = Infinity;\n      var anchorPoint = labelGuideConfig.anchor;\n      var targetTransform = target.getComputedTransform();\n      var targetInversedTransform = targetTransform && invert([], targetTransform);\n      var len = labelLineModel.get('length2') || 0;\n\n      if (anchorPoint) {\n        pt2.copy(anchorPoint);\n      }\n\n      for (var i = 0; i < searchSpace.length; i++) {\n        var candidate = searchSpace[i];\n        getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n        Point.scaleAndAdd(pt1, pt0, dir, len);\n        pt1.transform(targetInversedTransform);\n        var boundingRect = target.getBoundingRect();\n        var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);\n\n        if (dist < minDist) {\n          minDist = dist;\n          pt1.transform(targetTransform);\n          pt2.transform(targetTransform);\n          pt2.toArray(points[0]);\n          pt1.toArray(points[1]);\n          pt0.toArray(points[2]);\n        }\n      }\n\n      limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n      labelLine.setShape({\n        points: points\n      });\n    }\n    var tmpArr = [];\n    var tmpProjPoint = new Point();\n    function limitTurnAngle(linePoints, minTurnAngle) {\n      if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n        return;\n      }\n\n      minTurnAngle = minTurnAngle / 180 * Math.PI;\n      pt0.fromArray(linePoints[0]);\n      pt1.fromArray(linePoints[1]);\n      pt2.fromArray(linePoints[2]);\n      Point.sub(dir, pt0, pt1);\n      Point.sub(dir2, pt2, pt1);\n      var len1 = dir.len();\n      var len2 = dir2.len();\n\n      if (len1 < 1e-3 || len2 < 1e-3) {\n        return;\n      }\n\n      dir.scale(1 / len1);\n      dir2.scale(1 / len2);\n      var angleCos = dir.dot(dir2);\n      var minTurnAngleCos = Math.cos(minTurnAngle);\n\n      if (minTurnAngleCos < angleCos) {\n        var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n        tmpProjPoint.fromArray(tmpArr);\n        tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));\n        var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n        if (isNaN(t)) {\n          return;\n        }\n\n        if (t < 0) {\n          Point.copy(tmpProjPoint, pt1);\n        } else if (t > 1) {\n          Point.copy(tmpProjPoint, pt2);\n        }\n\n        tmpProjPoint.toArray(linePoints[1]);\n      }\n    }\n    function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n      if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n        return;\n      }\n\n      maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n      pt0.fromArray(linePoints[0]);\n      pt1.fromArray(linePoints[1]);\n      pt2.fromArray(linePoints[2]);\n      Point.sub(dir, pt1, pt0);\n      Point.sub(dir2, pt2, pt1);\n      var len1 = dir.len();\n      var len2 = dir2.len();\n\n      if (len1 < 1e-3 || len2 < 1e-3) {\n        return;\n      }\n\n      dir.scale(1 / len1);\n      dir2.scale(1 / len2);\n      var angleCos = dir.dot(surfaceNormal);\n      var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n      if (angleCos < maxSurfaceAngleCos) {\n        var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n        tmpProjPoint.fromArray(tmpArr);\n        var HALF_PI = Math.PI / 2;\n        var angle2 = Math.acos(dir2.dot(surfaceNormal));\n        var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n        if (newAngle >= HALF_PI) {\n          Point.copy(tmpProjPoint, pt2);\n        } else {\n          tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));\n          var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n          if (isNaN(t)) {\n            return;\n          }\n\n          if (t < 0) {\n            Point.copy(tmpProjPoint, pt1);\n          } else if (t > 1) {\n            Point.copy(tmpProjPoint, pt2);\n          }\n        }\n\n        tmpProjPoint.toArray(linePoints[1]);\n      }\n    }\n\n    function setLabelLineState(labelLine, ignore, stateName, stateModel) {\n      var isNormal = stateName === 'normal';\n      var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);\n      stateObj.ignore = ignore;\n      var smooth = stateModel.get('smooth');\n\n      if (smooth && smooth === true) {\n        smooth = 0.3;\n      }\n\n      stateObj.shape = stateObj.shape || {};\n\n      if (smooth > 0) {\n        stateObj.shape.smooth = smooth;\n      }\n\n      var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n      isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n    }\n\n    function buildLabelLinePath(path, shape) {\n      var smooth = shape.smooth;\n      var points = shape.points;\n\n      if (!points) {\n        return;\n      }\n\n      path.moveTo(points[0][0], points[0][1]);\n\n      if (smooth > 0 && points.length >= 3) {\n        var len1 = dist(points[0], points[1]);\n        var len2 = dist(points[1], points[2]);\n\n        if (!len1 || !len2) {\n          path.lineTo(points[1][0], points[1][1]);\n          path.lineTo(points[2][0], points[2][1]);\n          return;\n        }\n\n        var moveLen = Math.min(len1, len2) * smooth;\n        var midPoint0 = lerp([], points[1], points[0], moveLen / len1);\n        var midPoint2 = lerp([], points[1], points[2], moveLen / len2);\n        var midPoint1 = lerp([], midPoint0, midPoint2, 0.5);\n        path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n        path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n      } else {\n        for (var i = 1; i < points.length; i++) {\n          path.lineTo(points[i][0], points[i][1]);\n        }\n      }\n    }\n\n    function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n      var labelLine = targetEl.getTextGuideLine();\n      var label = targetEl.getTextContent();\n\n      if (!label) {\n        if (labelLine) {\n          targetEl.removeTextGuideLine();\n        }\n\n        return;\n      }\n\n      var normalModel = statesModels.normal;\n      var showNormal = normalModel.get('show');\n      var labelIgnoreNormal = label.ignore;\n\n      for (var i = 0; i < DISPLAY_STATES.length; i++) {\n        var stateName = DISPLAY_STATES[i];\n        var stateModel = statesModels[stateName];\n        var isNormal = stateName === 'normal';\n\n        if (stateModel) {\n          var stateShow = stateModel.get('show');\n          var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n          if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {\n            var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;\n\n            if (stateObj) {\n              stateObj.ignore = true;\n            }\n\n            continue;\n          }\n\n          if (!labelLine) {\n            labelLine = new Polyline();\n            targetEl.setTextGuideLine(labelLine);\n\n            if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n              setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n            }\n\n            if (targetEl.stateProxy) {\n              labelLine.stateProxy = targetEl.stateProxy;\n            }\n          }\n\n          setLabelLineState(labelLine, false, stateName, stateModel);\n        }\n      }\n\n      if (labelLine) {\n        defaults(labelLine.style, defaultStyle);\n        labelLine.style.fill = null;\n        var showAbove = normalModel.get('showAbove');\n        var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n        labelLineConfig.showAbove = showAbove || false;\n        labelLine.buildPath = buildLabelLinePath;\n      }\n    }\n    function getLabelLineStatesModels(itemModel, labelLineName) {\n      labelLineName = labelLineName || 'labelLine';\n      var statesModels = {\n        normal: itemModel.getModel(labelLineName)\n      };\n\n      for (var i = 0; i < SPECIAL_STATES.length; i++) {\n        var stateName = SPECIAL_STATES[i];\n        statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n      }\n\n      return statesModels;\n    }\n\n    function prepareLayoutList(input) {\n      var list = [];\n\n      for (var i = 0; i < input.length; i++) {\n        var rawItem = input[i];\n\n        if (rawItem.defaultAttr.ignore) {\n          continue;\n        }\n\n        var label = rawItem.label;\n        var transform = label.getComputedTransform();\n        var localRect = label.getBoundingRect();\n        var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n        var minMargin = label.style.margin || 0;\n        var globalRect = localRect.clone();\n        globalRect.applyTransform(transform);\n        globalRect.x -= minMargin / 2;\n        globalRect.y -= minMargin / 2;\n        globalRect.width += minMargin;\n        globalRect.height += minMargin;\n        var obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null;\n        list.push({\n          label: label,\n          labelLine: rawItem.labelLine,\n          rect: globalRect,\n          localRect: localRect,\n          obb: obb,\n          priority: rawItem.priority,\n          defaultAttr: rawItem.defaultAttr,\n          layoutOption: rawItem.computedLayoutOption,\n          axisAligned: isAxisAligned,\n          transform: transform\n        });\n      }\n\n      return list;\n    }\n\n    function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n      var len = list.length;\n\n      if (len < 2) {\n        return;\n      }\n\n      list.sort(function (a, b) {\n        return a.rect[xyDim] - b.rect[xyDim];\n      });\n      var lastPos = 0;\n      var delta;\n      var adjusted = false;\n      var totalShifts = 0;\n\n      for (var i = 0; i < len; i++) {\n        var item = list[i];\n        var rect = item.rect;\n        delta = rect[xyDim] - lastPos;\n\n        if (delta < 0) {\n          rect[xyDim] -= delta;\n          item.label[xyDim] -= delta;\n          adjusted = true;\n        }\n\n        var shift = Math.max(-delta, 0);\n        totalShifts += shift;\n        lastPos = rect[xyDim] + rect[sizeDim];\n      }\n\n      if (totalShifts > 0 && balanceShift) {\n        shiftList(-totalShifts / len, 0, len);\n      }\n\n      var first = list[0];\n      var last = list[len - 1];\n      var minGap;\n      var maxGap;\n      updateMinMaxGap();\n      minGap < 0 && squeezeGaps(-minGap, 0.8);\n      maxGap < 0 && squeezeGaps(maxGap, 0.8);\n      updateMinMaxGap();\n      takeBoundsGap(minGap, maxGap, 1);\n      takeBoundsGap(maxGap, minGap, -1);\n      updateMinMaxGap();\n\n      if (minGap < 0) {\n        squeezeWhenBailout(-minGap);\n      }\n\n      if (maxGap < 0) {\n        squeezeWhenBailout(maxGap);\n      }\n\n      function updateMinMaxGap() {\n        minGap = first.rect[xyDim] - minBound;\n        maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n      }\n\n      function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n        if (gapThisBound < 0) {\n          var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n          if (moveFromMaxGap > 0) {\n            shiftList(moveFromMaxGap * moveDir, 0, len);\n            var remained = moveFromMaxGap + gapThisBound;\n\n            if (remained < 0) {\n              squeezeGaps(-remained * moveDir, 1);\n            }\n          } else {\n            squeezeGaps(-gapThisBound * moveDir, 1);\n          }\n        }\n      }\n\n      function shiftList(delta, start, end) {\n        if (delta !== 0) {\n          adjusted = true;\n        }\n\n        for (var i = start; i < end; i++) {\n          var item = list[i];\n          var rect = item.rect;\n          rect[xyDim] += delta;\n          item.label[xyDim] += delta;\n        }\n      }\n\n      function squeezeGaps(delta, maxSqeezePercent) {\n        var gaps = [];\n        var totalGaps = 0;\n\n        for (var i = 1; i < len; i++) {\n          var prevItemRect = list[i - 1].rect;\n          var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n          gaps.push(gap);\n          totalGaps += gap;\n        }\n\n        if (!totalGaps) {\n          return;\n        }\n\n        var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n        if (delta > 0) {\n          for (var i = 0; i < len - 1; i++) {\n            var movement = gaps[i] * squeezePercent;\n            shiftList(movement, 0, i + 1);\n          }\n        } else {\n          for (var i = len - 1; i > 0; i--) {\n            var movement = gaps[i - 1] * squeezePercent;\n            shiftList(-movement, i, len);\n          }\n        }\n      }\n\n      function squeezeWhenBailout(delta) {\n        var dir = delta < 0 ? -1 : 1;\n        delta = Math.abs(delta);\n        var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n        for (var i = 0; i < len - 1; i++) {\n          if (dir > 0) {\n            shiftList(moveForEachLabel, 0, i + 1);\n          } else {\n            shiftList(-moveForEachLabel, len - i - 1, len);\n          }\n\n          delta -= moveForEachLabel;\n\n          if (delta <= 0) {\n            return;\n          }\n        }\n      }\n\n      return adjusted;\n    }\n\n    function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {\n      return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n    }\n    function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {\n      return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n    }\n    function hideOverlap(labelList) {\n      var displayedLabels = [];\n      labelList.sort(function (a, b) {\n        return b.priority - a.priority;\n      });\n      var globalRect = new BoundingRect(0, 0, 0, 0);\n\n      function hideEl(el) {\n        if (!el.ignore) {\n          var emphasisState = el.ensureState('emphasis');\n\n          if (emphasisState.ignore == null) {\n            emphasisState.ignore = false;\n          }\n        }\n\n        el.ignore = true;\n      }\n\n      for (var i = 0; i < labelList.length; i++) {\n        var labelItem = labelList[i];\n        var isAxisAligned = labelItem.axisAligned;\n        var localRect = labelItem.localRect;\n        var transform = labelItem.transform;\n        var label = labelItem.label;\n        var labelLine = labelItem.labelLine;\n        globalRect.copy(labelItem.rect);\n        globalRect.width -= 0.1;\n        globalRect.height -= 0.1;\n        globalRect.x += 0.05;\n        globalRect.y += 0.05;\n        var obb = labelItem.obb;\n        var overlapped = false;\n\n        for (var j = 0; j < displayedLabels.length; j++) {\n          var existsTextCfg = displayedLabels[j];\n\n          if (!globalRect.intersect(existsTextCfg.rect)) {\n            continue;\n          }\n\n          if (isAxisAligned && existsTextCfg.axisAligned) {\n            overlapped = true;\n            break;\n          }\n\n          if (!existsTextCfg.obb) {\n            existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n          }\n\n          if (!obb) {\n            obb = new OrientedBoundingRect(localRect, transform);\n          }\n\n          if (obb.intersect(existsTextCfg.obb)) {\n            overlapped = true;\n            break;\n          }\n        }\n\n        if (overlapped) {\n          hideEl(label);\n          labelLine && hideEl(labelLine);\n        } else {\n          label.attr('ignore', labelItem.defaultAttr.ignore);\n          labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n          displayedLabels.push(labelItem);\n        }\n      }\n    }\n\n    function cloneArr(points) {\n      if (points) {\n        var newPoints = [];\n\n        for (var i = 0; i < points.length; i++) {\n          newPoints.push(points[i].slice());\n        }\n\n        return newPoints;\n      }\n    }\n\n    function prepareLayoutCallbackParams(labelItem, hostEl) {\n      var label = labelItem.label;\n      var labelLine = hostEl && hostEl.getTextGuideLine();\n      return {\n        dataIndex: labelItem.dataIndex,\n        dataType: labelItem.dataType,\n        seriesIndex: labelItem.seriesModel.seriesIndex,\n        text: labelItem.label.style.text,\n        rect: labelItem.hostRect,\n        labelRect: labelItem.rect,\n        align: label.style.align,\n        verticalAlign: label.style.verticalAlign,\n        labelLinePoints: cloneArr(labelLine && labelLine.shape.points)\n      };\n    }\n\n    var LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize'];\n    var dummyTransformable = new Transformable();\n    var labelLayoutInnerStore = makeInner();\n    var labelLineAnimationStore = makeInner();\n\n    function extendWithKeys(target, source, keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n\n        if (source[key] != null) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    var LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation'];\n\n    var LabelManager = function () {\n      function LabelManager() {\n        this._labelList = [];\n        this._chartViewList = [];\n      }\n\n      LabelManager.prototype.clearLabels = function () {\n        this._labelList = [];\n        this._chartViewList = [];\n      };\n\n      LabelManager.prototype._addLabel = function (dataIndex, dataType, seriesModel, label, layoutOption) {\n        var labelStyle = label.style;\n        var hostEl = label.__hostTarget;\n        var textConfig = hostEl.textConfig || {};\n        var labelTransform = label.getComputedTransform();\n        var labelRect = label.getBoundingRect().plain();\n        BoundingRect.applyTransform(labelRect, labelRect, labelTransform);\n\n        if (labelTransform) {\n          dummyTransformable.setLocalTransform(labelTransform);\n        } else {\n          dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;\n          dummyTransformable.scaleX = dummyTransformable.scaleY = 1;\n        }\n\n        var host = label.__hostTarget;\n        var hostRect;\n\n        if (host) {\n          hostRect = host.getBoundingRect().plain();\n          var transform = host.getComputedTransform();\n          BoundingRect.applyTransform(hostRect, hostRect, transform);\n        }\n\n        var labelGuide = hostRect && host.getTextGuideLine();\n\n        this._labelList.push({\n          label: label,\n          labelLine: labelGuide,\n          seriesModel: seriesModel,\n          dataIndex: dataIndex,\n          dataType: dataType,\n          layoutOption: layoutOption,\n          computedLayoutOption: null,\n          rect: labelRect,\n          hostRect: hostRect,\n          priority: hostRect ? hostRect.width * hostRect.height : 0,\n          defaultAttr: {\n            ignore: label.ignore,\n            labelGuideIgnore: labelGuide && labelGuide.ignore,\n            x: dummyTransformable.x,\n            y: dummyTransformable.y,\n            rotation: dummyTransformable.rotation,\n            style: {\n              x: labelStyle.x,\n              y: labelStyle.y,\n              align: labelStyle.align,\n              verticalAlign: labelStyle.verticalAlign,\n              width: labelStyle.width,\n              height: labelStyle.height,\n              fontSize: labelStyle.fontSize\n            },\n            cursor: label.cursor,\n            attachedPos: textConfig.position,\n            attachedRot: textConfig.rotation\n          }\n        });\n      };\n\n      LabelManager.prototype.addLabelsOfSeries = function (chartView) {\n        var _this = this;\n\n        this._chartViewList.push(chartView);\n\n        var seriesModel = chartView.__model;\n        var layoutOption = seriesModel.get('labelLayout');\n\n        if (!(isFunction(layoutOption) || keys(layoutOption).length)) {\n          return;\n        }\n\n        chartView.group.traverse(function (child) {\n          if (child.ignore) {\n            return true;\n          }\n\n          var textEl = child.getTextContent();\n          var ecData = getECData(child);\n\n          if (textEl && !textEl.disableLabelLayout) {\n            _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);\n          }\n        });\n      };\n\n      LabelManager.prototype.updateLayoutConfig = function (api) {\n        var width = api.getWidth();\n        var height = api.getHeight();\n\n        function createDragHandler(el, labelLineModel) {\n          return function () {\n            updateLabelLinePoints(el, labelLineModel);\n          };\n        }\n\n        for (var i = 0; i < this._labelList.length; i++) {\n          var labelItem = this._labelList[i];\n          var label = labelItem.label;\n          var hostEl = label.__hostTarget;\n          var defaultLabelAttr = labelItem.defaultAttr;\n          var layoutOption = void 0;\n\n          if (typeof labelItem.layoutOption === 'function') {\n            layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));\n          } else {\n            layoutOption = labelItem.layoutOption;\n          }\n\n          layoutOption = layoutOption || {};\n          labelItem.computedLayoutOption = layoutOption;\n          var degreeToRadian = Math.PI / 180;\n\n          if (hostEl) {\n            hostEl.setTextConfig({\n              local: false,\n              position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,\n              rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,\n              offset: [layoutOption.dx || 0, layoutOption.dy || 0]\n            });\n          }\n\n          var needsUpdateLabelLine = false;\n\n          if (layoutOption.x != null) {\n            label.x = parsePercent$1(layoutOption.x, width);\n            label.setStyle('x', 0);\n            needsUpdateLabelLine = true;\n          } else {\n            label.x = defaultLabelAttr.x;\n            label.setStyle('x', defaultLabelAttr.style.x);\n          }\n\n          if (layoutOption.y != null) {\n            label.y = parsePercent$1(layoutOption.y, height);\n            label.setStyle('y', 0);\n            needsUpdateLabelLine = true;\n          } else {\n            label.y = defaultLabelAttr.y;\n            label.setStyle('y', defaultLabelAttr.style.y);\n          }\n\n          if (layoutOption.labelLinePoints) {\n            var guideLine = hostEl.getTextGuideLine();\n\n            if (guideLine) {\n              guideLine.setShape({\n                points: layoutOption.labelLinePoints\n              });\n              needsUpdateLabelLine = false;\n            }\n          }\n\n          var labelLayoutStore = labelLayoutInnerStore(label);\n          labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;\n          label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;\n\n          for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {\n            var key = LABEL_OPTION_TO_STYLE_KEYS[k];\n            label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);\n          }\n\n          if (layoutOption.draggable) {\n            label.draggable = true;\n            label.cursor = 'move';\n\n            if (hostEl) {\n              var hostModel = labelItem.seriesModel;\n\n              if (labelItem.dataIndex != null) {\n                var data = labelItem.seriesModel.getData(labelItem.dataType);\n                hostModel = data.getItemModel(labelItem.dataIndex);\n              }\n\n              label.on('drag', createDragHandler(hostEl, hostModel.getModel('labelLine')));\n            }\n          } else {\n            label.off('drag');\n            label.cursor = defaultLabelAttr.cursor;\n          }\n        }\n      };\n\n      LabelManager.prototype.layout = function (api) {\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var labelList = prepareLayoutList(this._labelList);\n        var labelsNeedsAdjustOnX = filter(labelList, function (item) {\n          return item.layoutOption.moveOverlap === 'shiftX';\n        });\n        var labelsNeedsAdjustOnY = filter(labelList, function (item) {\n          return item.layoutOption.moveOverlap === 'shiftY';\n        });\n        shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);\n        shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);\n        var labelsNeedsHideOverlap = filter(labelList, function (item) {\n          return item.layoutOption.hideOverlap;\n        });\n        hideOverlap(labelsNeedsHideOverlap);\n      };\n\n      LabelManager.prototype.processLabelsOverall = function () {\n        var _this = this;\n\n        each(this._chartViewList, function (chartView) {\n          var seriesModel = chartView.__model;\n          var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;\n          var animationEnabled = seriesModel.isAnimationEnabled();\n          chartView.group.traverse(function (child) {\n            if (child.ignore) {\n              return true;\n            }\n\n            var needsUpdateLabelLine = !ignoreLabelLineUpdate;\n            var label = child.getTextContent();\n\n            if (!needsUpdateLabelLine && label) {\n              needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;\n            }\n\n            if (needsUpdateLabelLine) {\n              _this._updateLabelLine(child, seriesModel);\n            }\n\n            if (animationEnabled) {\n              _this._animateLabels(child, seriesModel);\n            }\n          });\n        });\n      };\n\n      LabelManager.prototype._updateLabelLine = function (el, seriesModel) {\n        var textEl = el.getTextContent();\n        var ecData = getECData(el);\n        var dataIndex = ecData.dataIndex;\n\n        if (textEl && dataIndex != null) {\n          var data = seriesModel.getData(ecData.dataType);\n          var itemModel = data.getItemModel(dataIndex);\n          var defaultStyle = {};\n          var visualStyle = data.getItemVisual(dataIndex, 'style');\n          var visualType = data.getVisual('drawType');\n          defaultStyle.stroke = visualStyle[visualType];\n          var labelLineModel = itemModel.getModel('labelLine');\n          setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);\n          updateLabelLinePoints(el, labelLineModel);\n        }\n      };\n\n      LabelManager.prototype._animateLabels = function (el, seriesModel) {\n        var textEl = el.getTextContent();\n        var guideLine = el.getTextGuideLine();\n\n        if (textEl && !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el)) {\n          var layoutStore = labelLayoutInnerStore(textEl);\n          var oldLayout = layoutStore.oldLayout;\n          var ecData = getECData(el);\n          var dataIndex = ecData.dataIndex;\n          var newProps = {\n            x: textEl.x,\n            y: textEl.y,\n            rotation: textEl.rotation\n          };\n          var data = seriesModel.getData(ecData.dataType);\n\n          if (!oldLayout) {\n            textEl.attr(newProps);\n\n            if (!labelInner(textEl).valueAnimation) {\n              var oldOpacity = retrieve2(textEl.style.opacity, 1);\n              textEl.style.opacity = 0;\n              initProps(textEl, {\n                style: {\n                  opacity: oldOpacity\n                }\n              }, seriesModel, dataIndex);\n            }\n          } else {\n            textEl.attr(oldLayout);\n            var prevStates = el.prevStates;\n\n            if (prevStates) {\n              if (indexOf(prevStates, 'select') >= 0) {\n                textEl.attr(layoutStore.oldLayoutSelect);\n              }\n\n              if (indexOf(prevStates, 'emphasis') >= 0) {\n                textEl.attr(layoutStore.oldLayoutEmphasis);\n              }\n            }\n\n            updateProps(textEl, newProps, seriesModel, dataIndex);\n          }\n\n          layoutStore.oldLayout = newProps;\n\n          if (textEl.states.select) {\n            var layoutSelect = layoutStore.oldLayoutSelect = {};\n            extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);\n            extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);\n          }\n\n          if (textEl.states.emphasis) {\n            var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};\n            extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);\n            extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);\n          }\n\n          animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);\n        }\n\n        if (guideLine && !guideLine.ignore && !guideLine.invisible) {\n          var layoutStore = labelLineAnimationStore(guideLine);\n          var oldLayout = layoutStore.oldLayout;\n          var newLayout = {\n            points: guideLine.shape.points\n          };\n\n          if (!oldLayout) {\n            guideLine.setShape(newLayout);\n            guideLine.style.strokePercent = 0;\n            initProps(guideLine, {\n              style: {\n                strokePercent: 1\n              }\n            }, seriesModel);\n          } else {\n            guideLine.attr({\n              shape: oldLayout\n            });\n            updateProps(guideLine, {\n              shape: newLayout\n            }, seriesModel);\n          }\n\n          layoutStore.oldLayout = newLayout;\n        }\n      };\n\n      return LabelManager;\n    }();\n\n    function createLegacyDataSelectAction(seriesType, ecRegisterAction) {\n      function getSeriesIndices(ecModel, payload) {\n        var seriesIndices = [];\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: seriesType,\n          query: payload\n        }, function (seriesModel) {\n          seriesIndices.push(seriesModel.seriesIndex);\n        });\n        return seriesIndices;\n      }\n\n      each([[seriesType + 'ToggleSelect', 'toggleSelect'], [seriesType + 'Select', 'select'], [seriesType + 'UnSelect', 'unselect']], function (eventsMap) {\n        ecRegisterAction(eventsMap[0], function (payload, ecModel, api) {\n          payload = extend({}, payload);\n\n          if (\"development\" !== 'production') {\n            deprecateReplaceLog(payload.type, eventsMap[1]);\n          }\n\n          api.dispatchAction(extend(payload, {\n            type: eventsMap[1],\n            seriesIndex: getSeriesIndices(ecModel, payload)\n          }));\n        });\n      });\n    }\n\n    function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {\n      var legacyEventName = type + eventPostfix;\n\n      if (!ecIns.isSilent(legacyEventName)) {\n        if (\"development\" !== 'production') {\n          deprecateLog(\"event \" + legacyEventName + \" is deprecated.\");\n        }\n\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'pie'\n        }, function (seriesModel) {\n          var seriesIndex = seriesModel.seriesIndex;\n          var selected = payload.selected;\n\n          for (var i = 0; i < selected.length; i++) {\n            if (selected[i].seriesIndex === seriesIndex) {\n              var data = seriesModel.getData();\n              var dataIndex = queryDataIndex(data, payload.fromActionPayload);\n              ecIns.trigger(legacyEventName, {\n                type: legacyEventName,\n                seriesId: seriesModel.id,\n                name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),\n                selected: extend({}, seriesModel.option.selectedMap)\n              });\n            }\n          }\n        });\n      }\n    }\n\n    function handleLegacySelectEvents(messageCenter, ecIns, api) {\n      messageCenter.on('selectchanged', function (params) {\n        var ecModel = api.getModel();\n\n        if (params.isFromClick) {\n          handleSeriesLegacySelectEvents('map', 'selectchanged', ecIns, ecModel, params);\n          handleSeriesLegacySelectEvents('pie', 'selectchanged', ecIns, ecModel, params);\n        } else if (params.fromAction === 'select') {\n          handleSeriesLegacySelectEvents('map', 'selected', ecIns, ecModel, params);\n          handleSeriesLegacySelectEvents('pie', 'selected', ecIns, ecModel, params);\n        } else if (params.fromAction === 'unselect') {\n          handleSeriesLegacySelectEvents('map', 'unselected', ecIns, ecModel, params);\n          handleSeriesLegacySelectEvents('pie', 'unselected', ecIns, ecModel, params);\n        }\n      });\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function findEventDispatcher(target, det, returnFirstMatch) {\n      var found;\n\n      while (target) {\n        if (det(target)) {\n          found = target;\n\n          if (returnFirstMatch) {\n            break;\n          }\n        }\n\n        target = target.__hostTarget || target.parent;\n      }\n\n      return found;\n    }\n\n    var wmUniqueIndex = Math.round(Math.random() * 9);\n    var WeakMap = (function () {\n        function WeakMap() {\n            this._id = '__ec_inner_' + wmUniqueIndex++;\n        }\n        WeakMap.prototype.get = function (key) {\n            return this._guard(key)[this._id];\n        };\n        WeakMap.prototype.set = function (key, value) {\n            var target = this._guard(key);\n            if (typeof Object.defineProperty === 'function') {\n                Object.defineProperty(target, this._id, {\n                    value: value,\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            else {\n                target[this._id] = value;\n            }\n            return this;\n        };\n        WeakMap.prototype[\"delete\"] = function (key) {\n            if (this.has(key)) {\n                delete this._guard(key)[this._id];\n                return true;\n            }\n            return false;\n        };\n        WeakMap.prototype.has = function (key) {\n            return !!this._guard(key)[this._id];\n        };\n        WeakMap.prototype._guard = function (key) {\n            if (key !== Object(key)) {\n                throw TypeError('Value of WeakMap is not a non-null object.');\n            }\n            return key;\n        };\n        return WeakMap;\n    }());\n\n    var Triangle = Path.extend({\n      type: 'triangle',\n      shape: {\n        cx: 0,\n        cy: 0,\n        width: 0,\n        height: 0\n      },\n      buildPath: function (path, shape) {\n        var cx = shape.cx;\n        var cy = shape.cy;\n        var width = shape.width / 2;\n        var height = shape.height / 2;\n        path.moveTo(cx, cy - height);\n        path.lineTo(cx + width, cy + height);\n        path.lineTo(cx - width, cy + height);\n        path.closePath();\n      }\n    });\n    var Diamond = Path.extend({\n      type: 'diamond',\n      shape: {\n        cx: 0,\n        cy: 0,\n        width: 0,\n        height: 0\n      },\n      buildPath: function (path, shape) {\n        var cx = shape.cx;\n        var cy = shape.cy;\n        var width = shape.width / 2;\n        var height = shape.height / 2;\n        path.moveTo(cx, cy - height);\n        path.lineTo(cx + width, cy);\n        path.lineTo(cx, cy + height);\n        path.lineTo(cx - width, cy);\n        path.closePath();\n      }\n    });\n    var Pin = Path.extend({\n      type: 'pin',\n      shape: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      buildPath: function (path, shape) {\n        var x = shape.x;\n        var y = shape.y;\n        var w = shape.width / 5 * 3;\n        var h = Math.max(w, shape.height);\n        var r = w / 2;\n        var dy = r * r / (h - r);\n        var cy = y - h + r + dy;\n        var angle = Math.asin(dy / r);\n        var dx = Math.cos(angle) * r;\n        var tanX = Math.sin(angle);\n        var tanY = Math.cos(angle);\n        var cpLen = r * 0.6;\n        var cpLen2 = r * 0.7;\n        path.moveTo(x - dx, cy + dy);\n        path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);\n        path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);\n        path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);\n        path.closePath();\n      }\n    });\n    var Arrow = Path.extend({\n      type: 'arrow',\n      shape: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      buildPath: function (ctx, shape) {\n        var height = shape.height;\n        var width = shape.width;\n        var x = shape.x;\n        var y = shape.y;\n        var dx = width / 3 * 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + dx, y + height);\n        ctx.lineTo(x, y + height / 4 * 3);\n        ctx.lineTo(x - dx, y + height);\n        ctx.lineTo(x, y);\n        ctx.closePath();\n      }\n    });\n    var symbolCtors = {\n      line: Rect,\n      rect: Rect,\n      roundRect: Rect,\n      square: Rect,\n      circle: Circle,\n      diamond: Diamond,\n      pin: Pin,\n      arrow: Arrow,\n      triangle: Triangle\n    };\n    var symbolShapeMakers = {\n      line: function (x, y, w, h, shape) {\n        var thickness = 2;\n        shape.x = x;\n        shape.y = y + h / 2 - thickness / 2;\n        shape.width = w;\n        shape.height = thickness;\n      },\n      rect: function (x, y, w, h, shape) {\n        shape.x = x;\n        shape.y = y;\n        shape.width = w;\n        shape.height = h;\n      },\n      roundRect: function (x, y, w, h, shape) {\n        shape.x = x;\n        shape.y = y;\n        shape.width = w;\n        shape.height = h;\n        shape.r = Math.min(w, h) / 4;\n      },\n      square: function (x, y, w, h, shape) {\n        var size = Math.min(w, h);\n        shape.x = x;\n        shape.y = y;\n        shape.width = size;\n        shape.height = size;\n      },\n      circle: function (x, y, w, h, shape) {\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.r = Math.min(w, h) / 2;\n      },\n      diamond: function (x, y, w, h, shape) {\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n      },\n      pin: function (x, y, w, h, shape) {\n        shape.x = x + w / 2;\n        shape.y = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n      },\n      arrow: function (x, y, w, h, shape) {\n        shape.x = x + w / 2;\n        shape.y = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n      },\n      triangle: function (x, y, w, h, shape) {\n        shape.cx = x + w / 2;\n        shape.cy = y + h / 2;\n        shape.width = w;\n        shape.height = h;\n      }\n    };\n    var symbolBuildProxies = {};\n    each(symbolCtors, function (Ctor, name) {\n      symbolBuildProxies[name] = new Ctor();\n    });\n    var SymbolClz = Path.extend({\n      type: 'symbol',\n      shape: {\n        symbolType: '',\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      },\n      calculateTextPosition: function (out, config, rect) {\n        var res = calculateTextPosition(out, config, rect);\n        var shape = this.shape;\n\n        if (shape && shape.symbolType === 'pin' && config.position === 'inside') {\n          res.y = rect.y + rect.height * 0.4;\n        }\n\n        return res;\n      },\n      buildPath: function (ctx, shape, inBundle) {\n        var symbolType = shape.symbolType;\n\n        if (symbolType !== 'none') {\n          var proxySymbol = symbolBuildProxies[symbolType];\n\n          if (!proxySymbol) {\n            symbolType = 'rect';\n            proxySymbol = symbolBuildProxies[symbolType];\n          }\n\n          symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);\n          proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n        }\n      }\n    });\n\n    function symbolPathSetColor(color, innerColor) {\n      if (this.type !== 'image') {\n        var symbolStyle = this.style;\n\n        if (this.__isEmptyBrush) {\n          symbolStyle.stroke = color;\n          symbolStyle.fill = innerColor || '#fff';\n          symbolStyle.lineWidth = 2;\n        } else {\n          symbolStyle.fill = color;\n        }\n\n        this.markRedraw();\n      }\n    }\n\n    function createSymbol(symbolType, x, y, w, h, color, keepAspect) {\n      var isEmpty = symbolType.indexOf('empty') === 0;\n\n      if (isEmpty) {\n        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n      }\n\n      var symbolPath;\n\n      if (symbolType.indexOf('image://') === 0) {\n        symbolPath = makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n      } else if (symbolType.indexOf('path://') === 0) {\n        symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover');\n      } else {\n        symbolPath = new SymbolClz({\n          shape: {\n            symbolType: symbolType,\n            x: x,\n            y: y,\n            width: w,\n            height: h\n          }\n        });\n      }\n\n      symbolPath.__isEmptyBrush = isEmpty;\n      symbolPath.setColor = symbolPathSetColor;\n\n      if (color) {\n        symbolPath.setColor(color);\n      }\n\n      return symbolPath;\n    }\n\n    function createLinearGradient(ctx, obj, rect) {\n        var x = obj.x == null ? 0 : obj.x;\n        var x2 = obj.x2 == null ? 1 : obj.x2;\n        var y = obj.y == null ? 0 : obj.y;\n        var y2 = obj.y2 == null ? 0 : obj.y2;\n        if (!obj.global) {\n            x = x * rect.width + rect.x;\n            x2 = x2 * rect.width + rect.x;\n            y = y * rect.height + rect.y;\n            y2 = y2 * rect.height + rect.y;\n        }\n        x = isNaN(x) ? 0 : x;\n        x2 = isNaN(x2) ? 1 : x2;\n        y = isNaN(y) ? 0 : y;\n        y2 = isNaN(y2) ? 0 : y2;\n        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n        return canvasGradient;\n    }\n    function createRadialGradient(ctx, obj, rect) {\n        var width = rect.width;\n        var height = rect.height;\n        var min = Math.min(width, height);\n        var x = obj.x == null ? 0.5 : obj.x;\n        var y = obj.y == null ? 0.5 : obj.y;\n        var r = obj.r == null ? 0.5 : obj.r;\n        if (!obj.global) {\n            x = x * width + rect.x;\n            y = y * height + rect.y;\n            r = r * min;\n        }\n        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n        return canvasGradient;\n    }\n    function getCanvasGradient(ctx, obj, rect) {\n        var canvasGradient = obj.type === 'radial'\n            ? createRadialGradient(ctx, obj, rect)\n            : createLinearGradient(ctx, obj, rect);\n        var colorStops = obj.colorStops;\n        for (var i = 0; i < colorStops.length; i++) {\n            canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n        }\n        return canvasGradient;\n    }\n    function isClipPathChanged(clipPaths, prevClipPaths) {\n        if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {\n            return false;\n        }\n        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {\n            return true;\n        }\n        for (var i = 0; i < clipPaths.length; i++) {\n            if (clipPaths[i] !== prevClipPaths[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function normalizeLineDash(lineType, lineWidth) {\n        if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {\n            return null;\n        }\n        lineWidth = lineWidth || 1;\n        return lineType === 'dashed'\n            ? [4 * lineWidth, 2 * lineWidth]\n            : lineType === 'dotted'\n                ? [lineWidth]\n                : isNumber(lineType)\n                    ? [lineType] : isArray(lineType) ? lineType : null;\n    }\n\n    var pathProxyForDraw = new PathProxy(true);\n    function styleHasStroke(style) {\n        var stroke = style.stroke;\n        return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));\n    }\n    function styleHasFill(style) {\n        var fill = style.fill;\n        return fill != null && fill !== 'none';\n    }\n    function doFillPath(ctx, style) {\n        if (style.fillOpacity != null && style.fillOpacity !== 1) {\n            var originalGlobalAlpha = ctx.globalAlpha;\n            ctx.globalAlpha = style.fillOpacity * style.opacity;\n            ctx.fill();\n            ctx.globalAlpha = originalGlobalAlpha;\n        }\n        else {\n            ctx.fill();\n        }\n    }\n    function doStrokePath(ctx, style) {\n        if (style.strokeOpacity != null && style.strokeOpacity !== 1) {\n            var originalGlobalAlpha = ctx.globalAlpha;\n            ctx.globalAlpha = style.strokeOpacity * style.opacity;\n            ctx.stroke();\n            ctx.globalAlpha = originalGlobalAlpha;\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    function createCanvasPattern(ctx, pattern, el) {\n        var image = createOrUpdateImage(pattern.image, pattern.__image, el);\n        if (isImageReady(image)) {\n            var canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat');\n            if (typeof DOMMatrix === 'function') {\n                var matrix = new DOMMatrix();\n                matrix.rotateSelf(0, 0, (pattern.rotation || 0) / Math.PI * 180);\n                matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1));\n                matrix.translateSelf((pattern.x || 0), (pattern.y || 0));\n                canvasPattern.setTransform(matrix);\n            }\n            return canvasPattern;\n        }\n    }\n    function brushPath(ctx, el, style, inBatch) {\n        var hasStroke = styleHasStroke(style);\n        var hasFill = styleHasFill(style);\n        var strokePercent = style.strokePercent;\n        var strokePart = strokePercent < 1;\n        var firstDraw = !el.path;\n        if ((!el.silent || strokePart) && firstDraw) {\n            el.createPathProxy();\n        }\n        var path = el.path || pathProxyForDraw;\n        if (!inBatch) {\n            var fill = style.fill;\n            var stroke = style.stroke;\n            var hasFillGradient = hasFill && !!fill.colorStops;\n            var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n            var hasFillPattern = hasFill && !!fill.image;\n            var hasStrokePattern = hasStroke && !!stroke.image;\n            var fillGradient = void 0;\n            var strokeGradient = void 0;\n            var fillPattern = void 0;\n            var strokePattern = void 0;\n            var rect = void 0;\n            if (hasFillGradient || hasStrokeGradient) {\n                rect = el.getBoundingRect();\n            }\n            if (hasFillGradient) {\n                fillGradient = el.__dirty\n                    ? getCanvasGradient(ctx, fill, rect)\n                    : el.__canvasFillGradient;\n                el.__canvasFillGradient = fillGradient;\n            }\n            if (hasStrokeGradient) {\n                strokeGradient = el.__dirty\n                    ? getCanvasGradient(ctx, stroke, rect)\n                    : el.__canvasStrokeGradient;\n                el.__canvasStrokeGradient = strokeGradient;\n            }\n            if (hasFillPattern) {\n                fillPattern = (el.__dirty || !el.__canvasFillPattern)\n                    ? createCanvasPattern(ctx, fill, el)\n                    : el.__canvasFillPattern;\n                el.__canvasFillPattern = fillPattern;\n            }\n            if (hasStrokePattern) {\n                strokePattern = (el.__dirty || !el.__canvasStrokePattern)\n                    ? createCanvasPattern(ctx, stroke, el)\n                    : el.__canvasStrokePattern;\n                el.__canvasStrokePattern = fillPattern;\n            }\n            if (hasFillGradient) {\n                ctx.fillStyle = fillGradient;\n            }\n            else if (hasFillPattern) {\n                if (fillPattern) {\n                    ctx.fillStyle = fillPattern;\n                }\n                else {\n                    hasFill = false;\n                }\n            }\n            if (hasStrokeGradient) {\n                ctx.strokeStyle = strokeGradient;\n            }\n            else if (hasStrokePattern) {\n                if (strokePattern) {\n                    ctx.strokeStyle = strokePattern;\n                }\n                else {\n                    hasStroke = false;\n                }\n            }\n        }\n        var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);\n        var lineDashOffset = style.lineDashOffset;\n        var ctxLineDash = !!ctx.setLineDash;\n        var scale = el.getGlobalScale();\n        path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold);\n        if (lineDash) {\n            var lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;\n            if (lineScale_1 && lineScale_1 !== 1) {\n                lineDash = map(lineDash, function (rawVal) {\n                    return rawVal / lineScale_1;\n                });\n                lineDashOffset /= lineScale_1;\n            }\n        }\n        var needsRebuild = true;\n        if (firstDraw || (el.__dirty & Path.SHAPE_CHANGED_BIT)\n            || (lineDash && !ctxLineDash && hasStroke)) {\n            path.setDPR(ctx.dpr);\n            if (strokePart) {\n                path.setContext(null);\n            }\n            else {\n                path.setContext(ctx);\n                needsRebuild = false;\n            }\n            path.reset();\n            if (lineDash && !ctxLineDash) {\n                path.setLineDash(lineDash);\n                path.setLineDashOffset(lineDashOffset);\n            }\n            el.buildPath(path, el.shape, inBatch);\n            path.toStatic();\n            el.pathUpdated();\n        }\n        if (needsRebuild) {\n            path.rebuildPath(ctx, strokePart ? strokePercent : 1);\n        }\n        if (lineDash && ctxLineDash) {\n            ctx.setLineDash(lineDash);\n            ctx.lineDashOffset = lineDashOffset;\n        }\n        if (!inBatch) {\n            if (style.strokeFirst) {\n                if (hasStroke) {\n                    doStrokePath(ctx, style);\n                }\n                if (hasFill) {\n                    doFillPath(ctx, style);\n                }\n            }\n            else {\n                if (hasFill) {\n                    doFillPath(ctx, style);\n                }\n                if (hasStroke) {\n                    doStrokePath(ctx, style);\n                }\n            }\n        }\n        if (lineDash && ctxLineDash) {\n            ctx.setLineDash([]);\n        }\n    }\n    function brushImage(ctx, el, style) {\n        var image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);\n        if (!image || !isImageReady(image)) {\n            return;\n        }\n        var x = style.x || 0;\n        var y = style.y || 0;\n        var width = el.getWidth();\n        var height = el.getHeight();\n        var aspect = image.width / image.height;\n        if (width == null && height != null) {\n            width = height * aspect;\n        }\n        else if (height == null && width != null) {\n            height = width / aspect;\n        }\n        else if (width == null && height == null) {\n            width = image.width;\n            height = image.height;\n        }\n        if (style.sWidth && style.sHeight) {\n            var sx = style.sx || 0;\n            var sy = style.sy || 0;\n            ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n        }\n        else if (style.sx && style.sy) {\n            var sx = style.sx;\n            var sy = style.sy;\n            var sWidth = width - sx;\n            var sHeight = height - sy;\n            ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n        }\n        else {\n            ctx.drawImage(image, x, y, width, height);\n        }\n    }\n    function brushText(ctx, el, style) {\n        var text = style.text;\n        text != null && (text += '');\n        if (text) {\n            ctx.font = style.font || DEFAULT_FONT;\n            ctx.textAlign = style.textAlign;\n            ctx.textBaseline = style.textBaseline;\n            var hasLineDash = void 0;\n            if (ctx.setLineDash) {\n                var lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);\n                var lineDashOffset = style.lineDashOffset;\n                if (lineDash) {\n                    var lineScale_2 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;\n                    if (lineScale_2 && lineScale_2 !== 1) {\n                        lineDash = map(lineDash, function (rawVal) {\n                            return rawVal / lineScale_2;\n                        });\n                        lineDashOffset /= lineScale_2;\n                    }\n                    ctx.setLineDash(lineDash);\n                    ctx.lineDashOffset = lineDashOffset;\n                    hasLineDash = true;\n                }\n            }\n            if (style.strokeFirst) {\n                if (styleHasStroke(style)) {\n                    ctx.strokeText(text, style.x, style.y);\n                }\n                if (styleHasFill(style)) {\n                    ctx.fillText(text, style.x, style.y);\n                }\n            }\n            else {\n                if (styleHasFill(style)) {\n                    ctx.fillText(text, style.x, style.y);\n                }\n                if (styleHasStroke(style)) {\n                    ctx.strokeText(text, style.x, style.y);\n                }\n            }\n            if (hasLineDash) {\n                ctx.setLineDash([]);\n            }\n        }\n    }\n    var SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n    var STROKE_PROPS = [\n        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]\n    ];\n    function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {\n        var styleChanged = false;\n        if (!forceSetAll) {\n            prevStyle = prevStyle || {};\n            if (style === prevStyle) {\n                return false;\n            }\n        }\n        if (forceSetAll || style.opacity !== prevStyle.opacity) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.globalAlpha = style.opacity == null ? DEFAULT_COMMON_STYLE.opacity : style.opacity;\n        }\n        if (forceSetAll || style.blend !== prevStyle.blend) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;\n        }\n        for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {\n            var propName = SHADOW_NUMBER_PROPS[i];\n            if (forceSetAll || style[propName] !== prevStyle[propName]) {\n                if (!styleChanged) {\n                    flushPathDrawn(ctx, scope);\n                    styleChanged = true;\n                }\n                ctx[propName] = ctx.dpr * (style[propName] || 0);\n            }\n        }\n        if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;\n        }\n        return styleChanged;\n    }\n    function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {\n        var style = getStyle(el, scope.inHover);\n        var prevStyle = forceSetAll\n            ? null\n            : (prevEl && getStyle(prevEl, scope.inHover) || {});\n        if (style === prevStyle) {\n            return false;\n        }\n        var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);\n        if (forceSetAll || style.fill !== prevStyle.fill) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.fillStyle = style.fill;\n        }\n        if (forceSetAll || style.stroke !== prevStyle.stroke) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.strokeStyle = style.stroke;\n        }\n        if (forceSetAll || style.opacity !== prevStyle.opacity) {\n            if (!styleChanged) {\n                flushPathDrawn(ctx, scope);\n                styleChanged = true;\n            }\n            ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n        }\n        if (el.hasStroke()) {\n            var lineWidth = style.lineWidth;\n            var newLineWidth = lineWidth / ((style.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1);\n            if (ctx.lineWidth !== newLineWidth) {\n                if (!styleChanged) {\n                    flushPathDrawn(ctx, scope);\n                    styleChanged = true;\n                }\n                ctx.lineWidth = newLineWidth;\n            }\n        }\n        for (var i = 0; i < STROKE_PROPS.length; i++) {\n            var prop = STROKE_PROPS[i];\n            var propName = prop[0];\n            if (forceSetAll || style[propName] !== prevStyle[propName]) {\n                if (!styleChanged) {\n                    flushPathDrawn(ctx, scope);\n                    styleChanged = true;\n                }\n                ctx[propName] = style[propName] || prop[1];\n            }\n        }\n        return styleChanged;\n    }\n    function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {\n        return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);\n    }\n    function setContextTransform(ctx, el) {\n        var m = el.transform;\n        var dpr = ctx.dpr || 1;\n        if (m) {\n            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n        }\n        else {\n            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n        }\n    }\n    function updateClipStatus(clipPaths, ctx, scope) {\n        var allClipped = false;\n        for (var i = 0; i < clipPaths.length; i++) {\n            var clipPath = clipPaths[i];\n            allClipped = allClipped || clipPath.isZeroArea();\n            setContextTransform(ctx, clipPath);\n            ctx.beginPath();\n            clipPath.buildPath(ctx, clipPath.shape);\n            ctx.clip();\n        }\n        scope.allClipped = allClipped;\n    }\n    function isTransformChanged(m0, m1) {\n        if (m0 && m1) {\n            return m0[0] !== m1[0]\n                || m0[1] !== m1[1]\n                || m0[2] !== m1[2]\n                || m0[3] !== m1[3]\n                || m0[4] !== m1[4]\n                || m0[5] !== m1[5];\n        }\n        else if (!m0 && !m1) {\n            return false;\n        }\n        return true;\n    }\n    var DRAW_TYPE_PATH = 1;\n    var DRAW_TYPE_IMAGE = 2;\n    var DRAW_TYPE_TEXT = 3;\n    var DRAW_TYPE_INCREMENTAL = 4;\n    function canPathBatch(style) {\n        var hasFill = styleHasFill(style);\n        var hasStroke = styleHasStroke(style);\n        return !(style.lineDash\n            || !(+hasFill ^ +hasStroke)\n            || (hasFill && typeof style.fill !== 'string')\n            || (hasStroke && typeof style.stroke !== 'string')\n            || style.strokePercent < 1\n            || style.strokeOpacity < 1\n            || style.fillOpacity < 1);\n    }\n    function flushPathDrawn(ctx, scope) {\n        scope.batchFill && ctx.fill();\n        scope.batchStroke && ctx.stroke();\n        scope.batchFill = '';\n        scope.batchStroke = '';\n    }\n    function getStyle(el, inHover) {\n        return inHover ? (el.__hoverStyle || el.style) : el.style;\n    }\n    function brushSingle(ctx, el) {\n        brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);\n    }\n    function brush(ctx, el, scope, isLast) {\n        var m = el.transform;\n        if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {\n            el.__dirty &= ~Element.REDARAW_BIT;\n            el.__isRendered = false;\n            return;\n        }\n        var clipPaths = el.__clipPaths;\n        var prevElClipPaths = scope.prevElClipPaths;\n        var forceSetTransform = false;\n        var forceSetStyle = false;\n        if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n            if (prevElClipPaths && prevElClipPaths.length) {\n                flushPathDrawn(ctx, scope);\n                ctx.restore();\n                forceSetStyle = forceSetTransform = true;\n                scope.prevElClipPaths = null;\n                scope.allClipped = false;\n                scope.prevEl = null;\n            }\n            if (clipPaths && clipPaths.length) {\n                flushPathDrawn(ctx, scope);\n                ctx.save();\n                updateClipStatus(clipPaths, ctx, scope);\n                forceSetTransform = true;\n            }\n            scope.prevElClipPaths = clipPaths;\n        }\n        if (scope.allClipped) {\n            el.__isRendered = false;\n            return;\n        }\n        el.beforeBrush && el.beforeBrush();\n        el.innerBeforeBrush();\n        var prevEl = scope.prevEl;\n        if (!prevEl) {\n            forceSetStyle = forceSetTransform = true;\n        }\n        var canBatchPath = el instanceof Path\n            && el.autoBatch\n            && canPathBatch(el.style);\n        if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {\n            flushPathDrawn(ctx, scope);\n            setContextTransform(ctx, el);\n        }\n        else if (!canBatchPath) {\n            flushPathDrawn(ctx, scope);\n        }\n        var style = getStyle(el, scope.inHover);\n        if (el instanceof Path) {\n            if (scope.lastDrawType !== DRAW_TYPE_PATH) {\n                forceSetStyle = true;\n                scope.lastDrawType = DRAW_TYPE_PATH;\n            }\n            bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n            if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {\n                ctx.beginPath();\n            }\n            brushPath(ctx, el, style, canBatchPath);\n            if (canBatchPath) {\n                scope.batchFill = style.fill || '';\n                scope.batchStroke = style.stroke || '';\n            }\n        }\n        else {\n            if (el instanceof TSpan) {\n                if (scope.lastDrawType !== DRAW_TYPE_TEXT) {\n                    forceSetStyle = true;\n                    scope.lastDrawType = DRAW_TYPE_TEXT;\n                }\n                bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);\n                brushText(ctx, el, style);\n            }\n            else if (el instanceof ZRImage) {\n                if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {\n                    forceSetStyle = true;\n                    scope.lastDrawType = DRAW_TYPE_IMAGE;\n                }\n                bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);\n                brushImage(ctx, el, style);\n            }\n            else if (el instanceof IncrementalDisplayable) {\n                if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {\n                    forceSetStyle = true;\n                    scope.lastDrawType = DRAW_TYPE_INCREMENTAL;\n                }\n                brushIncremental(ctx, el, scope);\n            }\n        }\n        if (canBatchPath && isLast) {\n            flushPathDrawn(ctx, scope);\n        }\n        el.innerAfterBrush();\n        el.afterBrush && el.afterBrush();\n        scope.prevEl = el;\n        el.__dirty = 0;\n        el.__isRendered = true;\n    }\n    function brushIncremental(ctx, el, scope) {\n        var displayables = el.getDisplayables();\n        var temporalDisplayables = el.getTemporalDisplayables();\n        ctx.save();\n        var innerScope = {\n            prevElClipPaths: null,\n            prevEl: null,\n            allClipped: false,\n            viewWidth: scope.viewWidth,\n            viewHeight: scope.viewHeight,\n            inHover: scope.inHover\n        };\n        var i;\n        var len;\n        for (i = el.getCursor(), len = displayables.length; i < len; i++) {\n            var displayable = displayables[i];\n            displayable.beforeBrush && displayable.beforeBrush();\n            displayable.innerBeforeBrush();\n            brush(ctx, displayable, innerScope, i === len - 1);\n            displayable.innerAfterBrush();\n            displayable.afterBrush && displayable.afterBrush();\n            innerScope.prevEl = displayable;\n        }\n        for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {\n            var displayable = temporalDisplayables[i_1];\n            displayable.beforeBrush && displayable.beforeBrush();\n            displayable.innerBeforeBrush();\n            brush(ctx, displayable, innerScope, i_1 === len_1 - 1);\n            displayable.innerAfterBrush();\n            displayable.afterBrush && displayable.afterBrush();\n            innerScope.prevEl = displayable;\n        }\n        el.clearTemporalDisplayables();\n        el.notClear = true;\n        ctx.restore();\n    }\n\n    var decalMap = new WeakMap();\n    var decalCache = new LRU(100);\n    var decalKeys = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'maxTileWidth', 'maxTileHeight'];\n    function createOrUpdatePatternFromDecal(decalObject, api) {\n      if (decalObject === 'none') {\n        return null;\n      }\n\n      var dpr = api.getDevicePixelRatio();\n      var zr = api.getZr();\n      var isSVG = zr.painter.type === 'svg';\n\n      if (decalObject.dirty) {\n        decalMap[\"delete\"](decalObject);\n      }\n\n      var oldPattern = decalMap.get(decalObject);\n\n      if (oldPattern) {\n        return oldPattern;\n      }\n\n      var decalOpt = defaults(decalObject, {\n        symbol: 'rect',\n        symbolSize: 1,\n        symbolKeepAspect: true,\n        color: 'rgba(0, 0, 0, 0.2)',\n        backgroundColor: null,\n        dashArrayX: 5,\n        dashArrayY: 5,\n        rotation: 0,\n        maxTileWidth: 512,\n        maxTileHeight: 512\n      });\n\n      if (decalOpt.backgroundColor === 'none') {\n        decalOpt.backgroundColor = null;\n      }\n\n      var pattern = {\n        repeat: 'repeat'\n      };\n      setPatternnSource(pattern);\n      pattern.rotation = decalOpt.rotation;\n      pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr;\n      decalMap.set(decalObject, pattern);\n      decalObject.dirty = false;\n      return pattern;\n\n      function setPatternnSource(pattern) {\n        var keys = [dpr];\n        var isValidKey = true;\n\n        for (var i = 0; i < decalKeys.length; ++i) {\n          var value = decalOpt[decalKeys[i]];\n          var valueType = typeof value;\n\n          if (value != null && !isArray(value) && valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {\n            isValidKey = false;\n            break;\n          }\n\n          keys.push(value);\n        }\n\n        var cacheKey;\n\n        if (isValidKey) {\n          cacheKey = keys.join(',') + (isSVG ? '-svg' : '');\n          var cache = decalCache.get(cacheKey);\n\n          if (cache) {\n            isSVG ? pattern.svgElement = cache : pattern.image = cache;\n          }\n        }\n\n        var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);\n        var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);\n        var symbolArray = normalizeSymbolArray(decalOpt.symbol);\n        var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);\n        var lineBlockLengthY = getLineBlockLengthY(dashArrayY);\n        var canvas = !isSVG && createCanvas();\n        var svgRoot = isSVG && zr.painter.createSVGElement('g');\n        var pSize = getPatternSize();\n        var ctx;\n\n        if (canvas) {\n          canvas.width = pSize.width * dpr;\n          canvas.height = pSize.height * dpr;\n          ctx = canvas.getContext('2d');\n        }\n\n        brushDecal();\n\n        if (isValidKey) {\n          decalCache.put(cacheKey, canvas || svgRoot);\n        }\n\n        pattern.image = canvas;\n        pattern.svgElement = svgRoot;\n        pattern.svgWidth = pSize.width;\n        pattern.svgHeight = pSize.height;\n\n        function getPatternSize() {\n          var width = 1;\n\n          for (var i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {\n            width = getLeastCommonMultiple(width, lineBlockLengthsX[i]);\n          }\n\n          var symbolRepeats = 1;\n\n          for (var i = 0, xlen = symbolArray.length; i < xlen; ++i) {\n            symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i].length);\n          }\n\n          width *= symbolRepeats;\n          var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;\n\n          if (\"development\" !== 'production') {\n            var warn = function (attrName) {\n              console.warn(\"Calculated decal size is greater than \" + attrName + \" due to decal option settings so \" + attrName + \" is used for the decal size. Please consider changing the decal option to make a smaller decal or set \" + attrName + \" to be larger to avoid incontinuity.\");\n            };\n\n            if (width > decalOpt.maxTileWidth) {\n              warn('maxTileWidth');\n            }\n\n            if (height > decalOpt.maxTileHeight) {\n              warn('maxTileHeight');\n            }\n          }\n\n          return {\n            width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),\n            height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))\n          };\n        }\n\n        function brushDecal() {\n          if (ctx) {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n            if (decalOpt.backgroundColor) {\n              ctx.fillStyle = decalOpt.backgroundColor;\n              ctx.fillRect(0, 0, canvas.width, canvas.height);\n            }\n          }\n\n          var ySum = 0;\n\n          for (var i = 0; i < dashArrayY.length; ++i) {\n            ySum += dashArrayY[i];\n          }\n\n          if (ySum <= 0) {\n            return;\n          }\n\n          var y = -lineBlockLengthY;\n          var yId = 0;\n          var yIdTotal = 0;\n          var xId0 = 0;\n\n          while (y < pSize.height) {\n            if (yId % 2 === 0) {\n              var symbolYId = yIdTotal / 2 % symbolArray.length;\n              var x = 0;\n              var xId1 = 0;\n              var xId1Total = 0;\n\n              while (x < pSize.width * 2) {\n                var xSum = 0;\n\n                for (var i = 0; i < dashArrayX[xId0].length; ++i) {\n                  xSum += dashArrayX[xId0][i];\n                }\n\n                if (xSum <= 0) {\n                  break;\n                }\n\n                if (xId1 % 2 === 0) {\n                  var size = (1 - decalOpt.symbolSize) * 0.5;\n                  var left = x + dashArrayX[xId0][xId1] * size;\n                  var top_1 = y + dashArrayY[yId] * size;\n                  var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;\n                  var height = dashArrayY[yId] * decalOpt.symbolSize;\n                  var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;\n                  brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);\n                }\n\n                x += dashArrayX[xId0][xId1];\n                ++xId1Total;\n                ++xId1;\n\n                if (xId1 === dashArrayX[xId0].length) {\n                  xId1 = 0;\n                }\n              }\n\n              ++xId0;\n\n              if (xId0 === dashArrayX.length) {\n                xId0 = 0;\n              }\n            }\n\n            y += dashArrayY[yId];\n            ++yIdTotal;\n            ++yId;\n\n            if (yId === dashArrayY.length) {\n              yId = 0;\n            }\n          }\n\n          function brushSymbol(x, y, width, height, symbolType) {\n            var scale = isSVG ? 1 : dpr;\n            var symbol = createSymbol(symbolType, x * scale, y * scale, width * scale, height * scale, decalOpt.color, decalOpt.symbolKeepAspect);\n\n            if (isSVG) {\n              svgRoot.appendChild(zr.painter.paintOne(symbol));\n            } else {\n              brushSingle(ctx, symbol);\n            }\n          }\n        }\n      }\n    }\n\n    function normalizeSymbolArray(symbol) {\n      if (!symbol || symbol.length === 0) {\n        return [['rect']];\n      }\n\n      if (typeof symbol === 'string') {\n        return [[symbol]];\n      }\n\n      var isAllString = true;\n\n      for (var i = 0; i < symbol.length; ++i) {\n        if (typeof symbol[i] !== 'string') {\n          isAllString = false;\n          break;\n        }\n      }\n\n      if (isAllString) {\n        return normalizeSymbolArray([symbol]);\n      }\n\n      var result = [];\n\n      for (var i = 0; i < symbol.length; ++i) {\n        if (typeof symbol[i] === 'string') {\n          result.push([symbol[i]]);\n        } else {\n          result.push(symbol[i]);\n        }\n      }\n\n      return result;\n    }\n\n    function normalizeDashArrayX(dash) {\n      if (!dash || dash.length === 0) {\n        return [[0, 0]];\n      }\n\n      if (typeof dash === 'number') {\n        var dashValue = Math.ceil(dash);\n        return [[dashValue, dashValue]];\n      }\n\n      var isAllNumber = true;\n\n      for (var i = 0; i < dash.length; ++i) {\n        if (typeof dash[i] !== 'number') {\n          isAllNumber = false;\n          break;\n        }\n      }\n\n      if (isAllNumber) {\n        return normalizeDashArrayX([dash]);\n      }\n\n      var result = [];\n\n      for (var i = 0; i < dash.length; ++i) {\n        if (typeof dash[i] === 'number') {\n          var dashValue = Math.ceil(dash[i]);\n          result.push([dashValue, dashValue]);\n        } else {\n          var dashValue = map(dash[i], function (n) {\n            return Math.ceil(n);\n          });\n\n          if (dashValue.length % 2 === 1) {\n            result.push(dashValue.concat(dashValue));\n          } else {\n            result.push(dashValue);\n          }\n        }\n      }\n\n      return result;\n    }\n\n    function normalizeDashArrayY(dash) {\n      if (!dash || typeof dash === 'object' && dash.length === 0) {\n        return [0, 0];\n      }\n\n      if (typeof dash === 'number') {\n        var dashValue_1 = Math.ceil(dash);\n        return [dashValue_1, dashValue_1];\n      }\n\n      var dashValue = map(dash, function (n) {\n        return Math.ceil(n);\n      });\n      return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;\n    }\n\n    function getLineBlockLengthX(dash) {\n      return map(dash, function (line) {\n        return getLineBlockLengthY(line);\n      });\n    }\n\n    function getLineBlockLengthY(dash) {\n      var blockLength = 0;\n\n      for (var i = 0; i < dash.length; ++i) {\n        blockLength += dash[i];\n      }\n\n      if (dash.length % 2 === 1) {\n        return blockLength * 2;\n      }\n\n      return blockLength;\n    }\n\n    function decalVisual(ecModel, api) {\n      ecModel.eachRawSeries(function (seriesModel) {\n        if (ecModel.isSeriesFiltered(seriesModel)) {\n          return;\n        }\n\n        var data = seriesModel.getData();\n\n        if (data.hasItemVisual()) {\n          data.each(function (idx) {\n            var decal = data.getItemVisual(idx, 'decal');\n\n            if (decal) {\n              var itemStyle = data.ensureUniqueItemVisual(idx, 'style');\n              itemStyle.decal = createOrUpdatePatternFromDecal(decal, api);\n            }\n          });\n        }\n\n        var decal = data.getVisual('decal');\n\n        if (decal) {\n          var style = data.getVisual('style');\n          style.decal = createOrUpdatePatternFromDecal(decal, api);\n        }\n      });\n    }\n\n    var assert$1 = assert;\n    var each$3 = each;\n    var isFunction$1 = isFunction;\n    var isObject$2 = isObject;\n    var indexOf$1 = indexOf;\n    var hasWindow = typeof window !== 'undefined';\n    var version$1 = '5.0.1';\n    var dependencies = {\n      zrender: '5.0.3'\n    };\n    var TEST_FRAME_REMAIN_TIME = 1;\n    var PRIORITY_PROCESSOR_SERIES_FILTER = 800;\n    var PRIORITY_PROCESSOR_DATASTACK = 900;\n    var PRIORITY_PROCESSOR_FILTER = 1000;\n    var PRIORITY_PROCESSOR_DEFAULT = 2000;\n    var PRIORITY_PROCESSOR_STATISTIC = 5000;\n    var PRIORITY_VISUAL_LAYOUT = 1000;\n    var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;\n    var PRIORITY_VISUAL_GLOBAL = 2000;\n    var PRIORITY_VISUAL_CHART = 3000;\n    var PRIORITY_VISUAL_COMPONENT = 4000;\n    var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;\n    var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;\n    var PRIORITY_VISUAL_BRUSH = 5000;\n    var PRIORITY_VISUAL_ARIA = 6000;\n    var PRIORITY_VISUAL_DECAL = 7000;\n    var PRIORITY = {\n      PROCESSOR: {\n        FILTER: PRIORITY_PROCESSOR_FILTER,\n        SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,\n        STATISTIC: PRIORITY_PROCESSOR_STATISTIC\n      },\n      VISUAL: {\n        LAYOUT: PRIORITY_VISUAL_LAYOUT,\n        PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,\n        GLOBAL: PRIORITY_VISUAL_GLOBAL,\n        CHART: PRIORITY_VISUAL_CHART,\n        POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,\n        COMPONENT: PRIORITY_VISUAL_COMPONENT,\n        BRUSH: PRIORITY_VISUAL_BRUSH,\n        CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,\n        ARIA: PRIORITY_VISUAL_ARIA,\n        DECAL: PRIORITY_VISUAL_DECAL\n      }\n    };\n    var IN_MAIN_PROCESS_KEY = '__flagInMainProcess';\n    var OPTION_UPDATED_KEY = '__optionUpdated';\n    var STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus';\n    var ACTION_REG = /^[a-zA-Z0-9_]+$/;\n    var CONNECT_STATUS_KEY = '__connectUpdateStatus';\n    var CONNECT_STATUS_PENDING = 0;\n    var CONNECT_STATUS_UPDATING = 1;\n    var CONNECT_STATUS_UPDATED = 2;\n\n    function createRegisterEventWithLowercaseECharts(method) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        if (this.isDisposed()) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        return toLowercaseNameAndCallEventful(this, method, args);\n      };\n    }\n\n    function createRegisterEventWithLowercaseMessageCenter(method) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return toLowercaseNameAndCallEventful(this, method, args);\n      };\n    }\n\n    function toLowercaseNameAndCallEventful(host, method, args) {\n      args[0] = args[0] && args[0].toLowerCase();\n      return Eventful.prototype[method].apply(host, args);\n    }\n\n    var MessageCenter = function (_super) {\n      __extends(MessageCenter, _super);\n\n      function MessageCenter() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      return MessageCenter;\n    }(Eventful);\n\n    var messageCenterProto = MessageCenter.prototype;\n    messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on');\n    messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off');\n    var prepare;\n    var prepareView;\n    var updateDirectly;\n    var updateMethods;\n    var doConvertPixel;\n    var updateStreamModes;\n    var doDispatchAction;\n    var flushPendingActions;\n    var triggerUpdatedEvent;\n    var bindRenderedEvent;\n    var bindMouseEvent;\n    var clearColorPalette;\n    var render;\n    var renderComponents;\n    var renderSeries;\n    var performPostUpdateFuncs;\n    var createExtensionAPI;\n    var enableConnect;\n    var setTransitionOpt;\n    var markStatusToUpdate;\n    var applyChangedStates;\n\n    var ECharts = function (_super) {\n      __extends(ECharts, _super);\n\n      function ECharts(dom, theme, opts) {\n        var _this = _super.call(this, new ECEventProcessor()) || this;\n\n        _this._chartsViews = [];\n        _this._chartsMap = {};\n        _this._componentsViews = [];\n        _this._componentsMap = {};\n        _this._pendingActions = [];\n        opts = opts || {};\n\n        if (typeof theme === 'string') {\n          theme = themeStorage[theme];\n        }\n\n        _this._dom = dom;\n        var defaultRenderer = 'canvas';\n        var defaultUseDirtyRect = false;\n\n        if (\"development\" !== 'production') {\n          var root = hasWindow ? window : global;\n          defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;\n          var devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;\n          defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect;\n        }\n\n        var zr = _this._zr = init(dom, {\n          renderer: opts.renderer || defaultRenderer,\n          devicePixelRatio: opts.devicePixelRatio,\n          width: opts.width,\n          height: opts.height,\n          useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect\n        });\n        _this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);\n        theme = clone(theme);\n        theme && globalBackwardCompat(theme, true);\n        _this._theme = theme;\n        _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);\n        _this._coordSysMgr = new CoordinateSystemManager();\n        var api = _this._api = createExtensionAPI(_this);\n\n        function prioritySortFunc(a, b) {\n          return a.__prio - b.__prio;\n        }\n\n        sort(visualFuncs, prioritySortFunc);\n        sort(dataProcessorFuncs, prioritySortFunc);\n        _this._scheduler = new Scheduler(_this, api, dataProcessorFuncs, visualFuncs);\n        _this._messageCenter = new MessageCenter();\n        _this._labelManager = new LabelManager();\n\n        _this._initEvents();\n\n        _this.resize = bind(_this.resize, _this);\n        zr.animation.on('frame', _this._onframe, _this);\n        bindRenderedEvent(zr, _this);\n        bindMouseEvent(zr, _this);\n        setAsPrimitive(_this);\n        return _this;\n      }\n\n      ECharts.prototype._onframe = function () {\n        if (this._disposed) {\n          return;\n        }\n\n        applyChangedStates(this);\n        var scheduler = this._scheduler;\n\n        if (this[OPTION_UPDATED_KEY]) {\n          var silent = this[OPTION_UPDATED_KEY].silent;\n          this[IN_MAIN_PROCESS_KEY] = true;\n          prepare(this);\n          updateMethods.update.call(this);\n\n          this._zr.flush();\n\n          this[IN_MAIN_PROCESS_KEY] = false;\n          this[OPTION_UPDATED_KEY] = false;\n          flushPendingActions.call(this, silent);\n          triggerUpdatedEvent.call(this, silent);\n        } else if (scheduler.unfinished) {\n          var remainTime = TEST_FRAME_REMAIN_TIME;\n          var ecModel = this._model;\n          var api = this._api;\n          scheduler.unfinished = false;\n\n          do {\n            var startTime = +new Date();\n            scheduler.performSeriesTasks(ecModel);\n            scheduler.performDataProcessorTasks(ecModel);\n            updateStreamModes(this, ecModel);\n            scheduler.performVisualTasks(ecModel);\n            renderSeries(this, this._model, api, 'remain');\n            remainTime -= +new Date() - startTime;\n          } while (remainTime > 0 && scheduler.unfinished);\n\n          if (!scheduler.unfinished) {\n            this._zr.flush();\n          }\n        }\n      };\n\n      ECharts.prototype.getDom = function () {\n        return this._dom;\n      };\n\n      ECharts.prototype.getId = function () {\n        return this.id;\n      };\n\n      ECharts.prototype.getZr = function () {\n        return this._zr;\n      };\n\n      ECharts.prototype.setOption = function (option, notMerge, lazyUpdate) {\n        if (\"development\" !== 'production') {\n          assert$1(!this[IN_MAIN_PROCESS_KEY], '`setOption` should not be called during main process.');\n        }\n\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        var silent;\n        var replaceMerge;\n        var transitionOpt;\n\n        if (isObject$2(notMerge)) {\n          lazyUpdate = notMerge.lazyUpdate;\n          silent = notMerge.silent;\n          replaceMerge = notMerge.replaceMerge;\n          transitionOpt = notMerge.transition;\n          notMerge = notMerge.notMerge;\n        }\n\n        this[IN_MAIN_PROCESS_KEY] = true;\n\n        if (!this._model || notMerge) {\n          var optionManager = new OptionManager(this._api);\n          var theme = this._theme;\n          var ecModel = this._model = new GlobalModel();\n          ecModel.scheduler = this._scheduler;\n          ecModel.init(null, null, null, theme, this._locale, optionManager);\n        }\n\n        this._model.setOption(option, {\n          replaceMerge: replaceMerge\n        }, optionPreprocessorFuncs);\n\n        setTransitionOpt(this, transitionOpt);\n\n        if (lazyUpdate) {\n          this[OPTION_UPDATED_KEY] = {\n            silent: silent\n          };\n          this[IN_MAIN_PROCESS_KEY] = false;\n          this.getZr().wakeUp();\n        } else {\n          prepare(this);\n          updateMethods.update.call(this);\n\n          this._zr.flush();\n\n          this[OPTION_UPDATED_KEY] = false;\n          this[IN_MAIN_PROCESS_KEY] = false;\n          flushPendingActions.call(this, silent);\n          triggerUpdatedEvent.call(this, silent);\n        }\n      };\n\n      ECharts.prototype.setTheme = function () {\n        console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0');\n      };\n\n      ECharts.prototype.getModel = function () {\n        return this._model;\n      };\n\n      ECharts.prototype.getOption = function () {\n        return this._model && this._model.getOption();\n      };\n\n      ECharts.prototype.getWidth = function () {\n        return this._zr.getWidth();\n      };\n\n      ECharts.prototype.getHeight = function () {\n        return this._zr.getHeight();\n      };\n\n      ECharts.prototype.getDevicePixelRatio = function () {\n        return this._zr.painter.dpr || hasWindow && window.devicePixelRatio || 1;\n      };\n\n      ECharts.prototype.getRenderedCanvas = function (opts) {\n        if (!env.canvasSupported) {\n          return;\n        }\n\n        opts = extend({}, opts || {});\n        opts.pixelRatio = opts.pixelRatio || 1;\n        opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');\n        var zr = this._zr;\n        return zr.painter.getRenderedCanvas(opts);\n      };\n\n      ECharts.prototype.getSvgDataURL = function () {\n        if (!env.svgSupported) {\n          return;\n        }\n\n        var zr = this._zr;\n        var list = zr.storage.getDisplayList();\n        each(list, function (el) {\n          el.stopAnimation(null, true);\n        });\n        return zr.painter.toDataURL();\n      };\n\n      ECharts.prototype.getDataURL = function (opts) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        opts = opts || {};\n        var excludeComponents = opts.excludeComponents;\n        var ecModel = this._model;\n        var excludesComponentViews = [];\n        var self = this;\n        each$3(excludeComponents, function (componentType) {\n          ecModel.eachComponent({\n            mainType: componentType\n          }, function (component) {\n            var view = self._componentsMap[component.__viewId];\n\n            if (!view.group.ignore) {\n              excludesComponentViews.push(view);\n              view.group.ignore = true;\n            }\n          });\n        });\n        var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));\n        each$3(excludesComponentViews, function (view) {\n          view.group.ignore = false;\n        });\n        return url;\n      };\n\n      ECharts.prototype.getConnectedDataURL = function (opts) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        if (!env.canvasSupported) {\n          return;\n        }\n\n        var isSvg = opts.type === 'svg';\n        var groupId = this.group;\n        var mathMin = Math.min;\n        var mathMax = Math.max;\n        var MAX_NUMBER = Infinity;\n\n        if (connectedGroups[groupId]) {\n          var left_1 = MAX_NUMBER;\n          var top_1 = MAX_NUMBER;\n          var right_1 = -MAX_NUMBER;\n          var bottom_1 = -MAX_NUMBER;\n          var canvasList_1 = [];\n          var dpr_1 = opts && opts.pixelRatio || 1;\n          each(instances$1, function (chart, id) {\n            if (chart.group === groupId) {\n              var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(clone(opts));\n              var boundingRect = chart.getDom().getBoundingClientRect();\n              left_1 = mathMin(boundingRect.left, left_1);\n              top_1 = mathMin(boundingRect.top, top_1);\n              right_1 = mathMax(boundingRect.right, right_1);\n              bottom_1 = mathMax(boundingRect.bottom, bottom_1);\n              canvasList_1.push({\n                dom: canvas,\n                left: boundingRect.left,\n                top: boundingRect.top\n              });\n            }\n          });\n          left_1 *= dpr_1;\n          top_1 *= dpr_1;\n          right_1 *= dpr_1;\n          bottom_1 *= dpr_1;\n          var width = right_1 - left_1;\n          var height = bottom_1 - top_1;\n          var targetCanvas = createCanvas();\n          var zr_1 = init(targetCanvas, {\n            renderer: isSvg ? 'svg' : 'canvas'\n          });\n          zr_1.resize({\n            width: width,\n            height: height\n          });\n\n          if (isSvg) {\n            var content_1 = '';\n            each$3(canvasList_1, function (item) {\n              var x = item.left - left_1;\n              var y = item.top - top_1;\n              content_1 += '<g transform=\"translate(' + x + ',' + y + ')\">' + item.dom + '</g>';\n            });\n            zr_1.painter.getSvgRoot().innerHTML = content_1;\n\n            if (opts.connectedBackgroundColor) {\n              zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);\n            }\n\n            zr_1.refreshImmediately();\n            return zr_1.painter.toDataURL();\n          } else {\n            if (opts.connectedBackgroundColor) {\n              zr_1.add(new Rect({\n                shape: {\n                  x: 0,\n                  y: 0,\n                  width: width,\n                  height: height\n                },\n                style: {\n                  fill: opts.connectedBackgroundColor\n                }\n              }));\n            }\n\n            each$3(canvasList_1, function (item) {\n              var img = new ZRImage({\n                style: {\n                  x: item.left * dpr_1 - left_1,\n                  y: item.top * dpr_1 - top_1,\n                  image: item.dom\n                }\n              });\n              zr_1.add(img);\n            });\n            zr_1.refreshImmediately();\n            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));\n          }\n        } else {\n          return this.getDataURL(opts);\n        }\n      };\n\n      ECharts.prototype.convertToPixel = function (finder, value) {\n        return doConvertPixel(this, 'convertToPixel', finder, value);\n      };\n\n      ECharts.prototype.convertFromPixel = function (finder, value) {\n        return doConvertPixel(this, 'convertFromPixel', finder, value);\n      };\n\n      ECharts.prototype.containPixel = function (finder, value) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        var ecModel = this._model;\n        var result;\n        var findResult = parseFinder(ecModel, finder);\n        each(findResult, function (models, key) {\n          key.indexOf('Models') >= 0 && each(models, function (model) {\n            var coordSys = model.coordinateSystem;\n\n            if (coordSys && coordSys.containPoint) {\n              result = result || !!coordSys.containPoint(value);\n            } else if (key === 'seriesModels') {\n              var view = this._chartsMap[model.__viewId];\n\n              if (view && view.containPoint) {\n                result = result || view.containPoint(value, model);\n              } else {\n                if (\"development\" !== 'production') {\n                  console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.'));\n                }\n              }\n            } else {\n              if (\"development\" !== 'production') {\n                console.warn(key + ': containPoint is not supported');\n              }\n            }\n          }, this);\n        }, this);\n        return !!result;\n      };\n\n      ECharts.prototype.getVisual = function (finder, visualType) {\n        var ecModel = this._model;\n        var parsedFinder = parseFinder(ecModel, finder, {\n          defaultMainType: 'series'\n        });\n        var seriesModel = parsedFinder.seriesModel;\n\n        if (\"development\" !== 'production') {\n          if (!seriesModel) {\n            console.warn('There is no specified seires model');\n          }\n        }\n\n        var data = seriesModel.getData();\n        var dataIndexInside = parsedFinder.hasOwnProperty('dataIndexInside') ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;\n        return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);\n      };\n\n      ECharts.prototype.getViewOfComponentModel = function (componentModel) {\n        return this._componentsMap[componentModel.__viewId];\n      };\n\n      ECharts.prototype.getViewOfSeriesModel = function (seriesModel) {\n        return this._chartsMap[seriesModel.__viewId];\n      };\n\n      ECharts.prototype._initEvents = function () {\n        var _this = this;\n\n        each$3(MOUSE_EVENT_NAMES, function (eveName) {\n          var handler = function (e) {\n            var ecModel = _this.getModel();\n\n            var el = e.target;\n            var params;\n            var isGlobalOut = eveName === 'globalout';\n\n            if (isGlobalOut) {\n              params = {};\n            } else {\n              el && findEventDispatcher(el, function (parent) {\n                var ecData = getECData(parent);\n\n                if (ecData && ecData.dataIndex != null) {\n                  var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);\n                  params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};\n                  return true;\n                } else if (ecData.eventData) {\n                  params = extend({}, ecData.eventData);\n                  return true;\n                }\n              }, true);\n            }\n\n            if (params) {\n              var componentType = params.componentType;\n              var componentIndex = params.componentIndex;\n\n              if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {\n                componentType = 'series';\n                componentIndex = params.seriesIndex;\n              }\n\n              var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);\n              var view = model && _this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];\n\n              if (\"development\" !== 'production') {\n                if (!isGlobalOut && !(model && view)) {\n                  console.warn('model or view can not be found by params');\n                }\n              }\n\n              params.event = e;\n              params.type = eveName;\n              _this._$eventProcessor.eventInfo = {\n                targetEl: el,\n                packedEvent: params,\n                model: model,\n                view: view\n              };\n\n              _this.trigger(eveName, params);\n            }\n          };\n\n          handler.zrEventfulCallAtLast = true;\n\n          _this._zr.on(eveName, handler, _this);\n        });\n        each$3(eventActionMap, function (actionType, eventType) {\n          _this._messageCenter.on(eventType, function (event) {\n            this.trigger(eventType, event);\n          }, _this);\n        });\n        each$3(['selectchanged'], function (eventType) {\n          _this._messageCenter.on(eventType, function (event) {\n            this.trigger(eventType, event);\n          }, _this);\n        });\n        handleLegacySelectEvents(this._messageCenter, this, this._api);\n      };\n\n      ECharts.prototype.isDisposed = function () {\n        return this._disposed;\n      };\n\n      ECharts.prototype.clear = function () {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        this.setOption({\n          series: []\n        }, true);\n      };\n\n      ECharts.prototype.dispose = function () {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        this._disposed = true;\n        setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');\n        var api = this._api;\n        var ecModel = this._model;\n        each$3(this._componentsViews, function (component) {\n          component.dispose(ecModel, api);\n        });\n        each$3(this._chartsViews, function (chart) {\n          chart.dispose(ecModel, api);\n        });\n\n        this._zr.dispose();\n\n        delete instances$1[this.id];\n      };\n\n      ECharts.prototype.resize = function (opts) {\n        if (\"development\" !== 'production') {\n          assert$1(!this[IN_MAIN_PROCESS_KEY], '`resize` should not be called during main process.');\n        }\n\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        this._zr.resize(opts);\n\n        var ecModel = this._model;\n        this._loadingFX && this._loadingFX.resize();\n\n        if (!ecModel) {\n          return;\n        }\n\n        var optionChanged = ecModel.resetOption('media');\n        var silent = opts && opts.silent;\n        this[IN_MAIN_PROCESS_KEY] = true;\n        optionChanged && prepare(this);\n        updateMethods.update.call(this, {\n          type: 'resize',\n          animation: {\n            duration: 0\n          }\n        });\n        this[IN_MAIN_PROCESS_KEY] = false;\n        flushPendingActions.call(this, silent);\n        triggerUpdatedEvent.call(this, silent);\n      };\n\n      ECharts.prototype.showLoading = function (name, cfg) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        if (isObject$2(name)) {\n          cfg = name;\n          name = '';\n        }\n\n        name = name || 'default';\n        this.hideLoading();\n\n        if (!loadingEffects[name]) {\n          if (\"development\" !== 'production') {\n            console.warn('Loading effects ' + name + ' not exists.');\n          }\n\n          return;\n        }\n\n        var el = loadingEffects[name](this._api, cfg);\n        var zr = this._zr;\n        this._loadingFX = el;\n        zr.add(el);\n      };\n\n      ECharts.prototype.hideLoading = function () {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        this._loadingFX && this._zr.remove(this._loadingFX);\n        this._loadingFX = null;\n      };\n\n      ECharts.prototype.makeActionFromEvent = function (eventObj) {\n        var payload = extend({}, eventObj);\n        payload.type = eventActionMap[eventObj.type];\n        return payload;\n      };\n\n      ECharts.prototype.dispatchAction = function (payload, opt) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        if (!isObject$2(opt)) {\n          opt = {\n            silent: !!opt\n          };\n        }\n\n        if (!actions[payload.type]) {\n          return;\n        }\n\n        if (!this._model) {\n          return;\n        }\n\n        if (this[IN_MAIN_PROCESS_KEY]) {\n          this._pendingActions.push(payload);\n\n          return;\n        }\n\n        var silent = opt.silent;\n        doDispatchAction.call(this, payload, silent);\n        var flush = opt.flush;\n\n        if (flush) {\n          this._zr.flush();\n        } else if (flush !== false && env.browser.weChat) {\n          this._throttledZrFlush();\n        }\n\n        flushPendingActions.call(this, silent);\n        triggerUpdatedEvent.call(this, silent);\n      };\n\n      ECharts.prototype.updateLabelLayout = function () {\n        var labelManager = this._labelManager;\n        labelManager.updateLayoutConfig(this._api);\n        labelManager.layout(this._api);\n        labelManager.processLabelsOverall();\n      };\n\n      ECharts.prototype.appendData = function (params) {\n        if (this._disposed) {\n          disposedWarning(this.id);\n          return;\n        }\n\n        var seriesIndex = params.seriesIndex;\n        var ecModel = this.getModel();\n        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n        if (\"development\" !== 'production') {\n          assert$1(params.data && seriesModel);\n        }\n\n        seriesModel.appendData(params);\n        this._scheduler.unfinished = true;\n        this.getZr().wakeUp();\n      };\n\n      ECharts.internalField = function () {\n        prepare = function (ecIns) {\n          var scheduler = ecIns._scheduler;\n          scheduler.restorePipelines(ecIns._model);\n          scheduler.prepareStageTasks();\n          prepareView(ecIns, true);\n          prepareView(ecIns, false);\n          scheduler.plan();\n        };\n\n        prepareView = function (ecIns, isComponent) {\n          var ecModel = ecIns._model;\n          var scheduler = ecIns._scheduler;\n          var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;\n          var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;\n          var zr = ecIns._zr;\n          var api = ecIns._api;\n\n          for (var i = 0; i < viewList.length; i++) {\n            viewList[i].__alive = false;\n          }\n\n          isComponent ? ecModel.eachComponent(function (componentType, model) {\n            componentType !== 'series' && doPrepare(model);\n          }) : ecModel.eachSeries(doPrepare);\n\n          function doPrepare(model) {\n            var requireNewView = model.__requireNewView;\n            model.__requireNewView = false;\n            var viewId = '_ec_' + model.id + '_' + model.type;\n            var view = !requireNewView && viewMap[viewId];\n\n            if (!view) {\n              var classType = parseClassType(model.type);\n              var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);\n\n              if (\"development\" !== 'production') {\n                assert$1(Clazz, classType.sub + ' does not exist.');\n              }\n\n              view = new Clazz();\n              view.init(ecModel, api);\n              viewMap[viewId] = view;\n              viewList.push(view);\n              zr.add(view.group);\n            }\n\n            model.__viewId = view.__id = viewId;\n            view.__alive = true;\n            view.__model = model;\n            view.group.__ecComponentInfo = {\n              mainType: model.mainType,\n              index: model.componentIndex\n            };\n            !isComponent && scheduler.prepareView(view, model, ecModel, api);\n          }\n\n          for (var i = 0; i < viewList.length;) {\n            var view = viewList[i];\n\n            if (!view.__alive) {\n              !isComponent && view.renderTask.dispose();\n              zr.remove(view.group);\n              view.dispose(ecModel, api);\n              viewList.splice(i, 1);\n\n              if (viewMap[view.__id] === view) {\n                delete viewMap[view.__id];\n              }\n\n              view.__id = view.group.__ecComponentInfo = null;\n            } else {\n              i++;\n            }\n          }\n        };\n\n        updateDirectly = function (ecIns, method, payload, mainType, subType) {\n          var ecModel = ecIns._model;\n          ecModel.setUpdatePayload(payload);\n\n          if (!mainType) {\n            each$3([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);\n            return;\n          }\n\n          var query = {};\n          query[mainType + 'Id'] = payload[mainType + 'Id'];\n          query[mainType + 'Index'] = payload[mainType + 'Index'];\n          query[mainType + 'Name'] = payload[mainType + 'Name'];\n          var condition = {\n            mainType: mainType,\n            query: query\n          };\n          subType && (condition.subType = subType);\n          var excludeSeriesId = payload.excludeSeriesId;\n          var excludeSeriesIdMap;\n\n          if (excludeSeriesId != null) {\n            excludeSeriesIdMap = createHashMap();\n            each$3(normalizeToArray(excludeSeriesId), function (id) {\n              var modelId = convertOptionIdName(id, null);\n\n              if (modelId != null) {\n                excludeSeriesIdMap.set(modelId, true);\n              }\n            });\n          }\n\n          ecModel && ecModel.eachComponent(condition, function (model) {\n            if (!excludeSeriesIdMap || excludeSeriesIdMap.get(model.id) == null) {\n              if (isHighDownPayload(payload) && !payload.notBlur) {\n                if (model instanceof SeriesModel) {\n                  toggleSeriesBlurStateFromPayload(model, payload, ecIns._api);\n                }\n              } else if (isSelectChangePayload(payload)) {\n                if (model instanceof SeriesModel) {\n                  toggleSelectionFromPayload(model, payload, ecIns._api);\n                  updateSeriesElementSelection(model);\n                  markStatusToUpdate(ecIns);\n                }\n              }\n\n              callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);\n            }\n          }, ecIns);\n\n          function callView(view) {\n            view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);\n          }\n        };\n\n        updateMethods = {\n          prepareAndUpdate: function (payload) {\n            prepare(this);\n            updateMethods.update.call(this, payload);\n          },\n          update: function (payload) {\n            var ecModel = this._model;\n            var api = this._api;\n            var zr = this._zr;\n            var coordSysMgr = this._coordSysMgr;\n            var scheduler = this._scheduler;\n\n            if (!ecModel) {\n              return;\n            }\n\n            ecModel.setUpdatePayload(payload);\n            scheduler.restoreData(ecModel, payload);\n            scheduler.performSeriesTasks(ecModel);\n            coordSysMgr.create(ecModel, api);\n            scheduler.performDataProcessorTasks(ecModel, payload);\n            updateStreamModes(this, ecModel);\n            coordSysMgr.update(ecModel, api);\n            clearColorPalette(ecModel);\n            scheduler.performVisualTasks(ecModel, payload);\n            render(this, ecModel, api, payload);\n            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';\n            var darkMode = ecModel.get('darkMode');\n\n            if (!env.canvasSupported) {\n              var colorArr = parse(backgroundColor);\n              backgroundColor = stringify(colorArr, 'rgb');\n\n              if (colorArr[3] === 0) {\n                backgroundColor = 'transparent';\n              }\n            } else {\n              zr.setBackgroundColor(backgroundColor);\n\n              if (darkMode != null && darkMode !== 'auto') {\n                zr.setDarkMode(darkMode);\n              }\n            }\n\n            performPostUpdateFuncs(ecModel, api);\n          },\n          updateTransform: function (payload) {\n            var _this = this;\n\n            var ecModel = this._model;\n            var api = this._api;\n\n            if (!ecModel) {\n              return;\n            }\n\n            ecModel.setUpdatePayload(payload);\n            var componentDirtyList = [];\n            ecModel.eachComponent(function (componentType, componentModel) {\n              if (componentType === 'series') {\n                return;\n              }\n\n              var componentView = _this.getViewOfComponentModel(componentModel);\n\n              if (componentView && componentView.__alive) {\n                if (componentView.updateTransform) {\n                  var result = componentView.updateTransform(componentModel, ecModel, api, payload);\n                  result && result.update && componentDirtyList.push(componentView);\n                } else {\n                  componentDirtyList.push(componentView);\n                }\n              }\n            });\n            var seriesDirtyMap = createHashMap();\n            ecModel.eachSeries(function (seriesModel) {\n              var chartView = _this._chartsMap[seriesModel.__viewId];\n\n              if (chartView.updateTransform) {\n                var result = chartView.updateTransform(seriesModel, ecModel, api, payload);\n                result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);\n              } else {\n                seriesDirtyMap.set(seriesModel.uid, 1);\n              }\n            });\n            clearColorPalette(ecModel);\n\n            this._scheduler.performVisualTasks(ecModel, payload, {\n              setDirty: true,\n              dirtyMap: seriesDirtyMap\n            });\n\n            renderSeries(this, ecModel, api, payload, seriesDirtyMap);\n            performPostUpdateFuncs(ecModel, this._api);\n          },\n          updateView: function (payload) {\n            var ecModel = this._model;\n\n            if (!ecModel) {\n              return;\n            }\n\n            ecModel.setUpdatePayload(payload);\n            ChartView.markUpdateMethod(payload, 'updateView');\n            clearColorPalette(ecModel);\n\n            this._scheduler.performVisualTasks(ecModel, payload, {\n              setDirty: true\n            });\n\n            render(this, this._model, this._api, payload);\n            performPostUpdateFuncs(ecModel, this._api);\n          },\n          updateVisual: function (payload) {\n            var _this = this;\n\n            var ecModel = this._model;\n\n            if (!ecModel) {\n              return;\n            }\n\n            ecModel.setUpdatePayload(payload);\n            ecModel.eachSeries(function (seriesModel) {\n              seriesModel.getData().clearAllVisual();\n            });\n            ChartView.markUpdateMethod(payload, 'updateVisual');\n            clearColorPalette(ecModel);\n\n            this._scheduler.performVisualTasks(ecModel, payload, {\n              visualType: 'visual',\n              setDirty: true\n            });\n\n            ecModel.eachComponent(function (componentType, componentModel) {\n              if (componentType !== 'series') {\n                var componentView = _this.getViewOfComponentModel(componentModel);\n\n                componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);\n              }\n            });\n            ecModel.eachSeries(function (seriesModel) {\n              var chartView = _this._chartsMap[seriesModel.__viewId];\n              chartView.updateVisual(seriesModel, ecModel, _this._api, payload);\n            });\n            performPostUpdateFuncs(ecModel, this._api);\n          },\n          updateLayout: function (payload) {\n            updateMethods.update.call(this, payload);\n          }\n        };\n\n        doConvertPixel = function (ecIns, methodName, finder, value) {\n          if (ecIns._disposed) {\n            disposedWarning(ecIns.id);\n            return;\n          }\n\n          var ecModel = ecIns._model;\n\n          var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();\n\n          var result;\n          var parsedFinder = parseFinder(ecModel, finder);\n\n          for (var i = 0; i < coordSysList.length; i++) {\n            var coordSys = coordSysList[i];\n\n            if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {\n              return result;\n            }\n          }\n\n          if (\"development\" !== 'production') {\n            console.warn('No coordinate system that supports ' + methodName + ' found by the given finder.');\n          }\n        };\n\n        updateStreamModes = function (ecIns, ecModel) {\n          var chartsMap = ecIns._chartsMap;\n          var scheduler = ecIns._scheduler;\n          ecModel.eachSeries(function (seriesModel) {\n            scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);\n          });\n        };\n\n        doDispatchAction = function (payload, silent) {\n          var _this = this;\n\n          var ecModel = this.getModel();\n          var payloadType = payload.type;\n          var escapeConnect = payload.escapeConnect;\n          var actionWrap = actions[payloadType];\n          var actionInfo = actionWrap.actionInfo;\n          var cptTypeTmp = (actionInfo.update || 'update').split(':');\n          var updateMethod = cptTypeTmp.pop();\n          var cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);\n          this[IN_MAIN_PROCESS_KEY] = true;\n          var payloads = [payload];\n          var batched = false;\n\n          if (payload.batch) {\n            batched = true;\n            payloads = map(payload.batch, function (item) {\n              item = defaults(extend({}, item), payload);\n              item.batch = null;\n              return item;\n            });\n          }\n\n          var eventObjBatch = [];\n          var eventObj;\n          var isSelectChange = isSelectChangePayload(payload);\n          var isStatusChange = isHighDownPayload(payload) || isSelectChange;\n          each$3(payloads, function (batchItem) {\n            eventObj = actionWrap.action(batchItem, _this._model, _this._api);\n            eventObj = eventObj || extend({}, batchItem);\n            eventObj.type = actionInfo.event || eventObj.type;\n            eventObjBatch.push(eventObj);\n\n            if (isStatusChange) {\n              updateDirectly(_this, updateMethod, batchItem, 'series');\n              markStatusToUpdate(_this);\n            } else if (cptType) {\n              updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);\n            }\n          });\n\n          if (updateMethod !== 'none' && !isStatusChange && !cptType) {\n            if (this[OPTION_UPDATED_KEY]) {\n              prepare(this);\n              updateMethods.update.call(this, payload);\n              this[OPTION_UPDATED_KEY] = false;\n            } else {\n              updateMethods[updateMethod].call(this, payload);\n            }\n          }\n\n          if (batched) {\n            eventObj = {\n              type: actionInfo.event || payloadType,\n              escapeConnect: escapeConnect,\n              batch: eventObjBatch\n            };\n          } else {\n            eventObj = eventObjBatch[0];\n          }\n\n          this[IN_MAIN_PROCESS_KEY] = false;\n\n          if (!silent) {\n            var messageCenter = this._messageCenter;\n            messageCenter.trigger(eventObj.type, eventObj);\n\n            if (isSelectChange) {\n              var newObj = {\n                type: 'selectchanged',\n                escapeConnect: escapeConnect,\n                selected: getAllSelectedIndices(ecModel),\n                isFromClick: payload.isFromClick || false,\n                fromAction: payload.type,\n                fromActionPayload: payload\n              };\n              messageCenter.trigger(newObj.type, newObj);\n            }\n          }\n        };\n\n        flushPendingActions = function (silent) {\n          var pendingActions = this._pendingActions;\n\n          while (pendingActions.length) {\n            var payload = pendingActions.shift();\n            doDispatchAction.call(this, payload, silent);\n          }\n        };\n\n        triggerUpdatedEvent = function (silent) {\n          !silent && this.trigger('updated');\n        };\n\n        bindRenderedEvent = function (zr, ecIns) {\n          zr.on('rendered', function (params) {\n            ecIns.trigger('rendered', params);\n\n            if (zr.animation.isFinished() && !ecIns[OPTION_UPDATED_KEY] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {\n              ecIns.trigger('finished');\n            }\n          });\n        };\n\n        bindMouseEvent = function (zr, ecIns) {\n          zr.on('mouseover', function (e) {\n            var el = e.target;\n            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);\n\n            if (dispatcher) {\n              var ecData = getECData(dispatcher);\n              toggleSeriesBlurState(ecData.seriesIndex, ecData.focus, ecData.blurScope, ecIns._api, true);\n              enterEmphasisWhenMouseOver(dispatcher, e);\n              markStatusToUpdate(ecIns);\n            }\n          }).on('mouseout', function (e) {\n            var el = e.target;\n            var dispatcher = findEventDispatcher(el, isHighDownDispatcher);\n\n            if (dispatcher) {\n              var ecData = getECData(dispatcher);\n              toggleSeriesBlurState(ecData.seriesIndex, ecData.focus, ecData.blurScope, ecIns._api, false);\n              leaveEmphasisWhenMouseOut(dispatcher, e);\n              markStatusToUpdate(ecIns);\n            }\n          }).on('click', function (e) {\n            var el = e.target;\n            var dispatcher = findEventDispatcher(el, function (target) {\n              return getECData(target).dataIndex != null;\n            }, true);\n\n            if (dispatcher) {\n              var actionType = dispatcher.selected ? 'unselect' : 'select';\n              var ecData = getECData(dispatcher);\n\n              ecIns._api.dispatchAction({\n                type: actionType,\n                dataType: ecData.dataType,\n                dataIndexInside: ecData.dataIndex,\n                seriesIndex: ecData.seriesIndex,\n                isFromClick: true\n              });\n            }\n          });\n        };\n\n        clearColorPalette = function (ecModel) {\n          ecModel.clearColorPalette();\n          ecModel.eachSeries(function (seriesModel) {\n            seriesModel.clearColorPalette();\n          });\n        };\n\n        render = function (ecIns, ecModel, api, payload) {\n          renderComponents(ecIns, ecModel, api, payload);\n          each$3(ecIns._chartsViews, function (chart) {\n            chart.__alive = false;\n          });\n          renderSeries(ecIns, ecModel, api, payload);\n          each$3(ecIns._chartsViews, function (chart) {\n            if (!chart.__alive) {\n              chart.remove(ecModel, api);\n            }\n          });\n        };\n\n        renderComponents = function (ecIns, ecModel, api, payload, dirtyList) {\n          each$3(dirtyList || ecIns._componentsViews, function (componentView) {\n            var componentModel = componentView.__model;\n            clearStates(componentModel, componentView);\n            componentView.render(componentModel, ecModel, api, payload);\n            updateZ(componentModel, componentView);\n            updateStates(componentModel, componentView);\n          });\n        };\n\n        renderSeries = function (ecIns, ecModel, api, payload, dirtyMap) {\n          var scheduler = ecIns._scheduler;\n          var labelManager = ecIns._labelManager;\n          labelManager.clearLabels();\n          var unfinished = false;\n          ecModel.eachSeries(function (seriesModel) {\n            var chartView = ecIns._chartsMap[seriesModel.__viewId];\n            chartView.__alive = true;\n            var renderTask = chartView.renderTask;\n            scheduler.updatePayload(renderTask, payload);\n            clearStates(seriesModel, chartView);\n\n            if (dirtyMap && dirtyMap.get(seriesModel.uid)) {\n              renderTask.dirty();\n            }\n\n            if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {\n              unfinished = true;\n            }\n\n            seriesModel.__transientTransitionOpt = null;\n            chartView.group.silent = !!seriesModel.get('silent');\n            updateBlend(seriesModel, chartView);\n            updateSeriesElementSelection(seriesModel);\n            labelManager.addLabelsOfSeries(chartView);\n          });\n          scheduler.unfinished = unfinished || scheduler.unfinished;\n          labelManager.updateLayoutConfig(api);\n          labelManager.layout(api);\n          labelManager.processLabelsOverall();\n          ecModel.eachSeries(function (seriesModel) {\n            var chartView = ecIns._chartsMap[seriesModel.__viewId];\n            updateZ(seriesModel, chartView);\n            updateStates(seriesModel, chartView);\n          });\n          updateHoverLayerStatus(ecIns, ecModel);\n        };\n\n        performPostUpdateFuncs = function (ecModel, api) {\n          each$3(postUpdateFuncs, function (func) {\n            func(ecModel, api);\n          });\n        };\n\n        markStatusToUpdate = function (ecIns) {\n          ecIns[STATUS_NEEDS_UPDATE_KEY] = true;\n          ecIns.getZr().wakeUp();\n        };\n\n        applyChangedStates = function (ecIns) {\n          if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {\n            return;\n          }\n\n          ecIns.getZr().storage.traverse(function (el) {\n            if (isElementRemoved(el)) {\n              return;\n            }\n\n            applyElementStates(el);\n          });\n          ecIns[STATUS_NEEDS_UPDATE_KEY] = false;\n        };\n\n        function applyElementStates(el) {\n          var newStates = [];\n          var oldStates = el.currentStates;\n\n          for (var i = 0; i < oldStates.length; i++) {\n            var stateName = oldStates[i];\n\n            if (!(stateName === 'emphasis' || stateName === 'blur' || stateName === 'select')) {\n              newStates.push(stateName);\n            }\n          }\n\n          if (el.selected && el.states.select) {\n            newStates.push('select');\n          }\n\n          if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {\n            newStates.push('emphasis');\n          } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {\n            newStates.push('blur');\n          }\n\n          el.useStates(newStates);\n        }\n\n        function updateHoverLayerStatus(ecIns, ecModel) {\n          var zr = ecIns._zr;\n          var storage = zr.storage;\n          var elCount = 0;\n          storage.traverse(function (el) {\n            if (!el.isGroup) {\n              elCount++;\n            }\n          });\n\n          if (elCount > ecModel.get('hoverLayerThreshold') && !env.node && !env.worker) {\n            ecModel.eachSeries(function (seriesModel) {\n              if (seriesModel.preventUsingHoverLayer) {\n                return;\n              }\n\n              var chartView = ecIns._chartsMap[seriesModel.__viewId];\n\n              if (chartView.__alive) {\n                chartView.group.traverse(function (el) {\n                  if (el.states.emphasis) {\n                    el.states.emphasis.hoverLayer = true;\n                  }\n                });\n              }\n            });\n          }\n        }\n\n        function updateBlend(seriesModel, chartView) {\n          var blendMode = seriesModel.get('blendMode') || null;\n\n          if (\"development\" !== 'production') {\n            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {\n              console.warn('Only canvas support blendMode');\n            }\n          }\n\n          chartView.group.traverse(function (el) {\n            if (!el.isGroup) {\n              el.style.blend = blendMode;\n            }\n\n            if (el.eachPendingDisplayable) {\n              el.eachPendingDisplayable(function (displayable) {\n                displayable.style.blend = blendMode;\n              });\n            }\n          });\n        }\n\n        function updateZ(model, view) {\n          if (model.preventAutoZ) {\n            return;\n          }\n\n          var z = model.get('z');\n          var zlevel = model.get('zlevel');\n          view.group.traverse(function (el) {\n            if (!el.isGroup) {\n              z != null && (el.z = z);\n              zlevel != null && (el.zlevel = zlevel);\n              var label = el.getTextContent();\n              var labelLine = el.getTextGuideLine();\n\n              if (label) {\n                label.z = el.z;\n                label.zlevel = el.zlevel;\n                label.z2 = el.z2 + 2;\n              }\n\n              if (labelLine) {\n                var showAbove = el.textGuideLineConfig && el.textGuideLineConfig.showAbove;\n                labelLine.z = el.z;\n                labelLine.zlevel = el.zlevel;\n                labelLine.z2 = el.z2 + (showAbove ? 1 : -1);\n              }\n            }\n          });\n        }\n\n        function clearStates(model, view) {\n          view.group.traverse(function (el) {\n            if (isElementRemoved(el)) {\n              return;\n            }\n\n            var textContent = el.getTextContent();\n            var textGuide = el.getTextGuideLine();\n\n            if (el.stateTransition) {\n              el.stateTransition = null;\n            }\n\n            if (textContent && textContent.stateTransition) {\n              textContent.stateTransition = null;\n            }\n\n            if (textGuide && textGuide.stateTransition) {\n              textGuide.stateTransition = null;\n            }\n\n            if (el.hasState()) {\n              el.prevStates = el.currentStates;\n              el.clearStates();\n            } else if (el.prevStates) {\n              el.prevStates = null;\n            }\n          });\n        }\n\n        function updateStates(model, view) {\n          var stateAnimationModel = model.getModel('stateAnimation');\n          var enableAnimation = model.isAnimationEnabled();\n          var duration = stateAnimationModel.get('duration');\n          var stateTransition = duration > 0 ? {\n            duration: duration,\n            delay: stateAnimationModel.get('delay'),\n            easing: stateAnimationModel.get('easing')\n          } : null;\n          view.group.traverse(function (el) {\n            if (el.states && el.states.emphasis) {\n              if (isElementRemoved(el)) {\n                return;\n              }\n\n              if (el instanceof Path) {\n                savePathStates(el);\n              }\n\n              if (el.__dirty) {\n                var prevStates = el.prevStates;\n\n                if (prevStates) {\n                  el.useStates(prevStates);\n                }\n              }\n\n              if (enableAnimation) {\n                el.stateTransition = stateTransition;\n                var textContent = el.getTextContent();\n                var textGuide = el.getTextGuideLine();\n\n                if (textContent) {\n                  textContent.stateTransition = stateTransition;\n                }\n\n                if (textGuide) {\n                  textGuide.stateTransition = stateTransition;\n                }\n              }\n\n              if (el.__dirty) {\n                applyElementStates(el);\n              }\n            }\n          });\n        }\n\n        createExtensionAPI = function (ecIns) {\n          return new (function (_super) {\n            __extends(class_1, _super);\n\n            function class_1() {\n              return _super !== null && _super.apply(this, arguments) || this;\n            }\n\n            class_1.prototype.getCoordinateSystems = function () {\n              return ecIns._coordSysMgr.getCoordinateSystems();\n            };\n\n            class_1.prototype.getComponentByElement = function (el) {\n              while (el) {\n                var modelInfo = el.__ecComponentInfo;\n\n                if (modelInfo != null) {\n                  return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);\n                }\n\n                el = el.parent;\n              }\n            };\n\n            class_1.prototype.enterEmphasis = function (el, highlightDigit) {\n              enterEmphasis(el, highlightDigit);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.leaveEmphasis = function (el, highlightDigit) {\n              leaveEmphasis(el, highlightDigit);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.enterBlur = function (el) {\n              enterBlur(el);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.leaveBlur = function (el) {\n              leaveBlur(el);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.enterSelect = function (el) {\n              enterSelect(el);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.leaveSelect = function (el) {\n              leaveSelect(el);\n              markStatusToUpdate(ecIns);\n            };\n\n            class_1.prototype.getModel = function () {\n              return ecIns.getModel();\n            };\n\n            class_1.prototype.getViewOfComponentModel = function (componentModel) {\n              return ecIns.getViewOfComponentModel(componentModel);\n            };\n\n            class_1.prototype.getViewOfSeriesModel = function (seriesModel) {\n              return ecIns.getViewOfSeriesModel(seriesModel);\n            };\n\n            return class_1;\n          }(ExtensionAPI))(ecIns);\n        };\n\n        enableConnect = function (chart) {\n          function updateConnectedChartsStatus(charts, status) {\n            for (var i = 0; i < charts.length; i++) {\n              var otherChart = charts[i];\n              otherChart[CONNECT_STATUS_KEY] = status;\n            }\n          }\n\n          each$3(eventActionMap, function (actionType, eventType) {\n            chart._messageCenter.on(eventType, function (event) {\n              if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {\n                if (event && event.escapeConnect) {\n                  return;\n                }\n\n                var action_1 = chart.makeActionFromEvent(event);\n                var otherCharts_1 = [];\n                each$3(instances$1, function (otherChart) {\n                  if (otherChart !== chart && otherChart.group === chart.group) {\n                    otherCharts_1.push(otherChart);\n                  }\n                });\n                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);\n                each$3(otherCharts_1, function (otherChart) {\n                  if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {\n                    otherChart.dispatchAction(action_1);\n                  }\n                });\n                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);\n              }\n            });\n          });\n        };\n\n        setTransitionOpt = function (chart, transitionOpt) {\n          var ecModel = chart._model;\n          each(normalizeToArray(transitionOpt), function (transOpt) {\n            var errMsg;\n            var fromOpt = transOpt.from;\n            var toOpt = transOpt.to;\n\n            if (toOpt == null) {\n              if (\"development\" !== 'production') {\n                errMsg = '`transition.to` must be specified.';\n              }\n\n              throwError(errMsg);\n            }\n\n            var finderOpt = {\n              includeMainTypes: ['series'],\n              enableAll: false,\n              enableNone: false\n            };\n            var fromResult = fromOpt ? parseFinder(ecModel, fromOpt, finderOpt) : null;\n            var toResult = parseFinder(ecModel, toOpt, finderOpt);\n            var toSeries = toResult.seriesModel;\n\n            if (toSeries == null) {\n              errMsg = '';\n\n              if (\"development\" !== 'production') {\n                errMsg = '`transition` is only supported on series.';\n              }\n            }\n\n            if (fromResult && fromResult.seriesModel !== toSeries) {\n              errMsg = '';\n\n              if (\"development\" !== 'production') {\n                errMsg = '`transition.from` and `transition.to` must be specified to the same series.';\n              }\n            }\n\n            if (errMsg != null) {\n              throwError(errMsg);\n            }\n\n            toSeries.__transientTransitionOpt = {\n              from: fromOpt ? fromOpt.dimension : null,\n              to: toOpt.dimension,\n              dividingMethod: transOpt.dividingMethod\n            };\n          });\n        };\n      }();\n\n      return ECharts;\n    }(Eventful);\n\n    var echartsProto = ECharts.prototype;\n    echartsProto.on = createRegisterEventWithLowercaseECharts('on');\n    echartsProto.off = createRegisterEventWithLowercaseECharts('off');\n\n    echartsProto.one = function (eventName, cb, ctx) {\n      var self = this;\n      deprecateLog('ECharts#one is deprecated.');\n\n      function wrapped() {\n        var args2 = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args2[_i] = arguments[_i];\n        }\n\n        cb && cb.apply && cb.apply(this, args2);\n        self.off(eventName, wrapped);\n      }\n      this.on.call(this, eventName, wrapped, ctx);\n    };\n\n    var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];\n\n    function disposedWarning(id) {\n      if (\"development\" !== 'production') {\n        console.warn('Instance ' + id + ' has been disposed');\n      }\n    }\n\n    var actions = {};\n    var eventActionMap = {};\n    var dataProcessorFuncs = [];\n    var optionPreprocessorFuncs = [];\n    var postInitFuncs = [];\n    var postUpdateFuncs = [];\n    var visualFuncs = [];\n    var themeStorage = {};\n    var loadingEffects = {};\n    var instances$1 = {};\n    var connectedGroups = {};\n    var idBase = +new Date() - 0;\n    var groupIdBase = +new Date() - 0;\n    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';\n    function init$1(dom, theme, opts) {\n      if (\"development\" !== 'production') {\n        if (!dom) {\n          throw new Error('Initialize failed: invalid dom.');\n        }\n      }\n\n      var existInstance = getInstanceByDom(dom);\n\n      if (existInstance) {\n        if (\"development\" !== 'production') {\n          console.warn('There is a chart instance already initialized on the dom.');\n        }\n\n        return existInstance;\n      }\n\n      if (\"development\" !== 'production') {\n        if (isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {\n          console.warn('Can\\'t get DOM width or height. Please check ' + 'dom.clientWidth and dom.clientHeight. They should not be 0.' + 'For example, you may need to call this in the callback ' + 'of window.onload.');\n        }\n      }\n\n      var chart = new ECharts(dom, theme, opts);\n      chart.id = 'ec_' + idBase++;\n      instances$1[chart.id] = chart;\n      setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);\n      enableConnect(chart);\n      each$3(postInitFuncs, function (postInitFunc) {\n        postInitFunc(chart);\n      });\n      return chart;\n    }\n    function connect(groupId) {\n      if (isArray(groupId)) {\n        var charts = groupId;\n        groupId = null;\n        each$3(charts, function (chart) {\n          if (chart.group != null) {\n            groupId = chart.group;\n          }\n        });\n        groupId = groupId || 'g_' + groupIdBase++;\n        each$3(charts, function (chart) {\n          chart.group = groupId;\n        });\n      }\n\n      connectedGroups[groupId] = true;\n      return groupId;\n    }\n    function disConnect(groupId) {\n      connectedGroups[groupId] = false;\n    }\n    var disconnect = disConnect;\n    function dispose$1(chart) {\n      if (typeof chart === 'string') {\n        chart = instances$1[chart];\n      } else if (!(chart instanceof ECharts)) {\n        chart = getInstanceByDom(chart);\n      }\n\n      if (chart instanceof ECharts && !chart.isDisposed()) {\n        chart.dispose();\n      }\n    }\n    function getInstanceByDom(dom) {\n      return instances$1[getAttribute(dom, DOM_ATTRIBUTE_KEY)];\n    }\n    function getInstanceById(key) {\n      return instances$1[key];\n    }\n    function registerTheme(name, theme) {\n      themeStorage[name] = theme;\n    }\n    function registerPreprocessor(preprocessorFunc) {\n      if (indexOf$1(optionPreprocessorFuncs, preprocessorFunc) < 0) {\n        optionPreprocessorFuncs.push(preprocessorFunc);\n      }\n    }\n    function registerProcessor(priority, processor) {\n      normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);\n    }\n    function registerPostInit(postInitFunc) {\n      if (indexOf$1(postInitFuncs, postInitFunc) < 0) {\n        postInitFunc && postInitFuncs.push(postInitFunc);\n      }\n    }\n    function registerPostUpdate(postUpdateFunc) {\n      if (indexOf$1(postUpdateFuncs, postUpdateFunc) < 0) {\n        postUpdateFunc && postUpdateFuncs.push(postUpdateFunc);\n      }\n    }\n    function registerAction(actionInfo, eventName, action) {\n      if (typeof eventName === 'function') {\n        action = eventName;\n        eventName = '';\n      }\n\n      var actionType = isObject$2(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {\n        event: eventName\n      }][0];\n      actionInfo.event = (actionInfo.event || actionType).toLowerCase();\n      eventName = actionInfo.event;\n\n      if (eventActionMap[eventName]) {\n        return;\n      }\n\n      assert$1(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));\n\n      if (!actions[actionType]) {\n        actions[actionType] = {\n          action: action,\n          actionInfo: actionInfo\n        };\n      }\n\n      eventActionMap[eventName] = actionType;\n    }\n    function registerCoordinateSystem(type, coordSysCreator) {\n      CoordinateSystemManager.register(type, coordSysCreator);\n    }\n    function getCoordinateSystemDimensions(type) {\n      var coordSysCreator = CoordinateSystemManager.get(type);\n\n      if (coordSysCreator) {\n        return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();\n      }\n    }\n\n    function registerLayout(priority, layoutTask) {\n      normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');\n    }\n\n    function registerVisual(priority, visualTask) {\n      normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');\n    }\n    var registeredTasks = [];\n\n    function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {\n      if (isFunction$1(priority) || isObject$2(priority)) {\n        fn = priority;\n        priority = defaultPriority;\n      }\n\n      if (\"development\" !== 'production') {\n        if (isNaN(priority) || priority == null) {\n          throw new Error('Illegal priority');\n        }\n\n        each$3(targetList, function (wrap) {\n          assert$1(wrap.__raw !== fn);\n        });\n      }\n\n      if (indexOf$1(registeredTasks, fn) >= 0) {\n        return;\n      }\n\n      registeredTasks.push(fn);\n      var stageHandler = Scheduler.wrapStageHandler(fn, visualType);\n      stageHandler.__prio = priority;\n      stageHandler.__raw = fn;\n      targetList.push(stageHandler);\n    }\n\n    function registerLoading(name, loadingFx) {\n      loadingEffects[name] = loadingFx;\n    }\n    function setCanvasCreator(creator) {\n      $override('createCanvas', creator);\n    }\n    function registerMap(mapName, geoJson, specialAreas) {\n      mapDataStorage.registerMap(mapName, geoJson, specialAreas);\n    }\n    function getMap(mapName) {\n      var records = mapDataStorage.retrieveMap(mapName);\n      return records && records[0] && {\n        geoJson: records[0].geoJSON,\n        specialAreas: records[0].specialAreas\n      };\n    }\n    var registerTransform = registerExternalTransform;\n    registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);\n    registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);\n    registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);\n    registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);\n    registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);\n    registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);\n    registerPreprocessor(globalBackwardCompat);\n    registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);\n    registerLoading('default', defaultLoading);\n    registerAction({\n      type: HIGHLIGHT_ACTION_TYPE,\n      event: HIGHLIGHT_ACTION_TYPE,\n      update: HIGHLIGHT_ACTION_TYPE\n    }, noop);\n    registerAction({\n      type: DOWNPLAY_ACTION_TYPE,\n      event: DOWNPLAY_ACTION_TYPE,\n      update: DOWNPLAY_ACTION_TYPE\n    }, noop);\n    registerAction({\n      type: SELECT_ACTION_TYPE,\n      event: SELECT_ACTION_TYPE,\n      update: SELECT_ACTION_TYPE\n    }, noop);\n    registerAction({\n      type: UNSELECT_ACTION_TYPE,\n      event: UNSELECT_ACTION_TYPE,\n      update: UNSELECT_ACTION_TYPE\n    }, noop);\n    registerAction({\n      type: TOGGLE_SELECT_ACTION_TYPE,\n      event: TOGGLE_SELECT_ACTION_TYPE,\n      update: TOGGLE_SELECT_ACTION_TYPE\n    }, noop);\n    registerTheme('light', lightTheme);\n    registerTheme('dark', theme);\n    var dataTool = {};\n\n    var extensions = [];\n    var extensionRegisters = {\n      registerPreprocessor: registerPreprocessor,\n      registerProcessor: registerProcessor,\n      registerPostInit: registerPostInit,\n      registerPostUpdate: registerPostUpdate,\n      registerAction: registerAction,\n      registerCoordinateSystem: registerCoordinateSystem,\n      registerLayout: registerLayout,\n      registerVisual: registerVisual,\n      registerTransform: registerTransform,\n      registerLoading: registerLoading,\n      registerMap: registerMap,\n      PRIORITY: PRIORITY,\n      ComponentModel: ComponentModel,\n      ComponentView: ComponentView,\n      SeriesModel: SeriesModel,\n      ChartView: ChartView,\n      registerComponentModel: function (ComponentModelClass) {\n        ComponentModel.registerClass(ComponentModelClass);\n      },\n      registerComponentView: function (ComponentViewClass) {\n        ComponentView.registerClass(ComponentViewClass);\n      },\n      registerSeriesModel: function (SeriesModelClass) {\n        SeriesModel.registerClass(SeriesModelClass);\n      },\n      registerChartView: function (ChartViewClass) {\n        ChartView.registerClass(ChartViewClass);\n      },\n      registerSubTypeDefaulter: function (componentType, defaulter) {\n        ComponentModel.registerSubTypeDefaulter(componentType, defaulter);\n      },\n      registerPainter: function (painterType, PainterCtor) {\n        registerPainter(painterType, PainterCtor);\n      }\n    };\n    function use(ext) {\n      if (isArray(ext)) {\n        each(ext, function (singleExt) {\n          use(singleExt);\n        });\n        return;\n      }\n\n      if (indexOf(extensions, ext) >= 0) {\n        return;\n      }\n\n      extensions.push(ext);\n\n      if (isFunction(ext)) {\n        ext = {\n          install: ext\n        };\n      }\n\n      ext.install(extensionRegisters);\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {\n      return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;\n    }\n\n    function defaultKeyGetter(item) {\n      return item;\n    }\n\n    var DataDiffer = function () {\n      function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {\n        this._old = oldArr;\n        this._new = newArr;\n        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;\n        this._newKeyGetter = newKeyGetter || defaultKeyGetter;\n        this.context = context;\n        this._diffModeMultiple = diffMode === 'multiple';\n      }\n\n      DataDiffer.prototype.add = function (func) {\n        this._add = func;\n        return this;\n      };\n\n      DataDiffer.prototype.update = function (func) {\n        this._update = func;\n        return this;\n      };\n\n      DataDiffer.prototype.updateManyToOne = function (func) {\n        this._updateManyToOne = func;\n        return this;\n      };\n\n      DataDiffer.prototype.updateOneToMany = function (func) {\n        this._updateOneToMany = func;\n        return this;\n      };\n\n      DataDiffer.prototype.remove = function (func) {\n        this._remove = func;\n        return this;\n      };\n\n      DataDiffer.prototype.execute = function () {\n        this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();\n      };\n\n      DataDiffer.prototype._executeOneToOne = function () {\n        var oldArr = this._old;\n        var newArr = this._new;\n        var newDataIndexMap = {};\n        var oldDataKeyArr = new Array(oldArr.length);\n        var newDataKeyArr = new Array(newArr.length);\n\n        this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');\n\n        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n        for (var i = 0; i < oldArr.length; i++) {\n          var oldKey = oldDataKeyArr[i];\n          var newIdxMapVal = newDataIndexMap[oldKey];\n          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n          if (newIdxMapValLen > 1) {\n            var newIdx = newIdxMapVal.shift();\n\n            if (newIdxMapVal.length === 1) {\n              newDataIndexMap[oldKey] = newIdxMapVal[0];\n            }\n\n            this._update && this._update(newIdx, i);\n          } else if (newIdxMapValLen === 1) {\n            newDataIndexMap[oldKey] = null;\n            this._update && this._update(newIdxMapVal, i);\n          } else {\n            this._remove && this._remove(i);\n          }\n        }\n\n        this._performRestAdd(newDataKeyArr, newDataIndexMap);\n      };\n\n      DataDiffer.prototype._executeMultiple = function () {\n        var oldArr = this._old;\n        var newArr = this._new;\n        var oldDataIndexMap = {};\n        var newDataIndexMap = {};\n        var oldDataKeyArr = [];\n        var newDataKeyArr = [];\n\n        this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');\n\n        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');\n\n        for (var i = 0; i < oldDataKeyArr.length; i++) {\n          var oldKey = oldDataKeyArr[i];\n          var oldIdxMapVal = oldDataIndexMap[oldKey];\n          var newIdxMapVal = newDataIndexMap[oldKey];\n          var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);\n          var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n          if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {\n            this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);\n            newDataIndexMap[oldKey] = null;\n          } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {\n            this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);\n            newDataIndexMap[oldKey] = null;\n          } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {\n            this._update && this._update(newIdxMapVal, oldIdxMapVal);\n            newDataIndexMap[oldKey] = null;\n          } else if (oldIdxMapValLen > 1) {\n            for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {\n              this._remove && this._remove(oldIdxMapVal[i_1]);\n            }\n          } else {\n            this._remove && this._remove(oldIdxMapVal);\n          }\n        }\n\n        this._performRestAdd(newDataKeyArr, newDataIndexMap);\n      };\n\n      DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {\n        for (var i = 0; i < newDataKeyArr.length; i++) {\n          var newKey = newDataKeyArr[i];\n          var newIdxMapVal = newDataIndexMap[newKey];\n          var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);\n\n          if (idxMapValLen > 1) {\n            for (var j = 0; j < idxMapValLen; j++) {\n              this._add && this._add(newIdxMapVal[j]);\n            }\n          } else if (idxMapValLen === 1) {\n            this._add && this._add(newIdxMapVal);\n          }\n\n          newDataIndexMap[newKey] = null;\n        }\n      };\n\n      DataDiffer.prototype._initIndexMap = function (arr, map, keyArr, keyGetterName) {\n        var cbModeMultiple = this._diffModeMultiple;\n\n        for (var i = 0; i < arr.length; i++) {\n          var key = '_ec_' + this[keyGetterName](arr[i], i);\n\n          if (!cbModeMultiple) {\n            keyArr[i] = key;\n          }\n\n          if (!map) {\n            continue;\n          }\n\n          var idxMapVal = map[key];\n          var idxMapValLen = dataIndexMapValueLength(idxMapVal);\n\n          if (idxMapValLen === 0) {\n            map[key] = i;\n\n            if (cbModeMultiple) {\n              keyArr.push(key);\n            }\n          } else if (idxMapValLen === 1) {\n            map[key] = [idxMapVal, i];\n          } else {\n            idxMapVal.push(i);\n          }\n        }\n      };\n\n      return DataDiffer;\n    }();\n\n    function summarizeDimensions(data) {\n      var summary = {};\n      var encode = summary.encode = {};\n      var notExtraCoordDimMap = createHashMap();\n      var defaultedLabel = [];\n      var defaultedTooltip = [];\n      var userOutput = summary.userOutput = {\n        dimensionNames: data.dimensions.slice(),\n        encode: {}\n      };\n      each(data.dimensions, function (dimName) {\n        var dimItem = data.getDimensionInfo(dimName);\n        var coordDim = dimItem.coordDim;\n\n        if (coordDim) {\n          if (\"development\" !== 'production') {\n            assert(VISUAL_DIMENSIONS.get(coordDim) == null);\n          }\n\n          var coordDimIndex = dimItem.coordDimIndex;\n          getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;\n\n          if (!dimItem.isExtraCoord) {\n            notExtraCoordDimMap.set(coordDim, 1);\n\n            if (mayLabelDimType(dimItem.type)) {\n              defaultedLabel[0] = dimName;\n            }\n\n            getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;\n          }\n\n          if (dimItem.defaultTooltip) {\n            defaultedTooltip.push(dimName);\n          }\n        }\n\n        VISUAL_DIMENSIONS.each(function (v, otherDim) {\n          var encodeArr = getOrCreateEncodeArr(encode, otherDim);\n          var dimIndex = dimItem.otherDims[otherDim];\n\n          if (dimIndex != null && dimIndex !== false) {\n            encodeArr[dimIndex] = dimItem.name;\n          }\n        });\n      });\n      var dataDimsOnCoord = [];\n      var encodeFirstDimNotExtra = {};\n      notExtraCoordDimMap.each(function (v, coordDim) {\n        var dimArr = encode[coordDim];\n        encodeFirstDimNotExtra[coordDim] = dimArr[0];\n        dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);\n      });\n      summary.dataDimsOnCoord = dataDimsOnCoord;\n      summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;\n      var encodeLabel = encode.label;\n\n      if (encodeLabel && encodeLabel.length) {\n        defaultedLabel = encodeLabel.slice();\n      }\n\n      var encodeTooltip = encode.tooltip;\n\n      if (encodeTooltip && encodeTooltip.length) {\n        defaultedTooltip = encodeTooltip.slice();\n      } else if (!defaultedTooltip.length) {\n        defaultedTooltip = defaultedLabel.slice();\n      }\n\n      encode.defaultedLabel = defaultedLabel;\n      encode.defaultedTooltip = defaultedTooltip;\n      return summary;\n    }\n\n    function getOrCreateEncodeArr(encode, dim) {\n      if (!encode.hasOwnProperty(dim)) {\n        encode[dim] = [];\n      }\n\n      return encode[dim];\n    }\n\n    function getDimensionTypeByAxis(axisType) {\n      return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';\n    }\n\n    function mayLabelDimType(dimType) {\n      return !(dimType === 'ordinal' || dimType === 'time');\n    }\n\n    var DataDimensionInfo = function () {\n      function DataDimensionInfo(opt) {\n        this.otherDims = {};\n\n        if (opt != null) {\n          extend(this, opt);\n        }\n      }\n\n      return DataDimensionInfo;\n    }();\n\n    var mathFloor = Math.floor;\n    var isObject$3 = isObject;\n    var map$1 = map;\n    var UNDEFINED = 'undefined';\n    var INDEX_NOT_FOUND = -1;\n    var ID_PREFIX = 'e\\0\\0';\n    var dataCtors = {\n      'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n      'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n      'ordinal': Array,\n      'number': Array,\n      'time': Array\n    };\n    var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\n    var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\n    var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n    var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\n    var CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n    var defaultDimValueGetters;\n    var prepareInvertedIndex;\n    var getIndicesCtor;\n    var prepareStorage;\n    var getRawIndexWithoutIndices;\n    var getRawIndexWithIndices;\n    var getId;\n    var getIdNameFromStore;\n    var makeIdFromName;\n    var normalizeDimensions;\n    var validateDimensions;\n    var cloneListForMapAndSample;\n    var getInitialExtent;\n    var setItemDataAndSeriesIndex;\n    var transferProperties;\n\n    var List = function () {\n      function List(dimensions, hostModel) {\n        this.type = 'list';\n        this._count = 0;\n        this._rawCount = 0;\n        this._storage = {};\n        this._storageArr = [];\n        this._nameList = [];\n        this._idList = [];\n        this._visual = {};\n        this._layout = {};\n        this._itemVisuals = [];\n        this._itemLayouts = [];\n        this._graphicEls = [];\n        this._rawExtent = {};\n        this._extent = {};\n        this._approximateExtent = {};\n        this._calculationInfo = {};\n        this.hasItemOption = true;\n        this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n        this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n        this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n        this.getRawIndex = getRawIndexWithoutIndices;\n        dimensions = dimensions || ['x', 'y'];\n        var dimensionInfos = {};\n        var dimensionNames = [];\n        var invertedIndicesMap = {};\n\n        for (var i = 0; i < dimensions.length; i++) {\n          var dimInfoInput = dimensions[i];\n          var dimensionInfo = isString(dimInfoInput) ? new DataDimensionInfo({\n            name: dimInfoInput\n          }) : !(dimInfoInput instanceof DataDimensionInfo) ? new DataDimensionInfo(dimInfoInput) : dimInfoInput;\n          var dimensionName = dimensionInfo.name;\n          dimensionInfo.type = dimensionInfo.type || 'float';\n\n          if (!dimensionInfo.coordDim) {\n            dimensionInfo.coordDim = dimensionName;\n            dimensionInfo.coordDimIndex = 0;\n          }\n\n          var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n          dimensionNames.push(dimensionName);\n          dimensionInfos[dimensionName] = dimensionInfo;\n          dimensionInfo.index = i;\n\n          if (dimensionInfo.createInvertedIndices) {\n            invertedIndicesMap[dimensionName] = [];\n          }\n\n          if (otherDims.itemName === 0) {\n            this._nameDimIdx = i;\n            this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n          }\n\n          if (otherDims.itemId === 0) {\n            this._idDimIdx = i;\n            this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n          }\n        }\n\n        this.dimensions = dimensionNames;\n        this._dimensionInfos = dimensionInfos;\n        this.hostModel = hostModel;\n        this._dimensionsSummary = summarizeDimensions(this);\n        this._invertedIndicesMap = invertedIndicesMap;\n        this.userOutput = this._dimensionsSummary.userOutput;\n      }\n\n      List.prototype.getDimension = function (dim) {\n        if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n          dim = this.dimensions[dim];\n        }\n\n        return dim;\n      };\n\n      List.prototype.getDimensionInfo = function (dim) {\n        return this._dimensionInfos[this.getDimension(dim)];\n      };\n\n      List.prototype.getDimensionsOnCoord = function () {\n        return this._dimensionsSummary.dataDimsOnCoord.slice();\n      };\n\n      List.prototype.mapDimension = function (coordDim, idx) {\n        var dimensionsSummary = this._dimensionsSummary;\n\n        if (idx == null) {\n          return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n        }\n\n        var dims = dimensionsSummary.encode[coordDim];\n        return dims ? dims[idx] : null;\n      };\n\n      List.prototype.mapDimensionsAll = function (coordDim) {\n        var dimensionsSummary = this._dimensionsSummary;\n        var dims = dimensionsSummary.encode[coordDim];\n        return (dims || []).slice();\n      };\n\n      List.prototype.initData = function (data, nameList, dimValueGetter) {\n        var notProvider = isSourceInstance(data) || isArrayLike(data);\n        var provider = notProvider ? new DefaultDataProvider(data, this.dimensions.length) : data;\n\n        if (\"development\" !== 'production') {\n          assert(notProvider || isFunction(provider.getItem) && isFunction(provider.count), 'Inavlid data provider.');\n        }\n\n        this._rawData = provider;\n        var sourceFormat = provider.getSource().sourceFormat;\n        this._storage = {};\n        this._indices = null;\n        this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;\n        this._nameList = (nameList || []).slice();\n        this._idList = [];\n        this._nameRepeatCount = {};\n\n        if (!dimValueGetter) {\n          this.hasItemOption = false;\n        }\n\n        this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];\n        this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n        this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;\n        this._rawExtent = {};\n\n        this._initDataFromProvider(0, provider.count());\n\n        if (provider.pure) {\n          this.hasItemOption = false;\n        }\n      };\n\n      List.prototype.getProvider = function () {\n        return this._rawData;\n      };\n\n      List.prototype.appendData = function (data) {\n        if (\"development\" !== 'production') {\n          assert(!this._indices, 'appendData can only be called on raw data.');\n        }\n\n        var rawData = this._rawData;\n        var start = this.count();\n        rawData.appendData(data);\n        var end = rawData.count();\n\n        if (!rawData.persistent) {\n          end += start;\n        }\n\n        this._initDataFromProvider(start, end, true);\n      };\n\n      List.prototype.appendValues = function (values, names) {\n        var storage = this._storage;\n        var dimensions = this.dimensions;\n        var dimLen = dimensions.length;\n        var rawExtent = this._rawExtent;\n        var start = this.count();\n        var end = start + Math.max(values.length, names ? names.length : 0);\n\n        for (var i = 0; i < dimLen; i++) {\n          var dim = dimensions[i];\n\n          if (!rawExtent[dim]) {\n            rawExtent[dim] = getInitialExtent();\n          }\n\n          prepareStorage(storage, this._dimensionInfos[dim], end, true);\n        }\n\n        var rawExtentArr = map$1(dimensions, function (dim) {\n          return rawExtent[dim];\n        });\n        var storageArr = this._storageArr = map$1(dimensions, function (dim) {\n          return storage[dim];\n        });\n        var emptyDataItem = [];\n\n        for (var idx = start; idx < end; idx++) {\n          var sourceIdx = idx - start;\n\n          for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n            var dim = dimensions[dimIdx];\n\n            var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n            storageArr[dimIdx][idx] = val;\n            var dimRawExtent = rawExtentArr[dimIdx];\n            val < dimRawExtent[0] && (dimRawExtent[0] = val);\n            val > dimRawExtent[1] && (dimRawExtent[1] = val);\n          }\n\n          if (names) {\n            this._nameList[idx] = names[sourceIdx];\n\n            if (!this._dontMakeIdFromName) {\n              makeIdFromName(this, idx);\n            }\n          }\n        }\n\n        this._rawCount = this._count = end;\n        this._extent = {};\n        prepareInvertedIndex(this);\n      };\n\n      List.prototype._initDataFromProvider = function (start, end, append) {\n        if (start >= end) {\n          return;\n        }\n\n        var rawData = this._rawData;\n        var storage = this._storage;\n        var dimensions = this.dimensions;\n        var dimLen = dimensions.length;\n        var dimensionInfoMap = this._dimensionInfos;\n        var nameList = this._nameList;\n        var idList = this._idList;\n        var rawExtent = this._rawExtent;\n        var sourceFormat = rawData.getSource().sourceFormat;\n        var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;\n\n        for (var i = 0; i < dimLen; i++) {\n          var dim = dimensions[i];\n\n          if (!rawExtent[dim]) {\n            rawExtent[dim] = getInitialExtent();\n          }\n\n          prepareStorage(storage, dimensionInfoMap[dim], end, append);\n        }\n\n        var storageArr = this._storageArr = map$1(dimensions, function (dim) {\n          return storage[dim];\n        });\n        var rawExtentArr = map$1(dimensions, function (dim) {\n          return rawExtent[dim];\n        });\n\n        if (rawData.fillStorage) {\n          rawData.fillStorage(start, end, storageArr, rawExtentArr);\n        } else {\n          var dataItem = [];\n\n          for (var idx = start; idx < end; idx++) {\n            dataItem = rawData.getItem(idx, dataItem);\n\n            for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n              var dim = dimensions[dimIdx];\n              var dimStorage = storageArr[dimIdx];\n\n              var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n              dimStorage[idx] = val;\n              var dimRawExtent = rawExtentArr[dimIdx];\n              val < dimRawExtent[0] && (dimRawExtent[0] = val);\n              val > dimRawExtent[1] && (dimRawExtent[1] = val);\n            }\n\n            if (isFormatOriginal && !rawData.pure && dataItem) {\n              var itemName = dataItem.name;\n\n              if (nameList[idx] == null && itemName != null) {\n                nameList[idx] = convertOptionIdName(itemName, null);\n              }\n\n              var itemId = dataItem.id;\n\n              if (idList[idx] == null && itemId != null) {\n                idList[idx] = convertOptionIdName(itemId, null);\n              }\n            }\n\n            if (!this._dontMakeIdFromName) {\n              makeIdFromName(this, idx);\n            }\n          }\n        }\n\n        if (!rawData.persistent && rawData.clean) {\n          rawData.clean();\n        }\n\n        this._rawCount = this._count = end;\n        this._extent = {};\n        prepareInvertedIndex(this);\n      };\n\n      List.prototype.count = function () {\n        return this._count;\n      };\n\n      List.prototype.getIndices = function () {\n        var newIndices;\n        var indices = this._indices;\n\n        if (indices) {\n          var Ctor = indices.constructor;\n          var thisCount = this._count;\n\n          if (Ctor === Array) {\n            newIndices = new Ctor(thisCount);\n\n            for (var i = 0; i < thisCount; i++) {\n              newIndices[i] = indices[i];\n            }\n          } else {\n            newIndices = new Ctor(indices.buffer, 0, thisCount);\n          }\n        } else {\n          var Ctor = getIndicesCtor(this);\n          newIndices = new Ctor(this.count());\n\n          for (var i = 0; i < newIndices.length; i++) {\n            newIndices[i] = i;\n          }\n        }\n\n        return newIndices;\n      };\n\n      List.prototype.getByDimIdx = function (dimIdx, idx) {\n        if (!(idx >= 0 && idx < this._count)) {\n          return NaN;\n        }\n\n        var dimStore = this._storageArr[dimIdx];\n        return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n      };\n\n      List.prototype.get = function (dim, idx) {\n        if (!(idx >= 0 && idx < this._count)) {\n          return NaN;\n        }\n\n        var dimStore = this._storage[dim];\n        return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n      };\n\n      List.prototype.getByRawIndex = function (dim, rawIdx) {\n        if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n          return NaN;\n        }\n\n        var dimStore = this._storage[dim];\n        return dimStore ? dimStore[rawIdx] : NaN;\n      };\n\n      List.prototype.getValues = function (dimensions, idx) {\n        var values = [];\n\n        if (!isArray(dimensions)) {\n          idx = dimensions;\n          dimensions = this.dimensions;\n        }\n\n        for (var i = 0, len = dimensions.length; i < len; i++) {\n          values.push(this.get(dimensions[i], idx));\n        }\n\n        return values;\n      };\n\n      List.prototype.hasValue = function (idx) {\n        var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n        for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n          if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      List.prototype.getDataExtent = function (dim) {\n        dim = this.getDimension(dim);\n        var dimData = this._storage[dim];\n        var initialExtent = getInitialExtent();\n\n        if (!dimData) {\n          return initialExtent;\n        }\n\n        var currEnd = this.count();\n        var useRaw = !this._indices;\n        var dimExtent;\n\n        if (useRaw) {\n          return this._rawExtent[dim].slice();\n        }\n\n        dimExtent = this._extent[dim];\n\n        if (dimExtent) {\n          return dimExtent.slice();\n        }\n\n        dimExtent = initialExtent;\n        var min = dimExtent[0];\n        var max = dimExtent[1];\n\n        for (var i = 0; i < currEnd; i++) {\n          var rawIdx = this.getRawIndex(i);\n          var value = dimData[rawIdx];\n          value < min && (min = value);\n          value > max && (max = value);\n        }\n\n        dimExtent = [min, max];\n        this._extent[dim] = dimExtent;\n        return dimExtent;\n      };\n\n      List.prototype.getApproximateExtent = function (dim) {\n        dim = this.getDimension(dim);\n        return this._approximateExtent[dim] || this.getDataExtent(dim);\n      };\n\n      List.prototype.setApproximateExtent = function (extent, dim) {\n        dim = this.getDimension(dim);\n        this._approximateExtent[dim] = extent.slice();\n      };\n\n      List.prototype.getCalculationInfo = function (key) {\n        return this._calculationInfo[key];\n      };\n\n      List.prototype.setCalculationInfo = function (key, value) {\n        isObject$3(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n      };\n\n      List.prototype.getSum = function (dim) {\n        var dimData = this._storage[dim];\n        var sum = 0;\n\n        if (dimData) {\n          for (var i = 0, len = this.count(); i < len; i++) {\n            var value = this.get(dim, i);\n\n            if (!isNaN(value)) {\n              sum += value;\n            }\n          }\n        }\n\n        return sum;\n      };\n\n      List.prototype.getMedian = function (dim) {\n        var dimDataArray = [];\n        this.each(dim, function (val) {\n          if (!isNaN(val)) {\n            dimDataArray.push(val);\n          }\n        });\n        var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n          return a - b;\n        });\n        var len = this.count();\n        return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n      };\n\n      List.prototype.rawIndexOf = function (dim, value) {\n        var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n        if (\"development\" !== 'production') {\n          if (!invertedIndices) {\n            throw new Error('Do not supported yet');\n          }\n        }\n\n        var rawIndex = invertedIndices[value];\n\n        if (rawIndex == null || isNaN(rawIndex)) {\n          return INDEX_NOT_FOUND;\n        }\n\n        return rawIndex;\n      };\n\n      List.prototype.indexOfName = function (name) {\n        for (var i = 0, len = this.count(); i < len; i++) {\n          if (this.getName(i) === name) {\n            return i;\n          }\n        }\n\n        return -1;\n      };\n\n      List.prototype.indexOfRawIndex = function (rawIndex) {\n        if (rawIndex >= this._rawCount || rawIndex < 0) {\n          return -1;\n        }\n\n        if (!this._indices) {\n          return rawIndex;\n        }\n\n        var indices = this._indices;\n        var rawDataIndex = indices[rawIndex];\n\n        if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n          return rawIndex;\n        }\n\n        var left = 0;\n        var right = this._count - 1;\n\n        while (left <= right) {\n          var mid = (left + right) / 2 | 0;\n\n          if (indices[mid] < rawIndex) {\n            left = mid + 1;\n          } else if (indices[mid] > rawIndex) {\n            right = mid - 1;\n          } else {\n            return mid;\n          }\n        }\n\n        return -1;\n      };\n\n      List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n        var storage = this._storage;\n        var dimData = storage[dim];\n        var nearestIndices = [];\n\n        if (!dimData) {\n          return nearestIndices;\n        }\n\n        if (maxDistance == null) {\n          maxDistance = Infinity;\n        }\n\n        var minDist = Infinity;\n        var minDiff = -1;\n        var nearestIndicesLen = 0;\n\n        for (var i = 0, len = this.count(); i < len; i++) {\n          var dataIndex = this.getRawIndex(i);\n          var diff = value - dimData[dataIndex];\n          var dist = Math.abs(diff);\n\n          if (dist <= maxDistance) {\n            if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n              minDist = dist;\n              minDiff = diff;\n              nearestIndicesLen = 0;\n            }\n\n            if (diff === minDiff) {\n              nearestIndices[nearestIndicesLen++] = i;\n            }\n          }\n        }\n\n        nearestIndices.length = nearestIndicesLen;\n        return nearestIndices;\n      };\n\n      List.prototype.getRawDataItem = function (idx) {\n        if (!this._rawData.persistent) {\n          var val = [];\n\n          for (var i = 0; i < this.dimensions.length; i++) {\n            var dim = this.dimensions[i];\n            val.push(this.get(dim, idx));\n          }\n\n          return val;\n        } else {\n          return this._rawData.getItem(this.getRawIndex(idx));\n        }\n      };\n\n      List.prototype.getName = function (idx) {\n        var rawIndex = this.getRawIndex(idx);\n        var name = this._nameList[rawIndex];\n\n        if (name == null && this._nameDimIdx != null) {\n          name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n        }\n\n        if (name == null) {\n          name = '';\n        }\n\n        return name;\n      };\n\n      List.prototype.getId = function (idx) {\n        return getId(this, this.getRawIndex(idx));\n      };\n\n      List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n\n        var _this = this;\n\n        if (!this._count) {\n          return;\n        }\n\n        if (typeof dims === 'function') {\n          ctxCompat = ctx;\n          ctx = cb;\n          cb = dims;\n          dims = [];\n        }\n\n        var fCtx = ctx || ctxCompat || this;\n        var dimNames = map$1(normalizeDimensions(dims), this.getDimension, this);\n\n        if (\"development\" !== 'production') {\n          validateDimensions(this, dimNames);\n        }\n\n        var dimSize = dimNames.length;\n        var dimIndices = map$1(dimNames, function (dimName) {\n          return _this._dimensionInfos[dimName].index;\n        });\n        var storageArr = this._storageArr;\n\n        for (var i = 0, len = this.count(); i < len; i++) {\n          var rawIdx = this.getRawIndex(i);\n\n          switch (dimSize) {\n            case 0:\n              cb.call(fCtx, i);\n              break;\n\n            case 1:\n              cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n              break;\n\n            case 2:\n              cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n              break;\n\n            default:\n              var k = 0;\n              var value = [];\n\n              for (; k < dimSize; k++) {\n                value[k] = storageArr[dimIndices[k]][rawIdx];\n              }\n\n              value[k] = i;\n              cb.apply(fCtx, value);\n          }\n        }\n      };\n\n      List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n\n        var _this = this;\n\n        if (!this._count) {\n          return;\n        }\n\n        if (typeof dims === 'function') {\n          ctxCompat = ctx;\n          ctx = cb;\n          cb = dims;\n          dims = [];\n        }\n\n        var fCtx = ctx || ctxCompat || this;\n        var dimNames = map$1(normalizeDimensions(dims), this.getDimension, this);\n\n        if (\"development\" !== 'production') {\n          validateDimensions(this, dimNames);\n        }\n\n        var count = this.count();\n        var Ctor = getIndicesCtor(this);\n        var newIndices = new Ctor(count);\n        var value = [];\n        var dimSize = dimNames.length;\n        var offset = 0;\n        var dimIndices = map$1(dimNames, function (dimName) {\n          return _this._dimensionInfos[dimName].index;\n        });\n        var dim0 = dimIndices[0];\n        var storageArr = this._storageArr;\n\n        for (var i = 0; i < count; i++) {\n          var keep = void 0;\n          var rawIdx = this.getRawIndex(i);\n\n          if (dimSize === 0) {\n            keep = cb.call(fCtx, i);\n          } else if (dimSize === 1) {\n            var val = storageArr[dim0][rawIdx];\n            keep = cb.call(fCtx, val, i);\n          } else {\n            var k = 0;\n\n            for (; k < dimSize; k++) {\n              value[k] = storageArr[dimIndices[k]][rawIdx];\n            }\n\n            value[k] = i;\n            keep = cb.apply(fCtx, value);\n          }\n\n          if (keep) {\n            newIndices[offset++] = rawIdx;\n          }\n        }\n\n        if (offset < count) {\n          this._indices = newIndices;\n        }\n\n        this._count = offset;\n        this._extent = {};\n        this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n        return this;\n      };\n\n      List.prototype.selectRange = function (range) {\n\n        var _this = this;\n\n        var len = this._count;\n\n        if (!len) {\n          return;\n        }\n\n        var dimensions = [];\n\n        for (var dim in range) {\n          if (range.hasOwnProperty(dim)) {\n            dimensions.push(dim);\n          }\n        }\n\n        if (\"development\" !== 'production') {\n          validateDimensions(this, dimensions);\n        }\n\n        var dimSize = dimensions.length;\n\n        if (!dimSize) {\n          return;\n        }\n\n        var originalCount = this.count();\n        var Ctor = getIndicesCtor(this);\n        var newIndices = new Ctor(originalCount);\n        var offset = 0;\n        var dim0 = dimensions[0];\n        var dimIndices = map$1(dimensions, function (dimName) {\n          return _this._dimensionInfos[dimName].index;\n        });\n        var min = range[dim0][0];\n        var max = range[dim0][1];\n        var storageArr = this._storageArr;\n        var quickFinished = false;\n\n        if (!this._indices) {\n          var idx = 0;\n\n          if (dimSize === 1) {\n            var dimStorage = storageArr[dimIndices[0]];\n\n            for (var i = 0; i < len; i++) {\n              var val = dimStorage[i];\n\n              if (val >= min && val <= max || isNaN(val)) {\n                newIndices[offset++] = idx;\n              }\n\n              idx++;\n            }\n\n            quickFinished = true;\n          } else if (dimSize === 2) {\n            var dimStorage = storageArr[dimIndices[0]];\n            var dimStorage2 = storageArr[dimIndices[1]];\n            var min2 = range[dimensions[1]][0];\n            var max2 = range[dimensions[1]][1];\n\n            for (var i = 0; i < len; i++) {\n              var val = dimStorage[i];\n              var val2 = dimStorage2[i];\n\n              if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n                newIndices[offset++] = idx;\n              }\n\n              idx++;\n            }\n\n            quickFinished = true;\n          }\n        }\n\n        if (!quickFinished) {\n          if (dimSize === 1) {\n            for (var i = 0; i < originalCount; i++) {\n              var rawIndex = this.getRawIndex(i);\n              var val = storageArr[dimIndices[0]][rawIndex];\n\n              if (val >= min && val <= max || isNaN(val)) {\n                newIndices[offset++] = rawIndex;\n              }\n            }\n          } else {\n            for (var i = 0; i < originalCount; i++) {\n              var keep = true;\n              var rawIndex = this.getRawIndex(i);\n\n              for (var k = 0; k < dimSize; k++) {\n                var dimk = dimensions[k];\n                var val = storageArr[dimIndices[k]][rawIndex];\n\n                if (val < range[dimk][0] || val > range[dimk][1]) {\n                  keep = false;\n                }\n              }\n\n              if (keep) {\n                newIndices[offset++] = this.getRawIndex(i);\n              }\n            }\n          }\n        }\n\n        if (offset < originalCount) {\n          this._indices = newIndices;\n        }\n\n        this._count = offset;\n        this._extent = {};\n        this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n        return this;\n      };\n\n      List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n\n        if (typeof dims === 'function') {\n          ctxCompat = ctx;\n          ctx = cb;\n          cb = dims;\n          dims = [];\n        }\n\n        ctx = ctx || ctxCompat || this;\n        var result = [];\n        this.each(dims, function () {\n          result.push(cb && cb.apply(this, arguments));\n        }, ctx);\n        return result;\n      };\n\n      List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n\n        var fCtx = ctx || ctxCompat || this;\n        var dimNames = map$1(normalizeDimensions(dims), this.getDimension, this);\n\n        if (\"development\" !== 'production') {\n          validateDimensions(this, dimNames);\n        }\n\n        var list = cloneListForMapAndSample(this, dimNames);\n        var storage = list._storage;\n        list._indices = this._indices;\n        list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n        var tmpRetValue = [];\n        var dimSize = dimNames.length;\n        var dataCount = this.count();\n        var values = [];\n        var rawExtent = list._rawExtent;\n\n        for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n          for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n            values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n          }\n\n          values[dimSize] = dataIndex;\n          var retValue = cb && cb.apply(fCtx, values);\n\n          if (retValue != null) {\n            if (typeof retValue !== 'object') {\n              tmpRetValue[0] = retValue;\n              retValue = tmpRetValue;\n            }\n\n            var rawIndex = this.getRawIndex(dataIndex);\n\n            for (var i = 0; i < retValue.length; i++) {\n              var dim = dimNames[i];\n              var val = retValue[i];\n              var rawExtentOnDim = rawExtent[dim];\n              var dimStore = storage[dim];\n\n              if (dimStore) {\n                dimStore[rawIndex] = val;\n              }\n\n              if (val < rawExtentOnDim[0]) {\n                rawExtentOnDim[0] = val;\n              }\n\n              if (val > rawExtentOnDim[1]) {\n                rawExtentOnDim[1] = val;\n              }\n            }\n          }\n        }\n\n        return list;\n      };\n\n      List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n        var list = cloneListForMapAndSample(this, [dimension]);\n        var targetStorage = list._storage;\n        var frameValues = [];\n        var frameSize = mathFloor(1 / rate);\n        var dimStore = targetStorage[dimension];\n        var len = this.count();\n        var rawExtentOnDim = list._rawExtent[dimension];\n        var newIndices = new (getIndicesCtor(this))(len);\n        var offset = 0;\n\n        for (var i = 0; i < len; i += frameSize) {\n          if (frameSize > len - i) {\n            frameSize = len - i;\n            frameValues.length = frameSize;\n          }\n\n          for (var k = 0; k < frameSize; k++) {\n            var dataIdx = this.getRawIndex(i + k);\n            frameValues[k] = dimStore[dataIdx];\n          }\n\n          var value = sampleValue(frameValues);\n          var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n          dimStore[sampleFrameIdx] = value;\n\n          if (value < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = value;\n          }\n\n          if (value > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = value;\n          }\n\n          newIndices[offset++] = sampleFrameIdx;\n        }\n\n        list._count = offset;\n        list._indices = newIndices;\n        list.getRawIndex = getRawIndexWithIndices;\n        return list;\n      };\n\n      List.prototype.lttbDownSample = function (valueDimension, rate) {\n        var list = cloneListForMapAndSample(this, []);\n        var targetStorage = list._storage;\n        var dimStore = targetStorage[valueDimension];\n        var len = this.count();\n        var newIndices = new (getIndicesCtor(this))(len);\n        var sampledIndex = 0;\n        var frameSize = mathFloor(1 / rate);\n        var currentRawIndex = this.getRawIndex(0);\n        var maxArea;\n        var area;\n        var nextRawIndex;\n        newIndices[sampledIndex++] = currentRawIndex;\n\n        for (var i = 1; i < len - 1; i += frameSize) {\n          var nextFrameStart = Math.min(i + frameSize, len - 1);\n          var nextFrameEnd = Math.min(i + frameSize * 2, len);\n          var avgX = (nextFrameEnd + nextFrameStart) / 2;\n          var avgY = 0;\n\n          for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n            var rawIndex = this.getRawIndex(idx);\n            var y = dimStore[rawIndex];\n\n            if (isNaN(y)) {\n              continue;\n            }\n\n            avgY += y;\n          }\n\n          avgY /= nextFrameEnd - nextFrameStart;\n          var frameStart = i;\n          var frameEnd = Math.min(i + frameSize, len);\n          var pointAX = i - 1;\n          var pointAY = dimStore[currentRawIndex];\n          maxArea = -1;\n          nextRawIndex = frameStart;\n\n          for (var idx = frameStart; idx < frameEnd; idx++) {\n            var rawIndex = this.getRawIndex(idx);\n            var y = dimStore[rawIndex];\n\n            if (isNaN(y)) {\n              continue;\n            }\n\n            area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n            if (area > maxArea) {\n              maxArea = area;\n              nextRawIndex = rawIndex;\n            }\n          }\n\n          newIndices[sampledIndex++] = nextRawIndex;\n          currentRawIndex = nextRawIndex;\n        }\n\n        newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n        list._count = sampledIndex;\n        list._indices = newIndices;\n        list.getRawIndex = getRawIndexWithIndices;\n        return list;\n      };\n\n      List.prototype.getItemModel = function (idx) {\n        var hostModel = this.hostModel;\n        var dataItem = this.getRawDataItem(idx);\n        return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n      };\n\n      List.prototype.diff = function (otherList) {\n        var thisList = this;\n        return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n          return getId(otherList, idx);\n        }, function (idx) {\n          return getId(thisList, idx);\n        });\n      };\n\n      List.prototype.getVisual = function (key) {\n        var visual = this._visual;\n        return visual && visual[key];\n      };\n\n      List.prototype.setVisual = function (kvObj, val) {\n        this._visual = this._visual || {};\n\n        if (isObject$3(kvObj)) {\n          extend(this._visual, kvObj);\n        } else {\n          this._visual[kvObj] = val;\n        }\n      };\n\n      List.prototype.getItemVisual = function (idx, key) {\n        var itemVisual = this._itemVisuals[idx];\n        var val = itemVisual && itemVisual[key];\n\n        if (val == null) {\n          return this.getVisual(key);\n        }\n\n        return val;\n      };\n\n      List.prototype.hasItemVisual = function () {\n        return this._itemVisuals.length > 0;\n      };\n\n      List.prototype.ensureUniqueItemVisual = function (idx, key) {\n        var itemVisuals = this._itemVisuals;\n        var itemVisual = itemVisuals[idx];\n\n        if (!itemVisual) {\n          itemVisual = itemVisuals[idx] = {};\n        }\n\n        var val = itemVisual[key];\n\n        if (val == null) {\n          val = this.getVisual(key);\n\n          if (isArray(val)) {\n            val = val.slice();\n          } else if (isObject$3(val)) {\n            val = extend({}, val);\n          }\n\n          itemVisual[key] = val;\n        }\n\n        return val;\n      };\n\n      List.prototype.setItemVisual = function (idx, key, value) {\n        var itemVisual = this._itemVisuals[idx] || {};\n        this._itemVisuals[idx] = itemVisual;\n\n        if (isObject$3(key)) {\n          extend(itemVisual, key);\n        } else {\n          itemVisual[key] = value;\n        }\n      };\n\n      List.prototype.clearAllVisual = function () {\n        this._visual = {};\n        this._itemVisuals = [];\n      };\n\n      List.prototype.setLayout = function (key, val) {\n        if (isObject$3(key)) {\n          for (var name_1 in key) {\n            if (key.hasOwnProperty(name_1)) {\n              this.setLayout(name_1, key[name_1]);\n            }\n          }\n\n          return;\n        }\n\n        this._layout[key] = val;\n      };\n\n      List.prototype.getLayout = function (key) {\n        return this._layout[key];\n      };\n\n      List.prototype.getItemLayout = function (idx) {\n        return this._itemLayouts[idx];\n      };\n\n      List.prototype.setItemLayout = function (idx, layout, merge) {\n        this._itemLayouts[idx] = merge ? extend(this._itemLayouts[idx] || {}, layout) : layout;\n      };\n\n      List.prototype.clearItemLayouts = function () {\n        this._itemLayouts.length = 0;\n      };\n\n      List.prototype.setItemGraphicEl = function (idx, el) {\n        var hostModel = this.hostModel;\n\n        if (el) {\n          var ecData = getECData(el);\n          ecData.dataIndex = idx;\n          ecData.dataType = this.dataType;\n          ecData.seriesIndex = hostModel && hostModel.seriesIndex;\n\n          if (el.type === 'group') {\n            el.traverse(setItemDataAndSeriesIndex, el);\n          }\n        }\n\n        this._graphicEls[idx] = el;\n      };\n\n      List.prototype.getItemGraphicEl = function (idx) {\n        return this._graphicEls[idx];\n      };\n\n      List.prototype.eachItemGraphicEl = function (cb, context) {\n        each(this._graphicEls, function (el, idx) {\n          if (el) {\n            cb && cb.call(context, el, idx);\n          }\n        });\n      };\n\n      List.prototype.cloneShallow = function (list) {\n        if (!list) {\n          var dimensionInfoList = map$1(this.dimensions, this.getDimensionInfo, this);\n          list = new List(dimensionInfoList, this.hostModel);\n        }\n\n        list._storage = this._storage;\n        list._storageArr = this._storageArr;\n        transferProperties(list, this);\n\n        if (this._indices) {\n          var Ctor = this._indices.constructor;\n\n          if (Ctor === Array) {\n            var thisCount = this._indices.length;\n            list._indices = new Ctor(thisCount);\n\n            for (var i = 0; i < thisCount; i++) {\n              list._indices[i] = this._indices[i];\n            }\n          } else {\n            list._indices = new Ctor(this._indices);\n          }\n        } else {\n          list._indices = null;\n        }\n\n        list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n        return list;\n      };\n\n      List.prototype.wrapMethod = function (methodName, injectFunction) {\n        var originalMethod = this[methodName];\n\n        if (typeof originalMethod !== 'function') {\n          return;\n        }\n\n        this.__wrappedMethods = this.__wrappedMethods || [];\n\n        this.__wrappedMethods.push(methodName);\n\n        this[methodName] = function () {\n          var res = originalMethod.apply(this, arguments);\n          return injectFunction.apply(this, [res].concat(slice(arguments)));\n        };\n      };\n\n      List.internalField = function () {\n        defaultDimValueGetters = {\n          arrayRows: getDimValueSimply,\n          objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n            return parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n          },\n          keyedColumns: getDimValueSimply,\n          original: function (dataItem, dimName, dataIndex, dimIndex) {\n            var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\n            if (!this._rawData.pure && isDataItemOption(dataItem)) {\n              this.hasItemOption = true;\n            }\n\n            return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);\n          },\n          typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n            return dataItem[dimIndex];\n          }\n        };\n\n        function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n          return parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n        }\n\n        prepareInvertedIndex = function (list) {\n          var invertedIndicesMap = list._invertedIndicesMap;\n          each(invertedIndicesMap, function (invertedIndices, dim) {\n            var dimInfo = list._dimensionInfos[dim];\n            var ordinalMeta = dimInfo.ordinalMeta;\n\n            if (ordinalMeta) {\n              invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n\n              for (var i = 0; i < invertedIndices.length; i++) {\n                invertedIndices[i] = INDEX_NOT_FOUND;\n              }\n\n              for (var i = 0; i < list._count; i++) {\n                invertedIndices[list.get(dim, i)] = i;\n              }\n            }\n          });\n        };\n\n        getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n          var val;\n          var chunk = list._storageArr[dimIdx];\n\n          if (chunk) {\n            val = chunk[rawIndex];\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              val = ordinalMeta.categories[val];\n            }\n          }\n\n          return convertOptionIdName(val, null);\n        };\n\n        getIndicesCtor = function (list) {\n          return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n        };\n\n        prepareStorage = function (storage, dimInfo, end, append) {\n          var DataCtor = dataCtors[dimInfo.type];\n          var dim = dimInfo.name;\n\n          if (append) {\n            var oldStore = storage[dim];\n            var oldLen = oldStore && oldStore.length;\n\n            if (!(oldLen === end)) {\n              var newStore = new DataCtor(end);\n\n              for (var j = 0; j < oldLen; j++) {\n                newStore[j] = oldStore[j];\n              }\n\n              storage[dim] = newStore;\n            }\n          } else {\n            storage[dim] = new DataCtor(end);\n          }\n        };\n\n        getRawIndexWithoutIndices = function (idx) {\n          return idx;\n        };\n\n        getRawIndexWithIndices = function (idx) {\n          if (idx < this._count && idx >= 0) {\n            return this._indices[idx];\n          }\n\n          return -1;\n        };\n\n        getId = function (list, rawIndex) {\n          var id = list._idList[rawIndex];\n\n          if (id == null && list._idDimIdx != null) {\n            id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n          }\n\n          if (id == null) {\n            id = ID_PREFIX + rawIndex;\n          }\n\n          return id;\n        };\n\n        normalizeDimensions = function (dimensions) {\n          if (!isArray(dimensions)) {\n            dimensions = dimensions != null ? [dimensions] : [];\n          }\n\n          return dimensions;\n        };\n\n        validateDimensions = function (list, dims) {\n          for (var i = 0; i < dims.length; i++) {\n            if (!list._dimensionInfos[dims[i]]) {\n              console.error('Unkown dimension ' + dims[i]);\n            }\n          }\n        };\n\n        cloneListForMapAndSample = function (original, excludeDimensions) {\n          var allDimensions = original.dimensions;\n          var list = new List(map$1(allDimensions, original.getDimensionInfo, original), original.hostModel);\n          transferProperties(list, original);\n          var storage = list._storage = {};\n          var originalStorage = original._storage;\n          var storageArr = list._storageArr = [];\n\n          for (var i = 0; i < allDimensions.length; i++) {\n            var dim = allDimensions[i];\n\n            if (originalStorage[dim]) {\n              if (indexOf(excludeDimensions, dim) >= 0) {\n                storage[dim] = cloneChunk(originalStorage[dim]);\n                list._rawExtent[dim] = getInitialExtent();\n                list._extent[dim] = null;\n              } else {\n                storage[dim] = originalStorage[dim];\n              }\n\n              storageArr.push(storage[dim]);\n            }\n          }\n\n          return list;\n        };\n\n        function cloneChunk(originalChunk) {\n          var Ctor = originalChunk.constructor;\n          return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n        }\n\n        getInitialExtent = function () {\n          return [Infinity, -Infinity];\n        };\n\n        setItemDataAndSeriesIndex = function (child) {\n          var childECData = getECData(child);\n          var thisECData = getECData(this);\n          childECData.seriesIndex = thisECData.seriesIndex;\n          childECData.dataIndex = thisECData.dataIndex;\n          childECData.dataType = thisECData.dataType;\n        };\n\n        transferProperties = function (target, source) {\n          each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n            if (source.hasOwnProperty(propName)) {\n              target[propName] = source[propName];\n            }\n          });\n          target.__wrappedMethods = source.__wrappedMethods;\n          each(CLONE_PROPERTIES, function (propName) {\n            target[propName] = clone(source[propName]);\n          });\n          target._calculationInfo = extend({}, source._calculationInfo);\n        };\n\n        makeIdFromName = function (list, idx) {\n          var nameList = list._nameList;\n          var idList = list._idList;\n          var nameDimIdx = list._nameDimIdx;\n          var idDimIdx = list._idDimIdx;\n          var name = nameList[idx];\n          var id = idList[idx];\n\n          if (name == null && nameDimIdx != null) {\n            nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n          }\n\n          if (id == null && idDimIdx != null) {\n            idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n          }\n\n          if (id == null && name != null) {\n            var nameRepeatCount = list._nameRepeatCount;\n            var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n            id = name;\n\n            if (nmCnt > 1) {\n              id += '__ec__' + nmCnt;\n            }\n\n            idList[idx] = id;\n          }\n        };\n      }();\n\n      return List;\n    }();\n\n    function completeDimensions(sysDims, source, opt) {\n      if (!isSourceInstance(source)) {\n        source = createSourceFromSeriesDataOption(source);\n      }\n\n      opt = opt || {};\n      sysDims = (sysDims || []).slice();\n      var dimsDef = (opt.dimsDef || []).slice();\n      var dataDimNameMap = createHashMap();\n      var coordDimNameMap = createHashMap();\n      var result = [];\n      var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount);\n\n      for (var i = 0; i < dimCount; i++) {\n        var dimDefItemRaw = dimsDef[i];\n        var dimDefItem = dimsDef[i] = extend({}, isObject(dimDefItemRaw) ? dimDefItemRaw : {\n          name: dimDefItemRaw\n        });\n        var userDimName = dimDefItem.name;\n        var resultItem = result[i] = new DataDimensionInfo();\n\n        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {\n          resultItem.name = resultItem.displayName = userDimName;\n          dataDimNameMap.set(userDimName, i);\n        }\n\n        dimDefItem.type != null && (resultItem.type = dimDefItem.type);\n        dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);\n      }\n\n      var encodeDef = opt.encodeDef;\n\n      if (!encodeDef && opt.encodeDefaulter) {\n        encodeDef = opt.encodeDefaulter(source, dimCount);\n      }\n\n      var encodeDefMap = createHashMap(encodeDef);\n      encodeDefMap.each(function (dataDimsRaw, coordDim) {\n        var dataDims = normalizeToArray(dataDimsRaw).slice();\n\n        if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {\n          encodeDefMap.set(coordDim, false);\n          return;\n        }\n\n        var validDataDims = encodeDefMap.set(coordDim, []);\n        each(dataDims, function (resultDimIdxOrName, idx) {\n          var resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;\n\n          if (resultDimIdx != null && resultDimIdx < dimCount) {\n            validDataDims[idx] = resultDimIdx;\n            applyDim(result[resultDimIdx], coordDim, idx);\n          }\n        });\n      });\n      var availDimIdx = 0;\n      each(sysDims, function (sysDimItemRaw) {\n        var coordDim;\n        var sysDimItemDimsDef;\n        var sysDimItemOtherDims;\n        var sysDimItem;\n\n        if (isString(sysDimItemRaw)) {\n          coordDim = sysDimItemRaw;\n          sysDimItem = {};\n        } else {\n          sysDimItem = sysDimItemRaw;\n          coordDim = sysDimItem.name;\n          var ordinalMeta = sysDimItem.ordinalMeta;\n          sysDimItem.ordinalMeta = null;\n          sysDimItem = clone(sysDimItem);\n          sysDimItem.ordinalMeta = ordinalMeta;\n          sysDimItemDimsDef = sysDimItem.dimsDef;\n          sysDimItemOtherDims = sysDimItem.otherDims;\n          sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;\n        }\n\n        var dataDims = encodeDefMap.get(coordDim);\n\n        if (dataDims === false) {\n          return;\n        }\n\n        dataDims = normalizeToArray(dataDims);\n\n        if (!dataDims.length) {\n          for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {\n            while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {\n              availDimIdx++;\n            }\n\n            availDimIdx < result.length && dataDims.push(availDimIdx++);\n          }\n        }\n\n        each(dataDims, function (resultDimIdx, coordDimIndex) {\n          var resultItem = result[resultDimIdx];\n          applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);\n\n          if (resultItem.name == null && sysDimItemDimsDef) {\n            var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];\n            !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {\n              name: sysDimItemDimsDefItem\n            });\n            resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;\n            resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;\n          }\n\n          sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);\n        });\n      });\n\n      function applyDim(resultItem, coordDim, coordDimIndex) {\n        if (VISUAL_DIMENSIONS.get(coordDim) != null) {\n          resultItem.otherDims[coordDim] = coordDimIndex;\n        } else {\n          resultItem.coordDim = coordDim;\n          resultItem.coordDimIndex = coordDimIndex;\n          coordDimNameMap.set(coordDim, true);\n        }\n      }\n\n      var generateCoord = opt.generateCoord;\n      var generateCoordCount = opt.generateCoordCount;\n      var fromZero = generateCoordCount != null;\n      generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;\n      var extra = generateCoord || 'value';\n\n      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {\n        var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();\n        var coordDim = resultItem.coordDim;\n\n        if (coordDim == null) {\n          resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);\n          resultItem.coordDimIndex = 0;\n\n          if (!generateCoord || generateCoordCount <= 0) {\n            resultItem.isExtraCoord = true;\n          }\n\n          generateCoordCount--;\n        }\n\n        resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap, false));\n\n        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {\n          resultItem.type = 'ordinal';\n        }\n      }\n\n      return result;\n    }\n\n    function getDimCount(source, sysDims, dimsDef, optDimCount) {\n      var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);\n      each(sysDims, function (sysDimItem) {\n        var sysDimItemDimsDef;\n\n        if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {\n          dimCount = Math.max(dimCount, sysDimItemDimsDef.length);\n        }\n      });\n      return dimCount;\n    }\n\n    function genName(name, map, fromZero) {\n      if (fromZero || map.get(name) != null) {\n        var i = 0;\n\n        while (map.get(name + i) != null) {\n          i++;\n        }\n\n        name += i;\n      }\n\n      map.set(name, true);\n      return name;\n    }\n\n    function createDimensions(source, opt) {\n      opt = opt || {};\n      return completeDimensions(opt.coordDimensions || [], source, {\n        dimsDef: opt.dimensionsDefine || source.dimensionsDefine,\n        encodeDef: opt.encodeDefine || source.encodeDefine,\n        dimCount: opt.dimensionsCount,\n        encodeDefaulter: opt.encodeDefaulter,\n        generateCoord: opt.generateCoord,\n        generateCoordCount: opt.generateCoordCount\n      });\n    }\n\n    var CoordSysInfo = function () {\n      function CoordSysInfo(coordSysName) {\n        this.coordSysDims = [];\n        this.axisMap = createHashMap();\n        this.categoryAxisMap = createHashMap();\n        this.coordSysName = coordSysName;\n      }\n\n      return CoordSysInfo;\n    }();\n\n    function getCoordSysInfoBySeries(seriesModel) {\n      var coordSysName = seriesModel.get('coordinateSystem');\n      var result = new CoordSysInfo(coordSysName);\n      var fetch = fetchers[coordSysName];\n\n      if (fetch) {\n        fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);\n        return result;\n      }\n    }\n    var fetchers = {\n      cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {\n        var xAxisModel = seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n        var yAxisModel = seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n\n        if (\"development\" !== 'production') {\n          if (!xAxisModel) {\n            throw new Error('xAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n          }\n\n          if (!yAxisModel) {\n            throw new Error('yAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n          }\n        }\n\n        result.coordSysDims = ['x', 'y'];\n        axisMap.set('x', xAxisModel);\n        axisMap.set('y', yAxisModel);\n\n        if (isCategory(xAxisModel)) {\n          categoryAxisMap.set('x', xAxisModel);\n          result.firstCategoryDimIndex = 0;\n        }\n\n        if (isCategory(yAxisModel)) {\n          categoryAxisMap.set('y', yAxisModel);\n          result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n        }\n      },\n      singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {\n        var singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];\n\n        if (\"development\" !== 'production') {\n          if (!singleAxisModel) {\n            throw new Error('singleAxis should be specified.');\n          }\n        }\n\n        result.coordSysDims = ['single'];\n        axisMap.set('single', singleAxisModel);\n\n        if (isCategory(singleAxisModel)) {\n          categoryAxisMap.set('single', singleAxisModel);\n          result.firstCategoryDimIndex = 0;\n        }\n      },\n      polar: function (seriesModel, result, axisMap, categoryAxisMap) {\n        var polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0];\n        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n        var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\n        if (\"development\" !== 'production') {\n          if (!angleAxisModel) {\n            throw new Error('angleAxis option not found');\n          }\n\n          if (!radiusAxisModel) {\n            throw new Error('radiusAxis option not found');\n          }\n        }\n\n        result.coordSysDims = ['radius', 'angle'];\n        axisMap.set('radius', radiusAxisModel);\n        axisMap.set('angle', angleAxisModel);\n\n        if (isCategory(radiusAxisModel)) {\n          categoryAxisMap.set('radius', radiusAxisModel);\n          result.firstCategoryDimIndex = 0;\n        }\n\n        if (isCategory(angleAxisModel)) {\n          categoryAxisMap.set('angle', angleAxisModel);\n          result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n        }\n      },\n      geo: function (seriesModel, result, axisMap, categoryAxisMap) {\n        result.coordSysDims = ['lng', 'lat'];\n      },\n      parallel: function (seriesModel, result, axisMap, categoryAxisMap) {\n        var ecModel = seriesModel.ecModel;\n        var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n        var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();\n        each(parallelModel.parallelAxisIndex, function (axisIndex, index) {\n          var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n          var axisDim = coordSysDims[index];\n          axisMap.set(axisDim, axisModel);\n\n          if (isCategory(axisModel)) {\n            categoryAxisMap.set(axisDim, axisModel);\n\n            if (result.firstCategoryDimIndex == null) {\n              result.firstCategoryDimIndex = index;\n            }\n          }\n        });\n      }\n    };\n\n    function isCategory(axisModel) {\n      return axisModel.get('type') === 'category';\n    }\n\n    function enableDataStack(seriesModel, dimensionInfoList, opt) {\n      opt = opt || {};\n      var byIndex = opt.byIndex;\n      var stackedCoordDimension = opt.stackedCoordDimension;\n      var mayStack = !!(seriesModel && seriesModel.get('stack'));\n      var stackedByDimInfo;\n      var stackedDimInfo;\n      var stackResultDimension;\n      var stackedOverDimension;\n      each(dimensionInfoList, function (dimensionInfo, index) {\n        if (isString(dimensionInfo)) {\n          dimensionInfoList[index] = dimensionInfo = {\n            name: dimensionInfo\n          };\n        }\n\n        if (mayStack && !dimensionInfo.isExtraCoord) {\n          if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n            stackedByDimInfo = dimensionInfo;\n          }\n\n          if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n            stackedDimInfo = dimensionInfo;\n          }\n        }\n      });\n\n      if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n        byIndex = true;\n      }\n\n      if (stackedDimInfo) {\n        stackResultDimension = '__\\0ecstackresult';\n        stackedOverDimension = '__\\0ecstackedover';\n\n        if (stackedByDimInfo) {\n          stackedByDimInfo.createInvertedIndices = true;\n        }\n\n        var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n        var stackedDimType = stackedDimInfo.type;\n        var stackedDimCoordIndex_1 = 0;\n        each(dimensionInfoList, function (dimensionInfo) {\n          if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n            stackedDimCoordIndex_1++;\n          }\n        });\n        dimensionInfoList.push({\n          name: stackResultDimension,\n          coordDim: stackedDimCoordDim_1,\n          coordDimIndex: stackedDimCoordIndex_1,\n          type: stackedDimType,\n          isExtraCoord: true,\n          isCalculationCoord: true\n        });\n        stackedDimCoordIndex_1++;\n        dimensionInfoList.push({\n          name: stackedOverDimension,\n          coordDim: stackedOverDimension,\n          coordDimIndex: stackedDimCoordIndex_1,\n          type: stackedDimType,\n          isExtraCoord: true,\n          isCalculationCoord: true\n        });\n      }\n\n      return {\n        stackedDimension: stackedDimInfo && stackedDimInfo.name,\n        stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n        isStackedByIndex: byIndex,\n        stackedOverDimension: stackedOverDimension,\n        stackResultDimension: stackResultDimension\n      };\n    }\n    function isDimensionStacked(data, stackedDim) {\n      return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n    }\n    function getStackedDimension(data, targetDim) {\n      return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n    }\n\n    function createListFromArray(source, seriesModel, opt) {\n      opt = opt || {};\n\n      if (!isSourceInstance(source)) {\n        source = createSourceFromSeriesDataOption(source);\n      }\n\n      var coordSysName = seriesModel.get('coordinateSystem');\n      var registeredCoordSys = CoordinateSystemManager.get(coordSysName);\n      var coordSysInfo = getCoordSysInfoBySeries(seriesModel);\n      var coordSysDimDefs;\n\n      if (coordSysInfo && coordSysInfo.coordSysDims) {\n        coordSysDimDefs = map(coordSysInfo.coordSysDims, function (dim) {\n          var dimInfo = {\n            name: dim\n          };\n          var axisModel = coordSysInfo.axisMap.get(dim);\n\n          if (axisModel) {\n            var axisType = axisModel.get('type');\n            dimInfo.type = getDimensionTypeByAxis(axisType);\n          }\n\n          return dimInfo;\n        });\n      }\n\n      if (!coordSysDimDefs) {\n        coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n      }\n\n      var useEncodeDefaulter = opt.useEncodeDefaulter;\n      var dimInfoList = createDimensions(source, {\n        coordDimensions: coordSysDimDefs,\n        generateCoord: opt.generateCoord,\n        encodeDefaulter: isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null\n      });\n      var firstCategoryDimIndex;\n      var hasNameEncode;\n      coordSysInfo && each(dimInfoList, function (dimInfo, dimIndex) {\n        var coordDim = dimInfo.coordDim;\n        var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);\n\n        if (categoryAxisModel) {\n          if (firstCategoryDimIndex == null) {\n            firstCategoryDimIndex = dimIndex;\n          }\n\n          dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();\n\n          if (opt.createInvertedIndices) {\n            dimInfo.createInvertedIndices = true;\n          }\n        }\n\n        if (dimInfo.otherDims.itemName != null) {\n          hasNameEncode = true;\n        }\n      });\n\n      if (!hasNameEncode && firstCategoryDimIndex != null) {\n        dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;\n      }\n\n      var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList);\n      var list = new List(dimInfoList, seriesModel);\n      list.setCalculationInfo(stackCalculationInfo);\n      var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n        return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);\n      } : null;\n      list.hasItemOption = false;\n      list.initData(source, null, dimValueGetter);\n      return list;\n    }\n\n    function isNeedCompleteOrdinalData(source) {\n      if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n        var sampleItem = firstDataNotNull(source.data || []);\n        return sampleItem != null && !isArray(getDataItemValue(sampleItem));\n      }\n    }\n\n    function firstDataNotNull(data) {\n      var i = 0;\n\n      while (i < data.length && data[i] == null) {\n        i++;\n      }\n\n      return data[i];\n    }\n\n    var Scale = function () {\n      function Scale(setting) {\n        this._setting = setting || {};\n        this._extent = [Infinity, -Infinity];\n      }\n\n      Scale.prototype.getSetting = function (name) {\n        return this._setting[name];\n      };\n\n      Scale.prototype.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n      };\n\n      Scale.prototype.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getApproximateExtent(dim));\n      };\n\n      Scale.prototype.getExtent = function () {\n        return this._extent.slice();\n      };\n\n      Scale.prototype.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n\n        if (!isNaN(start)) {\n          thisExtent[0] = start;\n        }\n\n        if (!isNaN(end)) {\n          thisExtent[1] = end;\n        }\n      };\n\n      Scale.prototype.isInExtentRange = function (value) {\n        return this._extent[0] <= value && this._extent[1] >= value;\n      };\n\n      Scale.prototype.isBlank = function () {\n        return this._isBlank;\n      };\n\n      Scale.prototype.setBlank = function (isBlank) {\n        this._isBlank = isBlank;\n      };\n\n      return Scale;\n    }();\n\n    enableClassManagement(Scale);\n\n    var OrdinalMeta = function () {\n      function OrdinalMeta(opt) {\n        this.categories = opt.categories || [];\n        this._needCollect = opt.needCollect;\n        this._deduplication = opt.deduplication;\n      }\n\n      OrdinalMeta.createByAxisModel = function (axisModel) {\n        var option = axisModel.option;\n        var data = option.data;\n        var categories = data && map(data, getName);\n        return new OrdinalMeta({\n          categories: categories,\n          needCollect: !categories,\n          deduplication: option.dedplication !== false\n        });\n      };\n\n      OrdinalMeta.prototype.getOrdinal = function (category) {\n        return this._getOrCreateMap().get(category);\n      };\n\n      OrdinalMeta.prototype.parseAndCollect = function (category) {\n        var index;\n        var needCollect = this._needCollect;\n\n        if (typeof category !== 'string' && !needCollect) {\n          return category;\n        }\n\n        if (needCollect && !this._deduplication) {\n          index = this.categories.length;\n          this.categories[index] = category;\n          return index;\n        }\n\n        var map = this._getOrCreateMap();\n\n        index = map.get(category);\n\n        if (index == null) {\n          if (needCollect) {\n            index = this.categories.length;\n            this.categories[index] = category;\n            map.set(category, index);\n          } else {\n            index = NaN;\n          }\n        }\n\n        return index;\n      };\n\n      OrdinalMeta.prototype._getOrCreateMap = function () {\n        return this._map || (this._map = createHashMap(this.categories));\n      };\n\n      return OrdinalMeta;\n    }();\n\n    function getName(obj) {\n      if (isObject(obj) && obj.value != null) {\n        return obj.value;\n      } else {\n        return obj + '';\n      }\n    }\n\n    var roundNumber = round;\n    function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {\n      var result = {};\n      var span = extent[1] - extent[0];\n      var interval = result.interval = nice(span / splitNumber, true);\n\n      if (minInterval != null && interval < minInterval) {\n        interval = result.interval = minInterval;\n      }\n\n      if (maxInterval != null && interval > maxInterval) {\n        interval = result.interval = maxInterval;\n      }\n\n      var precision = result.intervalPrecision = getIntervalPrecision(interval);\n      var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];\n      fixExtent(niceTickExtent, extent);\n      return result;\n    }\n    function getIntervalPrecision(interval) {\n      return getPrecisionSafe(interval) + 2;\n    }\n\n    function clamp(niceTickExtent, idx, extent) {\n      niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);\n    }\n\n    function fixExtent(niceTickExtent, extent) {\n      !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);\n      !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);\n      clamp(niceTickExtent, 0, extent);\n      clamp(niceTickExtent, 1, extent);\n\n      if (niceTickExtent[0] > niceTickExtent[1]) {\n        niceTickExtent[0] = niceTickExtent[1];\n      }\n    }\n    function contain$1(val, extent) {\n      return val >= extent[0] && val <= extent[1];\n    }\n    function normalize$1(val, extent) {\n      if (extent[1] === extent[0]) {\n        return 0.5;\n      }\n\n      return (val - extent[0]) / (extent[1] - extent[0]);\n    }\n    function scale$2(val, extent) {\n      return val * (extent[1] - extent[0]) + extent[0];\n    }\n\n    var OrdinalScale = function (_super) {\n      __extends(OrdinalScale, _super);\n\n      function OrdinalScale(setting) {\n        var _this = _super.call(this, setting) || this;\n\n        _this.type = 'ordinal';\n\n        var ordinalMeta = _this.getSetting('ordinalMeta');\n\n        if (!ordinalMeta) {\n          ordinalMeta = new OrdinalMeta({});\n        }\n\n        if (isArray(ordinalMeta)) {\n          ordinalMeta = new OrdinalMeta({\n            categories: map(ordinalMeta, function (item) {\n              return isObject(item) ? item.value : item;\n            })\n          });\n        }\n\n        _this._ordinalMeta = ordinalMeta;\n        _this._extent = _this.getSetting('extent') || [0, ordinalMeta.categories.length - 1];\n        return _this;\n      }\n\n      OrdinalScale.prototype.parse = function (val) {\n        return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) : Math.round(val);\n      };\n\n      OrdinalScale.prototype.contain = function (rank) {\n        rank = this.parse(rank);\n        return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null;\n      };\n\n      OrdinalScale.prototype.normalize = function (val) {\n        val = this._getTickNumber(this.parse(val));\n        return normalize$1(val, this._extent);\n      };\n\n      OrdinalScale.prototype.scale = function (val) {\n        val = Math.round(scale$2(val, this._extent));\n        return this.getRawOrdinalNumber(val);\n      };\n\n      OrdinalScale.prototype.getTicks = function () {\n        var ticks = [];\n        var extent = this._extent;\n        var rank = extent[0];\n\n        while (rank <= extent[1]) {\n          ticks.push({\n            value: rank\n          });\n          rank++;\n        }\n\n        return ticks;\n      };\n\n      OrdinalScale.prototype.getMinorTicks = function (splitNumber) {\n        return;\n      };\n\n      OrdinalScale.prototype.setSortInfo = function (info) {\n        if (info == null) {\n          this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;\n          return;\n        }\n\n        var infoOrdinalNumbers = info.ordinalNumbers;\n        var ordinalsByTick = this._ordinalNumbersByTick = [];\n        var ticksByOrdinal = this._ticksByOrdinalNumber = [];\n        var tickNum = 0;\n        var allCategoryLen = this._ordinalMeta.categories.length;\n\n        for (var len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {\n          var ordinalNumber = infoOrdinalNumbers[tickNum];\n          ordinalsByTick[tickNum] = ordinalNumber;\n          ticksByOrdinal[ordinalNumber] = tickNum;\n        }\n\n        var unusedOrdinal = 0;\n\n        for (; tickNum < allCategoryLen; ++tickNum) {\n          while (ticksByOrdinal[unusedOrdinal] != null) {\n            unusedOrdinal++;\n          }\n          ordinalsByTick.push(unusedOrdinal);\n          ticksByOrdinal[unusedOrdinal] = tickNum;\n        }\n      };\n\n      OrdinalScale.prototype._getTickNumber = function (ordinal) {\n        var ticksByOrdinalNumber = this._ticksByOrdinalNumber;\n        return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;\n      };\n\n      OrdinalScale.prototype.getRawOrdinalNumber = function (tickNumber) {\n        var ordinalNumbersByTick = this._ordinalNumbersByTick;\n        return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;\n      };\n\n      OrdinalScale.prototype.getLabel = function (tick) {\n        if (!this.isBlank()) {\n          var ordinalNumber = this.getRawOrdinalNumber(tick.value);\n          var cateogry = this._ordinalMeta.categories[ordinalNumber];\n          return cateogry == null ? '' : cateogry + '';\n        }\n      };\n\n      OrdinalScale.prototype.count = function () {\n        return this._extent[1] - this._extent[0] + 1;\n      };\n\n      OrdinalScale.prototype.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getApproximateExtent(dim));\n      };\n\n      OrdinalScale.prototype.isInExtentRange = function (value) {\n        value = this._getTickNumber(value);\n        return this._extent[0] <= value && this._extent[1] >= value;\n      };\n\n      OrdinalScale.prototype.getOrdinalMeta = function () {\n        return this._ordinalMeta;\n      };\n\n      OrdinalScale.prototype.niceTicks = function () {};\n\n      OrdinalScale.prototype.niceExtent = function () {};\n\n      OrdinalScale.type = 'ordinal';\n      return OrdinalScale;\n    }(Scale);\n\n    Scale.registerClass(OrdinalScale);\n\n    var roundNumber$1 = round;\n\n    var IntervalScale = function (_super) {\n      __extends(IntervalScale, _super);\n\n      function IntervalScale() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'interval';\n        _this._interval = 0;\n        _this._intervalPrecision = 2;\n        return _this;\n      }\n\n      IntervalScale.prototype.parse = function (val) {\n        return val;\n      };\n\n      IntervalScale.prototype.contain = function (val) {\n        return contain$1(val, this._extent);\n      };\n\n      IntervalScale.prototype.normalize = function (val) {\n        return normalize$1(val, this._extent);\n      };\n\n      IntervalScale.prototype.scale = function (val) {\n        return scale$2(val, this._extent);\n      };\n\n      IntervalScale.prototype.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n\n        if (!isNaN(start)) {\n          thisExtent[0] = parseFloat(start);\n        }\n\n        if (!isNaN(end)) {\n          thisExtent[1] = parseFloat(end);\n        }\n      };\n\n      IntervalScale.prototype.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        this.setExtent(extent[0], extent[1]);\n      };\n\n      IntervalScale.prototype.getInterval = function () {\n        return this._interval;\n      };\n\n      IntervalScale.prototype.setInterval = function (interval) {\n        this._interval = interval;\n        this._niceExtent = this._extent.slice();\n        this._intervalPrecision = getIntervalPrecision(interval);\n      };\n\n      IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n        var interval = this._interval;\n        var extent = this._extent;\n        var niceTickExtent = this._niceExtent;\n        var intervalPrecision = this._intervalPrecision;\n        var ticks = [];\n\n        if (!interval) {\n          return ticks;\n        }\n\n        var safeLimit = 10000;\n\n        if (extent[0] < niceTickExtent[0]) {\n          if (expandToNicedExtent) {\n            ticks.push({\n              value: roundNumber$1(niceTickExtent[0] - interval, intervalPrecision)\n            });\n          } else {\n            ticks.push({\n              value: extent[0]\n            });\n          }\n        }\n\n        var tick = niceTickExtent[0];\n\n        while (tick <= niceTickExtent[1]) {\n          ticks.push({\n            value: tick\n          });\n          tick = roundNumber$1(tick + interval, intervalPrecision);\n\n          if (tick === ticks[ticks.length - 1].value) {\n            break;\n          }\n\n          if (ticks.length > safeLimit) {\n            return [];\n          }\n        }\n\n        var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n        if (extent[1] > lastNiceTick) {\n          if (expandToNicedExtent) {\n            ticks.push({\n              value: roundNumber$1(lastNiceTick + interval, intervalPrecision)\n            });\n          } else {\n            ticks.push({\n              value: extent[1]\n            });\n          }\n        }\n\n        return ticks;\n      };\n\n      IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n        var ticks = this.getTicks(true);\n        var minorTicks = [];\n        var extent = this.getExtent();\n\n        for (var i = 1; i < ticks.length; i++) {\n          var nextTick = ticks[i];\n          var prevTick = ticks[i - 1];\n          var count = 0;\n          var minorTicksGroup = [];\n          var interval = nextTick.value - prevTick.value;\n          var minorInterval = interval / splitNumber;\n\n          while (count < splitNumber - 1) {\n            var minorTick = roundNumber$1(prevTick.value + (count + 1) * minorInterval);\n\n            if (minorTick > extent[0] && minorTick < extent[1]) {\n              minorTicksGroup.push(minorTick);\n            }\n\n            count++;\n          }\n\n          minorTicks.push(minorTicksGroup);\n        }\n\n        return minorTicks;\n      };\n\n      IntervalScale.prototype.getLabel = function (data, opt) {\n        if (data == null) {\n          return '';\n        }\n\n        var precision = opt && opt.precision;\n\n        if (precision == null) {\n          precision = getPrecisionSafe(data.value) || 0;\n        } else if (precision === 'auto') {\n          precision = this._intervalPrecision;\n        }\n\n        var dataNum = roundNumber$1(data.value, precision, true);\n        return addCommas(dataNum);\n      };\n\n      IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {\n        splitNumber = splitNumber || 5;\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n\n        if (!isFinite(span)) {\n          return;\n        }\n\n        if (span < 0) {\n          span = -span;\n          extent.reverse();\n        }\n\n        var result = intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n        this._intervalPrecision = result.intervalPrecision;\n        this._interval = result.interval;\n        this._niceExtent = result.niceTickExtent;\n      };\n\n      IntervalScale.prototype.niceExtent = function (opt) {\n        var extent = this._extent;\n\n        if (extent[0] === extent[1]) {\n          if (extent[0] !== 0) {\n            var expandSize = extent[0];\n\n            if (!opt.fixMax) {\n              extent[1] += expandSize / 2;\n              extent[0] -= expandSize / 2;\n            } else {\n              extent[0] -= expandSize / 2;\n            }\n          } else {\n            extent[1] = 1;\n          }\n        }\n\n        var span = extent[1] - extent[0];\n\n        if (!isFinite(span)) {\n          extent[0] = 0;\n          extent[1] = 1;\n        }\n\n        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n        var interval = this._interval;\n\n        if (!opt.fixMin) {\n          extent[0] = roundNumber$1(Math.floor(extent[0] / interval) * interval);\n        }\n\n        if (!opt.fixMax) {\n          extent[1] = roundNumber$1(Math.ceil(extent[1] / interval) * interval);\n        }\n      };\n\n      IntervalScale.type = 'interval';\n      return IntervalScale;\n    }(Scale);\n\n    Scale.registerClass(IntervalScale);\n\n    var STACK_PREFIX = '__ec_stack_';\n    var LARGE_BAR_MIN_WIDTH = 0.5;\n    var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\n    function getSeriesStackId(seriesModel) {\n      return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey(axis) {\n      return axis.dim + axis.index;\n    }\n\n    function getLayoutOnAxis(opt) {\n      var params = [];\n      var baseAxis = opt.axis;\n      var axisKey = 'axis0';\n\n      if (baseAxis.type !== 'category') {\n        return;\n      }\n\n      var bandWidth = baseAxis.getBandWidth();\n\n      for (var i = 0; i < opt.count || 0; i++) {\n        params.push(defaults({\n          bandWidth: bandWidth,\n          axisKey: axisKey,\n          stackId: STACK_PREFIX + i\n        }, opt));\n      }\n\n      var widthAndOffsets = doCalBarWidthAndOffset(params);\n      var result = [];\n\n      for (var i = 0; i < opt.count; i++) {\n        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n        item.offsetCenter = item.offset + item.width / 2;\n        result.push(item);\n      }\n\n      return result;\n    }\n    function prepareLayoutBarSeries(seriesType, ecModel) {\n      var seriesModels = [];\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n          seriesModels.push(seriesModel);\n        }\n      });\n      return seriesModels;\n    }\n\n    function getValueAxesMinGaps(barSeries) {\n      var axisValues = {};\n      each(barSeries, function (seriesModel) {\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n\n        if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n          return;\n        }\n\n        var data = seriesModel.getData();\n        var key = baseAxis.dim + '_' + baseAxis.index;\n        var dim = data.mapDimension(baseAxis.dim);\n\n        for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n          var value = data.get(dim, i);\n\n          if (!axisValues[key]) {\n            axisValues[key] = [value];\n          } else {\n            axisValues[key].push(value);\n          }\n        }\n      });\n      var axisMinGaps = {};\n\n      for (var key in axisValues) {\n        if (axisValues.hasOwnProperty(key)) {\n          var valuesInAxis = axisValues[key];\n\n          if (valuesInAxis) {\n            valuesInAxis.sort(function (a, b) {\n              return a - b;\n            });\n            var min = null;\n\n            for (var j = 1; j < valuesInAxis.length; ++j) {\n              var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n              if (delta > 0) {\n                min = min === null ? delta : Math.min(min, delta);\n              }\n            }\n\n            axisMinGaps[key] = min;\n          }\n        }\n      }\n\n      return axisMinGaps;\n    }\n\n    function makeColumnLayout(barSeries) {\n      var axisMinGaps = getValueAxesMinGaps(barSeries);\n      var seriesInfoList = [];\n      each(barSeries, function (seriesModel) {\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var axisExtent = baseAxis.getExtent();\n        var bandWidth;\n\n        if (baseAxis.type === 'category') {\n          bandWidth = baseAxis.getBandWidth();\n        } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n          var key = baseAxis.dim + '_' + baseAxis.index;\n          var minGap = axisMinGaps[key];\n          var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n          var scale = baseAxis.scale.getExtent();\n          var scaleSpan = Math.abs(scale[1] - scale[0]);\n          bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;\n        } else {\n          var data = seriesModel.getData();\n          bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n        }\n\n        var barWidth = parsePercent$1(seriesModel.get('barWidth'), bandWidth);\n        var barMaxWidth = parsePercent$1(seriesModel.get('barMaxWidth'), bandWidth);\n        var barMinWidth = parsePercent$1(seriesModel.get('barMinWidth') || 1, bandWidth);\n        var barGap = seriesModel.get('barGap');\n        var barCategoryGap = seriesModel.get('barCategoryGap');\n        seriesInfoList.push({\n          bandWidth: bandWidth,\n          barWidth: barWidth,\n          barMaxWidth: barMaxWidth,\n          barMinWidth: barMinWidth,\n          barGap: barGap,\n          barCategoryGap: barCategoryGap,\n          axisKey: getAxisKey(baseAxis),\n          stackId: getSeriesStackId(seriesModel)\n        });\n      });\n      return doCalBarWidthAndOffset(seriesInfoList);\n    }\n\n    function doCalBarWidthAndOffset(seriesInfoList) {\n      var columnsMap = {};\n      each(seriesInfoList, function (seriesInfo, idx) {\n        var axisKey = seriesInfo.axisKey;\n        var bandWidth = seriesInfo.bandWidth;\n        var columnsOnAxis = columnsMap[axisKey] || {\n          bandWidth: bandWidth,\n          remainedWidth: bandWidth,\n          autoWidthCount: 0,\n          categoryGap: null,\n          gap: '20%',\n          stacks: {}\n        };\n        var stacks = columnsOnAxis.stacks;\n        columnsMap[axisKey] = columnsOnAxis;\n        var stackId = seriesInfo.stackId;\n\n        if (!stacks[stackId]) {\n          columnsOnAxis.autoWidthCount++;\n        }\n\n        stacks[stackId] = stacks[stackId] || {\n          width: 0,\n          maxWidth: 0\n        };\n        var barWidth = seriesInfo.barWidth;\n\n        if (barWidth && !stacks[stackId].width) {\n          stacks[stackId].width = barWidth;\n          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n          columnsOnAxis.remainedWidth -= barWidth;\n        }\n\n        var barMaxWidth = seriesInfo.barMaxWidth;\n        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n        var barMinWidth = seriesInfo.barMinWidth;\n        barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n        var barGap = seriesInfo.barGap;\n        barGap != null && (columnsOnAxis.gap = barGap);\n        var barCategoryGap = seriesInfo.barCategoryGap;\n        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n      });\n      var result = {};\n      each(columnsMap, function (columnsOnAxis, coordSysName) {\n        result[coordSysName] = {};\n        var stacks = columnsOnAxis.stacks;\n        var bandWidth = columnsOnAxis.bandWidth;\n        var categoryGapPercent = columnsOnAxis.categoryGap;\n\n        if (categoryGapPercent == null) {\n          var columnCount = keys(stacks).length;\n          categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n        }\n\n        var categoryGap = parsePercent$1(categoryGapPercent, bandWidth);\n        var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);\n        var remainedWidth = columnsOnAxis.remainedWidth;\n        var autoWidthCount = columnsOnAxis.autoWidthCount;\n        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n        each(stacks, function (column) {\n          var maxWidth = column.maxWidth;\n          var minWidth = column.minWidth;\n\n          if (!column.width) {\n            var finalWidth = autoWidth;\n\n            if (maxWidth && maxWidth < finalWidth) {\n              finalWidth = Math.min(maxWidth, remainedWidth);\n            }\n\n            if (minWidth && minWidth > finalWidth) {\n              finalWidth = minWidth;\n            }\n\n            if (finalWidth !== autoWidth) {\n              column.width = finalWidth;\n              remainedWidth -= finalWidth + barGapPercent * finalWidth;\n              autoWidthCount--;\n            }\n          } else {\n            var finalWidth = column.width;\n\n            if (maxWidth) {\n              finalWidth = Math.min(finalWidth, maxWidth);\n            }\n\n            if (minWidth) {\n              finalWidth = Math.max(finalWidth, minWidth);\n            }\n\n            column.width = finalWidth;\n            remainedWidth -= finalWidth + barGapPercent * finalWidth;\n            autoWidthCount--;\n          }\n        });\n        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n        var widthSum = 0;\n        var lastColumn;\n        each(stacks, function (column, idx) {\n          if (!column.width) {\n            column.width = autoWidth;\n          }\n\n          lastColumn = column;\n          widthSum += column.width * (1 + barGapPercent);\n        });\n\n        if (lastColumn) {\n          widthSum -= lastColumn.width * barGapPercent;\n        }\n\n        var offset = -widthSum / 2;\n        each(stacks, function (column, stackId) {\n          result[coordSysName][stackId] = result[coordSysName][stackId] || {\n            bandWidth: bandWidth,\n            offset: offset,\n            width: column.width\n          };\n          offset += column.width * (1 + barGapPercent);\n        });\n      });\n      return result;\n    }\n\n    function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n      if (barWidthAndOffset && axis) {\n        var result = barWidthAndOffset[getAxisKey(axis)];\n\n        if (result != null && seriesModel != null) {\n          return result[getSeriesStackId(seriesModel)];\n        }\n\n        return result;\n      }\n    }\n    function layout(seriesType, ecModel) {\n      var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n      var barWidthAndOffset = makeColumnLayout(seriesModels);\n      var lastStackCoords = {};\n      each(seriesModels, function (seriesModel) {\n        var data = seriesModel.getData();\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var stackId = getSeriesStackId(seriesModel);\n        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n        var columnOffset = columnLayoutInfo.offset;\n        var columnWidth = columnLayoutInfo.width;\n        var valueAxis = cartesian.getOtherAxis(baseAxis);\n        var barMinHeight = seriesModel.get('barMinHeight') || 0;\n        lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n        data.setLayout({\n          bandWidth: columnLayoutInfo.bandWidth,\n          offset: columnOffset,\n          size: columnWidth\n        });\n        var valueDim = data.mapDimension(valueAxis.dim);\n        var baseDim = data.mapDimension(baseAxis.dim);\n        var stacked = isDimensionStacked(data, valueDim);\n        var isValueAxisH = valueAxis.isHorizontal();\n        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);\n\n        for (var idx = 0, len = data.count(); idx < len; idx++) {\n          var value = data.get(valueDim, idx);\n          var baseValue = data.get(baseDim, idx);\n          var sign = value >= 0 ? 'p' : 'n';\n          var baseCoord = valueAxisStart;\n\n          if (stacked) {\n            if (!lastStackCoords[stackId][baseValue]) {\n              lastStackCoords[stackId][baseValue] = {\n                p: valueAxisStart,\n                n: valueAxisStart\n              };\n            }\n\n            baseCoord = lastStackCoords[stackId][baseValue][sign];\n          }\n\n          var x = void 0;\n          var y = void 0;\n          var width = void 0;\n          var height = void 0;\n\n          if (isValueAxisH) {\n            var coord = cartesian.dataToPoint([value, baseValue]);\n            x = baseCoord;\n            y = coord[1] + columnOffset;\n            width = coord[0] - valueAxisStart;\n            height = columnWidth;\n\n            if (Math.abs(width) < barMinHeight) {\n              width = (width < 0 ? -1 : 1) * barMinHeight;\n            }\n\n            if (!isNaN(width)) {\n              stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n            }\n          } else {\n            var coord = cartesian.dataToPoint([baseValue, value]);\n            x = coord[0] + columnOffset;\n            y = baseCoord;\n            width = columnWidth;\n            height = coord[1] - valueAxisStart;\n\n            if (Math.abs(height) < barMinHeight) {\n              height = (height <= 0 ? -1 : 1) * barMinHeight;\n            }\n\n            if (!isNaN(height)) {\n              stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n            }\n          }\n\n          data.setItemLayout(idx, {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          });\n        }\n      });\n    }\n    var largeLayout = {\n      seriesType: 'bar',\n      plan: createRenderPlanner(),\n      reset: function (seriesModel) {\n        if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n          return;\n        }\n\n        var data = seriesModel.getData();\n        var cartesian = seriesModel.coordinateSystem;\n        var coordLayout = cartesian.master.getRect();\n        var baseAxis = cartesian.getBaseAxis();\n        var valueAxis = cartesian.getOtherAxis(baseAxis);\n        var valueDim = data.mapDimension(valueAxis.dim);\n        var baseDim = data.mapDimension(baseAxis.dim);\n        var valueAxisHorizontal = valueAxis.isHorizontal();\n        var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n        var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n        if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n          barWidth = LARGE_BAR_MIN_WIDTH;\n        }\n\n        return {\n          progress: function (params, data) {\n            var count = params.count;\n            var largePoints = new LargeArr(count * 2);\n            var largeBackgroundPoints = new LargeArr(count * 2);\n            var largeDataIndices = new LargeArr(count);\n            var dataIndex;\n            var coord = [];\n            var valuePair = [];\n            var pointsOffset = 0;\n            var idxOffset = 0;\n\n            while ((dataIndex = params.next()) != null) {\n              valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n              valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n              coord = cartesian.dataToPoint(valuePair, null, coord);\n              largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n              largePoints[pointsOffset++] = coord[0];\n              largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n              largePoints[pointsOffset++] = coord[1];\n              largeDataIndices[idxOffset++] = dataIndex;\n            }\n\n            data.setLayout({\n              largePoints: largePoints,\n              largeDataIndices: largeDataIndices,\n              largeBackgroundPoints: largeBackgroundPoints,\n              barWidth: barWidth,\n              valueAxisStart: getValueAxisStart(baseAxis, valueAxis),\n              backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n              valueAxisHorizontal: valueAxisHorizontal\n            });\n          }\n        };\n      }\n    };\n\n    function isOnCartesian(seriesModel) {\n      return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n    }\n\n    function isInLargeMode(seriesModel) {\n      return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n    }\n\n    function getValueAxisStart(baseAxis, valueAxis, stacked) {\n      return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n    }\n\n    var bisect = function (a, x, lo, hi) {\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n\n        if (a[mid][1] < x) {\n          lo = mid + 1;\n        } else {\n          hi = mid;\n        }\n      }\n\n      return lo;\n    };\n\n    var TimeScale = function (_super) {\n      __extends(TimeScale, _super);\n\n      function TimeScale(settings) {\n        var _this = _super.call(this, settings) || this;\n\n        _this.type = 'time';\n        return _this;\n      }\n\n      TimeScale.prototype.getLabel = function (tick) {\n        var useUTC = this.getSetting('useUTC');\n        return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting('locale'));\n      };\n\n      TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {\n        var isUTC = this.getSetting('useUTC');\n        var lang = this.getSetting('locale');\n        return leveledFormat(tick, idx, labelFormatter, lang, isUTC);\n      };\n\n      TimeScale.prototype.getTicks = function (expandToNicedExtent) {\n        var interval = this._interval;\n        var extent = this._extent;\n        var ticks = [];\n\n        if (!interval) {\n          return ticks;\n        }\n\n        ticks.push({\n          value: extent[0],\n          level: 0\n        });\n        var useUTC = this.getSetting('useUTC');\n        var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent);\n        ticks = ticks.concat(innerTicks);\n        ticks.push({\n          value: extent[1],\n          level: 0\n        });\n        return ticks;\n      };\n\n      TimeScale.prototype.niceExtent = function (opt) {\n        var extent = this._extent;\n\n        if (extent[0] === extent[1]) {\n          extent[0] -= ONE_DAY;\n          extent[1] += ONE_DAY;\n        }\n\n        if (extent[1] === -Infinity && extent[0] === Infinity) {\n          var d = new Date();\n          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());\n          extent[0] = extent[1] - ONE_DAY;\n        }\n\n        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n      };\n\n      TimeScale.prototype.niceTicks = function (approxTickNum, minInterval, maxInterval) {\n        approxTickNum = approxTickNum || 10;\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n        this._approxInterval = span / approxTickNum;\n\n        if (minInterval != null && this._approxInterval < minInterval) {\n          this._approxInterval = minInterval;\n        }\n\n        if (maxInterval != null && this._approxInterval > maxInterval) {\n          this._approxInterval = maxInterval;\n        }\n\n        var scaleIntervalsLen = scaleIntervals.length;\n        var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);\n        this._interval = scaleIntervals[idx][1];\n        this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];\n      };\n\n      TimeScale.prototype.parse = function (val) {\n        return typeof val === 'number' ? val : +parseDate(val);\n      };\n\n      TimeScale.prototype.contain = function (val) {\n        return contain$1(this.parse(val), this._extent);\n      };\n\n      TimeScale.prototype.normalize = function (val) {\n        return normalize$1(this.parse(val), this._extent);\n      };\n\n      TimeScale.prototype.scale = function (val) {\n        return scale$2(val, this._extent);\n      };\n\n      TimeScale.type = 'time';\n      return TimeScale;\n    }(IntervalScale);\n\n    var scaleIntervals = [['second', ONE_SECOND], ['minute', ONE_MINUTE], ['hour', ONE_HOUR], ['quarter-day', ONE_HOUR * 6], ['half-day', ONE_HOUR * 12], ['day', ONE_DAY * 1.2], ['half-week', ONE_DAY * 3.5], ['week', ONE_DAY * 7], ['month', ONE_DAY * 31], ['quarter', ONE_DAY * 95], ['half-year', ONE_YEAR / 2], ['year', ONE_YEAR]];\n\n    function isUnitValueSame(unit, valueA, valueB, isUTC) {\n      var dateA = parseDate(valueA);\n      var dateB = parseDate(valueB);\n\n      var isSame = function (unit) {\n        return getUnitValue(dateA, unit, isUTC) === getUnitValue(dateB, unit, isUTC);\n      };\n\n      var isSameYear = function () {\n        return isSame('year');\n      };\n\n      var isSameMonth = function () {\n        return isSameYear() && isSame('month');\n      };\n\n      var isSameDay = function () {\n        return isSameMonth() && isSame('day');\n      };\n\n      var isSameHour = function () {\n        return isSameDay() && isSame('hour');\n      };\n\n      var isSameMinute = function () {\n        return isSameHour() && isSame('minute');\n      };\n\n      var isSameSecond = function () {\n        return isSameMinute() && isSame('second');\n      };\n\n      var isSameMilliSecond = function () {\n        return isSameSecond() && isSame('millisecond');\n      };\n\n      switch (unit) {\n        case 'year':\n          return isSameYear();\n\n        case 'month':\n          return isSameMonth();\n\n        case 'day':\n          return isSameDay();\n\n        case 'hour':\n          return isSameHour();\n\n        case 'minute':\n          return isSameMinute();\n\n        case 'second':\n          return isSameSecond();\n\n        case 'millisecond':\n          return isSameMilliSecond();\n      }\n    }\n\n    function getDateInterval(approxInterval, daysInMonth) {\n      approxInterval /= ONE_DAY;\n      return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;\n    }\n\n    function getMonthInterval(approxInterval) {\n      var APPROX_ONE_MONTH = 30 * ONE_DAY;\n      approxInterval /= APPROX_ONE_MONTH;\n      return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;\n    }\n\n    function getHourInterval(approxInterval) {\n      approxInterval /= ONE_HOUR;\n      return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;\n    }\n\n    function getMinutesAndSecondsInterval(approxInterval, isMinutes) {\n      approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;\n      return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;\n    }\n\n    function getMillisecondsInterval(approxInterval) {\n      return nice(approxInterval, true);\n    }\n\n    function getFirstTimestampOfUnit(date, unitName, isUTC) {\n      var outDate = new Date(date);\n\n      switch (getPrimaryTimeUnit(unitName)) {\n        case 'year':\n        case 'month':\n          outDate[monthSetterName(isUTC)](0);\n\n        case 'day':\n          outDate[dateSetterName(isUTC)](1);\n\n        case 'hour':\n          outDate[hoursSetterName(isUTC)](0);\n\n        case 'minute':\n          outDate[minutesSetterName(isUTC)](0);\n\n        case 'second':\n          outDate[secondsSetterName(isUTC)](0);\n          outDate[millisecondsSetterName(isUTC)](0);\n      }\n\n      return outDate.getTime();\n    }\n\n    function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent) {\n      var safeLimit = 10000;\n      var unitNames = timeUnits;\n      var iter = 0;\n\n      function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {\n        var date = new Date(minTimestamp);\n        var dateTime = minTimestamp;\n        var d = date[getMethodName]();\n\n        while (dateTime < maxTimestamp && dateTime <= extent[1]) {\n          out.push({\n            value: dateTime\n          });\n          d += interval;\n          date[setMethodName](d);\n          dateTime = date.getTime();\n        }\n\n        out.push({\n          value: dateTime,\n          notAdd: true\n        });\n      }\n\n      function addLevelTicks(unitName, lastLevelTicks, levelTicks) {\n        var newAddedTicks = [];\n        var isFirstLevel = !lastLevelTicks.length;\n\n        if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {\n          return;\n        }\n\n        if (isFirstLevel) {\n          lastLevelTicks = [{\n            value: getFirstTimestampOfUnit(new Date(extent[0]), unitName, isUTC)\n          }, {\n            value: extent[1]\n          }];\n        }\n\n        for (var i = 0; i < lastLevelTicks.length - 1; i++) {\n          var startTick = lastLevelTicks[i].value;\n          var endTick = lastLevelTicks[i + 1].value;\n\n          if (startTick === endTick) {\n            continue;\n          }\n\n          var interval = void 0;\n          var getterName = void 0;\n          var setterName = void 0;\n          var isDate = false;\n\n          switch (unitName) {\n            case 'year':\n              interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));\n              getterName = fullYearGetterName(isUTC);\n              setterName = fullYearSetterName(isUTC);\n              break;\n\n            case 'half-year':\n            case 'quarter':\n            case 'month':\n              interval = getMonthInterval(approxInterval);\n              getterName = monthGetterName(isUTC);\n              setterName = monthSetterName(isUTC);\n              break;\n\n            case 'week':\n            case 'half-week':\n            case 'day':\n              interval = getDateInterval(approxInterval);\n              getterName = dateGetterName(isUTC);\n              setterName = dateSetterName(isUTC);\n              isDate = true;\n              break;\n\n            case 'half-day':\n            case 'quarter-day':\n            case 'hour':\n              interval = getHourInterval(approxInterval);\n              getterName = hoursGetterName(isUTC);\n              setterName = hoursSetterName(isUTC);\n              break;\n\n            case 'minute':\n              interval = getMinutesAndSecondsInterval(approxInterval, true);\n              getterName = minutesGetterName(isUTC);\n              setterName = minutesSetterName(isUTC);\n              break;\n\n            case 'second':\n              interval = getMinutesAndSecondsInterval(approxInterval, false);\n              getterName = secondsGetterName(isUTC);\n              setterName = secondsSetterName(isUTC);\n              break;\n\n            case 'millisecond':\n              interval = getMillisecondsInterval(approxInterval);\n              getterName = millisecondsGetterName(isUTC);\n              setterName = millisecondsSetterName(isUTC);\n              break;\n          }\n\n          addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);\n\n          if (unitName === 'year' && levelTicks.length > 1 && i === 0) {\n            levelTicks.unshift({\n              value: levelTicks[0].value - interval\n            });\n          }\n        }\n\n        for (var i = 0; i < newAddedTicks.length; i++) {\n          levelTicks.push(newAddedTicks[i]);\n        }\n\n        return newAddedTicks;\n      }\n\n      var levelsTicks = [];\n      var currentLevelTicks = [];\n      var tickCount = 0;\n      var lastLevelTickCount = 0;\n\n      for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {\n        var primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);\n\n        if (!isPrimaryTimeUnit(unitNames[i])) {\n          continue;\n        }\n\n        addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);\n        var nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;\n\n        if (primaryTimeUnit !== nextPrimaryTimeUnit) {\n          if (currentLevelTicks.length) {\n            lastLevelTickCount = tickCount;\n            currentLevelTicks.sort(function (a, b) {\n              return a.value - b.value;\n            });\n            var levelTicksRemoveDuplicated = [];\n\n            for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {\n              var tickValue = currentLevelTicks[i_1].value;\n\n              if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {\n                levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);\n\n                if (tickValue >= extent[0] && tickValue <= extent[1]) {\n                  tickCount++;\n                }\n              }\n            }\n\n            var targetTickNum = (extent[1] - extent[0]) / approxInterval;\n\n            if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {\n              break;\n            }\n\n            levelsTicks.push(levelTicksRemoveDuplicated);\n\n            if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {\n              break;\n            }\n          }\n\n          currentLevelTicks = [];\n        }\n      }\n\n      if (\"development\" !== 'production') {\n        if (iter >= safeLimit) {\n          warn('Exceed safe limit.');\n        }\n      }\n\n      var levelsTicksInExtent = filter(map(levelsTicks, function (levelTicks) {\n        return filter(levelTicks, function (tick) {\n          return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;\n        });\n      }), function (levelTicks) {\n        return levelTicks.length > 0;\n      });\n      var ticks = [];\n      var maxLevel = levelsTicksInExtent.length - 1;\n\n      for (var i = 0; i < levelsTicksInExtent.length; ++i) {\n        var levelTicks = levelsTicksInExtent[i];\n\n        for (var k = 0; k < levelTicks.length; ++k) {\n          ticks.push({\n            value: levelTicks[k].value,\n            level: maxLevel - i\n          });\n        }\n      }\n\n      ticks.sort(function (a, b) {\n        return a.value - b.value;\n      });\n      var result = [];\n\n      for (var i = 0; i < ticks.length; ++i) {\n        if (i === 0 || ticks[i].value !== ticks[i - 1].value) {\n          result.push(ticks[i]);\n        }\n      }\n\n      return result;\n    }\n\n    Scale.registerClass(TimeScale);\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n    var getPrecisionSafe$1 = getPrecisionSafe;\n    var roundingErrorFix = round;\n    var mathFloor$1 = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow$1 = Math.pow;\n    var mathLog = Math.log;\n\n    var LogScale = function (_super) {\n      __extends(LogScale, _super);\n\n      function LogScale() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'log';\n        _this.base = 10;\n        _this._originalScale = new IntervalScale();\n        _this._interval = 0;\n        return _this;\n      }\n\n      LogScale.prototype.getTicks = function (expandToNicedExtent) {\n        var originalScale = this._originalScale;\n        var extent = this._extent;\n        var originalExtent = originalScale.getExtent();\n        var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);\n        return map(ticks, function (tick) {\n          var val = tick.value;\n          var powVal = round(mathPow$1(this.base, val));\n          powVal = val === extent[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;\n          powVal = val === extent[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;\n          return {\n            value: powVal\n          };\n        }, this);\n      };\n\n      LogScale.prototype.setExtent = function (start, end) {\n        var base = this.base;\n        start = mathLog(start) / mathLog(base);\n        end = mathLog(end) / mathLog(base);\n        intervalScaleProto.setExtent.call(this, start, end);\n      };\n\n      LogScale.prototype.getExtent = function () {\n        var base = this.base;\n        var extent = scaleProto.getExtent.call(this);\n        extent[0] = mathPow$1(base, extent[0]);\n        extent[1] = mathPow$1(base, extent[1]);\n        var originalScale = this._originalScale;\n        var originalExtent = originalScale.getExtent();\n        this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n        this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n        return extent;\n      };\n\n      LogScale.prototype.unionExtent = function (extent) {\n        this._originalScale.unionExtent(extent);\n\n        var base = this.base;\n        extent[0] = mathLog(extent[0]) / mathLog(base);\n        extent[1] = mathLog(extent[1]) / mathLog(base);\n        scaleProto.unionExtent.call(this, extent);\n      };\n\n      LogScale.prototype.unionExtentFromData = function (data, dim) {\n        this.unionExtent(data.getApproximateExtent(dim));\n      };\n\n      LogScale.prototype.niceTicks = function (approxTickNum) {\n        approxTickNum = approxTickNum || 10;\n        var extent = this._extent;\n        var span = extent[1] - extent[0];\n\n        if (span === Infinity || span <= 0) {\n          return;\n        }\n\n        var interval = quantity(span);\n        var err = approxTickNum / span * interval;\n\n        if (err <= 0.5) {\n          interval *= 10;\n        }\n\n        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n          interval *= 10;\n        }\n\n        var niceExtent = [round(mathCeil(extent[0] / interval) * interval), round(mathFloor$1(extent[1] / interval) * interval)];\n        this._interval = interval;\n        this._niceExtent = niceExtent;\n      };\n\n      LogScale.prototype.niceExtent = function (opt) {\n        intervalScaleProto.niceExtent.call(this, opt);\n        this._fixMin = opt.fixMin;\n        this._fixMax = opt.fixMax;\n      };\n\n      LogScale.prototype.parse = function (val) {\n        return val;\n      };\n\n      LogScale.prototype.contain = function (val) {\n        val = mathLog(val) / mathLog(this.base);\n        return contain$1(val, this._extent);\n      };\n\n      LogScale.prototype.normalize = function (val) {\n        val = mathLog(val) / mathLog(this.base);\n        return normalize$1(val, this._extent);\n      };\n\n      LogScale.prototype.scale = function (val) {\n        val = scale$2(val, this._extent);\n        return mathPow$1(this.base, val);\n      };\n\n      LogScale.type = 'log';\n      return LogScale;\n    }(Scale);\n\n    var proto = LogScale.prototype;\n    proto.getMinorTicks = intervalScaleProto.getMinorTicks;\n    proto.getLabel = intervalScaleProto.getLabel;\n\n    function fixRoundingError(val, originalVal) {\n      return roundingErrorFix(val, getPrecisionSafe$1(originalVal));\n    }\n\n    Scale.registerClass(LogScale);\n\n    var ScaleRawExtentInfo = function () {\n      function ScaleRawExtentInfo(scale, model, originalExtent) {\n        this._prepareParams(scale, model, originalExtent);\n      }\n\n      ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, dataExtent) {\n        if (dataExtent[1] < dataExtent[0]) {\n          dataExtent = [NaN, NaN];\n        }\n\n        this._dataMin = dataExtent[0];\n        this._dataMax = dataExtent[1];\n        var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n        this._needCrossZero = model.getNeedCrossZero && model.getNeedCrossZero();\n        var modelMinRaw = this._modelMinRaw = model.get('min', true);\n\n        if (isFunction(modelMinRaw)) {\n          this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n            min: dataExtent[0],\n            max: dataExtent[1]\n          }));\n        } else if (modelMinRaw !== 'dataMin') {\n          this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n        }\n\n        var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n\n        if (isFunction(modelMaxRaw)) {\n          this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n            min: dataExtent[0],\n            max: dataExtent[1]\n          }));\n        } else if (modelMaxRaw !== 'dataMax') {\n          this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n        }\n\n        if (isOrdinal) {\n          this._axisDataLen = model.getCategories().length;\n        } else {\n          var boundaryGap = model.get('boundaryGap');\n          var boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n\n          if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n            if (\"development\" !== 'production') {\n              console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., \"20%\". Currently, ' + 'boundaryGap is set to be 0.');\n            }\n\n            this._boundaryGapInner = [0, 0];\n          } else {\n            this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)];\n          }\n        }\n      };\n\n      ScaleRawExtentInfo.prototype.calculate = function () {\n        var isOrdinal = this._isOrdinal;\n        var dataMin = this._dataMin;\n        var dataMax = this._dataMax;\n        var axisDataLen = this._axisDataLen;\n        var boundaryGapInner = this._boundaryGapInner;\n        var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;\n        var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n        var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum;\n        var minFixed = min != null;\n        var maxFixed = max != null;\n\n        if (min == null) {\n          min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n        }\n\n        if (max == null) {\n          max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n        }\n\n        (min == null || !isFinite(min)) && (min = NaN);\n        (max == null || !isFinite(max)) && (max = NaN);\n\n        if (min > max) {\n          min = NaN;\n          max = NaN;\n        }\n\n        var isBlank = eqNaN(min) || eqNaN(max) || isOrdinal && !axisDataLen;\n\n        if (this._needCrossZero) {\n          if (min > 0 && max > 0 && !minFixed) {\n            min = 0;\n          }\n\n          if (min < 0 && max < 0 && !maxFixed) {\n            max = 0;\n          }\n        }\n\n        var determinedMin = this._determinedMin;\n        var determinedMax = this._determinedMax;\n\n        if (determinedMin != null) {\n          min = determinedMin;\n          minFixed = true;\n        }\n\n        if (determinedMax != null) {\n          max = determinedMax;\n          maxFixed = true;\n        }\n\n        return {\n          min: min,\n          max: max,\n          minFixed: minFixed,\n          maxFixed: maxFixed,\n          isBlank: isBlank\n        };\n      };\n\n      ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n        if (\"development\" !== 'production') {\n          assert(!this.frozen);\n        }\n\n        this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n      };\n\n      ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n        var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n\n        if (\"development\" !== 'production') {\n          assert(!this.frozen && this[attr] == null);\n        }\n\n        this[attr] = val;\n      };\n\n      ScaleRawExtentInfo.prototype.freeze = function () {\n        this.frozen = true;\n      };\n\n      return ScaleRawExtentInfo;\n    }();\n    var DETERMINED_MIN_MAX_ATTR = {\n      min: '_determinedMin',\n      max: '_determinedMax'\n    };\n    var DATA_MIN_MAX_ATTR = {\n      min: '_dataMin',\n      max: '_dataMax'\n    };\n    function ensureScaleRawExtentInfo(scale, model, originalExtent) {\n      var rawExtentInfo = scale.rawExtentInfo;\n\n      if (rawExtentInfo) {\n        return rawExtentInfo;\n      }\n\n      rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent);\n      scale.rawExtentInfo = rawExtentInfo;\n      return rawExtentInfo;\n    }\n    function parseAxisModelMinMax(scale, minMax) {\n      return minMax == null ? null : eqNaN(minMax) ? NaN : scale.parse(minMax);\n    }\n\n    function getScaleExtent(scale, model) {\n      var scaleType = scale.type;\n      var rawExtentResult = ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();\n      scale.setBlank(rawExtentResult.isBlank);\n      var min = rawExtentResult.min;\n      var max = rawExtentResult.max;\n      var ecModel = model.ecModel;\n\n      if (ecModel && scaleType === 'time') {\n        var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n        var isBaseAxisAndHasBarSeries_1 = false;\n        each(barSeriesModels, function (seriesModel) {\n          isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n        });\n\n        if (isBaseAxisAndHasBarSeries_1) {\n          var barWidthAndOffset = makeColumnLayout(barSeriesModels);\n          var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n          min = adjustedScale.min;\n          max = adjustedScale.max;\n        }\n      }\n\n      return {\n        extent: [min, max],\n        fixMin: rawExtentResult.minFixed,\n        fixMax: rawExtentResult.maxFixed\n      };\n    }\n\n    function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n      var axisExtent = model.axis.getExtent();\n      var axisLength = axisExtent[1] - axisExtent[0];\n      var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n      if (barsOnCurrentAxis === undefined) {\n        return {\n          min: min,\n          max: max\n        };\n      }\n\n      var minOverflow = Infinity;\n      each(barsOnCurrentAxis, function (item) {\n        minOverflow = Math.min(item.offset, minOverflow);\n      });\n      var maxOverflow = -Infinity;\n      each(barsOnCurrentAxis, function (item) {\n        maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n      });\n      minOverflow = Math.abs(minOverflow);\n      maxOverflow = Math.abs(maxOverflow);\n      var totalOverFlow = minOverflow + maxOverflow;\n      var oldRange = max - min;\n      var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n      var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n      max += overflowBuffer * (maxOverflow / totalOverFlow);\n      min -= overflowBuffer * (minOverflow / totalOverFlow);\n      return {\n        min: min,\n        max: max\n      };\n    }\n\n    function niceScaleExtent(scale, model) {\n      var extentInfo = getScaleExtent(scale, model);\n      var extent = extentInfo.extent;\n      var splitNumber = model.get('splitNumber');\n\n      if (scale instanceof LogScale) {\n        scale.base = model.get('logBase');\n      }\n\n      var scaleType = scale.type;\n      scale.setExtent(extent[0], extent[1]);\n      scale.niceExtent({\n        splitNumber: splitNumber,\n        fixMin: extentInfo.fixMin,\n        fixMax: extentInfo.fixMax,\n        minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n        maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n      });\n      var interval = model.get('interval');\n\n      if (interval != null) {\n        scale.setInterval && scale.setInterval(interval);\n      }\n    }\n    function createScaleByModel(model, axisType) {\n      axisType = axisType || model.get('type');\n\n      if (axisType) {\n        switch (axisType) {\n          case 'category':\n            return new OrdinalScale({\n              ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n              extent: [Infinity, -Infinity]\n            });\n\n          case 'time':\n            return new TimeScale({\n              locale: model.ecModel.getLocaleModel(),\n              useUTC: model.ecModel.get('useUTC')\n            });\n\n          default:\n            return new (Scale.getClass(axisType) || IntervalScale)();\n        }\n      }\n    }\n    function ifAxisCrossZero(axis) {\n      var dataExtent = axis.scale.getExtent();\n      var min = dataExtent[0];\n      var max = dataExtent[1];\n      return !(min > 0 && max > 0 || min < 0 && max < 0);\n    }\n    function makeLabelFormatter(axis) {\n      var labelFormatter = axis.getLabelModel().get('formatter');\n      var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n      if (axis.scale.type === 'time') {\n        return function (tpl) {\n          return function (tick, idx) {\n            return axis.scale.getFormattedLabel(tick, idx, tpl);\n          };\n        }(labelFormatter);\n      } else if (typeof labelFormatter === 'string') {\n        return function (tpl) {\n          return function (tick) {\n            var label = axis.scale.getLabel(tick);\n            var text = tpl.replace('{value}', label != null ? label : '');\n            return text;\n          };\n        }(labelFormatter);\n      } else if (typeof labelFormatter === 'function') {\n        return function (cb) {\n          return function (tick, idx) {\n            if (categoryTickStart != null) {\n              idx = tick.value - categoryTickStart;\n            }\n\n            return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n              level: tick.level\n            } : null);\n          };\n        }(labelFormatter);\n      } else {\n        return function (tick) {\n          return axis.scale.getLabel(tick);\n        };\n      }\n    }\n    function getAxisRawValue(axis, tick) {\n      return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n    }\n    function estimateLabelUnionRect(axis) {\n      var axisModel = axis.model;\n      var scale = axis.scale;\n\n      if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n        return;\n      }\n\n      var realNumberScaleTicks;\n      var tickCount;\n      var categoryScaleExtent = scale.getExtent();\n\n      if (scale instanceof OrdinalScale) {\n        tickCount = scale.count();\n      } else {\n        realNumberScaleTicks = scale.getTicks();\n        tickCount = realNumberScaleTicks.length;\n      }\n\n      var axisLabelModel = axis.getLabelModel();\n      var labelFormatter = makeLabelFormatter(axis);\n      var rect;\n      var step = 1;\n\n      if (tickCount > 40) {\n        step = Math.ceil(tickCount / 40);\n      }\n\n      for (var i = 0; i < tickCount; i += step) {\n        var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n          value: categoryScaleExtent[0] + i\n        };\n        var label = labelFormatter(tick, i);\n        var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n        var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n        rect ? rect.union(singleRect) : rect = singleRect;\n      }\n\n      return rect;\n    }\n\n    function rotateTextRect(textRect, rotate) {\n      var rotateRadians = rotate * Math.PI / 180;\n      var beforeWidth = textRect.width;\n      var beforeHeight = textRect.height;\n      var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n      var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n      var rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight);\n      return rotatedRect;\n    }\n\n    function getOptionCategoryInterval(model) {\n      var interval = model.get('interval');\n      return interval == null ? 'auto' : interval;\n    }\n    function shouldShowAllLabels(axis) {\n      return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n    }\n    function getDataDimensionsOnAxis(data, axisDim) {\n      var dataDimMap = {};\n      each(data.mapDimensionsAll(axisDim), function (dataDim) {\n        dataDimMap[getStackedDimension(data, dataDim)] = true;\n      });\n      return keys(dataDimMap);\n    }\n    function unionAxisExtentFromData(dataExtent, data, axisDim) {\n      if (data) {\n        each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n          var seriesExtent = data.getApproximateExtent(dim);\n          seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n          seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n        });\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var AxisModelCommonMixin = function () {\n      function AxisModelCommonMixin() {}\n\n      AxisModelCommonMixin.prototype.getNeedCrossZero = function () {\n        var option = this.option;\n        return !option.scale;\n      };\n\n      AxisModelCommonMixin.prototype.getCoordSysModel = function () {\n        return;\n      };\n\n      return AxisModelCommonMixin;\n    }();\n\n    function createList(seriesModel) {\n      return createListFromArray(seriesModel.getSource(), seriesModel);\n    }\n    var dataStack$1 = {\n      isDimensionStacked: isDimensionStacked,\n      enableDataStack: enableDataStack,\n      getStackedDimension: getStackedDimension\n    };\n    function createScale(dataExtent, option) {\n      var axisModel = option;\n\n      if (!(option instanceof Model)) {\n        axisModel = new Model(option);\n      }\n\n      var scale = createScaleByModel(axisModel);\n      scale.setExtent(dataExtent[0], dataExtent[1]);\n      niceScaleExtent(scale, axisModel);\n      return scale;\n    }\n    function mixinAxisModelCommonMethods(Model) {\n      mixin(Model, AxisModelCommonMixin);\n    }\n    function createTextStyle$1(textStyleModel, opts) {\n      opts = opts || {};\n      return createTextStyle(textStyleModel, null, null, opts.state !== 'normal');\n    }\n\n    var helper = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        createList: createList,\n        getLayoutRect: getLayoutRect,\n        dataStack: dataStack$1,\n        createScale: createScale,\n        mixinAxisModelCommonMethods: mixinAxisModelCommonMethods,\n        getECData: getECData,\n        createTextStyle: createTextStyle$1,\n        createDimensions: createDimensions,\n        createSymbol: createSymbol,\n        enableHoverEmphasis: enableHoverEmphasis\n    });\n\n    var EPSILON$3 = 1e-8;\n    function isAroundEqual$1(a, b) {\n        return Math.abs(a - b) < EPSILON$3;\n    }\n    function contain$2(points, x, y) {\n        var w = 0;\n        var p = points[0];\n        if (!p) {\n            return false;\n        }\n        for (var i = 1; i < points.length; i++) {\n            var p2 = points[i];\n            w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n            p = p2;\n        }\n        var p0 = points[0];\n        if (!isAroundEqual$1(p[0], p0[0]) || !isAroundEqual$1(p[1], p0[1])) {\n            w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n        }\n        return w !== 0;\n    }\n\n    var Region = function () {\n      function Region(name, geometries, cp) {\n        this.name = name;\n        this.geometries = geometries;\n\n        if (!cp) {\n          var rect = this.getBoundingRect();\n          cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n        } else {\n          cp = [cp[0], cp[1]];\n        }\n\n        this.center = cp;\n      }\n\n      Region.prototype.getBoundingRect = function () {\n        var rect = this._rect;\n\n        if (rect) {\n          return rect;\n        }\n\n        var MAX_NUMBER = Number.MAX_VALUE;\n        var min$1 = [MAX_NUMBER, MAX_NUMBER];\n        var max$1 = [-MAX_NUMBER, -MAX_NUMBER];\n        var min2 = [];\n        var max2 = [];\n        var geometries = this.geometries;\n        var i = 0;\n\n        for (; i < geometries.length; i++) {\n          if (geometries[i].type !== 'polygon') {\n            continue;\n          }\n\n          var exterior = geometries[i].exterior;\n          fromPoints(exterior, min2, max2);\n          min(min$1, min$1, min2);\n          max(max$1, max$1, max2);\n        }\n\n        if (i === 0) {\n          min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0;\n        }\n\n        return this._rect = new BoundingRect(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1]);\n      };\n\n      Region.prototype.contain = function (coord) {\n        var rect = this.getBoundingRect();\n        var geometries = this.geometries;\n\n        if (!rect.contain(coord[0], coord[1])) {\n          return false;\n        }\n\n        loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n          if (geometries[i].type !== 'polygon') {\n            continue;\n          }\n\n          var exterior = geometries[i].exterior;\n          var interiors = geometries[i].interiors;\n\n          if (contain$2(exterior, coord[0], coord[1])) {\n            for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n              if (contain$2(interiors[k], coord[0], coord[1])) {\n                continue loopGeo;\n              }\n            }\n\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      Region.prototype.transformTo = function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n        var aspect = rect.width / rect.height;\n\n        if (!width) {\n          width = aspect * height;\n        } else if (!height) {\n          height = width / aspect;\n        }\n\n        var target = new BoundingRect(x, y, width, height);\n        var transform = rect.calculateTransform(target);\n        var geometries = this.geometries;\n\n        for (var i = 0; i < geometries.length; i++) {\n          if (geometries[i].type !== 'polygon') {\n            continue;\n          }\n\n          var exterior = geometries[i].exterior;\n          var interiors = geometries[i].interiors;\n\n          for (var p = 0; p < exterior.length; p++) {\n            applyTransform(exterior[p], exterior[p], transform);\n          }\n\n          for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n            for (var p = 0; p < interiors[h].length; p++) {\n              applyTransform(interiors[h][p], interiors[h][p], transform);\n            }\n          }\n        }\n\n        rect = this._rect;\n        rect.copy(target);\n        this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n      };\n\n      Region.prototype.cloneShallow = function (name) {\n        name == null && (name = this.name);\n        var newRegion = new Region(name, this.geometries, this.center);\n        newRegion._rect = this._rect;\n        newRegion.transformTo = null;\n        return newRegion;\n      };\n\n      return Region;\n    }();\n\n    function decode(json) {\n      if (!json.UTF8Encoding) {\n        return json;\n      }\n\n      var jsonCompressed = json;\n      var encodeScale = jsonCompressed.UTF8Scale;\n\n      if (encodeScale == null) {\n        encodeScale = 1024;\n      }\n\n      var features = jsonCompressed.features;\n\n      for (var f = 0; f < features.length; f++) {\n        var feature = features[f];\n        var geometry = feature.geometry;\n\n        if (geometry.type === 'Polygon') {\n          var coordinates = geometry.coordinates;\n\n          for (var c = 0; c < coordinates.length; c++) {\n            coordinates[c] = decodePolygon(coordinates[c], geometry.encodeOffsets[c], encodeScale);\n          }\n        } else if (geometry.type === 'MultiPolygon') {\n          var coordinates = geometry.coordinates;\n\n          for (var c = 0; c < coordinates.length; c++) {\n            var coordinate = coordinates[c];\n\n            for (var c2 = 0; c2 < coordinate.length; c2++) {\n              coordinate[c2] = decodePolygon(coordinate[c2], geometry.encodeOffsets[c][c2], encodeScale);\n            }\n          }\n        }\n      }\n\n      jsonCompressed.UTF8Encoding = false;\n      return jsonCompressed;\n    }\n\n    function decodePolygon(coordinate, encodeOffsets, encodeScale) {\n      var result = [];\n      var prevX = encodeOffsets[0];\n      var prevY = encodeOffsets[1];\n\n      for (var i = 0; i < coordinate.length; i += 2) {\n        var x = coordinate.charCodeAt(i) - 64;\n        var y = coordinate.charCodeAt(i + 1) - 64;\n        x = x >> 1 ^ -(x & 1);\n        y = y >> 1 ^ -(y & 1);\n        x += prevX;\n        y += prevY;\n        prevX = x;\n        prevY = y;\n        result.push([x / encodeScale, y / encodeScale]);\n      }\n\n      return result;\n    }\n\n    function parseGeoJSON(geoJson, nameProperty) {\n      geoJson = decode(geoJson);\n      return map(filter(geoJson.features, function (featureObj) {\n        return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;\n      }), function (featureObj) {\n        var properties = featureObj.properties;\n        var geo = featureObj.geometry;\n        var geometries = [];\n\n        if (geo.type === 'Polygon') {\n          var coordinates = geo.coordinates;\n          geometries.push({\n            type: 'polygon',\n            exterior: coordinates[0],\n            interiors: coordinates.slice(1)\n          });\n        }\n\n        if (geo.type === 'MultiPolygon') {\n          var coordinates = geo.coordinates;\n          each(coordinates, function (item) {\n            if (item[0]) {\n              geometries.push({\n                type: 'polygon',\n                exterior: item[0],\n                interiors: item.slice(1)\n              });\n            }\n          });\n        }\n\n        var region = new Region(properties[nameProperty || 'name'], geometries, properties.cp);\n        region.properties = properties;\n        return region;\n      });\n    }\n\n    var number = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        linearMap: linearMap,\n        round: round,\n        asc: asc,\n        getPrecision: getPrecision,\n        getPrecisionSafe: getPrecisionSafe,\n        getPixelPrecision: getPixelPrecision,\n        getPercentWithPrecision: getPercentWithPrecision,\n        MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\n        remRadian: remRadian,\n        isRadianAroundZero: isRadianAroundZero,\n        parseDate: parseDate,\n        quantity: quantity,\n        quantityExponent: quantityExponent,\n        nice: nice,\n        quantile: quantile,\n        reformIntervals: reformIntervals,\n        isNumeric: isNumeric,\n        numericToNumber: numericToNumber\n    });\n\n    var time = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        parse: parseDate,\n        format: format\n    });\n\n    var graphic$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        extendShape: extendShape,\n        extendPath: extendPath,\n        makePath: makePath,\n        makeImage: makeImage,\n        mergePath: mergePath$1,\n        resizePath: resizePath,\n        createIcon: createIcon,\n        updateProps: updateProps,\n        initProps: initProps,\n        getTransform: getTransform,\n        clipPointsByRect: clipPointsByRect,\n        clipRectByRect: clipRectByRect,\n        registerShape: registerShape,\n        getShapeClass: getShapeClass,\n        Group: Group,\n        Image: ZRImage,\n        Text: ZRText,\n        Circle: Circle,\n        Ellipse: Ellipse,\n        Sector: Sector,\n        Ring: Ring,\n        Polygon: Polygon,\n        Polyline: Polyline,\n        Rect: Rect,\n        Line: Line,\n        BezierCurve: BezierCurve,\n        Arc: Arc,\n        IncrementalDisplayable: IncrementalDisplayable,\n        CompoundPath: CompoundPath,\n        LinearGradient: LinearGradient,\n        RadialGradient: RadialGradient,\n        BoundingRect: BoundingRect\n    });\n\n    var format$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        addCommas: addCommas,\n        toCamelCase: toCamelCase,\n        normalizeCssArray: normalizeCssArray$1,\n        encodeHTML: encodeHTML,\n        formatTpl: formatTpl,\n        getTooltipMarker: getTooltipMarker,\n        formatTime: formatTime,\n        capitalFirst: capitalFirst,\n        truncateText: truncateText,\n        getTextRect: getTextRect\n    });\n\n    var util$1 = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        map: map,\n        each: each,\n        indexOf: indexOf,\n        inherits: inherits,\n        reduce: reduce,\n        filter: filter,\n        bind: bind,\n        curry: curry,\n        isArray: isArray,\n        isString: isString,\n        isObject: isObject,\n        isFunction: isFunction,\n        extend: extend,\n        defaults: defaults,\n        clone: clone,\n        merge: merge\n    });\n\n    var inner$4 = makeInner();\n    function createAxisLabels(axis) {\n      return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n    }\n    function createAxisTicks(axis, tickModel) {\n      return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n        ticks: map(axis.scale.getTicks(), function (tick) {\n          return tick.value;\n        })\n      };\n    }\n\n    function makeCategoryLabels(axis) {\n      var labelModel = axis.getLabelModel();\n      var result = makeCategoryLabelsActually(axis, labelModel);\n      return !labelModel.get('show') || axis.scale.isBlank() ? {\n        labels: [],\n        labelCategoryInterval: result.labelCategoryInterval\n      } : result;\n    }\n\n    function makeCategoryLabelsActually(axis, labelModel) {\n      var labelsCache = getListCache(axis, 'labels');\n      var optionLabelInterval = getOptionCategoryInterval(labelModel);\n      var result = listCacheGet(labelsCache, optionLabelInterval);\n\n      if (result) {\n        return result;\n      }\n\n      var labels;\n      var numericLabelInterval;\n\n      if (isFunction(optionLabelInterval)) {\n        labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n      } else {\n        numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n        labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n      }\n\n      return listCacheSet(labelsCache, optionLabelInterval, {\n        labels: labels,\n        labelCategoryInterval: numericLabelInterval\n      });\n    }\n\n    function makeCategoryTicks(axis, tickModel) {\n      var ticksCache = getListCache(axis, 'ticks');\n      var optionTickInterval = getOptionCategoryInterval(tickModel);\n      var result = listCacheGet(ticksCache, optionTickInterval);\n\n      if (result) {\n        return result;\n      }\n\n      var ticks;\n      var tickCategoryInterval;\n\n      if (!tickModel.get('show') || axis.scale.isBlank()) {\n        ticks = [];\n      }\n\n      if (isFunction(optionTickInterval)) {\n        ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n      } else if (optionTickInterval === 'auto') {\n        var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n        tickCategoryInterval = labelsResult.labelCategoryInterval;\n        ticks = map(labelsResult.labels, function (labelItem) {\n          return labelItem.tickValue;\n        });\n      } else {\n        tickCategoryInterval = optionTickInterval;\n        ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n      }\n\n      return listCacheSet(ticksCache, optionTickInterval, {\n        ticks: ticks,\n        tickCategoryInterval: tickCategoryInterval\n      });\n    }\n\n    function makeRealNumberLabels(axis) {\n      var ticks = axis.scale.getTicks();\n      var labelFormatter = makeLabelFormatter(axis);\n      return {\n        labels: map(ticks, function (tick, idx) {\n          return {\n            formattedLabel: labelFormatter(tick, idx),\n            rawLabel: axis.scale.getLabel(tick),\n            tickValue: tick.value\n          };\n        })\n      };\n    }\n\n    function getListCache(axis, prop) {\n      return inner$4(axis)[prop] || (inner$4(axis)[prop] = []);\n    }\n\n    function listCacheGet(cache, key) {\n      for (var i = 0; i < cache.length; i++) {\n        if (cache[i].key === key) {\n          return cache[i].value;\n        }\n      }\n    }\n\n    function listCacheSet(cache, key, value) {\n      cache.push({\n        key: key,\n        value: value\n      });\n      return value;\n    }\n\n    function makeAutoCategoryInterval(axis) {\n      var result = inner$4(axis).autoInterval;\n      return result != null ? result : inner$4(axis).autoInterval = axis.calculateCategoryInterval();\n    }\n\n    function calculateCategoryInterval(axis) {\n      var params = fetchAutoCategoryIntervalCalculationParams(axis);\n      var labelFormatter = makeLabelFormatter(axis);\n      var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n      var ordinalScale = axis.scale;\n      var ordinalExtent = ordinalScale.getExtent();\n      var tickCount = ordinalScale.count();\n\n      if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n        return 0;\n      }\n\n      var step = 1;\n\n      if (tickCount > 40) {\n        step = Math.max(1, Math.floor(tickCount / 40));\n      }\n\n      var tickValue = ordinalExtent[0];\n      var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n      var unitW = Math.abs(unitSpan * Math.cos(rotation));\n      var unitH = Math.abs(unitSpan * Math.sin(rotation));\n      var maxW = 0;\n      var maxH = 0;\n\n      for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n        var width = 0;\n        var height = 0;\n        var rect = getBoundingRect(labelFormatter({\n          value: tickValue\n        }), params.font, 'center', 'top');\n        width = rect.width * 1.3;\n        height = rect.height * 1.3;\n        maxW = Math.max(maxW, width, 7);\n        maxH = Math.max(maxH, height, 7);\n      }\n\n      var dw = maxW / unitW;\n      var dh = maxH / unitH;\n      isNaN(dw) && (dw = Infinity);\n      isNaN(dh) && (dh = Infinity);\n      var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n      var cache = inner$4(axis.model);\n      var axisExtent = axis.getExtent();\n      var lastAutoInterval = cache.lastAutoInterval;\n      var lastTickCount = cache.lastTickCount;\n\n      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n        interval = lastAutoInterval;\n      } else {\n        cache.lastTickCount = tickCount;\n        cache.lastAutoInterval = interval;\n        cache.axisExtent0 = axisExtent[0];\n        cache.axisExtent1 = axisExtent[1];\n      }\n\n      return interval;\n    }\n\n    function fetchAutoCategoryIntervalCalculationParams(axis) {\n      var labelModel = axis.getLabelModel();\n      return {\n        axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n        labelRotate: labelModel.get('rotate') || 0,\n        font: labelModel.getFont()\n      };\n    }\n\n    function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n      var labelFormatter = makeLabelFormatter(axis);\n      var ordinalScale = axis.scale;\n      var ordinalExtent = ordinalScale.getExtent();\n      var labelModel = axis.getLabelModel();\n      var result = [];\n      var step = Math.max((categoryInterval || 0) + 1, 1);\n      var startTick = ordinalExtent[0];\n      var tickCount = ordinalScale.count();\n\n      if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n        startTick = Math.round(Math.ceil(startTick / step) * step);\n      }\n\n      var showAllLabel = shouldShowAllLabels(axis);\n      var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n      var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n      if (includeMinLabel && startTick !== ordinalExtent[0]) {\n        addItem(ordinalExtent[0]);\n      }\n\n      var tickValue = startTick;\n\n      for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n        addItem(tickValue);\n      }\n\n      if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n        addItem(ordinalExtent[1]);\n      }\n\n      function addItem(tickValue) {\n        var tickObj = {\n          value: tickValue\n        };\n        result.push(onlyTick ? tickValue : {\n          formattedLabel: labelFormatter(tickObj),\n          rawLabel: ordinalScale.getLabel(tickObj),\n          tickValue: tickValue\n        });\n      }\n\n      return result;\n    }\n\n    function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n      var ordinalScale = axis.scale;\n      var labelFormatter = makeLabelFormatter(axis);\n      var result = [];\n      each(ordinalScale.getTicks(), function (tick) {\n        var rawLabel = ordinalScale.getLabel(tick);\n        var tickValue = tick.value;\n\n        if (categoryInterval(tick.value, rawLabel)) {\n          result.push(onlyTick ? tickValue : {\n            formattedLabel: labelFormatter(tick),\n            rawLabel: rawLabel,\n            tickValue: tickValue\n          });\n        }\n      });\n      return result;\n    }\n\n    var NORMALIZED_EXTENT = [0, 1];\n\n    var Axis = function () {\n      function Axis(dim, scale, extent) {\n        this.onBand = false;\n        this.inverse = false;\n        this.dim = dim;\n        this.scale = scale;\n        this._extent = extent || [0, 0];\n      }\n\n      Axis.prototype.contain = function (coord) {\n        var extent = this._extent;\n        var min = Math.min(extent[0], extent[1]);\n        var max = Math.max(extent[0], extent[1]);\n        return coord >= min && coord <= max;\n      };\n\n      Axis.prototype.containData = function (data) {\n        return this.scale.contain(data);\n      };\n\n      Axis.prototype.getExtent = function () {\n        return this._extent.slice();\n      };\n\n      Axis.prototype.getPixelPrecision = function (dataExtent) {\n        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);\n      };\n\n      Axis.prototype.setExtent = function (start, end) {\n        var extent = this._extent;\n        extent[0] = start;\n        extent[1] = end;\n      };\n\n      Axis.prototype.dataToCoord = function (data, clamp) {\n        var extent = this._extent;\n        var scale = this.scale;\n        data = scale.normalize(data);\n\n        if (this.onBand && scale.type === 'ordinal') {\n          extent = extent.slice();\n          fixExtentWithBands(extent, scale.count());\n        }\n\n        return linearMap(data, NORMALIZED_EXTENT, extent, clamp);\n      };\n\n      Axis.prototype.coordToData = function (coord, clamp) {\n        var extent = this._extent;\n        var scale = this.scale;\n\n        if (this.onBand && scale.type === 'ordinal') {\n          extent = extent.slice();\n          fixExtentWithBands(extent, scale.count());\n        }\n\n        var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);\n        return this.scale.scale(t);\n      };\n\n      Axis.prototype.pointToData = function (point, clamp) {\n        return;\n      };\n\n      Axis.prototype.getTicksCoords = function (opt) {\n        opt = opt || {};\n        var tickModel = opt.tickModel || this.getTickModel();\n        var result = createAxisTicks(this, tickModel);\n        var ticks = result.ticks;\n        var ticksCoords = map(ticks, function (tickVal) {\n          return {\n            coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),\n            tickValue: tickVal\n          };\n        }, this);\n        var alignWithLabel = tickModel.get('alignWithLabel');\n        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);\n        return ticksCoords;\n      };\n\n      Axis.prototype.getMinorTicksCoords = function () {\n        if (this.scale.type === 'ordinal') {\n          return [];\n        }\n\n        var minorTickModel = this.model.getModel('minorTick');\n        var splitNumber = minorTickModel.get('splitNumber');\n\n        if (!(splitNumber > 0 && splitNumber < 100)) {\n          splitNumber = 5;\n        }\n\n        var minorTicks = this.scale.getMinorTicks(splitNumber);\n        var minorTicksCoords = map(minorTicks, function (minorTicksGroup) {\n          return map(minorTicksGroup, function (minorTick) {\n            return {\n              coord: this.dataToCoord(minorTick),\n              tickValue: minorTick\n            };\n          }, this);\n        }, this);\n        return minorTicksCoords;\n      };\n\n      Axis.prototype.getViewLabels = function () {\n        return createAxisLabels(this).labels;\n      };\n\n      Axis.prototype.getLabelModel = function () {\n        return this.model.getModel('axisLabel');\n      };\n\n      Axis.prototype.getTickModel = function () {\n        return this.model.getModel('axisTick');\n      };\n\n      Axis.prototype.getBandWidth = function () {\n        var axisExtent = this._extent;\n        var dataExtent = this.scale.getExtent();\n        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n        len === 0 && (len = 1);\n        var size = Math.abs(axisExtent[1] - axisExtent[0]);\n        return Math.abs(size) / len;\n      };\n\n      Axis.prototype.calculateCategoryInterval = function () {\n        return calculateCategoryInterval(this);\n      };\n\n      return Axis;\n    }();\n\n    function fixExtentWithBands(extent, nTick) {\n      var size = extent[1] - extent[0];\n      var len = nTick;\n      var margin = size / len / 2;\n      extent[0] += margin;\n      extent[1] -= margin;\n    }\n\n    function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {\n      var ticksLen = ticksCoords.length;\n\n      if (!axis.onBand || alignWithLabel || !ticksLen) {\n        return;\n      }\n\n      var axisExtent = axis.getExtent();\n      var last;\n      var diffSize;\n\n      if (ticksLen === 1) {\n        ticksCoords[0].coord = axisExtent[0];\n        last = ticksCoords[1] = {\n          coord: axisExtent[0]\n        };\n      } else {\n        var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;\n        var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;\n        each(ticksCoords, function (ticksItem) {\n          ticksItem.coord -= shift_1 / 2;\n        });\n        var dataExtent = axis.scale.getExtent();\n        diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;\n        last = {\n          coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize\n        };\n        ticksCoords.push(last);\n      }\n\n      var inverse = axisExtent[0] > axisExtent[1];\n\n      if (littleThan(ticksCoords[0].coord, axisExtent[0])) {\n        clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();\n      }\n\n      if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {\n        ticksCoords.unshift({\n          coord: axisExtent[0]\n        });\n      }\n\n      if (littleThan(axisExtent[1], last.coord)) {\n        clamp ? last.coord = axisExtent[1] : ticksCoords.pop();\n      }\n\n      if (clamp && littleThan(last.coord, axisExtent[1])) {\n        ticksCoords.push({\n          coord: axisExtent[1]\n        });\n      }\n\n      function littleThan(a, b) {\n        a = round(a);\n        b = round(b);\n        return inverse ? a > b : a < b;\n      }\n    }\n\n    function extendComponentModel(proto) {\n      var Model = ComponentModel.extend(proto);\n      ComponentModel.registerClass(Model);\n      return Model;\n    }\n    function extendComponentView(proto) {\n      var View = ComponentView.extend(proto);\n      ComponentView.registerClass(View);\n      return View;\n    }\n    function extendSeriesModel(proto) {\n      var Model = SeriesModel.extend(proto);\n      SeriesModel.registerClass(Model);\n      return Model;\n    }\n    function extendChartView(proto) {\n      var View = ChartView.extend(proto);\n      ChartView.registerClass(View);\n      return View;\n    }\n\n    function createElement(name) {\n        return document.createElementNS('http://www.w3.org/2000/svg', name);\n    }\n\n    function diff(oldArr, newArr, equals) {\n        if (!equals) {\n            equals = function (a, b) {\n                return a === b;\n            };\n        }\n        oldArr = oldArr.slice();\n        newArr = newArr.slice();\n        var newLen = newArr.length;\n        var oldLen = oldArr.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        var bestPath = [{ newPos: -1, components: [] }];\n        var oldPos = extractCommon(bestPath[0], newArr, oldArr, 0, equals);\n        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            var indices = [];\n            for (var i = 0; i < newArr.length; i++) {\n                indices.push(i);\n            }\n            return [{\n                    indices: indices,\n                    count: newArr.length,\n                    added: false,\n                    removed: false\n                }];\n        }\n        function execEditLength() {\n            for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n                var basePath;\n                var addPath = bestPath[diagonalPath - 1];\n                var removePath = bestPath[diagonalPath + 1];\n                var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n                if (addPath) {\n                    bestPath[diagonalPath - 1] = undefined;\n                }\n                var canAdd = addPath && addPath.newPos + 1 < newLen;\n                var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n                if (!canAdd && !canRemove) {\n                    bestPath[diagonalPath] = undefined;\n                    continue;\n                }\n                if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n                    basePath = clonePath(removePath);\n                    pushComponent(basePath.components, false, true);\n                }\n                else {\n                    basePath = addPath;\n                    basePath.newPos++;\n                    pushComponent(basePath.components, true, false);\n                }\n                oldPos = extractCommon(basePath, newArr, oldArr, diagonalPath, equals);\n                if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n                    return buildValues(basePath.components);\n                }\n                else {\n                    bestPath[diagonalPath] = basePath;\n                }\n            }\n            editLength++;\n        }\n        while (editLength <= maxEditLength) {\n            var ret = execEditLength();\n            if (ret) {\n                return ret;\n            }\n        }\n    }\n    function extractCommon(basePath, newArr, oldArr, diagonalPath, equals) {\n        var newLen = newArr.length;\n        var oldLen = oldArr.length;\n        var newPos = basePath.newPos;\n        var oldPos = newPos - diagonalPath;\n        var commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n            newPos++;\n            oldPos++;\n            commonCount++;\n        }\n        if (commonCount) {\n            basePath.components.push({\n                count: commonCount,\n                added: false,\n                removed: false,\n                indices: []\n            });\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n    }\n    function pushComponent(components, added, removed) {\n        var last = components[components.length - 1];\n        if (last && last.added === added && last.removed === removed) {\n            components[components.length - 1] = {\n                count: last.count + 1,\n                added: added,\n                removed: removed,\n                indices: []\n            };\n        }\n        else {\n            components.push({\n                count: 1,\n                added: added,\n                removed: removed,\n                indices: []\n            });\n        }\n    }\n    function buildValues(components) {\n        var componentPos = 0;\n        var componentLen = components.length;\n        var newPos = 0;\n        var oldPos = 0;\n        for (; componentPos < componentLen; componentPos++) {\n            var component = components[componentPos];\n            if (!component.removed) {\n                var indices = [];\n                for (var i = newPos; i < newPos + component.count; i++) {\n                    indices.push(i);\n                }\n                component.indices = indices;\n                newPos += component.count;\n                if (!component.added) {\n                    oldPos += component.count;\n                }\n            }\n            else {\n                for (var i = oldPos; i < oldPos + component.count; i++) {\n                    component.indices.push(i);\n                }\n                oldPos += component.count;\n            }\n        }\n        return components;\n    }\n    function clonePath(path) {\n        return { newPos: path.newPos, components: path.components.slice(0) };\n    }\n    function arrayDiff(oldArr, newArr, equal) {\n        return diff(oldArr, newArr, equal);\n    }\n\n    var NONE = 'none';\n    var mathRound = Math.round;\n    var mathSin$4 = Math.sin;\n    var mathCos$4 = Math.cos;\n    var PI$4 = Math.PI;\n    var PI2$7 = Math.PI * 2;\n    var degree = 180 / PI$4;\n    var EPSILON$4 = 1e-4;\n    function round3(val) {\n        return mathRound(val * 1e3) / 1e3;\n    }\n    function round4(val) {\n        return mathRound(val * 1e4) / 1e4;\n    }\n    function isAroundZero$1(val) {\n        return val < EPSILON$4 && val > -EPSILON$4;\n    }\n    function pathHasFill(style) {\n        var fill = style.fill;\n        return fill != null && fill !== NONE;\n    }\n    function pathHasStroke(style) {\n        var stroke = style.stroke;\n        return stroke != null && stroke !== NONE;\n    }\n    function setTransform(svgEl, m) {\n        if (m) {\n            attr(svgEl, 'transform', 'matrix('\n                + round3(m[0]) + ','\n                + round3(m[1]) + ','\n                + round3(m[2]) + ','\n                + round3(m[3]) + ','\n                + round4(m[4]) + ','\n                + round4(m[5])\n                + ')');\n        }\n    }\n    function attr(el, key, val) {\n        if (!val || val.type !== 'linear' && val.type !== 'radial') {\n            el.setAttribute(key, val);\n        }\n    }\n    function attrXLink(el, key, val) {\n        el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n    }\n    function attrXML(el, key, val) {\n        el.setAttributeNS('http://www.w3.org/XML/1998/namespace', key, val);\n    }\n    function bindStyle(svgEl, style, el) {\n        var opacity = style.opacity == null ? 1 : style.opacity;\n        if (el instanceof ZRImage) {\n            svgEl.style.opacity = opacity + '';\n            return;\n        }\n        if (pathHasFill(style)) {\n            var fill = style.fill;\n            fill = fill === 'transparent' ? NONE : fill;\n            attr(svgEl, 'fill', fill);\n            attr(svgEl, 'fill-opacity', (style.fillOpacity != null ? style.fillOpacity * opacity : opacity) + '');\n        }\n        else {\n            attr(svgEl, 'fill', NONE);\n        }\n        if (pathHasStroke(style)) {\n            var stroke = style.stroke;\n            stroke = stroke === 'transparent' ? NONE : stroke;\n            attr(svgEl, 'stroke', stroke);\n            var strokeWidth = style.lineWidth;\n            var strokeScale_1 = style.strokeNoScale\n                ? el.getLineScale()\n                : 1;\n            attr(svgEl, 'stroke-width', (strokeScale_1 ? strokeWidth / strokeScale_1 : 0) + '');\n            attr(svgEl, 'paint-order', style.strokeFirst ? 'stroke' : 'fill');\n            attr(svgEl, 'stroke-opacity', (style.strokeOpacity != null ? style.strokeOpacity * opacity : opacity) + '');\n            var lineDash = style.lineDash && strokeWidth > 0 && normalizeLineDash(style.lineDash, strokeWidth);\n            if (lineDash) {\n                var lineDashOffset = style.lineDashOffset;\n                if (strokeScale_1 && strokeScale_1 !== 1) {\n                    lineDash = map(lineDash, function (rawVal) {\n                        return rawVal / strokeScale_1;\n                    });\n                    if (lineDashOffset) {\n                        lineDashOffset /= strokeScale_1;\n                        lineDashOffset = mathRound(lineDashOffset);\n                    }\n                }\n                attr(svgEl, 'stroke-dasharray', lineDash.join(','));\n                attr(svgEl, 'stroke-dashoffset', (lineDashOffset || 0) + '');\n            }\n            else {\n                attr(svgEl, 'stroke-dasharray', '');\n            }\n            style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n            style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n            style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit + '');\n        }\n        else {\n            attr(svgEl, 'stroke', NONE);\n        }\n    }\n    var SVGPathRebuilder = (function () {\n        function SVGPathRebuilder() {\n        }\n        SVGPathRebuilder.prototype.reset = function () {\n            this._d = [];\n            this._str = '';\n        };\n        SVGPathRebuilder.prototype.moveTo = function (x, y) {\n            this._add('M', x, y);\n        };\n        SVGPathRebuilder.prototype.lineTo = function (x, y) {\n            this._add('L', x, y);\n        };\n        SVGPathRebuilder.prototype.bezierCurveTo = function (x, y, x2, y2, x3, y3) {\n            this._add('C', x, y, x2, y2, x3, y3);\n        };\n        SVGPathRebuilder.prototype.quadraticCurveTo = function (x, y, x2, y2) {\n            this._add('Q', x, y, x2, y2);\n        };\n        SVGPathRebuilder.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n            this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);\n        };\n        SVGPathRebuilder.prototype.ellipse = function (cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {\n            var firstCmd = this._d.length === 0;\n            var dTheta = endAngle - startAngle;\n            var clockwise = !anticlockwise;\n            var dThetaPositive = Math.abs(dTheta);\n            var isCircle = isAroundZero$1(dThetaPositive - PI2$7)\n                || (clockwise ? dTheta >= PI2$7 : -dTheta >= PI2$7);\n            var unifiedTheta = dTheta > 0 ? dTheta % PI2$7 : (dTheta % PI2$7 + PI2$7);\n            var large = false;\n            if (isCircle) {\n                large = true;\n            }\n            else if (isAroundZero$1(dThetaPositive)) {\n                large = false;\n            }\n            else {\n                large = (unifiedTheta >= PI$4) === !!clockwise;\n            }\n            var x0 = round4(cx + rx * mathCos$4(startAngle));\n            var y0 = round4(cy + ry * mathSin$4(startAngle));\n            if (isCircle) {\n                if (clockwise) {\n                    dTheta = PI2$7 - 1e-4;\n                }\n                else {\n                    dTheta = -PI2$7 + 1e-4;\n                }\n                large = true;\n                if (firstCmd) {\n                    this._d.push('M', x0, y0);\n                }\n            }\n            var x = round4(cx + rx * mathCos$4(startAngle + dTheta));\n            var y = round4(cy + ry * mathSin$4(startAngle + dTheta));\n            if (isNaN(x0) || isNaN(y0) || isNaN(rx) || isNaN(ry) || isNaN(psi) || isNaN(degree) || isNaN(x) || isNaN(y)) {\n                return '';\n            }\n            this._d.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        };\n        SVGPathRebuilder.prototype.rect = function (x, y, w, h) {\n            this._add('M', x, y);\n            this._add('L', x + w, y);\n            this._add('L', x + w, y + h);\n            this._add('L', x, y + h);\n            this._add('L', x, y);\n        };\n        SVGPathRebuilder.prototype.closePath = function () {\n            if (this._d.length > 0) {\n                this._add('Z');\n            }\n        };\n        SVGPathRebuilder.prototype._add = function (cmd, a, b, c, d, e, f, g, h) {\n            this._d.push(cmd);\n            for (var i = 1; i < arguments.length; i++) {\n                var val = arguments[i];\n                if (isNaN(val)) {\n                    this._invalid = true;\n                    return;\n                }\n                this._d.push(round4(val));\n            }\n        };\n        SVGPathRebuilder.prototype.generateStr = function () {\n            this._str = this._invalid ? '' : this._d.join(' ');\n            this._d = [];\n        };\n        SVGPathRebuilder.prototype.getStr = function () {\n            return this._str;\n        };\n        return SVGPathRebuilder;\n    }());\n    var svgPath = {\n        brush: function (el) {\n            var style = el.style;\n            var svgEl = el.__svgEl;\n            if (!svgEl) {\n                svgEl = createElement('path');\n                el.__svgEl = svgEl;\n            }\n            if (!el.path) {\n                el.createPathProxy();\n            }\n            var path = el.path;\n            if (el.shapeChanged()) {\n                path.beginPath();\n                el.buildPath(path, el.shape);\n                el.pathUpdated();\n            }\n            var pathVersion = path.getVersion();\n            var elExt = el;\n            var svgPathBuilder = elExt.__svgPathBuilder;\n            if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || el.style.strokePercent < 1) {\n                if (!svgPathBuilder) {\n                    svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder();\n                }\n                svgPathBuilder.reset();\n                path.rebuildPath(svgPathBuilder, el.style.strokePercent);\n                svgPathBuilder.generateStr();\n                elExt.__svgPathVersion = pathVersion;\n            }\n            attr(svgEl, 'd', svgPathBuilder.getStr());\n            bindStyle(svgEl, style, el);\n            setTransform(svgEl, el.transform);\n        }\n    };\n    var svgImage = {\n        brush: function (el) {\n            var style = el.style;\n            var image = style.image;\n            if (image instanceof HTMLImageElement) {\n                image = image.src;\n            }\n            else if (image instanceof HTMLCanvasElement) {\n                image = image.toDataURL();\n            }\n            if (!image) {\n                return;\n            }\n            var x = style.x || 0;\n            var y = style.y || 0;\n            var dw = style.width;\n            var dh = style.height;\n            var svgEl = el.__svgEl;\n            if (!svgEl) {\n                svgEl = createElement('image');\n                el.__svgEl = svgEl;\n            }\n            if (image !== el.__imageSrc) {\n                attrXLink(svgEl, 'href', image);\n                el.__imageSrc = image;\n            }\n            attr(svgEl, 'width', dw + '');\n            attr(svgEl, 'height', dh + '');\n            attr(svgEl, 'x', x + '');\n            attr(svgEl, 'y', y + '');\n            bindStyle(svgEl, style, el);\n            setTransform(svgEl, el.transform);\n        }\n    };\n    var TEXT_ALIGN_TO_ANCHOR = {\n        left: 'start',\n        right: 'end',\n        center: 'middle',\n        middle: 'middle'\n    };\n    function adjustTextY$1(y, lineHeight, textBaseline) {\n        if (textBaseline === 'top') {\n            y += lineHeight / 2;\n        }\n        else if (textBaseline === 'bottom') {\n            y -= lineHeight / 2;\n        }\n        return y;\n    }\n    var svgText = {\n        brush: function (el) {\n            var style = el.style;\n            var text = style.text;\n            text != null && (text += '');\n            if (!text || isNaN(style.x) || isNaN(style.y)) {\n                return;\n            }\n            var textSvgEl = el.__svgEl;\n            if (!textSvgEl) {\n                textSvgEl = createElement('text');\n                attrXML(textSvgEl, 'xml:space', 'preserve');\n                el.__svgEl = textSvgEl;\n            }\n            var font = style.font || DEFAULT_FONT;\n            var textSvgElStyle = textSvgEl.style;\n            textSvgElStyle.font = font;\n            textSvgEl.textContent = text;\n            bindStyle(textSvgEl, style, el);\n            setTransform(textSvgEl, el.transform);\n            var x = style.x || 0;\n            var y = adjustTextY$1(style.y || 0, getLineHeight(font), style.textBaseline);\n            var textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign]\n                || style.textAlign;\n            attr(textSvgEl, 'dominant-baseline', 'central');\n            attr(textSvgEl, 'text-anchor', textAlign);\n            attr(textSvgEl, 'x', x + '');\n            attr(textSvgEl, 'y', y + '');\n        }\n    };\n\n    var MARK_UNUSED = '0';\n    var MARK_USED = '1';\n    var Definable = (function () {\n        function Definable(zrId, svgRoot, tagNames, markLabel, domName) {\n            this.nextId = 0;\n            this._domName = '_dom';\n            this.createElement = createElement;\n            this._zrId = zrId;\n            this._svgRoot = svgRoot;\n            this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;\n            this._markLabel = markLabel;\n            if (domName) {\n                this._domName = domName;\n            }\n        }\n        Definable.prototype.getDefs = function (isForceCreating) {\n            var svgRoot = this._svgRoot;\n            var defs = this._svgRoot.getElementsByTagName('defs');\n            if (defs.length === 0) {\n                if (isForceCreating) {\n                    var defs_1 = svgRoot.insertBefore(this.createElement('defs'), svgRoot.firstChild);\n                    if (!defs_1.contains) {\n                        defs_1.contains = function (el) {\n                            var children = defs_1.children;\n                            if (!children) {\n                                return false;\n                            }\n                            for (var i = children.length - 1; i >= 0; --i) {\n                                if (children[i] === el) {\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n                    }\n                    return defs_1;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return defs[0];\n            }\n        };\n        Definable.prototype.doUpdate = function (target, onUpdate) {\n            if (!target) {\n                return;\n            }\n            var defs = this.getDefs(false);\n            if (target[this._domName] && defs.contains(target[this._domName])) {\n                if (typeof onUpdate === 'function') {\n                    onUpdate(target);\n                }\n            }\n            else {\n                var dom = this.add(target);\n                if (dom) {\n                    target[this._domName] = dom;\n                }\n            }\n        };\n        Definable.prototype.add = function (target) {\n            return null;\n        };\n        Definable.prototype.addDom = function (dom) {\n            var defs = this.getDefs(true);\n            if (dom.parentNode !== defs) {\n                defs.appendChild(dom);\n            }\n        };\n        Definable.prototype.removeDom = function (target) {\n            var defs = this.getDefs(false);\n            if (defs && target[this._domName]) {\n                defs.removeChild(target[this._domName]);\n                target[this._domName] = null;\n            }\n        };\n        Definable.prototype.getDoms = function () {\n            var defs = this.getDefs(false);\n            if (!defs) {\n                return [];\n            }\n            var doms = [];\n            each(this._tagNames, function (tagName) {\n                var tags = defs.getElementsByTagName(tagName);\n                for (var i = 0; i < tags.length; i++) {\n                    doms.push(tags[i]);\n                }\n            });\n            return doms;\n        };\n        Definable.prototype.markAllUnused = function () {\n            var doms = this.getDoms();\n            var that = this;\n            each(doms, function (dom) {\n                dom[that._markLabel] = MARK_UNUSED;\n            });\n        };\n        Definable.prototype.markDomUsed = function (dom) {\n            dom && (dom[this._markLabel] = MARK_USED);\n        };\n        Definable.prototype.markDomUnused = function (dom) {\n            dom && (dom[this._markLabel] = MARK_UNUSED);\n        };\n        Definable.prototype.isDomUnused = function (dom) {\n            return dom && dom[this._markLabel] !== MARK_USED;\n        };\n        Definable.prototype.removeUnused = function () {\n            var _this = this;\n            var defs = this.getDefs(false);\n            if (!defs) {\n                return;\n            }\n            var doms = this.getDoms();\n            each(doms, function (dom) {\n                if (_this.isDomUnused(dom)) {\n                    defs.removeChild(dom);\n                }\n            });\n        };\n        Definable.prototype.getSvgProxy = function (displayable) {\n            if (displayable instanceof Path) {\n                return svgPath;\n            }\n            else if (displayable instanceof ZRImage) {\n                return svgImage;\n            }\n            else if (displayable instanceof TSpan) {\n                return svgText;\n            }\n            else {\n                return svgPath;\n            }\n        };\n        Definable.prototype.getSvgElement = function (displayable) {\n            return displayable.__svgEl;\n        };\n        return Definable;\n    }());\n\n    function isLinearGradient(value) {\n        return value.type === 'linear';\n    }\n    function isRadialGradient(value) {\n        return value.type === 'radial';\n    }\n    function isGradient(value) {\n        return value && (value.type === 'linear'\n            || value.type === 'radial');\n    }\n    var GradientManager = (function (_super) {\n        __extends(GradientManager, _super);\n        function GradientManager(zrId, svgRoot) {\n            return _super.call(this, zrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__') || this;\n        }\n        GradientManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n            if (displayable && displayable.style) {\n                var that_1 = this;\n                each(['fill', 'stroke'], function (fillOrStroke) {\n                    var value = displayable.style[fillOrStroke];\n                    if (isGradient(value)) {\n                        var gradient = value;\n                        var defs = that_1.getDefs(true);\n                        var dom = void 0;\n                        if (gradient.__dom) {\n                            dom = gradient.__dom;\n                            if (!defs.contains(gradient.__dom)) {\n                                that_1.addDom(dom);\n                            }\n                        }\n                        else {\n                            dom = that_1.add(gradient);\n                        }\n                        that_1.markUsed(displayable);\n                        var id = dom.getAttribute('id');\n                        svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n                    }\n                });\n            }\n        };\n        GradientManager.prototype.add = function (gradient) {\n            var dom;\n            if (isLinearGradient(gradient)) {\n                dom = this.createElement('linearGradient');\n            }\n            else if (isRadialGradient(gradient)) {\n                dom = this.createElement('radialGradient');\n            }\n            else {\n                logError('Illegal gradient type.');\n                return null;\n            }\n            gradient.id = gradient.id || this.nextId++;\n            dom.setAttribute('id', 'zr' + this._zrId\n                + '-gradient-' + gradient.id);\n            this.updateDom(gradient, dom);\n            this.addDom(dom);\n            return dom;\n        };\n        GradientManager.prototype.update = function (gradient) {\n            if (!isGradient(gradient)) {\n                return;\n            }\n            var that = this;\n            this.doUpdate(gradient, function () {\n                var dom = gradient.__dom;\n                if (!dom) {\n                    return;\n                }\n                var tagName = dom.tagName;\n                var type = gradient.type;\n                if (type === 'linear' && tagName === 'linearGradient'\n                    || type === 'radial' && tagName === 'radialGradient') {\n                    that.updateDom(gradient, gradient.__dom);\n                }\n                else {\n                    that.removeDom(gradient);\n                    that.add(gradient);\n                }\n            });\n        };\n        GradientManager.prototype.updateDom = function (gradient, dom) {\n            if (isLinearGradient(gradient)) {\n                dom.setAttribute('x1', gradient.x + '');\n                dom.setAttribute('y1', gradient.y + '');\n                dom.setAttribute('x2', gradient.x2 + '');\n                dom.setAttribute('y2', gradient.y2 + '');\n            }\n            else if (isRadialGradient(gradient)) {\n                dom.setAttribute('cx', gradient.x + '');\n                dom.setAttribute('cy', gradient.y + '');\n                dom.setAttribute('r', gradient.r + '');\n            }\n            else {\n                logError('Illegal gradient type.');\n                return;\n            }\n            if (gradient.global) {\n                dom.setAttribute('gradientUnits', 'userSpaceOnUse');\n            }\n            else {\n                dom.setAttribute('gradientUnits', 'objectBoundingBox');\n            }\n            dom.innerHTML = '';\n            var colors = gradient.colorStops;\n            for (var i = 0, len = colors.length; i < len; ++i) {\n                var stop_1 = this.createElement('stop');\n                stop_1.setAttribute('offset', colors[i].offset * 100 + '%');\n                var color$1 = colors[i].color;\n                if (color$1.indexOf('rgba') > -1) {\n                    var opacity = parse(color$1)[3];\n                    var hex = toHex(color$1);\n                    stop_1.setAttribute('stop-color', '#' + hex);\n                    stop_1.setAttribute('stop-opacity', opacity + '');\n                }\n                else {\n                    stop_1.setAttribute('stop-color', colors[i].color);\n                }\n                dom.appendChild(stop_1);\n            }\n            gradient.__dom = dom;\n        };\n        GradientManager.prototype.markUsed = function (displayable) {\n            if (displayable.style) {\n                var gradient = displayable.style.fill;\n                if (gradient && gradient.__dom) {\n                    _super.prototype.markDomUsed.call(this, gradient.__dom);\n                }\n                gradient = displayable.style.stroke;\n                if (gradient && gradient.__dom) {\n                    _super.prototype.markDomUsed.call(this, gradient.__dom);\n                }\n            }\n        };\n        return GradientManager;\n    }(Definable));\n\n    function isPattern(value) {\n        return value && (!!value.image || !!value.svgElement);\n    }\n    var patternDomMap = new WeakMap();\n    var PatternManager = (function (_super) {\n        __extends(PatternManager, _super);\n        function PatternManager(zrId, svgRoot) {\n            return _super.call(this, zrId, svgRoot, ['pattern'], '__pattern_in_use__') || this;\n        }\n        PatternManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n            if (displayable && displayable.style) {\n                var that_1 = this;\n                each(['fill', 'stroke'], function (fillOrStroke) {\n                    var pattern = displayable.style[fillOrStroke];\n                    if (isPattern(pattern)) {\n                        var defs = that_1.getDefs(true);\n                        var dom = patternDomMap.get(pattern);\n                        if (dom) {\n                            if (!defs.contains(dom)) {\n                                that_1.addDom(dom);\n                            }\n                        }\n                        else {\n                            dom = that_1.add(pattern);\n                        }\n                        that_1.markUsed(displayable);\n                        var id = dom.getAttribute('id');\n                        svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n                    }\n                });\n            }\n        };\n        PatternManager.prototype.add = function (pattern) {\n            if (!isPattern(pattern)) {\n                return;\n            }\n            var dom = this.createElement('pattern');\n            pattern.id = pattern.id == null ? this.nextId++ : pattern.id;\n            dom.setAttribute('id', 'zr' + this._zrId\n                + '-pattern-' + pattern.id);\n            dom.setAttribute('x', '0');\n            dom.setAttribute('y', '0');\n            dom.setAttribute('patternUnits', 'userSpaceOnUse');\n            this.updateDom(pattern, dom);\n            this.addDom(dom);\n            return dom;\n        };\n        PatternManager.prototype.update = function (pattern) {\n            if (!isPattern(pattern)) {\n                return;\n            }\n            var that = this;\n            this.doUpdate(pattern, function () {\n                var dom = patternDomMap.get(pattern);\n                that.updateDom(pattern, dom);\n            });\n        };\n        PatternManager.prototype.updateDom = function (pattern, patternDom) {\n            var svgElement = pattern.svgElement;\n            if (svgElement instanceof SVGElement) {\n                if (svgElement.parentNode !== patternDom) {\n                    patternDom.innerHTML = '';\n                    patternDom.appendChild(svgElement);\n                    patternDom.setAttribute('width', pattern.svgWidth + '');\n                    patternDom.setAttribute('height', pattern.svgHeight + '');\n                }\n            }\n            else {\n                var img = void 0;\n                var prevImage = patternDom.getElementsByTagName('image');\n                if (prevImage.length) {\n                    if (pattern.image) {\n                        img = prevImage[0];\n                    }\n                    else {\n                        patternDom.removeChild(prevImage[0]);\n                        return;\n                    }\n                }\n                else if (pattern.image) {\n                    img = this.createElement('image');\n                }\n                if (img) {\n                    var imageSrc = void 0;\n                    if (typeof pattern.image === 'string') {\n                        imageSrc = pattern.image;\n                    }\n                    else if (pattern.image instanceof HTMLImageElement) {\n                        imageSrc = pattern.image.src;\n                    }\n                    else if (pattern.image instanceof HTMLCanvasElement) {\n                        imageSrc = pattern.image.toDataURL();\n                    }\n                    if (imageSrc) {\n                        img.setAttribute('href', imageSrc);\n                        img.setAttribute('x', '0');\n                        img.setAttribute('y', '0');\n                        var hostEl = {\n                            dirty: function () { }\n                        };\n                        var createdImage = createOrUpdateImage(imageSrc, img, hostEl, function (img) {\n                            patternDom.setAttribute('width', img.width + '');\n                            patternDom.setAttribute('height', img.height + '');\n                        });\n                        if (createdImage && createdImage.width && createdImage.height) {\n                            patternDom.setAttribute('width', createdImage.width + '');\n                            patternDom.setAttribute('height', createdImage.height + '');\n                        }\n                        patternDom.appendChild(img);\n                    }\n                }\n            }\n            var x = pattern.x || 0;\n            var y = pattern.y || 0;\n            var rotation = (pattern.rotation || 0) / Math.PI * 180;\n            var scaleX = pattern.scaleX || 1;\n            var scaleY = pattern.scaleY || 1;\n            var transform = \"translate(\" + x + \", \" + y + \") rotate(\" + rotation + \") scale(\" + scaleX + \", \" + scaleY + \")\";\n            patternDom.setAttribute('patternTransform', transform);\n            patternDomMap.set(pattern, patternDom);\n        };\n        PatternManager.prototype.markUsed = function (displayable) {\n            if (displayable.style) {\n                if (isPattern(displayable.style.fill)) {\n                    _super.prototype.markDomUsed.call(this, patternDomMap.get(displayable.style.fill));\n                }\n                if (isPattern(displayable.style.stroke)) {\n                    _super.prototype.markDomUsed.call(this, patternDomMap.get(displayable.style.stroke));\n                }\n            }\n        };\n        return PatternManager;\n    }(Definable));\n\n    function generateClipPathsKey(clipPaths) {\n        var key = [];\n        if (clipPaths) {\n            for (var i = 0; i < clipPaths.length; i++) {\n                var clipPath = clipPaths[i];\n                key.push(clipPath.id);\n            }\n        }\n        return key.join(',');\n    }\n    function hasClipPath(displayable) {\n        var clipPaths = displayable.__clipPaths;\n        return clipPaths && clipPaths.length > 0;\n    }\n    var ClippathManager = (function (_super) {\n        __extends(ClippathManager, _super);\n        function ClippathManager(zrId, svgRoot) {\n            var _this = _super.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__') || this;\n            _this._refGroups = {};\n            _this._keyDuplicateCount = {};\n            return _this;\n        }\n        ClippathManager.prototype.markAllUnused = function () {\n            _super.prototype.markAllUnused.call(this);\n            for (var key in this._refGroups) {\n                this.markDomUnused(this._refGroups[key]);\n            }\n            this._keyDuplicateCount = {};\n        };\n        ClippathManager.prototype._getClipPathGroup = function (displayable, prevDisplayable) {\n            if (!hasClipPath(displayable)) {\n                return;\n            }\n            var clipPaths = displayable.__clipPaths;\n            var keyDuplicateCount = this._keyDuplicateCount;\n            var clipPathKey = generateClipPathsKey(clipPaths);\n            if (isClipPathChanged(clipPaths, prevDisplayable && prevDisplayable.__clipPaths)) {\n                keyDuplicateCount[clipPathKey] = keyDuplicateCount[clipPathKey] || 0;\n                keyDuplicateCount[clipPathKey] && (clipPathKey += '-' + keyDuplicateCount[clipPathKey]);\n                keyDuplicateCount[clipPathKey]++;\n            }\n            return this._refGroups[clipPathKey]\n                || (this._refGroups[clipPathKey] = this.createElement('g'));\n        };\n        ClippathManager.prototype.update = function (displayable, prevDisplayable) {\n            var clipGroup = this._getClipPathGroup(displayable, prevDisplayable);\n            if (clipGroup) {\n                this.markDomUsed(clipGroup);\n                this.updateDom(clipGroup, displayable.__clipPaths);\n            }\n            return clipGroup;\n        };\n        ClippathManager.prototype.updateDom = function (parentEl, clipPaths) {\n            if (clipPaths && clipPaths.length > 0) {\n                var defs = this.getDefs(true);\n                var clipPath = clipPaths[0];\n                var clipPathEl = void 0;\n                var id = void 0;\n                if (clipPath._dom) {\n                    id = clipPath._dom.getAttribute('id');\n                    clipPathEl = clipPath._dom;\n                    if (!defs.contains(clipPathEl)) {\n                        defs.appendChild(clipPathEl);\n                    }\n                }\n                else {\n                    id = 'zr' + this._zrId + '-clip-' + this.nextId;\n                    ++this.nextId;\n                    clipPathEl = this.createElement('clipPath');\n                    clipPathEl.setAttribute('id', id);\n                    defs.appendChild(clipPathEl);\n                    clipPath._dom = clipPathEl;\n                }\n                var svgProxy = this.getSvgProxy(clipPath);\n                svgProxy.brush(clipPath);\n                var pathEl = this.getSvgElement(clipPath);\n                clipPathEl.innerHTML = '';\n                clipPathEl.appendChild(pathEl);\n                parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n                if (clipPaths.length > 1) {\n                    this.updateDom(clipPathEl, clipPaths.slice(1));\n                }\n            }\n            else {\n                if (parentEl) {\n                    parentEl.setAttribute('clip-path', 'none');\n                }\n            }\n        };\n        ClippathManager.prototype.markUsed = function (displayable) {\n            var _this = this;\n            if (displayable.__clipPaths) {\n                each(displayable.__clipPaths, function (clipPath) {\n                    if (clipPath._dom) {\n                        _super.prototype.markDomUsed.call(_this, clipPath._dom);\n                    }\n                });\n            }\n        };\n        ClippathManager.prototype.removeUnused = function () {\n            _super.prototype.removeUnused.call(this);\n            var newRefGroupsMap = {};\n            for (var key in this._refGroups) {\n                var group = this._refGroups[key];\n                if (!this.isDomUnused(group)) {\n                    newRefGroupsMap[key] = group;\n                }\n                else if (group.parentNode) {\n                    group.parentNode.removeChild(group);\n                }\n            }\n            this._refGroups = newRefGroupsMap;\n        };\n        return ClippathManager;\n    }(Definable));\n\n    var ShadowManager = (function (_super) {\n        __extends(ShadowManager, _super);\n        function ShadowManager(zrId, svgRoot) {\n            var _this = _super.call(this, zrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom') || this;\n            _this._shadowDomMap = {};\n            _this._shadowDomPool = [];\n            return _this;\n        }\n        ShadowManager.prototype._getFromPool = function () {\n            var shadowDom = this._shadowDomPool.pop();\n            if (!shadowDom) {\n                shadowDom = this.createElement('filter');\n                shadowDom.setAttribute('id', 'zr' + this._zrId + '-shadow-' + this.nextId++);\n                var domChild = this.createElement('feDropShadow');\n                shadowDom.appendChild(domChild);\n                this.addDom(shadowDom);\n            }\n            return shadowDom;\n        };\n        ShadowManager.prototype.update = function (svgElement, displayable) {\n            var style = displayable.style;\n            if (hasShadow(style)) {\n                var shadowKey = getShadowKey(displayable);\n                var shadowDom = displayable._shadowDom = this._shadowDomMap[shadowKey];\n                if (!shadowDom) {\n                    shadowDom = this._getFromPool();\n                    this._shadowDomMap[shadowKey] = shadowDom;\n                }\n                this.updateDom(svgElement, displayable, shadowDom);\n            }\n            else {\n                this.remove(svgElement, displayable);\n            }\n        };\n        ShadowManager.prototype.remove = function (svgElement, displayable) {\n            if (displayable._shadowDom != null) {\n                displayable._shadowDom = null;\n                svgElement.style.filter = '';\n            }\n        };\n        ShadowManager.prototype.updateDom = function (svgElement, displayable, shadowDom) {\n            var domChild = shadowDom.children[0];\n            var style = displayable.style;\n            var globalScale = displayable.getGlobalScale();\n            var scaleX = globalScale[0];\n            var scaleY = globalScale[1];\n            if (!scaleX || !scaleY) {\n                return;\n            }\n            var offsetX = style.shadowOffsetX || 0;\n            var offsetY = style.shadowOffsetY || 0;\n            var blur = style.shadowBlur;\n            var color = style.shadowColor;\n            domChild.setAttribute('dx', offsetX / scaleX + '');\n            domChild.setAttribute('dy', offsetY / scaleY + '');\n            domChild.setAttribute('flood-color', color);\n            var stdDx = blur / 2 / scaleX;\n            var stdDy = blur / 2 / scaleY;\n            var stdDeviation = stdDx + ' ' + stdDy;\n            domChild.setAttribute('stdDeviation', stdDeviation);\n            shadowDom.setAttribute('x', '-100%');\n            shadowDom.setAttribute('y', '-100%');\n            shadowDom.setAttribute('width', '300%');\n            shadowDom.setAttribute('height', '300%');\n            displayable._shadowDom = shadowDom;\n            var id = shadowDom.getAttribute('id');\n            svgElement.style.filter = 'url(#' + id + ')';\n        };\n        ShadowManager.prototype.removeUnused = function () {\n            var defs = this.getDefs(false);\n            if (!defs) {\n                return;\n            }\n            var shadowDomsPool = this._shadowDomPool;\n            for (var key in this._shadowDomMap) {\n                var dom = this._shadowDomMap[key];\n                shadowDomsPool.push(dom);\n            }\n            this._shadowDomMap = {};\n        };\n        return ShadowManager;\n    }(Definable));\n    function hasShadow(style) {\n        return style\n            && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);\n    }\n    function getShadowKey(displayable) {\n        var style = displayable.style;\n        var globalScale = displayable.getGlobalScale();\n        return [\n            style.shadowColor,\n            (style.shadowBlur || 0).toFixed(2),\n            (style.shadowOffsetX || 0).toFixed(2),\n            (style.shadowOffsetY || 0).toFixed(2),\n            globalScale[0],\n            globalScale[1]\n        ].join(',');\n    }\n\n    function parseInt10(val) {\n        return parseInt(val, 10);\n    }\n    function getSvgProxy(el) {\n        if (el instanceof Path) {\n            return svgPath;\n        }\n        else if (el instanceof ZRImage) {\n            return svgImage;\n        }\n        else if (el instanceof TSpan) {\n            return svgText;\n        }\n        else {\n            return svgPath;\n        }\n    }\n    function checkParentAvailable(parent, child) {\n        return child && parent && child.parentNode !== parent;\n    }\n    function insertAfter(parent, child, prevSibling) {\n        if (checkParentAvailable(parent, child) && prevSibling) {\n            var nextSibling = prevSibling.nextSibling;\n            nextSibling ? parent.insertBefore(child, nextSibling)\n                : parent.appendChild(child);\n        }\n    }\n    function prepend(parent, child) {\n        if (checkParentAvailable(parent, child)) {\n            var firstChild = parent.firstChild;\n            firstChild ? parent.insertBefore(child, firstChild)\n                : parent.appendChild(child);\n        }\n    }\n    function remove(parent, child) {\n        if (child && parent && child.parentNode === parent) {\n            parent.removeChild(child);\n        }\n    }\n    function removeFromMyParent(child) {\n        if (child && child.parentNode) {\n            child.parentNode.removeChild(child);\n        }\n    }\n    function getSvgElement(displayable) {\n        return displayable.__svgEl;\n    }\n    var SVGPainter = (function () {\n        function SVGPainter(root, storage, opts, zrId) {\n            this.type = 'svg';\n            this.refreshHover = createMethodNotSupport('refreshHover');\n            this.pathToImage = createMethodNotSupport('pathToImage');\n            this.configLayer = createMethodNotSupport('configLayer');\n            this.root = root;\n            this.storage = storage;\n            this._opts = opts = extend({}, opts || {});\n            var svgDom = createElement('svg');\n            svgDom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');\n            svgDom.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', 'http://www.w3.org/1999/xlink');\n            svgDom.setAttribute('version', '1.1');\n            svgDom.setAttribute('baseProfile', 'full');\n            svgDom.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';\n            var bgRoot = createElement('g');\n            svgDom.appendChild(bgRoot);\n            var svgRoot = createElement('g');\n            svgDom.appendChild(svgRoot);\n            this._gradientManager = new GradientManager(zrId, svgRoot);\n            this._patternManager = new PatternManager(zrId, svgRoot);\n            this._clipPathManager = new ClippathManager(zrId, svgRoot);\n            this._shadowManager = new ShadowManager(zrId, svgRoot);\n            var viewport = document.createElement('div');\n            viewport.style.cssText = 'overflow:hidden;position:relative';\n            this._svgDom = svgDom;\n            this._svgRoot = svgRoot;\n            this._backgroundRoot = bgRoot;\n            this._viewport = viewport;\n            root.appendChild(viewport);\n            viewport.appendChild(svgDom);\n            this.resize(opts.width, opts.height);\n            this._visibleList = [];\n        }\n        SVGPainter.prototype.getType = function () {\n            return 'svg';\n        };\n        SVGPainter.prototype.getViewportRoot = function () {\n            return this._viewport;\n        };\n        SVGPainter.prototype.getSvgDom = function () {\n            return this._svgDom;\n        };\n        SVGPainter.prototype.getSvgRoot = function () {\n            return this._svgRoot;\n        };\n        SVGPainter.prototype.getViewportRootOffset = function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        };\n        SVGPainter.prototype.refresh = function () {\n            var list = this.storage.getDisplayList(true);\n            this._paintList(list);\n        };\n        SVGPainter.prototype.setBackgroundColor = function (backgroundColor) {\n            if (this._backgroundRoot && this._backgroundNode) {\n                this._backgroundRoot.removeChild(this._backgroundNode);\n            }\n            var bgNode = createElement('rect');\n            bgNode.setAttribute('width', this.getWidth());\n            bgNode.setAttribute('height', this.getHeight());\n            bgNode.setAttribute('x', 0);\n            bgNode.setAttribute('y', 0);\n            bgNode.setAttribute('id', 0);\n            bgNode.style.fill = backgroundColor;\n            this._backgroundRoot.appendChild(bgNode);\n            this._backgroundNode = bgNode;\n        };\n        SVGPainter.prototype.createSVGElement = function (tag) {\n            return createElement(tag);\n        };\n        SVGPainter.prototype.paintOne = function (el) {\n            var svgProxy = getSvgProxy(el);\n            svgProxy && svgProxy.brush(el);\n            return getSvgElement(el);\n        };\n        SVGPainter.prototype._paintList = function (list) {\n            var gradientManager = this._gradientManager;\n            var patternManager = this._patternManager;\n            var clipPathManager = this._clipPathManager;\n            var shadowManager = this._shadowManager;\n            gradientManager.markAllUnused();\n            patternManager.markAllUnused();\n            clipPathManager.markAllUnused();\n            shadowManager.markAllUnused();\n            var svgRoot = this._svgRoot;\n            var visibleList = this._visibleList;\n            var listLen = list.length;\n            var newVisibleList = [];\n            for (var i = 0; i < listLen; i++) {\n                var displayable = list[i];\n                var svgProxy = getSvgProxy(displayable);\n                var svgElement = getSvgElement(displayable);\n                if (!displayable.invisible) {\n                    if (displayable.__dirty || !svgElement) {\n                        svgProxy && svgProxy.brush(displayable);\n                        svgElement = getSvgElement(displayable);\n                        if (svgElement && displayable.style) {\n                            gradientManager.update(displayable.style.fill);\n                            gradientManager.update(displayable.style.stroke);\n                            patternManager.update(displayable.style.fill);\n                            patternManager.update(displayable.style.stroke);\n                            shadowManager.update(svgElement, displayable);\n                        }\n                        displayable.__dirty = 0;\n                    }\n                    if (svgElement) {\n                        newVisibleList.push(displayable);\n                    }\n                }\n            }\n            var diff = arrayDiff(visibleList, newVisibleList);\n            var prevSvgElement;\n            var topPrevSvgElement;\n            for (var i = 0; i < diff.length; i++) {\n                var item = diff[i];\n                if (item.removed) {\n                    for (var k = 0; k < item.count; k++) {\n                        var displayable = visibleList[item.indices[k]];\n                        var svgElement = getSvgElement(displayable);\n                        hasClipPath(displayable) ? removeFromMyParent(svgElement)\n                            : remove(svgRoot, svgElement);\n                    }\n                }\n            }\n            var prevDisplayable;\n            var currentClipGroup;\n            for (var i = 0; i < diff.length; i++) {\n                var item = diff[i];\n                var isAdd = item.added;\n                if (item.removed) {\n                    continue;\n                }\n                for (var k = 0; k < item.count; k++) {\n                    var displayable = newVisibleList[item.indices[k]];\n                    var clipGroup = clipPathManager.update(displayable, prevDisplayable);\n                    if (clipGroup !== currentClipGroup) {\n                        prevSvgElement = topPrevSvgElement;\n                        if (clipGroup) {\n                            prevSvgElement ? insertAfter(svgRoot, clipGroup, prevSvgElement)\n                                : prepend(svgRoot, clipGroup);\n                            topPrevSvgElement = clipGroup;\n                            prevSvgElement = null;\n                        }\n                        currentClipGroup = clipGroup;\n                    }\n                    var svgElement = getSvgElement(displayable);\n                    prevSvgElement\n                        ? insertAfter(currentClipGroup || svgRoot, svgElement, prevSvgElement)\n                        : prepend(currentClipGroup || svgRoot, svgElement);\n                    prevSvgElement = svgElement || prevSvgElement;\n                    if (!currentClipGroup) {\n                        topPrevSvgElement = prevSvgElement;\n                    }\n                    gradientManager.markUsed(displayable);\n                    gradientManager.addWithoutUpdate(svgElement, displayable);\n                    patternManager.markUsed(displayable);\n                    patternManager.addWithoutUpdate(svgElement, displayable);\n                    clipPathManager.markUsed(displayable);\n                    prevDisplayable = displayable;\n                }\n            }\n            gradientManager.removeUnused();\n            patternManager.removeUnused();\n            clipPathManager.removeUnused();\n            shadowManager.removeUnused();\n            this._visibleList = newVisibleList;\n        };\n        SVGPainter.prototype._getDefs = function (isForceCreating) {\n            var svgRoot = this._svgDom;\n            var defs = svgRoot.getElementsByTagName('defs');\n            if (defs.length === 0) {\n                if (isForceCreating) {\n                    var defs_1 = svgRoot.insertBefore(createElement('defs'), svgRoot.firstChild);\n                    if (!defs_1.contains) {\n                        defs_1.contains = function (el) {\n                            var children = defs_1.children;\n                            if (!children) {\n                                return false;\n                            }\n                            for (var i = children.length - 1; i >= 0; --i) {\n                                if (children[i] === el) {\n                                    return true;\n                                }\n                            }\n                            return false;\n                        };\n                    }\n                    return defs_1;\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return defs[0];\n            }\n        };\n        SVGPainter.prototype.resize = function (width, height) {\n            var viewport = this._viewport;\n            viewport.style.display = 'none';\n            var opts = this._opts;\n            width != null && (opts.width = width);\n            height != null && (opts.height = height);\n            width = this._getSize(0);\n            height = this._getSize(1);\n            viewport.style.display = '';\n            if (this._width !== width || this._height !== height) {\n                this._width = width;\n                this._height = height;\n                var viewportStyle = viewport.style;\n                viewportStyle.width = width + 'px';\n                viewportStyle.height = height + 'px';\n                var svgRoot = this._svgDom;\n                svgRoot.setAttribute('width', width + '');\n                svgRoot.setAttribute('height', height + '');\n            }\n            if (this._backgroundNode) {\n                this._backgroundNode.setAttribute('width', width);\n                this._backgroundNode.setAttribute('height', height);\n            }\n        };\n        SVGPainter.prototype.getWidth = function () {\n            return this._width;\n        };\n        SVGPainter.prototype.getHeight = function () {\n            return this._height;\n        };\n        SVGPainter.prototype._getSize = function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))\n                - (parseInt10(stl[plt]) || 0)\n                - (parseInt10(stl[prb]) || 0)) | 0;\n        };\n        SVGPainter.prototype.dispose = function () {\n            this.root.innerHTML = '';\n            this._svgRoot\n                = this._backgroundRoot\n                    = this._svgDom\n                        = this._backgroundNode\n                            = this._viewport\n                                = this.storage\n                                    = null;\n        };\n        SVGPainter.prototype.clear = function () {\n            var viewportNode = this._viewport;\n            if (viewportNode && viewportNode.parentNode) {\n                viewportNode.parentNode.removeChild(viewportNode);\n            }\n        };\n        SVGPainter.prototype.toDataURL = function () {\n            this.refresh();\n            var svgDom = this._svgDom;\n            var outerHTML = svgDom.outerHTML\n                || (svgDom.parentNode && svgDom.parentNode).innerHTML;\n            var html = encodeURIComponent(outerHTML.replace(/></g, '>\\n\\r<'));\n            return 'data:image/svg+xml;charset=UTF-8,' + html;\n        };\n        return SVGPainter;\n    }());\n    function createMethodNotSupport(method) {\n        return function () {\n            logError('In SVG mode painter not support method \"' + method + '\"');\n        };\n    }\n\n    function install(registers) {\n      registers.registerPainter('svg', SVGPainter);\n    }\n\n    function returnFalse() {\n        return false;\n    }\n    function createDom(id, painter, dpr) {\n        var newDom = createCanvas();\n        var width = painter.getWidth();\n        var height = painter.getHeight();\n        var newDomStyle = newDom.style;\n        if (newDomStyle) {\n            newDomStyle.position = 'absolute';\n            newDomStyle.left = '0';\n            newDomStyle.top = '0';\n            newDomStyle.width = width + 'px';\n            newDomStyle.height = height + 'px';\n            newDom.setAttribute('data-zr-dom-id', id);\n        }\n        newDom.width = width * dpr;\n        newDom.height = height * dpr;\n        return newDom;\n    }\n    var Layer = (function (_super) {\n        __extends(Layer, _super);\n        function Layer(id, painter, dpr) {\n            var _this = _super.call(this) || this;\n            _this.motionBlur = false;\n            _this.lastFrameAlpha = 0.7;\n            _this.dpr = 1;\n            _this.virtual = false;\n            _this.config = {};\n            _this.incremental = false;\n            _this.zlevel = 0;\n            _this.maxRepaintRectCount = 5;\n            _this.__dirty = true;\n            _this.__firstTimePaint = true;\n            _this.__used = false;\n            _this.__drawIndex = 0;\n            _this.__startIndex = 0;\n            _this.__endIndex = 0;\n            _this.__prevStartIndex = null;\n            _this.__prevEndIndex = null;\n            var dom;\n            dpr = dpr || devicePixelRatio;\n            if (typeof id === 'string') {\n                dom = createDom(id, painter, dpr);\n            }\n            else if (isObject(id)) {\n                dom = id;\n                id = dom.id;\n            }\n            _this.id = id;\n            _this.dom = dom;\n            var domStyle = dom.style;\n            if (domStyle) {\n                dom.onselectstart = returnFalse;\n                domStyle.webkitUserSelect = 'none';\n                domStyle.userSelect = 'none';\n                domStyle.webkitTapHighlightColor = 'rgba(0,0,0,0)';\n                domStyle['-webkit-touch-callout'] = 'none';\n                domStyle.padding = '0';\n                domStyle.margin = '0';\n                domStyle.borderWidth = '0';\n            }\n            _this.domBack = null;\n            _this.ctxBack = null;\n            _this.painter = painter;\n            _this.config = null;\n            _this.dpr = dpr;\n            return _this;\n        }\n        Layer.prototype.getElementCount = function () {\n            return this.__endIndex - this.__startIndex;\n        };\n        Layer.prototype.afterBrush = function () {\n            this.__prevStartIndex = this.__startIndex;\n            this.__prevEndIndex = this.__endIndex;\n        };\n        Layer.prototype.initContext = function () {\n            this.ctx = this.dom.getContext('2d');\n            this.ctx.dpr = this.dpr;\n        };\n        Layer.prototype.setUnpainted = function () {\n            this.__firstTimePaint = true;\n        };\n        Layer.prototype.createBackBuffer = function () {\n            var dpr = this.dpr;\n            this.domBack = createDom('back-' + this.id, this.painter, dpr);\n            this.ctxBack = this.domBack.getContext('2d');\n            if (dpr !== 1) {\n                this.ctxBack.scale(dpr, dpr);\n            }\n        };\n        Layer.prototype.createRepaintRects = function (displayList, prevList, viewWidth, viewHeight) {\n            if (this.__firstTimePaint) {\n                this.__firstTimePaint = false;\n                return null;\n            }\n            var mergedRepaintRects = [];\n            var maxRepaintRectCount = this.maxRepaintRectCount;\n            var full = false;\n            var pendingRect = new BoundingRect(0, 0, 0, 0);\n            function addRectToMergePool(rect) {\n                if (!rect.isFinite() || rect.isZero()) {\n                    return;\n                }\n                if (mergedRepaintRects.length === 0) {\n                    var boundingRect = new BoundingRect(0, 0, 0, 0);\n                    boundingRect.copy(rect);\n                    mergedRepaintRects.push(boundingRect);\n                }\n                else {\n                    var isMerged = false;\n                    var minDeltaArea = Infinity;\n                    var bestRectToMergeIdx = 0;\n                    for (var i = 0; i < mergedRepaintRects.length; ++i) {\n                        var mergedRect = mergedRepaintRects[i];\n                        if (mergedRect.intersect(rect)) {\n                            var pendingRect_1 = new BoundingRect(0, 0, 0, 0);\n                            pendingRect_1.copy(mergedRect);\n                            pendingRect_1.union(rect);\n                            mergedRepaintRects[i] = pendingRect_1;\n                            isMerged = true;\n                            break;\n                        }\n                        else if (full) {\n                            pendingRect.copy(rect);\n                            pendingRect.union(mergedRect);\n                            var aArea = rect.width * rect.height;\n                            var bArea = mergedRect.width * mergedRect.height;\n                            var pendingArea = pendingRect.width * pendingRect.height;\n                            var deltaArea = pendingArea - aArea - bArea;\n                            if (deltaArea < minDeltaArea) {\n                                minDeltaArea = deltaArea;\n                                bestRectToMergeIdx = i;\n                            }\n                        }\n                    }\n                    if (full) {\n                        mergedRepaintRects[bestRectToMergeIdx].union(rect);\n                        isMerged = true;\n                    }\n                    if (!isMerged) {\n                        var boundingRect = new BoundingRect(0, 0, 0, 0);\n                        boundingRect.copy(rect);\n                        mergedRepaintRects.push(boundingRect);\n                    }\n                    if (!full) {\n                        full = mergedRepaintRects.length >= maxRepaintRectCount;\n                    }\n                }\n            }\n            for (var i = this.__startIndex; i < this.__endIndex; ++i) {\n                var el = displayList[i];\n                if (el) {\n                    var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);\n                    var prevRect = el.__isRendered && ((el.__dirty & Element.REDARAW_BIT) || !shouldPaint)\n                        ? el.getPrevPaintRect()\n                        : null;\n                    if (prevRect) {\n                        addRectToMergePool(prevRect);\n                    }\n                    var curRect = shouldPaint && ((el.__dirty & Element.REDARAW_BIT) || !el.__isRendered)\n                        ? el.getPaintRect()\n                        : null;\n                    if (curRect) {\n                        addRectToMergePool(curRect);\n                    }\n                }\n            }\n            for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {\n                var el = prevList[i];\n                var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);\n                if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {\n                    var prevRect = el.getPrevPaintRect();\n                    if (prevRect) {\n                        addRectToMergePool(prevRect);\n                    }\n                }\n            }\n            var hasIntersections;\n            do {\n                hasIntersections = false;\n                for (var i = 0; i < mergedRepaintRects.length;) {\n                    if (mergedRepaintRects[i].isZero()) {\n                        mergedRepaintRects.splice(i, 1);\n                        continue;\n                    }\n                    for (var j = i + 1; j < mergedRepaintRects.length;) {\n                        if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {\n                            hasIntersections = true;\n                            mergedRepaintRects[i].union(mergedRepaintRects[j]);\n                            mergedRepaintRects.splice(j, 1);\n                        }\n                        else {\n                            j++;\n                        }\n                    }\n                    i++;\n                }\n            } while (hasIntersections);\n            this._paintRects = mergedRepaintRects;\n            return mergedRepaintRects;\n        };\n        Layer.prototype.debugGetPaintRects = function () {\n            return (this._paintRects || []).slice();\n        };\n        Layer.prototype.resize = function (width, height) {\n            var dpr = this.dpr;\n            var dom = this.dom;\n            var domStyle = dom.style;\n            var domBack = this.domBack;\n            if (domStyle) {\n                domStyle.width = width + 'px';\n                domStyle.height = height + 'px';\n            }\n            dom.width = width * dpr;\n            dom.height = height * dpr;\n            if (domBack) {\n                domBack.width = width * dpr;\n                domBack.height = height * dpr;\n                if (dpr !== 1) {\n                    this.ctxBack.scale(dpr, dpr);\n                }\n            }\n        };\n        Layer.prototype.clear = function (clearAll, clearColor, repaintRects) {\n            var dom = this.dom;\n            var ctx = this.ctx;\n            var width = dom.width;\n            var height = dom.height;\n            clearColor = clearColor || this.clearColor;\n            var haveMotionBLur = this.motionBlur && !clearAll;\n            var lastFrameAlpha = this.lastFrameAlpha;\n            var dpr = this.dpr;\n            var self = this;\n            if (haveMotionBLur) {\n                if (!this.domBack) {\n                    this.createBackBuffer();\n                }\n                this.ctxBack.globalCompositeOperation = 'copy';\n                this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n            }\n            var domBack = this.domBack;\n            function doClear(x, y, width, height) {\n                ctx.clearRect(x, y, width, height);\n                if (clearColor && clearColor !== 'transparent') {\n                    var clearColorGradientOrPattern = void 0;\n                    if (isGradientObject(clearColor)) {\n                        clearColorGradientOrPattern = clearColor.__canvasGradient\n                            || getCanvasGradient(ctx, clearColor, {\n                                x: 0,\n                                y: 0,\n                                width: width,\n                                height: height\n                            });\n                        clearColor.__canvasGradient = clearColorGradientOrPattern;\n                    }\n                    else if (isPatternObject(clearColor)) {\n                        clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {\n                            dirty: function () {\n                                self.setUnpainted();\n                                self.__painter.refresh();\n                            }\n                        });\n                    }\n                    ctx.save();\n                    ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n                    ctx.fillRect(x, y, width, height);\n                    ctx.restore();\n                }\n                if (haveMotionBLur) {\n                    ctx.save();\n                    ctx.globalAlpha = lastFrameAlpha;\n                    ctx.drawImage(domBack, x, y, width, height);\n                    ctx.restore();\n                }\n            }\n            if (!repaintRects || haveMotionBLur) {\n                doClear(0, 0, width, height);\n            }\n            else if (repaintRects.length) {\n                each(repaintRects, function (rect) {\n                    doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);\n                });\n            }\n        };\n        return Layer;\n    }(Eventful));\n\n    var HOVER_LAYER_ZLEVEL = 1e5;\n    var CANVAS_ZLEVEL = 314159;\n    var EL_AFTER_INCREMENTAL_INC = 0.01;\n    var INCREMENTAL_INC = 0.001;\n    function parseInt10$1(val) {\n        return parseInt(val, 10);\n    }\n    function isLayerValid(layer) {\n        if (!layer) {\n            return false;\n        }\n        if (layer.__builtin__) {\n            return true;\n        }\n        if (typeof (layer.resize) !== 'function'\n            || typeof (layer.refresh) !== 'function') {\n            return false;\n        }\n        return true;\n    }\n    function createRoot(width, height) {\n        var domRoot = document.createElement('div');\n        domRoot.style.cssText = [\n            'position:relative',\n            'width:' + width + 'px',\n            'height:' + height + 'px',\n            'padding:0',\n            'margin:0',\n            'border-width:0'\n        ].join(';') + ';';\n        return domRoot;\n    }\n    var CanvasPainter = (function () {\n        function CanvasPainter(root, storage, opts, id) {\n            this.type = 'canvas';\n            this._zlevelList = [];\n            this._prevDisplayList = [];\n            this._layers = {};\n            this._layerConfig = {};\n            this._needsManuallyCompositing = false;\n            this.type = 'canvas';\n            var singleCanvas = !root.nodeName\n                || root.nodeName.toUpperCase() === 'CANVAS';\n            this._opts = opts = extend({}, opts || {});\n            this.dpr = opts.devicePixelRatio || devicePixelRatio;\n            this._singleCanvas = singleCanvas;\n            this.root = root;\n            var rootStyle = root.style;\n            if (rootStyle) {\n                rootStyle.webkitTapHighlightColor = 'transparent';\n                rootStyle.webkitUserSelect = 'none';\n                rootStyle.userSelect = 'none';\n                rootStyle['-webkit-touch-callout'] = 'none';\n                root.innerHTML = '';\n            }\n            this.storage = storage;\n            var zlevelList = this._zlevelList;\n            this._prevDisplayList = [];\n            var layers = this._layers;\n            if (!singleCanvas) {\n                this._width = this._getSize(0);\n                this._height = this._getSize(1);\n                var domRoot = this._domRoot = createRoot(this._width, this._height);\n                root.appendChild(domRoot);\n            }\n            else {\n                var rootCanvas = root;\n                var width = rootCanvas.width;\n                var height = rootCanvas.height;\n                if (opts.width != null) {\n                    width = opts.width;\n                }\n                if (opts.height != null) {\n                    height = opts.height;\n                }\n                this.dpr = opts.devicePixelRatio || 1;\n                rootCanvas.width = width * this.dpr;\n                rootCanvas.height = height * this.dpr;\n                this._width = width;\n                this._height = height;\n                var mainLayer = new Layer(rootCanvas, this, this.dpr);\n                mainLayer.__builtin__ = true;\n                mainLayer.initContext();\n                layers[CANVAS_ZLEVEL] = mainLayer;\n                mainLayer.zlevel = CANVAS_ZLEVEL;\n                zlevelList.push(CANVAS_ZLEVEL);\n                this._domRoot = root;\n            }\n        }\n        CanvasPainter.prototype.getType = function () {\n            return 'canvas';\n        };\n        CanvasPainter.prototype.isSingleCanvas = function () {\n            return this._singleCanvas;\n        };\n        CanvasPainter.prototype.getViewportRoot = function () {\n            return this._domRoot;\n        };\n        CanvasPainter.prototype.getViewportRootOffset = function () {\n            var viewportRoot = this.getViewportRoot();\n            if (viewportRoot) {\n                return {\n                    offsetLeft: viewportRoot.offsetLeft || 0,\n                    offsetTop: viewportRoot.offsetTop || 0\n                };\n            }\n        };\n        CanvasPainter.prototype.refresh = function (paintAll) {\n            var list = this.storage.getDisplayList(true);\n            var prevList = this._prevDisplayList;\n            var zlevelList = this._zlevelList;\n            this._redrawId = Math.random();\n            this._paintList(list, prevList, paintAll, this._redrawId);\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__ && layer.refresh) {\n                    var clearColor = i === 0 ? this._backgroundColor : null;\n                    layer.refresh(clearColor);\n                }\n            }\n            if (this._opts.useDirtyRect) {\n                this._prevDisplayList = list.slice();\n            }\n            return this;\n        };\n        CanvasPainter.prototype.refreshHover = function () {\n            this._paintHoverList(this.storage.getDisplayList(false));\n        };\n        CanvasPainter.prototype._paintHoverList = function (list) {\n            var len = list.length;\n            var hoverLayer = this._hoverlayer;\n            hoverLayer && hoverLayer.clear();\n            if (!len) {\n                return;\n            }\n            var scope = {\n                inHover: true,\n                viewWidth: this._width,\n                viewHeight: this._height\n            };\n            var ctx;\n            for (var i = 0; i < len; i++) {\n                var el = list[i];\n                if (el.__inHover) {\n                    if (!hoverLayer) {\n                        hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n                    }\n                    if (!ctx) {\n                        ctx = hoverLayer.ctx;\n                        ctx.save();\n                    }\n                    brush(ctx, el, scope, i === len - 1);\n                }\n            }\n            if (ctx) {\n                ctx.restore();\n            }\n        };\n        CanvasPainter.prototype.getHoverLayer = function () {\n            return this.getLayer(HOVER_LAYER_ZLEVEL);\n        };\n        CanvasPainter.prototype.paintOne = function (ctx, el) {\n            brushSingle(ctx, el);\n        };\n        CanvasPainter.prototype._paintList = function (list, prevList, paintAll, redrawId) {\n            if (this._redrawId !== redrawId) {\n                return;\n            }\n            paintAll = paintAll || false;\n            this._updateLayerStatus(list);\n            var _a = this._doPaintList(list, prevList, paintAll), finished = _a.finished, needsRefreshHover = _a.needsRefreshHover;\n            if (this._needsManuallyCompositing) {\n                this._compositeManually();\n            }\n            if (needsRefreshHover) {\n                this._paintHoverList(list);\n            }\n            if (!finished) {\n                var self_1 = this;\n                requestAnimationFrame$1(function () {\n                    self_1._paintList(list, prevList, paintAll, redrawId);\n                });\n            }\n            else {\n                this.eachLayer(function (layer) {\n                    layer.afterBrush && layer.afterBrush();\n                });\n            }\n        };\n        CanvasPainter.prototype._compositeManually = function () {\n            var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n            var width = this._domRoot.width;\n            var height = this._domRoot.height;\n            ctx.clearRect(0, 0, width, height);\n            this.eachBuiltinLayer(function (layer) {\n                if (layer.virtual) {\n                    ctx.drawImage(layer.dom, 0, 0, width, height);\n                }\n            });\n        };\n        CanvasPainter.prototype._doPaintList = function (list, prevList, paintAll) {\n            var _this = this;\n            var layerList = [];\n            var useDirtyRect = this._opts.useDirtyRect;\n            for (var zi = 0; zi < this._zlevelList.length; zi++) {\n                var zlevel = this._zlevelList[zi];\n                var layer = this._layers[zlevel];\n                if (layer.__builtin__\n                    && layer !== this._hoverlayer\n                    && (layer.__dirty || paintAll)) {\n                    layerList.push(layer);\n                }\n            }\n            var finished = true;\n            var needsRefreshHover = false;\n            var _loop_1 = function (k) {\n                var layer = layerList[k];\n                var ctx = layer.ctx;\n                var repaintRects = useDirtyRect\n                    && layer.createRepaintRects(list, prevList, this_1._width, this_1._height);\n                ctx.save();\n                var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n                var useTimer = !paintAll && layer.incremental && Date.now;\n                var startTime = useTimer && Date.now();\n                var clearColor = layer.zlevel === this_1._zlevelList[0]\n                    ? this_1._backgroundColor : null;\n                if (layer.__startIndex === layer.__endIndex) {\n                    layer.clear(false, clearColor, repaintRects);\n                }\n                else if (start === layer.__startIndex) {\n                    var firstEl = list[start];\n                    if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n                        layer.clear(false, clearColor, repaintRects);\n                    }\n                }\n                if (start === -1) {\n                    console.error('For some unknown reason. drawIndex is -1');\n                    start = layer.__startIndex;\n                }\n                var i;\n                var repaint = function (repaintRect) {\n                    var scope = {\n                        inHover: false,\n                        allClipped: false,\n                        prevEl: null,\n                        viewWidth: _this._width,\n                        viewHeight: _this._height\n                    };\n                    for (i = start; i < layer.__endIndex; i++) {\n                        var el = list[i];\n                        if (el.__inHover) {\n                            needsRefreshHover = true;\n                        }\n                        _this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);\n                        if (useTimer) {\n                            var dTime = Date.now() - startTime;\n                            if (dTime > 15) {\n                                break;\n                            }\n                        }\n                    }\n                    if (scope.prevElClipPaths) {\n                        ctx.restore();\n                    }\n                };\n                if (repaintRects) {\n                    if (repaintRects.length === 0) {\n                        i = layer.__endIndex;\n                    }\n                    else {\n                        var dpr = this_1.dpr;\n                        for (var r = 0; r < repaintRects.length; ++r) {\n                            var rect = repaintRects[r];\n                            ctx.save();\n                            ctx.beginPath();\n                            ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);\n                            ctx.clip();\n                            repaint(rect);\n                            ctx.restore();\n                        }\n                    }\n                }\n                else {\n                    ctx.save();\n                    repaint();\n                    ctx.restore();\n                }\n                layer.__drawIndex = i;\n                if (layer.__drawIndex < layer.__endIndex) {\n                    finished = false;\n                }\n            };\n            var this_1 = this;\n            for (var k = 0; k < layerList.length; k++) {\n                _loop_1(k);\n            }\n            if (env.wxa) {\n                each(this._layers, function (layer) {\n                    if (layer && layer.ctx && layer.ctx.draw) {\n                        layer.ctx.draw();\n                    }\n                });\n            }\n            return {\n                finished: finished,\n                needsRefreshHover: needsRefreshHover\n            };\n        };\n        CanvasPainter.prototype._doPaintEl = function (el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {\n            var ctx = currentLayer.ctx;\n            if (useDirtyRect) {\n                var paintRect = el.getPaintRect();\n                if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {\n                    brush(ctx, el, scope, isLast);\n                    el.setPrevPaintRect(paintRect);\n                }\n            }\n            else {\n                brush(ctx, el, scope, isLast);\n            }\n        };\n        CanvasPainter.prototype.getLayer = function (zlevel, virtual) {\n            if (this._singleCanvas && !this._needsManuallyCompositing) {\n                zlevel = CANVAS_ZLEVEL;\n            }\n            var layer = this._layers[zlevel];\n            if (!layer) {\n                layer = new Layer('zr_' + zlevel, this, this.dpr);\n                layer.zlevel = zlevel;\n                layer.__builtin__ = true;\n                if (this._layerConfig[zlevel]) {\n                    merge(layer, this._layerConfig[zlevel], true);\n                }\n                else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n                    merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n                }\n                if (virtual) {\n                    layer.virtual = virtual;\n                }\n                this.insertLayer(zlevel, layer);\n                layer.initContext();\n            }\n            return layer;\n        };\n        CanvasPainter.prototype.insertLayer = function (zlevel, layer) {\n            var layersMap = this._layers;\n            var zlevelList = this._zlevelList;\n            var len = zlevelList.length;\n            var domRoot = this._domRoot;\n            var prevLayer = null;\n            var i = -1;\n            if (layersMap[zlevel]) {\n                logError('ZLevel ' + zlevel + ' has been used already');\n                return;\n            }\n            if (!isLayerValid(layer)) {\n                logError('Layer of zlevel ' + zlevel + ' is not valid');\n                return;\n            }\n            if (len > 0 && zlevel > zlevelList[0]) {\n                for (i = 0; i < len - 1; i++) {\n                    if (zlevelList[i] < zlevel\n                        && zlevelList[i + 1] > zlevel) {\n                        break;\n                    }\n                }\n                prevLayer = layersMap[zlevelList[i]];\n            }\n            zlevelList.splice(i + 1, 0, zlevel);\n            layersMap[zlevel] = layer;\n            if (!layer.virtual) {\n                if (prevLayer) {\n                    var prevDom = prevLayer.dom;\n                    if (prevDom.nextSibling) {\n                        domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n                else {\n                    if (domRoot.firstChild) {\n                        domRoot.insertBefore(layer.dom, domRoot.firstChild);\n                    }\n                    else {\n                        domRoot.appendChild(layer.dom);\n                    }\n                }\n            }\n            layer.__painter = this;\n        };\n        CanvasPainter.prototype.eachLayer = function (cb, context) {\n            var zlevelList = this._zlevelList;\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                cb.call(context, this._layers[z], z);\n            }\n        };\n        CanvasPainter.prototype.eachBuiltinLayer = function (cb, context) {\n            var zlevelList = this._zlevelList;\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        };\n        CanvasPainter.prototype.eachOtherLayer = function (cb, context) {\n            var zlevelList = this._zlevelList;\n            for (var i = 0; i < zlevelList.length; i++) {\n                var z = zlevelList[i];\n                var layer = this._layers[z];\n                if (!layer.__builtin__) {\n                    cb.call(context, layer, z);\n                }\n            }\n        };\n        CanvasPainter.prototype.getLayers = function () {\n            return this._layers;\n        };\n        CanvasPainter.prototype._updateLayerStatus = function (list) {\n            this.eachBuiltinLayer(function (layer, z) {\n                layer.__dirty = layer.__used = false;\n            });\n            function updatePrevLayer(idx) {\n                if (prevLayer) {\n                    if (prevLayer.__endIndex !== idx) {\n                        prevLayer.__dirty = true;\n                    }\n                    prevLayer.__endIndex = idx;\n                }\n            }\n            if (this._singleCanvas) {\n                for (var i_1 = 1; i_1 < list.length; i_1++) {\n                    var el = list[i_1];\n                    if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {\n                        this._needsManuallyCompositing = true;\n                        break;\n                    }\n                }\n            }\n            var prevLayer = null;\n            var incrementalLayerCount = 0;\n            var prevZlevel;\n            var i;\n            for (i = 0; i < list.length; i++) {\n                var el = list[i];\n                var zlevel = el.zlevel;\n                var layer = void 0;\n                if (prevZlevel !== zlevel) {\n                    prevZlevel = zlevel;\n                    incrementalLayerCount = 0;\n                }\n                if (el.incremental) {\n                    layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n                    layer.incremental = true;\n                    incrementalLayerCount = 1;\n                }\n                else {\n                    layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n                }\n                if (!layer.__builtin__) {\n                    logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n                }\n                if (layer !== prevLayer) {\n                    layer.__used = true;\n                    if (layer.__startIndex !== i) {\n                        layer.__dirty = true;\n                    }\n                    layer.__startIndex = i;\n                    if (!layer.incremental) {\n                        layer.__drawIndex = i;\n                    }\n                    else {\n                        layer.__drawIndex = -1;\n                    }\n                    updatePrevLayer(i);\n                    prevLayer = layer;\n                }\n                if ((el.__dirty & Element.REDARAW_BIT) && !el.__inHover) {\n                    layer.__dirty = true;\n                    if (layer.incremental && layer.__drawIndex < 0) {\n                        layer.__drawIndex = i;\n                    }\n                }\n            }\n            updatePrevLayer(i);\n            this.eachBuiltinLayer(function (layer, z) {\n                if (!layer.__used && layer.getElementCount() > 0) {\n                    layer.__dirty = true;\n                    layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n                }\n                if (layer.__dirty && layer.__drawIndex < 0) {\n                    layer.__drawIndex = layer.__startIndex;\n                }\n            });\n        };\n        CanvasPainter.prototype.clear = function () {\n            this.eachBuiltinLayer(this._clearLayer);\n            return this;\n        };\n        CanvasPainter.prototype._clearLayer = function (layer) {\n            layer.clear();\n        };\n        CanvasPainter.prototype.setBackgroundColor = function (backgroundColor) {\n            this._backgroundColor = backgroundColor;\n            each(this._layers, function (layer) {\n                layer.setUnpainted();\n            });\n        };\n        CanvasPainter.prototype.configLayer = function (zlevel, config) {\n            if (config) {\n                var layerConfig = this._layerConfig;\n                if (!layerConfig[zlevel]) {\n                    layerConfig[zlevel] = config;\n                }\n                else {\n                    merge(layerConfig[zlevel], config, true);\n                }\n                for (var i = 0; i < this._zlevelList.length; i++) {\n                    var _zlevel = this._zlevelList[i];\n                    if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n                        var layer = this._layers[_zlevel];\n                        merge(layer, layerConfig[zlevel], true);\n                    }\n                }\n            }\n        };\n        CanvasPainter.prototype.delLayer = function (zlevel) {\n            var layers = this._layers;\n            var zlevelList = this._zlevelList;\n            var layer = layers[zlevel];\n            if (!layer) {\n                return;\n            }\n            layer.dom.parentNode.removeChild(layer.dom);\n            delete layers[zlevel];\n            zlevelList.splice(indexOf(zlevelList, zlevel), 1);\n        };\n        CanvasPainter.prototype.resize = function (width, height) {\n            if (!this._domRoot.style) {\n                if (width == null || height == null) {\n                    return;\n                }\n                this._width = width;\n                this._height = height;\n                this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n            }\n            else {\n                var domRoot = this._domRoot;\n                domRoot.style.display = 'none';\n                var opts = this._opts;\n                width != null && (opts.width = width);\n                height != null && (opts.height = height);\n                width = this._getSize(0);\n                height = this._getSize(1);\n                domRoot.style.display = '';\n                if (this._width !== width || height !== this._height) {\n                    domRoot.style.width = width + 'px';\n                    domRoot.style.height = height + 'px';\n                    for (var id in this._layers) {\n                        if (this._layers.hasOwnProperty(id)) {\n                            this._layers[id].resize(width, height);\n                        }\n                    }\n                    this.refresh(true);\n                }\n                this._width = width;\n                this._height = height;\n            }\n            return this;\n        };\n        CanvasPainter.prototype.clearLayer = function (zlevel) {\n            var layer = this._layers[zlevel];\n            if (layer) {\n                layer.clear();\n            }\n        };\n        CanvasPainter.prototype.dispose = function () {\n            this.root.innerHTML = '';\n            this.root =\n                this.storage =\n                    this._domRoot =\n                        this._layers = null;\n        };\n        CanvasPainter.prototype.getRenderedCanvas = function (opts) {\n            opts = opts || {};\n            if (this._singleCanvas && !this._compositeManually) {\n                return this._layers[CANVAS_ZLEVEL].dom;\n            }\n            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n            var ctx = imageLayer.ctx;\n            imageLayer.initContext();\n            imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n            if (opts.pixelRatio <= this.dpr) {\n                this.refresh();\n                var width_1 = imageLayer.dom.width;\n                var height_1 = imageLayer.dom.height;\n                var ctx_1 = imageLayer.ctx;\n                this.eachLayer(function (layer) {\n                    if (layer.__builtin__) {\n                        ctx_1.drawImage(layer.dom, 0, 0, width_1, height_1);\n                    }\n                    else if (layer.renderToCanvas) {\n                        imageLayer.ctx.save();\n                        layer.renderToCanvas(imageLayer.ctx);\n                        imageLayer.ctx.restore();\n                    }\n                });\n            }\n            else {\n                var scope = {\n                    inHover: false,\n                    viewWidth: this._width,\n                    viewHeight: this._height\n                };\n                var displayList = this.storage.getDisplayList(true);\n                for (var i = 0, len = displayList.length; i < len; i++) {\n                    var el = displayList[i];\n                    brush(ctx, el, scope, i === len - 1);\n                }\n            }\n            return imageLayer.dom;\n        };\n        CanvasPainter.prototype.getWidth = function () {\n            return this._width;\n        };\n        CanvasPainter.prototype.getHeight = function () {\n            return this._height;\n        };\n        CanvasPainter.prototype._getSize = function (whIdx) {\n            var opts = this._opts;\n            var wh = ['width', 'height'][whIdx];\n            var cwh = ['clientWidth', 'clientHeight'][whIdx];\n            var plt = ['paddingLeft', 'paddingTop'][whIdx];\n            var prb = ['paddingRight', 'paddingBottom'][whIdx];\n            if (opts[wh] != null && opts[wh] !== 'auto') {\n                return parseFloat(opts[wh]);\n            }\n            var root = this.root;\n            var stl = document.defaultView.getComputedStyle(root);\n            return ((root[cwh] || parseInt10$1(stl[wh]) || parseInt10$1(root.style[wh]))\n                - (parseInt10$1(stl[plt]) || 0)\n                - (parseInt10$1(stl[prb]) || 0)) | 0;\n        };\n        CanvasPainter.prototype.pathToImage = function (path, dpr) {\n            dpr = dpr || this.dpr;\n            var canvas = document.createElement('canvas');\n            var ctx = canvas.getContext('2d');\n            var rect = path.getBoundingRect();\n            var style = path.style;\n            var shadowBlurSize = style.shadowBlur * dpr;\n            var shadowOffsetX = style.shadowOffsetX * dpr;\n            var shadowOffsetY = style.shadowOffsetY * dpr;\n            var lineWidth = path.hasStroke() ? style.lineWidth : 0;\n            var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n            var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n            var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n            var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n            var width = rect.width + leftMargin + rightMargin;\n            var height = rect.height + topMargin + bottomMargin;\n            canvas.width = width * dpr;\n            canvas.height = height * dpr;\n            ctx.scale(dpr, dpr);\n            ctx.clearRect(0, 0, width, height);\n            ctx.dpr = dpr;\n            var pathTransform = {\n                x: path.x,\n                y: path.y,\n                scaleX: path.scaleX,\n                scaleY: path.scaleY,\n                rotation: path.rotation,\n                originX: path.originX,\n                originY: path.originY\n            };\n            path.x = leftMargin - rect.x;\n            path.y = topMargin - rect.y;\n            path.rotation = 0;\n            path.scaleX = 1;\n            path.scaleY = 1;\n            path.updateTransform();\n            if (path) {\n                brush(ctx, path, {\n                    inHover: false,\n                    viewWidth: this._width,\n                    viewHeight: this._height\n                }, true);\n            }\n            var imgShape = new ZRImage({\n                style: {\n                    x: 0,\n                    y: 0,\n                    image: canvas\n                }\n            });\n            extend(path, pathTransform);\n            return imgShape;\n        };\n        return CanvasPainter;\n    }());\n\n    function install$1(registers) {\n      registers.registerPainter('canvas', CanvasPainter);\n    }\n\n    var LineSeriesModel = function (_super) {\n      __extends(LineSeriesModel, _super);\n\n      function LineSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = LineSeriesModel.type;\n        _this.hasSymbolVisual = true;\n        _this.legendSymbol = 'line';\n        return _this;\n      }\n\n      LineSeriesModel.prototype.getInitialData = function (option) {\n        if (\"development\" !== 'production') {\n          var coordSys = option.coordinateSystem;\n\n          if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n            throw new Error('Line not support coordinateSystem besides cartesian and polar');\n          }\n        }\n\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: true\n        });\n      };\n\n      LineSeriesModel.type = 'series.line';\n      LineSeriesModel.dependencies = ['grid', 'polar'];\n      LineSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 3,\n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        clip: true,\n        label: {\n          position: 'top'\n        },\n        endLabel: {\n          show: false,\n          valueAnimation: true,\n          distance: 8\n        },\n        lineStyle: {\n          width: 2,\n          type: 'solid'\n        },\n        emphasis: {\n          scale: true,\n          lineStyle: {\n            width: 'bolder'\n          }\n        },\n        step: false,\n        smooth: false,\n        smoothMonotone: null,\n        symbol: 'emptyCircle',\n        symbolSize: 4,\n        symbolRotate: null,\n        showSymbol: true,\n        showAllSymbol: 'auto',\n        connectNulls: false,\n        sampling: 'none',\n        animationEasing: 'linear',\n        progressive: 0,\n        hoverLayerThreshold: Infinity\n      };\n      return LineSeriesModel;\n    }(SeriesModel);\n\n    function getDefaultLabel(data, dataIndex) {\n      var labelDims = data.mapDimensionsAll('defaultedLabel');\n      var len = labelDims.length;\n\n      if (len === 1) {\n        var rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);\n        return rawVal != null ? rawVal + '' : null;\n      } else if (len) {\n        var vals = [];\n\n        for (var i = 0; i < labelDims.length; i++) {\n          vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));\n        }\n\n        return vals.join(' ');\n      }\n    }\n    function getDefaultInterpolatedLabel(data, interpolatedValue) {\n      var labelDims = data.mapDimensionsAll('defaultedLabel');\n\n      if (!isArray(interpolatedValue)) {\n        return interpolatedValue + '';\n      }\n\n      var vals = [];\n\n      for (var i = 0; i < labelDims.length; i++) {\n        var dimInfo = data.getDimensionInfo(labelDims[i]);\n\n        if (dimInfo) {\n          vals.push(interpolatedValue[dimInfo.index]);\n        }\n      }\n\n      return vals.join(' ');\n    }\n\n    var Symbol = function (_super) {\n      __extends(Symbol, _super);\n\n      function Symbol(data, idx, seriesScope, opts) {\n        var _this = _super.call(this) || this;\n\n        _this.updateData(data, idx, seriesScope, opts);\n\n        return _this;\n      }\n\n      Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n        this.removeAll();\n        var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);\n        symbolPath.attr({\n          z2: 100,\n          culling: true,\n          scaleX: symbolSize[0] / 2,\n          scaleY: symbolSize[1] / 2\n        });\n        symbolPath.drift = driftSymbol;\n        this._symbolType = symbolType;\n        this.add(symbolPath);\n      };\n\n      Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(null, toLastFrame);\n      };\n\n      Symbol.prototype.getSymbolPath = function () {\n        return this.childAt(0);\n      };\n\n      Symbol.prototype.highlight = function () {\n        enterEmphasis(this.childAt(0));\n      };\n\n      Symbol.prototype.downplay = function () {\n        leaveEmphasis(this.childAt(0));\n      };\n\n      Symbol.prototype.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n      };\n\n      Symbol.prototype.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;\n      };\n\n      Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {\n        this.silent = false;\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = Symbol.getSymbolSize(data, idx);\n        var isInit = symbolType !== this._symbolType;\n        var disableAnimation = opts && opts.disableAnimation;\n\n        if (isInit) {\n          var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n          this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n        } else {\n          var symbolPath = this.childAt(0);\n          symbolPath.silent = false;\n          var target = {\n            scaleX: symbolSize[0] / 2,\n            scaleY: symbolSize[1] / 2\n          };\n          disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);\n        }\n\n        this._updateCommon(data, idx, symbolSize, seriesScope, opts);\n\n        if (isInit) {\n          var symbolPath = this.childAt(0);\n\n          if (!disableAnimation) {\n            var target = {\n              scaleX: this._sizeX,\n              scaleY: this._sizeY,\n              style: {\n                opacity: symbolPath.style.opacity\n              }\n            };\n            symbolPath.scaleX = symbolPath.scaleY = 0;\n            symbolPath.style.opacity = 0;\n            initProps(symbolPath, target, seriesModel, idx);\n          }\n        }\n\n        if (disableAnimation) {\n          this.childAt(0).stopAnimation('remove');\n        }\n\n        this._seriesModel = seriesModel;\n      };\n\n      Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var emphasisItemStyle;\n        var blurItemStyle;\n        var selectItemStyle;\n        var focus;\n        var blurScope;\n        var symbolOffset;\n        var labelStatesModels;\n        var hoverScale;\n        var cursorStyle;\n\n        if (seriesScope) {\n          emphasisItemStyle = seriesScope.emphasisItemStyle;\n          blurItemStyle = seriesScope.blurItemStyle;\n          selectItemStyle = seriesScope.selectItemStyle;\n          focus = seriesScope.focus;\n          blurScope = seriesScope.blurScope;\n          symbolOffset = seriesScope.symbolOffset;\n          labelStatesModels = seriesScope.labelStatesModels;\n          hoverScale = seriesScope.hoverScale;\n          cursorStyle = seriesScope.cursorStyle;\n        }\n\n        if (!seriesScope || data.hasItemOption) {\n          var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);\n          var emphasisModel = itemModel.getModel('emphasis');\n          emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n          selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n          blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n          focus = emphasisModel.get('focus');\n          blurScope = emphasisModel.get('blurScope');\n          symbolOffset = itemModel.getShallow('symbolOffset');\n          labelStatesModels = getLabelStatesModels(itemModel);\n          hoverScale = emphasisModel.getShallow('scale');\n          cursorStyle = itemModel.getShallow('cursor');\n        }\n\n        var symbolRotate = data.getItemVisual(idx, 'symbolRotate');\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n          symbolPath.x = parsePercent$1(symbolOffset[0], symbolSize[0]);\n          symbolPath.y = parsePercent$1(symbolOffset[1], symbolSize[1]);\n        }\n\n        cursorStyle && symbolPath.attr('cursor', cursorStyle);\n        var symbolStyle = data.getItemVisual(idx, 'style');\n        var visualColor = symbolStyle.fill;\n\n        if (symbolPath instanceof ZRImage) {\n          var pathStyle = symbolPath.style;\n          symbolPath.useStyle(extend({\n            image: pathStyle.image,\n            x: pathStyle.x,\n            y: pathStyle.y,\n            width: pathStyle.width,\n            height: pathStyle.height\n          }, symbolStyle));\n        } else {\n          if (symbolPath.__isEmptyBrush) {\n            symbolPath.useStyle(extend({}, symbolStyle));\n          } else {\n            symbolPath.useStyle(symbolStyle);\n          }\n\n          symbolPath.style.decal = null;\n          symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);\n          symbolPath.style.strokeNoScale = true;\n        }\n\n        var liftZ = data.getItemVisual(idx, 'liftZ');\n        var z2Origin = this._z2;\n\n        if (liftZ != null) {\n          if (z2Origin == null) {\n            this._z2 = symbolPath.z2;\n            symbolPath.z2 += liftZ;\n          }\n        } else if (z2Origin != null) {\n          symbolPath.z2 = z2Origin;\n          this._z2 = null;\n        }\n\n        var useNameLabel = opts && opts.useNameLabel;\n        setLabelStyle(symbolPath, labelStatesModels, {\n          labelFetcher: seriesModel,\n          labelDataIndex: idx,\n          defaultText: getLabelDefaultText,\n          inheritColor: visualColor,\n          defaultOpacity: symbolStyle.opacity\n        });\n\n        function getLabelDefaultText(idx) {\n          return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n        }\n\n        this._sizeX = symbolSize[0] / 2;\n        this._sizeY = symbolSize[1] / 2;\n        var emphasisState = symbolPath.ensureState('emphasis');\n        emphasisState.style = emphasisItemStyle;\n        symbolPath.ensureState('select').style = selectItemStyle;\n        symbolPath.ensureState('blur').style = blurItemStyle;\n\n        if (hoverScale) {\n          var scaleRatio = Math.max(1.1, 3 / this._sizeY);\n          emphasisState.scaleX = this._sizeX * scaleRatio;\n          emphasisState.scaleY = this._sizeY * scaleRatio;\n        }\n\n        this.setSymbolScale(1);\n        enableHoverEmphasis(this, focus, blurScope);\n      };\n\n      Symbol.prototype.setSymbolScale = function (scale) {\n        this.scaleX = this.scaleY = scale;\n      };\n\n      Symbol.prototype.fadeOut = function (cb, opt) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = this._seriesModel;\n        var dataIndex = getECData(this).dataIndex;\n        var animationOpt = opt && opt.animation;\n        this.silent = symbolPath.silent = true;\n\n        if (opt && opt.fadeLabel) {\n          var textContent = symbolPath.getTextContent();\n\n          if (textContent) {\n            removeElement(textContent, {\n              style: {\n                opacity: 0\n              }\n            }, seriesModel, {\n              dataIndex: dataIndex,\n              removeOpt: animationOpt,\n              cb: function () {\n                symbolPath.removeTextContent();\n              }\n            });\n          }\n        } else {\n          symbolPath.removeTextContent();\n        }\n\n        removeElement(symbolPath, {\n          style: {\n            opacity: 0\n          },\n          scaleX: 0,\n          scaleY: 0\n        }, seriesModel, {\n          dataIndex: dataIndex,\n          cb: cb,\n          removeOpt: animationOpt\n        });\n      };\n\n      Symbol.getSymbolSize = function (data, idx) {\n        var symbolSize = data.getItemVisual(idx, 'symbolSize');\n        return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n      };\n\n      return Symbol;\n    }(Group);\n\n    function driftSymbol(dx, dy) {\n      this.parent.drift(dx, dy);\n    }\n\n    function symbolNeedsDraw(data, point, idx, opt) {\n      return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n\n    function normalizeUpdateOpt(opt) {\n      if (opt != null && !isObject(opt)) {\n        opt = {\n          isIgnore: opt\n        };\n      }\n\n      return opt || {};\n    }\n\n    function makeSeriesScope(data) {\n      var seriesModel = data.hostModel;\n      var emphasisModel = seriesModel.getModel('emphasis');\n      return {\n        emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),\n        blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),\n        selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),\n        focus: emphasisModel.get('focus'),\n        blurScope: emphasisModel.get('blurScope'),\n        symbolRotate: seriesModel.get('symbolRotate'),\n        symbolOffset: seriesModel.get('symbolOffset'),\n        hoverScale: emphasisModel.get('scale'),\n        labelStatesModels: getLabelStatesModels(seriesModel),\n        cursorStyle: seriesModel.get('cursor')\n      };\n    }\n\n    var SymbolDraw = function () {\n      function SymbolDraw(SymbolCtor) {\n        this.group = new Group();\n        this._SymbolCtor = SymbolCtor || Symbol;\n      }\n\n      SymbolDraw.prototype.updateData = function (data, opt) {\n        opt = normalizeUpdateOpt(opt);\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n        var SymbolCtor = this._SymbolCtor;\n        var disableAnimation = opt.disableAnimation;\n        var seriesScope = makeSeriesScope(data);\n        var symbolUpdateOpt = {\n          disableAnimation: disableAnimation\n        };\n\n        var getSymbolPoint = opt.getSymbolPoint || function (idx) {\n          return data.getItemLayout(idx);\n        };\n\n        if (!oldData) {\n          group.removeAll();\n        }\n\n        data.diff(oldData).add(function (newIdx) {\n          var point = getSymbolPoint(newIdx);\n\n          if (symbolNeedsDraw(data, point, newIdx, opt)) {\n            var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);\n            symbolEl.setPosition(point);\n            data.setItemGraphicEl(newIdx, symbolEl);\n            group.add(symbolEl);\n          }\n        }).update(function (newIdx, oldIdx) {\n          var symbolEl = oldData.getItemGraphicEl(oldIdx);\n          var point = getSymbolPoint(newIdx);\n\n          if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n            group.remove(symbolEl);\n            return;\n          }\n\n          if (!symbolEl) {\n            symbolEl = new SymbolCtor(data, newIdx);\n            symbolEl.setPosition(point);\n          } else {\n            symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);\n            var target = {\n              x: point[0],\n              y: point[1]\n            };\n            disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);\n          }\n\n          group.add(symbolEl);\n          data.setItemGraphicEl(newIdx, symbolEl);\n        }).remove(function (oldIdx) {\n          var el = oldData.getItemGraphicEl(oldIdx);\n          el && el.fadeOut(function () {\n            group.remove(el);\n          });\n        }).execute();\n        this._getSymbolPoint = getSymbolPoint;\n        this._data = data;\n      };\n\n      SymbolDraw.prototype.isPersistent = function () {\n        return true;\n      };\n\n      SymbolDraw.prototype.updateLayout = function () {\n        var _this = this;\n\n        var data = this._data;\n\n        if (data) {\n          data.eachItemGraphicEl(function (el, idx) {\n            var point = _this._getSymbolPoint(idx);\n\n            el.setPosition(point);\n            el.markRedraw();\n          });\n        }\n      };\n\n      SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n        this._seriesScope = makeSeriesScope(data);\n        this._data = null;\n        this.group.removeAll();\n      };\n\n      SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n        opt = normalizeUpdateOpt(opt);\n\n        function updateIncrementalAndHover(el) {\n          if (!el.isGroup) {\n            el.incremental = true;\n            el.ensureState('emphasis').hoverLayer = true;\n          }\n        }\n\n        for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n          var point = data.getItemLayout(idx);\n\n          if (symbolNeedsDraw(data, point, idx, opt)) {\n            var el = new this._SymbolCtor(data, idx, this._seriesScope);\n            el.traverse(updateIncrementalAndHover);\n            el.setPosition(point);\n            this.group.add(el);\n            data.setItemGraphicEl(idx, el);\n          }\n        }\n      };\n\n      SymbolDraw.prototype.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n\n        if (data && enableAnimation) {\n          data.eachItemGraphicEl(function (el) {\n            el.fadeOut(function () {\n              group.remove(el);\n            });\n          });\n        } else {\n          group.removeAll();\n        }\n      };\n      return SymbolDraw;\n    }();\n\n    function prepareDataCoordInfo(coordSys, data, valueOrigin) {\n      var baseAxis = coordSys.getBaseAxis();\n      var valueAxis = coordSys.getOtherAxis(baseAxis);\n      var valueStart = getValueStart(valueAxis, valueOrigin);\n      var baseAxisDim = baseAxis.dim;\n      var valueAxisDim = valueAxis.dim;\n      var valueDim = data.mapDimension(valueAxisDim);\n      var baseDim = data.mapDimension(baseAxisDim);\n      var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n      var dims = map(coordSys.dimensions, function (coordDim) {\n        return data.mapDimension(coordDim);\n      });\n      var stacked = false;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0])) {\n        stacked = true;\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1])) {\n        stacked = true;\n        dims[1] = stackResultDim;\n      }\n\n      return {\n        dataDimsForPoint: dims,\n        valueStart: valueStart,\n        valueAxisDim: valueAxisDim,\n        baseAxisDim: baseAxisDim,\n        stacked: !!stacked,\n        valueDim: valueDim,\n        baseDim: baseDim,\n        baseDataOffset: baseDataOffset,\n        stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n      };\n    }\n\n    function getValueStart(valueAxis, valueOrigin) {\n      var valueStart = 0;\n      var extent = valueAxis.scale.getExtent();\n\n      if (valueOrigin === 'start') {\n        valueStart = extent[0];\n      } else if (valueOrigin === 'end') {\n        valueStart = extent[1];\n      } else {\n        if (extent[0] > 0) {\n          valueStart = extent[0];\n        } else if (extent[1] < 0) {\n          valueStart = extent[1];\n        }\n      }\n\n      return valueStart;\n    }\n\n    function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n      var value = NaN;\n\n      if (dataCoordInfo.stacked) {\n        value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n      }\n\n      if (isNaN(value)) {\n        value = dataCoordInfo.valueStart;\n      }\n\n      var baseDataOffset = dataCoordInfo.baseDataOffset;\n      var stackedData = [];\n      stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n      stackedData[1 - baseDataOffset] = value;\n      return coordSys.dataToPoint(stackedData);\n    }\n\n    var supportFloat32Array = typeof Float32Array !== 'undefined';\n    var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;\n    function createFloat32Array(arg) {\n      if (isArray(arg)) {\n        return supportFloat32Array ? new Float32Array(arg) : arg;\n      }\n\n      return new Float32ArrayCtor(arg);\n    }\n\n    function diffData(oldData, newData) {\n      var diffResult = [];\n      newData.diff(oldData).add(function (idx) {\n        diffResult.push({\n          cmd: '+',\n          idx: idx\n        });\n      }).update(function (newIdx, oldIdx) {\n        diffResult.push({\n          cmd: '=',\n          idx: oldIdx,\n          idx1: newIdx\n        });\n      }).remove(function (idx) {\n        diffResult.push({\n          cmd: '-',\n          idx: idx\n        });\n      }).execute();\n      return diffResult;\n    }\n\n    function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n      var diff = diffData(oldData, newData);\n      var currPoints = [];\n      var nextPoints = [];\n      var currStackedPoints = [];\n      var nextStackedPoints = [];\n      var status = [];\n      var sortedIndices = [];\n      var rawIndices = [];\n      var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n      var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n      var oldPoints = oldData.getLayout('points') || [];\n      var newPoints = newData.getLayout('points') || [];\n\n      for (var i = 0; i < diff.length; i++) {\n        var diffItem = diff[i];\n        var pointAdded = true;\n        var oldIdx2 = void 0;\n        var newIdx2 = void 0;\n\n        switch (diffItem.cmd) {\n          case '=':\n            oldIdx2 = diffItem.idx * 2;\n            newIdx2 = diffItem.idx1 * 2;\n            var currentX = oldPoints[oldIdx2];\n            var currentY = oldPoints[oldIdx2 + 1];\n            var nextX = newPoints[newIdx2];\n            var nextY = newPoints[newIdx2 + 1];\n\n            if (isNaN(currentX) || isNaN(currentY)) {\n              currentX = nextX;\n              currentY = nextY;\n            }\n\n            currPoints.push(currentX, currentY);\n            nextPoints.push(nextX, nextY);\n            currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);\n            nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n            rawIndices.push(newData.getRawIndex(diffItem.idx1));\n            break;\n\n          case '+':\n            var newIdx = diffItem.idx;\n            var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;\n            var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);\n            newIdx2 = newIdx * 2;\n            currPoints.push(oldPt[0], oldPt[1]);\n            nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);\n            var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);\n            currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);\n            nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);\n            rawIndices.push(newData.getRawIndex(newIdx));\n            break;\n\n          case '-':\n            var oldIdx = diffItem.idx;\n            var rawIndex = oldData.getRawIndex(oldIdx);\n            var oldDataDimsForPoint = oldDataNewCoordInfo.dataDimsForPoint;\n            oldIdx2 = oldIdx * 2;\n\n            if (rawIndex !== oldIdx) {\n              var newPt = newCoordSys.dataToPoint([oldData.get(oldDataDimsForPoint[0], oldIdx), oldData.get(oldDataDimsForPoint[1], oldIdx)]);\n              var newStackedOnPt = getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, oldIdx);\n              currPoints.push(oldPoints[oldIdx2], oldPoints[oldIdx2 + 1]);\n              nextPoints.push(newPt[0], newPt[1]);\n              currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);\n              nextStackedPoints.push(newStackedOnPt[0], newStackedOnPt[1]);\n              rawIndices.push(rawIndex);\n            } else {\n              pointAdded = false;\n            }\n\n        }\n\n        if (pointAdded) {\n          status.push(diffItem);\n          sortedIndices.push(sortedIndices.length);\n        }\n      }\n\n      sortedIndices.sort(function (a, b) {\n        return rawIndices[a] - rawIndices[b];\n      });\n      var len = currPoints.length;\n      var sortedCurrPoints = createFloat32Array(len);\n      var sortedNextPoints = createFloat32Array(len);\n      var sortedCurrStackedPoints = createFloat32Array(len);\n      var sortedNextStackedPoints = createFloat32Array(len);\n      var sortedStatus = [];\n\n      for (var i = 0; i < sortedIndices.length; i++) {\n        var idx = sortedIndices[i];\n        var i2 = i * 2;\n        var idx2 = idx * 2;\n        sortedCurrPoints[i2] = currPoints[idx2];\n        sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];\n        sortedNextPoints[i2] = nextPoints[idx2];\n        sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];\n        sortedCurrStackedPoints[i2] = currStackedPoints[idx2];\n        sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];\n        sortedNextStackedPoints[i2] = nextStackedPoints[idx2];\n        sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];\n        sortedStatus[i] = status[idx];\n      }\n\n      return {\n        current: sortedCurrPoints,\n        next: sortedNextPoints,\n        stackedOnCurrent: sortedCurrStackedPoints,\n        stackedOnNext: sortedNextStackedPoints,\n        status: sortedStatus\n      };\n    }\n\n    var mathMin$5 = Math.min;\n    var mathMax$5 = Math.max;\n\n    function isPointNull(x, y) {\n      return isNaN(x) || isNaN(y);\n    }\n\n    function drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {\n      var prevX;\n      var prevY;\n      var cpx0;\n      var cpy0;\n      var cpx1;\n      var cpy1;\n      var idx = start;\n      var k = 0;\n\n      for (; k < segLen; k++) {\n        var x = points[idx * 2];\n        var y = points[idx * 2 + 1];\n\n        if (idx >= allLen || idx < 0) {\n          break;\n        }\n\n        if (isPointNull(x, y)) {\n          if (connectNulls) {\n            idx += dir;\n            continue;\n          }\n\n          break;\n        }\n\n        if (idx === start) {\n          ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);\n          cpx0 = x;\n          cpy0 = y;\n        } else {\n          var dx = x - prevX;\n          var dy = y - prevY;\n\n          if (dx * dx + dy * dy < 0.5) {\n            idx += dir;\n            continue;\n          }\n\n          if (smooth > 0) {\n            var nextIdx = idx + dir;\n            var nextX = points[nextIdx * 2];\n            var nextY = points[nextIdx * 2 + 1];\n            var tmpK = k + 1;\n\n            if (connectNulls) {\n              while (isPointNull(nextX, nextY) && tmpK < segLen) {\n                tmpK++;\n                nextIdx += dir;\n                nextX = points[nextIdx * 2];\n                nextY = points[nextIdx * 2 + 1];\n              }\n            }\n\n            var ratioNextSeg = 0.5;\n            var vx = 0;\n            var vy = 0;\n            var nextCpx0 = void 0;\n            var nextCpy0 = void 0;\n\n            if (tmpK >= segLen || isPointNull(nextX, nextY)) {\n              cpx1 = x;\n              cpy1 = y;\n            } else {\n              vx = nextX - prevX;\n              vy = nextY - prevY;\n              var dx0 = x - prevX;\n              var dx1 = nextX - x;\n              var dy0 = y - prevY;\n              var dy1 = nextY - y;\n              var lenPrevSeg = void 0;\n              var lenNextSeg = void 0;\n\n              if (smoothMonotone === 'x') {\n                lenPrevSeg = Math.abs(dx0);\n                lenNextSeg = Math.abs(dx1);\n                cpx1 = x - lenPrevSeg * smooth;\n                cpy1 = y;\n                nextCpx0 = x + lenPrevSeg * smooth;\n                nextCpy0 = y;\n              } else if (smoothMonotone === 'y') {\n                lenPrevSeg = Math.abs(dy0);\n                lenNextSeg = Math.abs(dy1);\n                cpx1 = x;\n                cpy1 = y - lenPrevSeg * smooth;\n                nextCpx0 = x;\n                nextCpy0 = y + lenPrevSeg * smooth;\n              } else {\n                lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);\n                lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n                ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n                cpx1 = x - vx * smooth * (1 - ratioNextSeg);\n                cpy1 = y - vy * smooth * (1 - ratioNextSeg);\n                nextCpx0 = x + vx * smooth * ratioNextSeg;\n                nextCpy0 = y + vy * smooth * ratioNextSeg;\n                nextCpx0 = mathMin$5(nextCpx0, mathMax$5(nextX, x));\n                nextCpy0 = mathMin$5(nextCpy0, mathMax$5(nextY, y));\n                nextCpx0 = mathMax$5(nextCpx0, mathMin$5(nextX, x));\n                nextCpy0 = mathMax$5(nextCpy0, mathMin$5(nextY, y));\n                vx = nextCpx0 - x;\n                vy = nextCpy0 - y;\n                cpx1 = x - vx * lenPrevSeg / lenNextSeg;\n                cpy1 = y - vy * lenPrevSeg / lenNextSeg;\n                cpx1 = mathMin$5(cpx1, mathMax$5(prevX, x));\n                cpy1 = mathMin$5(cpy1, mathMax$5(prevY, y));\n                cpx1 = mathMax$5(cpx1, mathMin$5(prevX, x));\n                cpy1 = mathMax$5(cpy1, mathMin$5(prevY, y));\n                vx = x - cpx1;\n                vy = y - cpy1;\n                nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;\n                nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;\n              }\n            }\n\n            ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);\n            cpx0 = nextCpx0;\n            cpy0 = nextCpy0;\n          } else {\n            ctx.lineTo(x, y);\n          }\n        }\n\n        prevX = x;\n        prevY = y;\n        idx += dir;\n      }\n\n      return k;\n    }\n\n    var ECPolylineShape = function () {\n      function ECPolylineShape() {\n        this.smooth = 0;\n        this.smoothConstraint = true;\n      }\n\n      return ECPolylineShape;\n    }();\n\n    var ECPolyline = function (_super) {\n      __extends(ECPolyline, _super);\n\n      function ECPolyline(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'ec-polyline';\n        return _this;\n      }\n\n      ECPolyline.prototype.getDefaultStyle = function () {\n        return {\n          stroke: '#000',\n          fill: null\n        };\n      };\n\n      ECPolyline.prototype.getDefaultShape = function () {\n        return new ECPolylineShape();\n      };\n\n      ECPolyline.prototype.buildPath = function (ctx, shape) {\n        var points = shape.points;\n        var i = 0;\n        var len = points.length / 2;\n\n        if (shape.connectNulls) {\n          for (; len > 0; len--) {\n            if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n              break;\n            }\n          }\n\n          for (; i < len; i++) {\n            if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n              break;\n            }\n          }\n        }\n\n        while (i < len) {\n          i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n        }\n      };\n\n      ECPolyline.prototype.getPointOn = function (xOrY, dim) {\n        if (!this.path) {\n          this.createPathProxy();\n          this.buildPath(this.path, this.shape);\n        }\n\n        var path = this.path;\n        var data = path.data;\n        var CMD = PathProxy.CMD;\n        var x0;\n        var y0;\n        var isDimX = dim === 'x';\n        var roots = [];\n\n        for (var i = 0; i < data.length;) {\n          var cmd = data[i++];\n          var x = void 0;\n          var y = void 0;\n          var x2 = void 0;\n          var y2 = void 0;\n          var x3 = void 0;\n          var y3 = void 0;\n          var t = void 0;\n\n          switch (cmd) {\n            case CMD.M:\n              x0 = data[i++];\n              y0 = data[i++];\n              break;\n\n            case CMD.L:\n              x = data[i++];\n              y = data[i++];\n              t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);\n\n              if (t <= 1 && t >= 0) {\n                var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;\n                return isDimX ? [xOrY, val] : [val, xOrY];\n              }\n\n              x0 = x;\n              y0 = y;\n              break;\n\n            case CMD.C:\n              x = data[i++];\n              y = data[i++];\n              x2 = data[i++];\n              y2 = data[i++];\n              x3 = data[i++];\n              y3 = data[i++];\n              var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots);\n\n              if (nRoot > 0) {\n                for (var i_1 = 0; i_1 < nRoot; i_1++) {\n                  var t_1 = roots[i_1];\n\n                  if (t_1 <= 1 && t_1 >= 0) {\n                    var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1);\n                    return isDimX ? [xOrY, val] : [val, xOrY];\n                  }\n                }\n              }\n\n              x0 = x3;\n              y0 = y3;\n              break;\n          }\n        }\n      };\n\n      return ECPolyline;\n    }(Path);\n\n    var ECPolygonShape = function (_super) {\n      __extends(ECPolygonShape, _super);\n\n      function ECPolygonShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      return ECPolygonShape;\n    }(ECPolylineShape);\n\n    var ECPolygon = function (_super) {\n      __extends(ECPolygon, _super);\n\n      function ECPolygon(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'ec-polygon';\n        return _this;\n      }\n\n      ECPolygon.prototype.getDefaultShape = function () {\n        return new ECPolygonShape();\n      };\n\n      ECPolygon.prototype.buildPath = function (ctx, shape) {\n        var points = shape.points;\n        var stackedOnPoints = shape.stackedOnPoints;\n        var i = 0;\n        var len = points.length / 2;\n        var smoothMonotone = shape.smoothMonotone;\n\n        if (shape.connectNulls) {\n          for (; len > 0; len--) {\n            if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {\n              break;\n            }\n          }\n\n          for (; i < len; i++) {\n            if (!isPointNull(points[i * 2], points[i * 2 + 1])) {\n              break;\n            }\n          }\n        }\n\n        while (i < len) {\n          var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);\n          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n          i += k + 1;\n          ctx.closePath();\n        }\n      };\n\n      return ECPolygon;\n    }(Path);\n\n    function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {\n      var rect = cartesian.getArea();\n      var x = rect.x;\n      var y = rect.y;\n      var width = rect.width;\n      var height = rect.height;\n      var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2;\n      x -= lineWidth / 2;\n      y -= lineWidth / 2;\n      width += lineWidth;\n      height += lineWidth;\n      x = Math.floor(x);\n      width = Math.round(width);\n      var clipPath = new Rect({\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        }\n      });\n\n      if (hasAnimation) {\n        var baseAxis = cartesian.getBaseAxis();\n        var isHorizontal = baseAxis.isHorizontal();\n        var isAxisInversed = baseAxis.inverse;\n\n        if (isHorizontal) {\n          if (isAxisInversed) {\n            clipPath.shape.x += width;\n          }\n\n          clipPath.shape.width = 0;\n        } else {\n          if (!isAxisInversed) {\n            clipPath.shape.y += height;\n          }\n\n          clipPath.shape.height = 0;\n        }\n\n        var duringCb = typeof during === 'function' ? function (percent) {\n          during(percent, clipPath);\n        } : null;\n        initProps(clipPath, {\n          shape: {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n          }\n        }, seriesModel, null, done, duringCb);\n      }\n\n      return clipPath;\n    }\n\n    function createPolarClipPath(polar, hasAnimation, seriesModel) {\n      var sectorArea = polar.getArea();\n      var r0 = round(sectorArea.r0, 1);\n      var r = round(sectorArea.r, 1);\n      var clipPath = new Sector({\n        shape: {\n          cx: round(polar.cx, 1),\n          cy: round(polar.cy, 1),\n          r0: r0,\n          r: r,\n          startAngle: sectorArea.startAngle,\n          endAngle: sectorArea.endAngle,\n          clockwise: sectorArea.clockwise\n        }\n      });\n\n      if (hasAnimation) {\n        var isRadial = polar.getBaseAxis().dim === 'angle';\n\n        if (isRadial) {\n          clipPath.shape.endAngle = sectorArea.startAngle;\n        } else {\n          clipPath.shape.r = r0;\n        }\n\n        initProps(clipPath, {\n          shape: {\n            endAngle: sectorArea.endAngle,\n            r: r\n          }\n        }, seriesModel);\n      }\n\n      return clipPath;\n    }\n\n    function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {\n      if (!coordSys) {\n        return null;\n      } else if (coordSys.type === 'polar') {\n        return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n      } else if (coordSys.type === 'cartesian2d') {\n        return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);\n      }\n\n      return null;\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function isCoordinateSystemType(coordSys, type) {\n      return coordSys.type === type;\n    }\n\n    function isPointsSame(points1, points2) {\n      if (points1.length !== points2.length) {\n        return;\n      }\n\n      for (var i = 0; i < points1.length; i++) {\n        if (points1[i] !== points2[i]) {\n          return;\n        }\n      }\n\n      return true;\n    }\n\n    function bboxFromPoints(points) {\n      var minX = Infinity;\n      var minY = Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n\n      for (var i = 0; i < points.length;) {\n        var x = points[i++];\n        var y = points[i++];\n\n        if (!isNaN(x)) {\n          minX = Math.min(x, minX);\n          maxX = Math.max(x, maxX);\n        }\n\n        if (!isNaN(y)) {\n          minY = Math.min(y, minY);\n          maxY = Math.max(y, maxY);\n        }\n      }\n\n      return [[minX, minY], [maxX, maxY]];\n    }\n\n    function getBoundingDiff(points1, points2) {\n      var _a = bboxFromPoints(points1),\n          min1 = _a[0],\n          max1 = _a[1];\n\n      var _b = bboxFromPoints(points2),\n          min2 = _b[0],\n          max2 = _b[1];\n\n      return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));\n    }\n\n    function getSmooth(smooth) {\n      return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n    }\n\n    function getStackedOnPoints(coordSys, data, dataCoordInfo) {\n      if (!dataCoordInfo.valueDim) {\n        return [];\n      }\n\n      var len = data.count();\n      var points = createFloat32Array(len * 2);\n\n      for (var idx = 0; idx < len; idx++) {\n        var pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);\n        points[idx * 2] = pt[0];\n        points[idx * 2 + 1] = pt[1];\n      }\n\n      return points;\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n      var baseAxis = coordSys.getBaseAxis();\n      var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n      var stepPoints = [];\n      var i = 0;\n      var stepPt = [];\n      var pt = [];\n      var nextPt = [];\n\n      for (; i < points.length - 2; i += 2) {\n        nextPt[0] = points[i + 2];\n        nextPt[1] = points[i + 3];\n        pt[0] = points[i];\n        pt[1] = points[i + 1];\n        stepPoints.push(pt[0], pt[1]);\n\n        switch (stepTurnAt) {\n          case 'end':\n            stepPt[baseIndex] = nextPt[baseIndex];\n            stepPt[1 - baseIndex] = pt[1 - baseIndex];\n            stepPoints.push(stepPt[0], stepPt[1]);\n            break;\n\n          case 'middle':\n            var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n            var stepPt2 = [];\n            stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n            stepPt[1 - baseIndex] = pt[1 - baseIndex];\n            stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n            stepPoints.push(stepPt[0], stepPt[1]);\n            stepPoints.push(stepPt2[0], stepPt2[1]);\n            break;\n\n          default:\n            stepPt[baseIndex] = pt[baseIndex];\n            stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n            stepPoints.push(stepPt[0], stepPt[1]);\n        }\n      }\n\n      stepPoints.push(points[i++], points[i++]);\n      return stepPoints;\n    }\n\n    function getVisualGradient(data, coordSys) {\n      var visualMetaList = data.getVisual('visualMeta');\n\n      if (!visualMetaList || !visualMetaList.length || !data.count()) {\n        return;\n      }\n\n      if (coordSys.type !== 'cartesian2d') {\n        if (\"development\" !== 'production') {\n          console.warn('Visual map on line style is only supported on cartesian2d.');\n        }\n\n        return;\n      }\n\n      var coordDim;\n      var visualMeta;\n\n      for (var i = visualMetaList.length - 1; i >= 0; i--) {\n        var dimIndex = visualMetaList[i].dimension;\n        var dimName = data.dimensions[dimIndex];\n        var dimInfo = data.getDimensionInfo(dimName);\n        coordDim = dimInfo && dimInfo.coordDim;\n\n        if (coordDim === 'x' || coordDim === 'y') {\n          visualMeta = visualMetaList[i];\n          break;\n        }\n      }\n\n      if (!visualMeta) {\n        if (\"development\" !== 'production') {\n          console.warn('Visual map on line style only support x or y dimension.');\n        }\n\n        return;\n      }\n\n      var axis = coordSys.getAxis(coordDim);\n      var colorStops = map(visualMeta.stops, function (stop) {\n        return {\n          offset: 0,\n          coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n          color: stop.color\n        };\n      });\n      var stopLen = colorStops.length;\n      var outerColors = visualMeta.outerColors.slice();\n\n      if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n        colorStops.reverse();\n        outerColors.reverse();\n      }\n\n      var tinyExtent = 10;\n      var minCoord = colorStops[0].coord - tinyExtent;\n      var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n      var coordSpan = maxCoord - minCoord;\n\n      if (coordSpan < 1e-3) {\n        return 'transparent';\n      }\n\n      each(colorStops, function (stop) {\n        stop.offset = (stop.coord - minCoord) / coordSpan;\n      });\n      colorStops.push({\n        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n        color: outerColors[1] || 'transparent'\n      });\n      colorStops.unshift({\n        offset: stopLen ? colorStops[0].offset : 0.5,\n        color: outerColors[0] || 'transparent'\n      });\n      var gradient = new LinearGradient(0, 0, 0, 0, colorStops, true);\n      gradient[coordDim] = minCoord;\n      gradient[coordDim + '2'] = maxCoord;\n      return gradient;\n    }\n\n    function getIsIgnoreFunc(seriesModel, data, coordSys) {\n      var showAllSymbol = seriesModel.get('showAllSymbol');\n      var isAuto = showAllSymbol === 'auto';\n\n      if (showAllSymbol && !isAuto) {\n        return;\n      }\n\n      var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n      if (!categoryAxis) {\n        return;\n      }\n\n      if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {\n        return;\n      }\n\n      var categoryDataDim = data.mapDimension(categoryAxis.dim);\n      var labelMap = {};\n      each(categoryAxis.getViewLabels(), function (labelItem) {\n        var ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue);\n        labelMap[ordinalNumber] = 1;\n      });\n      return function (dataIndex) {\n        return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n      };\n    }\n\n    function canShowAllSymbolForCategory(categoryAxis, data) {\n      var axisExtent = categoryAxis.getExtent();\n      var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n      isNaN(availSize) && (availSize = 0);\n      var dataLen = data.count();\n      var step = Math.max(1, Math.round(dataLen / 5));\n\n      for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n        if (Symbol.getSymbolSize(data, dataIndex)[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    function isPointNull$1(x, y) {\n      return isNaN(x) || isNaN(y);\n    }\n\n    function getLastIndexNotNull(points) {\n      var len = points.length / 2;\n\n      for (; len > 0; len--) {\n        if (!isPointNull$1(points[len * 2 - 2], points[len * 2 - 1])) {\n          break;\n        }\n      }\n\n      return len - 1;\n    }\n\n    function getPointAtIndex(points, idx) {\n      return [points[idx * 2], points[idx * 2 + 1]];\n    }\n\n    function getIndexRange(points, xOrY, dim) {\n      var len = points.length / 2;\n      var dimIdx = dim === 'x' ? 0 : 1;\n      var a;\n      var b;\n      var prevIndex = 0;\n      var nextIndex = -1;\n\n      for (var i = 0; i < len; i++) {\n        b = points[i * 2 + dimIdx];\n\n        if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {\n          continue;\n        }\n\n        if (i === 0) {\n          a = b;\n          continue;\n        }\n\n        if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {\n          nextIndex = i;\n          break;\n        }\n\n        prevIndex = i;\n        a = b;\n      }\n\n      return {\n        range: [prevIndex, nextIndex],\n        t: (xOrY - a) / (b - a)\n      };\n    }\n\n    function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {\n      if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n        var endLabelModel_1 = seriesModel.getModel('endLabel');\n        var showEndLabel = endLabelModel_1.get('show');\n        var valueAnimation_1 = endLabelModel_1.get('valueAnimation');\n        var data_1 = seriesModel.getData();\n        var labelAnimationRecord_1 = {\n          lastFrameIndex: 0\n        };\n        var during = showEndLabel ? function (percent, clipRect) {\n          lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);\n        } : null;\n        var isHorizontal = coordSys.getBaseAxis().isHorizontal();\n        var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function () {\n          var endLabel = lineView._endLabel;\n\n          if (endLabel && hasAnimation) {\n            if (labelAnimationRecord_1.originalX != null) {\n              endLabel.attr({\n                x: labelAnimationRecord_1.originalX,\n                y: labelAnimationRecord_1.originalY\n              });\n            }\n          }\n        }, during);\n\n        if (!seriesModel.get('clip', true)) {\n          var rectShape = clipPath.shape;\n          var expandSize = Math.max(rectShape.width, rectShape.height);\n\n          if (isHorizontal) {\n            rectShape.y -= expandSize;\n            rectShape.height += expandSize * 2;\n          } else {\n            rectShape.x -= expandSize;\n            rectShape.width += expandSize * 2;\n          }\n        }\n\n        if (during) {\n          during(1, clipPath);\n        }\n\n        return clipPath;\n      } else {\n        if (\"development\" !== 'production') {\n          if (seriesModel.get(['endLabel', 'show'])) {\n            console.warn('endLabel is not supported for lines in polar systems.');\n          }\n        }\n\n        return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n      }\n    }\n\n    function getEndLabelStateSpecified(endLabelModel, coordSys) {\n      var baseAxis = coordSys.getBaseAxis();\n      var isHorizontal = baseAxis.isHorizontal();\n      var isBaseInversed = baseAxis.inverse;\n      var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';\n      var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';\n      return {\n        normal: {\n          align: endLabelModel.get('align') || align,\n          verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign\n        }\n      };\n    }\n\n    var LineView = function (_super) {\n      __extends(LineView, _super);\n\n      function LineView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      LineView.prototype.init = function () {\n        var lineGroup = new Group();\n        var symbolDraw = new SymbolDraw();\n        this.group.add(symbolDraw.group);\n        this._symbolDraw = symbolDraw;\n        this._lineGroup = lineGroup;\n      };\n\n      LineView.prototype.render = function (seriesModel, ecModel, api) {\n        var _this = this;\n\n        var coordSys = seriesModel.coordinateSystem;\n        var group = this.group;\n        var data = seriesModel.getData();\n        var lineStyleModel = seriesModel.getModel('lineStyle');\n        var areaStyleModel = seriesModel.getModel('areaStyle');\n        var points = data.getLayout('points') || [];\n        var isCoordSysPolar = coordSys.type === 'polar';\n        var prevCoordSys = this._coordSys;\n        var symbolDraw = this._symbolDraw;\n        var polyline = this._polyline;\n        var polygon = this._polygon;\n        var lineGroup = this._lineGroup;\n        var hasAnimation = seriesModel.get('animation');\n        var isAreaChart = !areaStyleModel.isEmpty();\n        var valueOrigin = areaStyleModel.get('origin');\n        var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n        var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);\n        var showSymbol = seriesModel.get('showSymbol');\n        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);\n        var oldData = this._data;\n        oldData && oldData.eachItemGraphicEl(function (el, idx) {\n          if (el.__temp) {\n            group.remove(el);\n            oldData.setItemGraphicEl(idx, null);\n          }\n        });\n\n        if (!showSymbol) {\n          symbolDraw.remove();\n        }\n\n        group.add(lineGroup);\n        var step = !isCoordSysPolar ? seriesModel.get('step') : false;\n        var clipShapeForSymbol;\n\n        if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {\n          clipShapeForSymbol = coordSys.getArea();\n\n          if (clipShapeForSymbol.width != null) {\n            clipShapeForSymbol.x -= 0.1;\n            clipShapeForSymbol.y -= 0.1;\n            clipShapeForSymbol.width += 0.2;\n            clipShapeForSymbol.height += 0.2;\n          } else if (clipShapeForSymbol.r0) {\n            clipShapeForSymbol.r0 -= 0.5;\n            clipShapeForSymbol.r += 0.5;\n          }\n        }\n\n        this._clipShapeForSymbol = clipShapeForSymbol;\n\n        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n          showSymbol && symbolDraw.updateData(data, {\n            isIgnore: isIgnoreFunc,\n            clipShape: clipShapeForSymbol,\n            disableAnimation: true,\n            getSymbolPoint: function (idx) {\n              return [points[idx * 2], points[idx * 2 + 1]];\n            }\n          });\n          hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);\n\n          if (step) {\n            points = turnPointsIntoStep(points, coordSys, step);\n\n            if (stackedOnPoints) {\n              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n            }\n          }\n\n          polyline = this._newPolyline(points);\n\n          if (isAreaChart) {\n            polygon = this._newPolygon(points, stackedOnPoints);\n          }\n\n          if (!isCoordSysPolar) {\n            this._initOrUpdateEndLabel(seriesModel, coordSys);\n          }\n\n          lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));\n        } else {\n          if (isAreaChart && !polygon) {\n            polygon = this._newPolygon(points, stackedOnPoints);\n          } else if (polygon && !isAreaChart) {\n            lineGroup.remove(polygon);\n            polygon = this._polygon = null;\n          }\n\n          if (!isCoordSysPolar) {\n            this._initOrUpdateEndLabel(seriesModel, coordSys);\n          }\n\n          lineGroup.setClipPath(createLineClipPath(this, coordSys, false, seriesModel));\n          showSymbol && symbolDraw.updateData(data, {\n            isIgnore: isIgnoreFunc,\n            clipShape: clipShapeForSymbol,\n            disableAnimation: true,\n            getSymbolPoint: function (idx) {\n              return [points[idx * 2], points[idx * 2 + 1]];\n            }\n          });\n\n          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n            if (hasAnimation) {\n              this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n            } else {\n              if (step) {\n                points = turnPointsIntoStep(points, coordSys, step);\n\n                if (stackedOnPoints) {\n                  stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n              }\n\n              polyline.setShape({\n                points: points\n              });\n              polygon && polygon.setShape({\n                points: points,\n                stackedOnPoints: stackedOnPoints\n              });\n            }\n          }\n        }\n\n        var visualColor = getVisualGradient(data, coordSys) || data.getVisual('style')[data.getVisual('drawType')];\n        var focus = seriesModel.get(['emphasis', 'focus']);\n        var blurScope = seriesModel.get(['emphasis', 'blurScope']);\n        polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {\n          fill: 'none',\n          stroke: visualColor,\n          lineJoin: 'bevel'\n        }));\n        setStatesStylesFromModel(polyline, seriesModel, 'lineStyle');\n\n        if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {\n          var emphasisLineStyle = polyline.getState('emphasis').style;\n          emphasisLineStyle.lineWidth = polyline.style.lineWidth + 1;\n        }\n\n        getECData(polyline).seriesIndex = seriesModel.seriesIndex;\n        enableHoverEmphasis(polyline, focus, blurScope);\n        var smooth = getSmooth(seriesModel.get('smooth'));\n        var smoothMonotone = seriesModel.get('smoothMonotone');\n        var connectNulls = seriesModel.get('connectNulls');\n        polyline.setShape({\n          smooth: smooth,\n          smoothMonotone: smoothMonotone,\n          connectNulls: connectNulls\n        });\n\n        if (polygon) {\n          var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n          var stackedOnSmooth = 0;\n          polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {\n            fill: visualColor,\n            opacity: 0.7,\n            lineJoin: 'bevel',\n            decal: data.getVisual('style').decal\n          }));\n\n          if (stackedOnSeries) {\n            stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n          }\n\n          polygon.setShape({\n            smooth: smooth,\n            stackedOnSmooth: stackedOnSmooth,\n            smoothMonotone: smoothMonotone,\n            connectNulls: connectNulls\n          });\n          setStatesStylesFromModel(polygon, seriesModel, 'areaStyle');\n          getECData(polygon).seriesIndex = seriesModel.seriesIndex;\n          enableHoverEmphasis(polygon, focus, blurScope);\n        }\n\n        var changePolyState = function (toState) {\n          _this._changePolyState(toState);\n        };\n\n        data.eachItemGraphicEl(function (el) {\n          el && (el.onHoverStateChange = changePolyState);\n        });\n        this._polyline.onHoverStateChange = changePolyState;\n        this._data = data;\n        this._coordSys = coordSys;\n        this._stackedOnPoints = stackedOnPoints;\n        this._points = points;\n        this._step = step;\n        this._valueOrigin = valueOrigin;\n      };\n\n      LineView.prototype.dispose = function () {};\n\n      LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {\n        var data = seriesModel.getData();\n        var dataIndex = queryDataIndex(data, payload);\n\n        this._changePolyState('emphasis');\n\n        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n          var points = data.getLayout('points');\n          var symbol = data.getItemGraphicEl(dataIndex);\n\n          if (!symbol) {\n            var x = points[dataIndex * 2];\n            var y = points[dataIndex * 2 + 1];\n\n            if (isNaN(x) || isNaN(y)) {\n              return;\n            }\n\n            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {\n              return;\n            }\n\n            symbol = new Symbol(data, dataIndex);\n            symbol.x = x;\n            symbol.y = y;\n            symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n            symbol.__temp = true;\n            data.setItemGraphicEl(dataIndex, symbol);\n            symbol.stopSymbolAnimation(true);\n            this.group.add(symbol);\n          }\n\n          symbol.highlight();\n        } else {\n          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n        }\n      };\n\n      LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {\n        var data = seriesModel.getData();\n        var dataIndex = queryDataIndex(data, payload);\n\n        this._changePolyState('normal');\n\n        if (dataIndex != null && dataIndex >= 0) {\n          var symbol = data.getItemGraphicEl(dataIndex);\n\n          if (symbol) {\n            if (symbol.__temp) {\n              data.setItemGraphicEl(dataIndex, null);\n              this.group.remove(symbol);\n            } else {\n              symbol.downplay();\n            }\n          }\n        } else {\n          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n        }\n      };\n\n      LineView.prototype._changePolyState = function (toState) {\n        var polygon = this._polygon;\n        setStatesFlag(this._polyline, toState);\n        polygon && setStatesFlag(polygon, toState);\n      };\n\n      LineView.prototype._newPolyline = function (points) {\n        var polyline = this._polyline;\n\n        if (polyline) {\n          this._lineGroup.remove(polyline);\n        }\n\n        polyline = new ECPolyline({\n          shape: {\n            points: points\n          },\n          segmentIgnoreThreshold: 2,\n          z2: 10\n        });\n\n        this._lineGroup.add(polyline);\n\n        this._polyline = polyline;\n        return polyline;\n      };\n\n      LineView.prototype._newPolygon = function (points, stackedOnPoints) {\n        var polygon = this._polygon;\n\n        if (polygon) {\n          this._lineGroup.remove(polygon);\n        }\n\n        polygon = new ECPolygon({\n          shape: {\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          },\n          segmentIgnoreThreshold: 2\n        });\n\n        this._lineGroup.add(polygon);\n\n        this._polygon = polygon;\n        return polygon;\n      };\n\n      LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {\n        var isHorizontalOrRadial;\n        var isCoordSysPolar;\n        var baseAxis = coordSys.getBaseAxis();\n        var isAxisInverse = baseAxis.inverse;\n\n        if (coordSys.type === 'cartesian2d') {\n          isHorizontalOrRadial = baseAxis.isHorizontal();\n          isCoordSysPolar = false;\n        } else if (coordSys.type === 'polar') {\n          isHorizontalOrRadial = baseAxis.dim === 'angle';\n          isCoordSysPolar = true;\n        }\n\n        var seriesModel = data.hostModel;\n        var seriesDuration = seriesModel.get('animationDuration');\n\n        if (typeof seriesDuration === 'function') {\n          seriesDuration = seriesDuration(null);\n        }\n\n        var seriesDalay = seriesModel.get('animationDelay') || 0;\n        var seriesDalayValue = typeof seriesDalay === 'function' ? seriesDalay(null) : seriesDalay;\n        data.eachItemGraphicEl(function (symbol, idx) {\n          var el = symbol;\n\n          if (el) {\n            var point = [symbol.x, symbol.y];\n            var start = void 0;\n            var end = void 0;\n            var current = void 0;\n\n            if (isCoordSysPolar) {\n              var polarClip = clipShape;\n              var coord = coordSys.pointToCoord(point);\n\n              if (isHorizontalOrRadial) {\n                start = polarClip.startAngle;\n                end = polarClip.endAngle;\n                current = -coord[1] / 180 * Math.PI;\n              } else {\n                start = polarClip.r0;\n                end = polarClip.r;\n                current = coord[0];\n              }\n            } else {\n              var gridClip = clipShape;\n\n              if (isHorizontalOrRadial) {\n                start = gridClip.x;\n                end = gridClip.x + gridClip.width;\n                current = symbol.x;\n              } else {\n                start = gridClip.y + gridClip.height;\n                end = gridClip.y;\n                current = symbol.y;\n              }\n            }\n\n            var ratio = end === start ? 0 : (current - start) / (end - start);\n\n            if (isAxisInverse) {\n              ratio = 1 - ratio;\n            }\n\n            var delay = typeof seriesDalay === 'function' ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;\n            var symbolPath = el.getSymbolPath();\n            var text = symbolPath.getTextContent();\n            el.attr({\n              scaleX: 0,\n              scaleY: 0\n            });\n            el.animateTo({\n              scaleX: 1,\n              scaleY: 1\n            }, {\n              duration: 200,\n              delay: delay\n            });\n\n            if (text) {\n              text.animateFrom({\n                style: {\n                  opacity: 0\n                }\n              }, {\n                duration: 300,\n                delay: delay\n              });\n            }\n\n            symbolPath.disableLabelAnimation = true;\n          }\n        });\n      };\n\n      LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys) {\n        var endLabelModel = seriesModel.getModel('endLabel');\n\n        if (endLabelModel.get('show')) {\n          var data_2 = seriesModel.getData();\n          var polyline = this._polyline;\n          var endLabel = this._endLabel;\n\n          if (!endLabel) {\n            endLabel = this._endLabel = new ZRText({\n              z2: 200\n            });\n            endLabel.ignoreClip = true;\n            polyline.setTextContent(this._endLabel);\n            polyline.disableLabelAnimation = true;\n          }\n\n          var dataIndex = getLastIndexNotNull(data_2.getLayout('points'));\n\n          if (dataIndex >= 0) {\n            setLabelStyle(polyline, getLabelStatesModels(seriesModel, 'endLabel'), {\n              labelFetcher: seriesModel,\n              labelDataIndex: dataIndex,\n              defaultText: function (dataIndex, opt, interpolatedValue) {\n                return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex);\n              },\n              enableTextSetter: true\n            }, getEndLabelStateSpecified(endLabelModel, coordSys));\n            polyline.textConfig.position = null;\n          }\n        } else if (this._endLabel) {\n          this._polyline.removeTextContent();\n\n          this._endLabel = null;\n        }\n      };\n\n      LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {\n        var endLabel = this._endLabel;\n        var polyline = this._polyline;\n\n        if (endLabel) {\n          if (percent < 1 && animationRecord.originalX == null) {\n            animationRecord.originalX = endLabel.x;\n            animationRecord.originalY = endLabel.y;\n          }\n\n          var points = data.getLayout('points');\n          var seriesModel = data.hostModel;\n          var connectNulls = seriesModel.get('connectNulls');\n          var precision = endLabelModel.get('precision');\n          var distance = endLabelModel.get('distance') || 0;\n          var baseAxis = coordSys.getBaseAxis();\n          var isHorizontal = baseAxis.isHorizontal();\n          var isBaseInversed = baseAxis.inverse;\n          var clipShape = clipRect.shape;\n          var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;\n          var distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1);\n          var distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1);\n          var dim = isHorizontal ? 'x' : 'y';\n          var dataIndexRange = getIndexRange(points, xOrY, dim);\n          var indices = dataIndexRange.range;\n          var diff = indices[1] - indices[0];\n          var value = void 0;\n\n          if (diff >= 1) {\n            if (diff > 1 && !connectNulls) {\n              var pt = getPointAtIndex(points, indices[0]);\n              endLabel.attr({\n                x: pt[0] + distanceX,\n                y: pt[1] + distanceY\n              });\n              valueAnimation && (value = seriesModel.getRawValue(indices[0]));\n            } else {\n              var pt = polyline.getPointOn(xOrY, dim);\n              pt && endLabel.attr({\n                x: pt[0] + distanceX,\n                y: pt[1] + distanceY\n              });\n              var startValue = seriesModel.getRawValue(indices[0]);\n              var endValue = seriesModel.getRawValue(indices[1]);\n              valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));\n            }\n\n            animationRecord.lastFrameIndex = indices[0];\n          } else {\n            var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;\n            var pt = getPointAtIndex(points, idx);\n            valueAnimation && (value = seriesModel.getRawValue(idx));\n            endLabel.attr({\n              x: pt[0] + distanceX,\n              y: pt[1] + distanceY\n            });\n          }\n\n          if (valueAnimation) {\n            labelInner(endLabel).setLabelText(value);\n          }\n        }\n      };\n\n      LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n        var polyline = this._polyline;\n        var polygon = this._polygon;\n        var seriesModel = data.hostModel;\n        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n        var current = diff.current;\n        var stackedOnCurrent = diff.stackedOnCurrent;\n        var next = diff.next;\n        var stackedOnNext = diff.stackedOnNext;\n\n        if (step) {\n          current = turnPointsIntoStep(diff.current, coordSys, step);\n          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n          next = turnPointsIntoStep(diff.next, coordSys, step);\n          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n        }\n\n        if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {\n          polyline.setShape({\n            points: next\n          });\n\n          if (polygon) {\n            polygon.setShape({\n              points: next,\n              stackedOnPoints: stackedOnNext\n            });\n          }\n\n          return;\n        }\n\n        polyline.shape.__points = diff.current;\n        polyline.shape.points = current;\n        var target = {\n          shape: {\n            points: next\n          }\n        };\n\n        if (diff.current !== current) {\n          target.shape.__points = diff.next;\n        }\n\n        polyline.stopAnimation();\n        updateProps(polyline, target, seriesModel);\n\n        if (polygon) {\n          polygon.setShape({\n            points: current,\n            stackedOnPoints: stackedOnCurrent\n          });\n          polygon.stopAnimation();\n          updateProps(polygon, {\n            shape: {\n              stackedOnPoints: stackedOnNext\n            }\n          }, seriesModel);\n\n          if (polyline.shape.points !== polygon.shape.points) {\n            polygon.shape.points = polyline.shape.points;\n          }\n        }\n\n        var updatedDataInfo = [];\n        var diffStatus = diff.status;\n\n        for (var i = 0; i < diffStatus.length; i++) {\n          var cmd = diffStatus[i].cmd;\n\n          if (cmd === '=') {\n            var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n            if (el) {\n              updatedDataInfo.push({\n                el: el,\n                ptIdx: i\n              });\n            }\n          }\n        }\n\n        if (polyline.animators && polyline.animators.length) {\n          polyline.animators[0].during(function () {\n            polygon && polygon.dirtyShape();\n            var points = polyline.shape.__points;\n\n            for (var i = 0; i < updatedDataInfo.length; i++) {\n              var el = updatedDataInfo[i].el;\n              var offset = updatedDataInfo[i].ptIdx * 2;\n              el.x = points[offset];\n              el.y = points[offset + 1];\n              el.markRedraw();\n            }\n          });\n        }\n      };\n\n      LineView.prototype.remove = function (ecModel) {\n        var group = this.group;\n        var oldData = this._data;\n\n        this._lineGroup.removeAll();\n\n        this._symbolDraw.remove(true);\n\n        oldData && oldData.eachItemGraphicEl(function (el, idx) {\n          if (el.__temp) {\n            group.remove(el);\n            oldData.setItemGraphicEl(idx, null);\n          }\n        });\n        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;\n      };\n\n      LineView.type = 'line';\n      return LineView;\n    }(ChartView);\n\n    function pointsLayout(seriesType, forceStoreInTypedArray) {\n      return {\n        seriesType: seriesType,\n        plan: createRenderPlanner(),\n        reset: function (seriesModel) {\n          var data = seriesModel.getData();\n          var coordSys = seriesModel.coordinateSystem;\n          var pipelineContext = seriesModel.pipelineContext;\n          var useTypedArray = forceStoreInTypedArray || pipelineContext.large;\n\n          if (!coordSys) {\n            return;\n          }\n\n          var dims = map(coordSys.dimensions, function (dim) {\n            return data.mapDimension(dim);\n          }).slice(0, 2);\n          var dimLen = dims.length;\n          var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n          if (isDimensionStacked(data, dims[0])) {\n            dims[0] = stackResultDim;\n          }\n\n          if (isDimensionStacked(data, dims[1])) {\n            dims[1] = stackResultDim;\n          }\n\n          var dimInfo0 = data.getDimensionInfo(dims[0]);\n          var dimInfo1 = data.getDimensionInfo(dims[1]);\n          var dimIdx0 = dimInfo0 && dimInfo0.index;\n          var dimIdx1 = dimInfo1 && dimInfo1.index;\n          return dimLen && {\n            progress: function (params, data) {\n              var segCount = params.end - params.start;\n              var points = useTypedArray && createFloat32Array(segCount * dimLen);\n              var tmpIn = [];\n              var tmpOut = [];\n\n              for (var i = params.start, offset = 0; i < params.end; i++) {\n                var point = void 0;\n\n                if (dimLen === 1) {\n                  var x = data.getByDimIdx(dimIdx0, i);\n                  point = coordSys.dataToPoint(x, null, tmpOut);\n                } else {\n                  tmpIn[0] = data.getByDimIdx(dimIdx0, i);\n                  tmpIn[1] = data.getByDimIdx(dimIdx1, i);\n                  point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n                }\n\n                if (useTypedArray) {\n                  points[offset++] = point[0];\n                  points[offset++] = point[1];\n                } else {\n                  data.setItemLayout(i, point.slice());\n                }\n              }\n\n              useTypedArray && data.setLayout('points', points);\n            }\n          };\n        }\n      };\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var samplers = {\n      average: function (frame) {\n        var sum = 0;\n        var count = 0;\n\n        for (var i = 0; i < frame.length; i++) {\n          if (!isNaN(frame[i])) {\n            sum += frame[i];\n            count++;\n          }\n        }\n\n        return count === 0 ? NaN : sum / count;\n      },\n      sum: function (frame) {\n        var sum = 0;\n\n        for (var i = 0; i < frame.length; i++) {\n          sum += frame[i] || 0;\n        }\n\n        return sum;\n      },\n      max: function (frame) {\n        var max = -Infinity;\n\n        for (var i = 0; i < frame.length; i++) {\n          frame[i] > max && (max = frame[i]);\n        }\n\n        return isFinite(max) ? max : NaN;\n      },\n      min: function (frame) {\n        var min = Infinity;\n\n        for (var i = 0; i < frame.length; i++) {\n          frame[i] < min && (min = frame[i]);\n        }\n\n        return isFinite(min) ? min : NaN;\n      },\n      nearest: function (frame) {\n        return frame[0];\n      }\n    };\n\n    var indexSampler = function (frame) {\n      return Math.round(frame.length / 2);\n    };\n\n    function dataSample(seriesType) {\n      return {\n        seriesType: seriesType,\n        reset: function (seriesModel, ecModel, api) {\n          var data = seriesModel.getData();\n          var sampling = seriesModel.get('sampling');\n          var coordSys = seriesModel.coordinateSystem;\n          var count = data.count();\n\n          if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {\n            var baseAxis = coordSys.getBaseAxis();\n            var valueAxis = coordSys.getOtherAxis(baseAxis);\n            var extent = baseAxis.getExtent();\n            var dpr = api.getDevicePixelRatio();\n            var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);\n            var rate = Math.round(count / size);\n\n            if (rate > 1) {\n              if (sampling === 'lttb') {\n                seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));\n              }\n\n              var sampler = void 0;\n\n              if (typeof sampling === 'string') {\n                sampler = samplers[sampling];\n              } else if (typeof sampling === 'function') {\n                sampler = sampling;\n              }\n\n              if (sampler) {\n                seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n              }\n            }\n          }\n        }\n      };\n    }\n\n    function install$2(registers) {\n      registers.registerChartView(LineView);\n      registers.registerSeriesModel(LineSeriesModel);\n      registers.registerLayout(pointsLayout('line', true));\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));\n    }\n\n    var BaseBarSeriesModel = function (_super) {\n      __extends(BaseBarSeriesModel, _super);\n\n      function BaseBarSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BaseBarSeriesModel.type;\n        return _this;\n      }\n\n      BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: true\n        });\n      };\n\n      BaseBarSeriesModel.prototype.getMarkerPosition = function (value) {\n        var coordSys = this.coordinateSystem;\n\n        if (coordSys) {\n          var pt = coordSys.dataToPoint(coordSys.clampData(value));\n          var data = this.getData();\n          var offset = data.getLayout('offset');\n          var size = data.getLayout('size');\n          var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n          pt[offsetIndex] += offset + size / 2;\n          return pt;\n        }\n\n        return [NaN, NaN];\n      };\n\n      BaseBarSeriesModel.type = 'series.__base_bar__';\n      BaseBarSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        barMinHeight: 0,\n        barMinAngle: 0,\n        large: false,\n        largeThreshold: 400,\n        progressive: 3e3,\n        progressiveChunkMode: 'mod'\n      };\n      return BaseBarSeriesModel;\n    }(SeriesModel);\n\n    SeriesModel.registerClass(BaseBarSeriesModel);\n\n    var BarSeriesModel = function (_super) {\n      __extends(BarSeriesModel, _super);\n\n      function BarSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BarSeriesModel.type;\n        return _this;\n      }\n\n      BarSeriesModel.prototype.getInitialData = function () {\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: true,\n          createInvertedIndices: !!this.get('realtimeSort', true) || null\n        });\n      };\n\n      BarSeriesModel.prototype.getProgressive = function () {\n        return this.get('large') ? this.get('progressive') : false;\n      };\n\n      BarSeriesModel.prototype.getProgressiveThreshold = function () {\n        var progressiveThreshold = this.get('progressiveThreshold');\n        var largeThreshold = this.get('largeThreshold');\n\n        if (largeThreshold > progressiveThreshold) {\n          progressiveThreshold = largeThreshold;\n        }\n\n        return progressiveThreshold;\n      };\n\n      BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n        return selectors.rect(data.getItemLayout(dataIndex));\n      };\n\n      BarSeriesModel.type = 'series.bar';\n      BarSeriesModel.dependencies = ['grid', 'polar'];\n      BarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {\n        clip: true,\n        roundCap: false,\n        showBackground: false,\n        backgroundStyle: {\n          color: 'rgba(180, 180, 180, 0.2)',\n          borderColor: null,\n          borderWidth: 0,\n          borderType: 'solid',\n          borderRadius: 0,\n          shadowBlur: 0,\n          shadowColor: null,\n          shadowOffsetX: 0,\n          shadowOffsetY: 0,\n          opacity: 1\n        },\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        },\n        realtimeSort: false\n      });\n      return BarSeriesModel;\n    }(BaseBarSeriesModel);\n\n    var SausageShape = function () {\n      function SausageShape() {\n        this.cx = 0;\n        this.cy = 0;\n        this.r0 = 0;\n        this.r = 0;\n        this.startAngle = 0;\n        this.endAngle = Math.PI * 2;\n        this.clockwise = true;\n      }\n\n      return SausageShape;\n    }();\n\n    var SausagePath = function (_super) {\n      __extends(SausagePath, _super);\n\n      function SausagePath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'sausage';\n        return _this;\n      }\n\n      SausagePath.prototype.getDefaultShape = function () {\n        return new SausageShape();\n      };\n\n      SausagePath.prototype.buildPath = function (ctx, shape) {\n        var x = shape.cx;\n        var y = shape.cy;\n        var r0 = Math.max(shape.r0 || 0, 0);\n        var r = Math.max(shape.r, 0);\n        var dr = (r - r0) * 0.5;\n        var rCenter = r0 + dr;\n        var startAngle = shape.startAngle;\n        var endAngle = shape.endAngle;\n        var clockwise = shape.clockwise;\n        var unitStartX = Math.cos(startAngle);\n        var unitStartY = Math.sin(startAngle);\n        var unitEndX = Math.cos(endAngle);\n        var unitEndY = Math.sin(endAngle);\n        var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;\n\n        if (lessThanCircle) {\n          ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);\n          ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);\n        }\n\n        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n        ctx.moveTo(unitEndX * r + x, unitEndY * r + y);\n        ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);\n\n        if (r0 !== 0) {\n          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n          ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);\n        }\n\n        ctx.closePath();\n      };\n\n      return SausagePath;\n    }(Path);\n\n    var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'];\n    var BAR_BORDER_RADIUS_QUERY = ['itemStyle', 'borderRadius'];\n    var _eventPos = [0, 0];\n    var mathMax$6 = Math.max;\n    var mathMin$6 = Math.min;\n\n    function getClipArea(coord, data) {\n      var coordSysClipArea = coord.getArea && coord.getArea();\n\n      if (isCoordinateSystemType(coord, 'cartesian2d')) {\n        var baseAxis = coord.getBaseAxis();\n\n        if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n          var expandWidth = data.getLayout('bandWidth');\n\n          if (baseAxis.isHorizontal()) {\n            coordSysClipArea.x -= expandWidth;\n            coordSysClipArea.width += expandWidth * 2;\n          } else {\n            coordSysClipArea.y -= expandWidth;\n            coordSysClipArea.height += expandWidth * 2;\n          }\n        }\n      }\n\n      return coordSysClipArea;\n    }\n\n    var BarView = function (_super) {\n      __extends(BarView, _super);\n\n      function BarView() {\n        var _this = _super.call(this) || this;\n\n        _this.type = BarView.type;\n        _this._isFirstFrame = true;\n        return _this;\n      }\n\n      BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n        this._model = seriesModel;\n\n        this._removeOnRenderedListener(api);\n\n        this._updateDrawMode(seriesModel);\n\n        var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n        if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n        } else if (\"development\" !== 'production') {\n          warn('Only cartesian2d and polar supported for bar.');\n        }\n      };\n\n      BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n        this._clear();\n\n        this._updateDrawMode(seriesModel);\n\n        this._updateLargeClip(seriesModel);\n      };\n\n      BarView.prototype.incrementalRender = function (params, seriesModel) {\n        this._incrementalRenderLarge(params, seriesModel);\n      };\n\n      BarView.prototype._updateDrawMode = function (seriesModel) {\n        var isLargeDraw = seriesModel.pipelineContext.large;\n\n        if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n          this._isLargeDraw = isLargeDraw;\n\n          this._clear();\n        }\n      };\n\n      BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var coord = seriesModel.coordinateSystem;\n        var baseAxis = coord.getBaseAxis();\n        var isHorizontalOrRadial;\n\n        if (coord.type === 'cartesian2d') {\n          isHorizontalOrRadial = baseAxis.isHorizontal();\n        } else if (coord.type === 'polar') {\n          isHorizontalOrRadial = baseAxis.dim === 'angle';\n        }\n\n        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n        var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n\n        if (realtimeSortCfg) {\n          this._enableRealtimeSort(realtimeSortCfg, data, api);\n        }\n\n        var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n        var coordSysClipArea = getClipArea(coord, data);\n        group.removeClipPath();\n        var roundCap = seriesModel.get('roundCap', true);\n        var drawBackground = seriesModel.get('showBackground', true);\n        var backgroundModel = seriesModel.getModel('backgroundStyle');\n        var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n        var bgEls = [];\n        var oldBgEls = this._backgroundEls;\n        var isInitSort = payload && payload.isInitSort;\n        var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n\n        function createBackground(dataIndex) {\n          var bgLayout = getLayout[coord.type](data, dataIndex);\n          var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n          bgEl.useStyle(backgroundModel.getItemStyle());\n\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          }\n\n          bgEls[dataIndex] = bgEl;\n          return bgEl;\n        }\n        data.diff(oldData).add(function (dataIndex) {\n          var itemModel = data.getItemModel(dataIndex);\n          var layout = getLayout[coord.type](data, dataIndex, itemModel);\n\n          if (drawBackground) {\n            createBackground(dataIndex);\n          }\n\n          if (!data.hasValue(dataIndex)) {\n            return;\n          }\n\n          var isClipped = false;\n\n          if (needsClip) {\n            isClipped = clip[coord.type](coordSysClipArea, layout);\n          }\n\n          var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n          updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n\n          if (isInitSort) {\n            el.attr({\n              shape: layout\n            });\n          } else if (realtimeSortCfg) {\n            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n          } else {\n            initProps(el, {\n              shape: layout\n            }, seriesModel, dataIndex);\n          }\n\n          data.setItemGraphicEl(dataIndex, el);\n          group.add(el);\n          el.ignore = isClipped;\n        }).update(function (newIndex, oldIndex) {\n          var itemModel = data.getItemModel(newIndex);\n          var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n          if (drawBackground) {\n            var bgEl = void 0;\n\n            if (oldBgEls.length === 0) {\n              bgEl = createBackground(oldIndex);\n            } else {\n              bgEl = oldBgEls[oldIndex];\n              bgEl.useStyle(backgroundModel.getItemStyle());\n\n              if (coord.type === 'cartesian2d') {\n                bgEl.setShape('r', barBorderRadius);\n              }\n\n              bgEls[newIndex] = bgEl;\n            }\n\n            var bgLayout = getLayout[coord.type](data, newIndex);\n            var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n            updateProps(bgEl, {\n              shape: shape\n            }, animationModel, newIndex);\n          }\n\n          var el = oldData.getItemGraphicEl(oldIndex);\n\n          if (!data.hasValue(newIndex)) {\n            group.remove(el);\n            el = null;\n            return;\n          }\n\n          var isClipped = false;\n\n          if (needsClip) {\n            isClipped = clip[coord.type](coordSysClipArea, layout);\n\n            if (isClipped) {\n              group.remove(el);\n            }\n          }\n\n          if (!el) {\n            el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);\n          }\n\n          if (!isChangeOrder) {\n            updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n          }\n\n          if (isInitSort) {\n            el.attr({\n              shape: layout\n            });\n          } else if (realtimeSortCfg) {\n            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n          } else {\n            updateProps(el, {\n              shape: layout\n            }, seriesModel, newIndex, null);\n          }\n\n          data.setItemGraphicEl(newIndex, el);\n          el.ignore = isClipped;\n          group.add(el);\n        }).remove(function (dataIndex) {\n          var el = oldData.getItemGraphicEl(dataIndex);\n          el && removeElementWithFadeOut(el, seriesModel, dataIndex);\n        }).execute();\n        var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());\n        bgGroup.removeAll();\n\n        for (var i = 0; i < bgEls.length; ++i) {\n          bgGroup.add(bgEls[i]);\n        }\n\n        group.add(bgGroup);\n        this._backgroundEls = bgEls;\n        this._data = data;\n      };\n\n      BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n        this._clear();\n\n        createLarge(seriesModel, this.group);\n\n        this._updateLargeClip(seriesModel);\n      };\n\n      BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n        this._removeBackground();\n\n        createLarge(seriesModel, this.group, true);\n      };\n\n      BarView.prototype._updateLargeClip = function (seriesModel) {\n        var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;\n\n        if (clipPath) {\n          this.group.setClipPath(clipPath);\n        } else {\n          this.group.removeClipPath();\n        }\n      };\n\n      BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n        var _this = this;\n\n        if (!data.count()) {\n          return;\n        }\n\n        var baseAxis = realtimeSortCfg.baseAxis;\n\n        if (this._isFirstFrame) {\n          this._dispatchInitSort(data, realtimeSortCfg, api);\n\n          this._isFirstFrame = false;\n        } else {\n          var orderMapping_1 = function (idx) {\n            var el = data.getItemGraphicEl(idx);\n\n            if (el) {\n              var shape = el.shape;\n              return (baseAxis.isHorizontal() ? Math.abs(shape.height) : Math.abs(shape.width)) || 0;\n            } else {\n              return 0;\n            }\n          };\n\n          this._onRendered = function () {\n            _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n          };\n\n          api.getZr().on('rendered', this._onRendered);\n        }\n      };\n\n      BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n        var info = [];\n        data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n          var mappedValue = orderMapping(dataIdx);\n          mappedValue = mappedValue == null ? NaN : mappedValue;\n          info.push({\n            dataIndex: dataIdx,\n            mappedValue: mappedValue,\n            ordinalNumber: ordinalNumber\n          });\n        });\n        info.sort(function (a, b) {\n          return b.mappedValue - a.mappedValue;\n        });\n        return {\n          ordinalNumbers: map(info, function (item) {\n            return item.ordinalNumber;\n          })\n        };\n      };\n\n      BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n        var scale = baseAxis.scale;\n        var ordinalDataDim = data.mapDimension(baseAxis.dim);\n        var lastValue = Number.MAX_VALUE;\n\n        for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n          var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n          var value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));\n\n          if (value > lastValue) {\n            return true;\n          }\n\n          lastValue = value;\n        }\n\n        return false;\n      };\n\n      BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n        var scale = baseAxis.scale;\n        var extent = scale.getExtent();\n        var tickNum = Math.max(0, extent[0]);\n        var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n\n        for (; tickNum <= tickMax; ++tickNum) {\n          if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n            return true;\n          }\n        }\n      };\n\n      BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n        if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n          return;\n        }\n\n        var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n\n        if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n          this._removeOnRenderedListener(api);\n\n          api.dispatchAction({\n            type: 'changeAxisOrder',\n            componentType: baseAxis.dim + 'Axis',\n            axisId: baseAxis.index,\n            sortInfo: sortInfo\n          });\n        }\n      };\n\n      BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n        var baseAxis = realtimeSortCfg.baseAxis;\n\n        var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n          return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n        });\n\n        api.dispatchAction({\n          type: 'changeAxisOrder',\n          componentType: baseAxis.dim + 'Axis',\n          isInitSort: true,\n          axisId: baseAxis.index,\n          sortInfo: sortResult,\n          animation: {\n            duration: 0\n          }\n        });\n      };\n\n      BarView.prototype.remove = function (ecModel, api) {\n        this._clear(this._model);\n\n        this._removeOnRenderedListener(api);\n      };\n\n      BarView.prototype.dispose = function (ecModel, api) {\n        this._removeOnRenderedListener(api);\n      };\n\n      BarView.prototype._removeOnRenderedListener = function (api) {\n        if (this._onRendered) {\n          api.getZr().off('rendered', this._onRendered);\n          this._onRendered = null;\n        }\n      };\n\n      BarView.prototype._clear = function (model) {\n        var group = this.group;\n        var data = this._data;\n\n        if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n          this._removeBackground();\n\n          this._backgroundEls = [];\n          data.eachItemGraphicEl(function (el) {\n            removeElementWithFadeOut(el, model, getECData(el).dataIndex);\n          });\n        } else {\n          group.removeAll();\n        }\n\n        this._data = null;\n        this._isFirstFrame = true;\n      };\n\n      BarView.prototype._removeBackground = function () {\n        this.group.remove(this._backgroundGroup);\n        this._backgroundGroup = null;\n      };\n\n      BarView.type = 'bar';\n      return BarView;\n    }(ChartView);\n\n    var clip = {\n      cartesian2d: function (coordSysBoundingRect, layout) {\n        var signWidth = layout.width < 0 ? -1 : 1;\n        var signHeight = layout.height < 0 ? -1 : 1;\n\n        if (signWidth < 0) {\n          layout.x += layout.width;\n          layout.width = -layout.width;\n        }\n\n        if (signHeight < 0) {\n          layout.y += layout.height;\n          layout.height = -layout.height;\n        }\n\n        var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n        var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n        var x = mathMax$6(layout.x, coordSysBoundingRect.x);\n        var x2 = mathMin$6(layout.x + layout.width, coordSysX2);\n        var y = mathMax$6(layout.y, coordSysBoundingRect.y);\n        var y2 = mathMin$6(layout.y + layout.height, coordSysY2);\n        var xClipped = x2 < x;\n        var yClipped = y2 < y;\n        layout.x = xClipped && x > coordSysX2 ? x2 : x;\n        layout.y = yClipped && y > coordSysY2 ? y2 : y;\n        layout.width = xClipped ? 0 : x2 - x;\n        layout.height = yClipped ? 0 : y2 - y;\n\n        if (signWidth < 0) {\n          layout.x += layout.width;\n          layout.width = -layout.width;\n        }\n\n        if (signHeight < 0) {\n          layout.y += layout.height;\n          layout.height = -layout.height;\n        }\n\n        return xClipped || yClipped;\n      },\n      polar: function (coordSysClipArea, layout) {\n        var signR = layout.r0 <= layout.r ? 1 : -1;\n\n        if (signR < 0) {\n          var tmp = layout.r;\n          layout.r = layout.r0;\n          layout.r0 = tmp;\n        }\n\n        var r = mathMin$6(layout.r, coordSysClipArea.r);\n        var r0 = mathMax$6(layout.r0, coordSysClipArea.r0);\n        layout.r = r;\n        layout.r0 = r0;\n        var clipped = r - r0 < 0;\n\n        if (signR < 0) {\n          var tmp = layout.r;\n          layout.r = layout.r0;\n          layout.r0 = tmp;\n        }\n\n        return clipped;\n      }\n    };\n    var elementCreator = {\n      cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n        var rect = new Rect({\n          shape: extend({}, layout),\n          z2: 1\n        });\n        rect.__dataIndex = newIndex;\n        rect.name = 'item';\n\n        if (animationModel) {\n          var rectShape = rect.shape;\n          var animateProperty = isHorizontal ? 'height' : 'width';\n          rectShape[animateProperty] = 0;\n        }\n\n        return rect;\n      },\n      polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n        var clockwise = layout.startAngle < layout.endAngle;\n        var ShapeClass = !isRadial && roundCap ? SausagePath : Sector;\n        var sector = new ShapeClass({\n          shape: defaults({\n            clockwise: clockwise\n          }, layout),\n          z2: 1\n        });\n        sector.name = 'item';\n\n        if (animationModel) {\n          var sectorShape = sector.shape;\n          var animateProperty = isRadial ? 'r' : 'endAngle';\n          var animateTarget = {};\n          sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n          animateTarget[animateProperty] = layout[animateProperty];\n          (isUpdate ? updateProps : initProps)(sector, {\n            shape: animateTarget\n          }, animationModel);\n        }\n\n        return sector;\n      }\n    };\n\n    function shouldRealtimeSort(seriesModel, coordSys) {\n      var realtimeSortOption = seriesModel.get('realtimeSort', true);\n      var baseAxis = coordSys.getBaseAxis();\n\n      if (\"development\" !== 'production') {\n        if (realtimeSortOption) {\n          if (baseAxis.type !== 'category') {\n            warn('`realtimeSort` will not work because this bar series is not based on a category axis.');\n          }\n\n          if (coordSys.type !== 'cartesian2d') {\n            warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');\n          }\n        }\n      }\n\n      if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n        return {\n          baseAxis: baseAxis,\n          otherAxis: coordSys.getOtherAxis(baseAxis)\n        };\n      }\n    }\n\n    function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n      var seriesTarget;\n      var axisTarget;\n\n      if (isHorizontal) {\n        axisTarget = {\n          x: layout.x,\n          width: layout.width\n        };\n        seriesTarget = {\n          y: layout.y,\n          height: layout.height\n        };\n      } else {\n        axisTarget = {\n          y: layout.y,\n          height: layout.height\n        };\n        seriesTarget = {\n          x: layout.x,\n          width: layout.width\n        };\n      }\n\n      if (!isChangeOrder) {\n        (isUpdate ? updateProps : initProps)(el, {\n          shape: seriesTarget\n        }, seriesAnimationModel, newIndex, null);\n      }\n\n      var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n      (isUpdate ? updateProps : initProps)(el, {\n        shape: axisTarget\n      }, axisAnimationModel, newIndex);\n    }\n\n    var getLayout = {\n      cartesian2d: function (data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;\n        var signX = layout.width > 0 ? 1 : -1;\n        var signY = layout.height > 0 ? 1 : -1;\n        return {\n          x: layout.x + signX * fixedLineWidth / 2,\n          y: layout.y + signY * fixedLineWidth / 2,\n          width: layout.width - signX * fixedLineWidth,\n          height: layout.height - signY * fixedLineWidth\n        };\n      },\n      polar: function (data, dataIndex, itemModel) {\n        var layout = data.getItemLayout(dataIndex);\n        return {\n          cx: layout.cx,\n          cy: layout.cy,\n          r0: layout.r0,\n          r: layout.r,\n          startAngle: layout.startAngle,\n          endAngle: layout.endAngle\n        };\n      }\n    };\n\n    function isZeroOnPolar(layout) {\n      return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n    }\n\n    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n      var style = data.getItemVisual(dataIndex, 'style');\n\n      if (!isPolar) {\n        el.setShape('r', itemModel.get(BAR_BORDER_RADIUS_QUERY) || 0);\n      }\n\n      el.useStyle(style);\n      var cursorStyle = itemModel.getShallow('cursor');\n      cursorStyle && el.attr('cursor', cursorStyle);\n\n      if (!isPolar) {\n        var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n        var labelStatesModels = getLabelStatesModels(itemModel);\n        setLabelStyle(el, labelStatesModels, {\n          labelFetcher: seriesModel,\n          labelDataIndex: dataIndex,\n          defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n          inheritColor: style.fill,\n          defaultOpacity: style.opacity,\n          defaultOutsidePosition: labelPositionOutside\n        });\n        var label = el.getTextContent();\n        setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n          return getDefaultInterpolatedLabel(data, value);\n        });\n      }\n\n      var emphasisModel = itemModel.getModel(['emphasis']);\n      enableHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n      setStatesStylesFromModel(el, itemModel);\n\n      if (isZeroOnPolar(layout)) {\n        el.style.fill = 'none';\n        el.style.stroke = 'none';\n        each(el.states, function (state) {\n          if (state.style) {\n            state.style.fill = state.style.stroke = 'none';\n          }\n        });\n      }\n    }\n\n    function getLineWidth(itemModel, rawLayout) {\n      var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n      var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n      var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n      return Math.min(lineWidth, width, height);\n    }\n\n    var LagePathShape = function () {\n      function LagePathShape() {}\n\n      return LagePathShape;\n    }();\n\n    var LargePath = function (_super) {\n      __extends(LargePath, _super);\n\n      function LargePath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'largeBar';\n        return _this;\n      }\n\n      LargePath.prototype.getDefaultShape = function () {\n        return new LagePathShape();\n      };\n\n      LargePath.prototype.buildPath = function (ctx, shape) {\n        var points = shape.points;\n        var startPoint = this.__startPoint;\n        var baseDimIdx = this.__baseDimIdx;\n\n        for (var i = 0; i < points.length; i += 2) {\n          startPoint[baseDimIdx] = points[i + baseDimIdx];\n          ctx.moveTo(startPoint[0], startPoint[1]);\n          ctx.lineTo(points[i], points[i + 1]);\n        }\n      };\n\n      return LargePath;\n    }(Path);\n\n    function createLarge(seriesModel, group, incremental) {\n      var data = seriesModel.getData();\n      var startPoint = [];\n      var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n      startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');\n      var largeDataIndices = data.getLayout('largeDataIndices');\n      var barWidth = data.getLayout('barWidth');\n      var backgroundModel = seriesModel.getModel('backgroundStyle');\n      var drawBackground = seriesModel.get('showBackground', true);\n\n      if (drawBackground) {\n        var points = data.getLayout('largeBackgroundPoints');\n        var backgroundStartPoint = [];\n        backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');\n        var bgEl = new LargePath({\n          shape: {\n            points: points\n          },\n          incremental: !!incremental,\n          silent: true,\n          z2: 0\n        });\n        bgEl.__startPoint = backgroundStartPoint;\n        bgEl.__baseDimIdx = baseDimIdx;\n        bgEl.__largeDataIndices = largeDataIndices;\n        bgEl.__barWidth = barWidth;\n        setLargeBackgroundStyle(bgEl, backgroundModel, data);\n        group.add(bgEl);\n      }\n\n      var el = new LargePath({\n        shape: {\n          points: data.getLayout('largePoints')\n        },\n        incremental: !!incremental\n      });\n      el.__startPoint = startPoint;\n      el.__baseDimIdx = baseDimIdx;\n      el.__largeDataIndices = largeDataIndices;\n      el.__barWidth = barWidth;\n      group.add(el);\n      setLargeStyle(el, seriesModel, data);\n      getECData(el).seriesIndex = seriesModel.seriesIndex;\n\n      if (!seriesModel.get('silent')) {\n        el.on('mousedown', largePathUpdateDataIndex);\n        el.on('mousemove', largePathUpdateDataIndex);\n      }\n    }\n\n    var largePathUpdateDataIndex = throttle(function (event) {\n      var largePath = this;\n      var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n      getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n    }, 30, false);\n\n    function largePathFindDataIndex(largePath, x, y) {\n      var baseDimIdx = largePath.__baseDimIdx;\n      var valueDimIdx = 1 - baseDimIdx;\n      var points = largePath.shape.points;\n      var largeDataIndices = largePath.__largeDataIndices;\n      var barWidthHalf = Math.abs(largePath.__barWidth / 2);\n      var startValueVal = largePath.__startPoint[valueDimIdx];\n      _eventPos[0] = x;\n      _eventPos[1] = y;\n      var pointerBaseVal = _eventPos[baseDimIdx];\n      var pointerValueVal = _eventPos[1 - baseDimIdx];\n      var baseLowerBound = pointerBaseVal - barWidthHalf;\n      var baseUpperBound = pointerBaseVal + barWidthHalf;\n\n      for (var i = 0, len = points.length / 2; i < len; i++) {\n        var ii = i * 2;\n        var barBaseVal = points[ii + baseDimIdx];\n        var barValueVal = points[ii + valueDimIdx];\n\n        if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {\n          return largeDataIndices[i];\n        }\n      }\n\n      return -1;\n    }\n\n    function setLargeStyle(el, seriesModel, data) {\n      var globalStyle = data.getVisual('style');\n      el.useStyle(extend({}, globalStyle));\n      el.style.fill = null;\n      el.style.stroke = globalStyle.fill;\n      el.style.lineWidth = data.getLayout('barWidth');\n    }\n\n    function setLargeBackgroundStyle(el, backgroundModel, data) {\n      var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');\n      var itemStyle = backgroundModel.getItemStyle();\n      el.useStyle(itemStyle);\n      el.style.fill = null;\n      el.style.stroke = borderColor;\n      el.style.lineWidth = data.getLayout('barWidth');\n    }\n\n    function createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n      if (isCoordinateSystemType(coord, 'cartesian2d')) {\n        var rectShape = layout;\n        var coordLayout = coord.getArea();\n        return {\n          x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n          y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n          width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n          height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n        };\n      } else {\n        var coordLayout = coord.getArea();\n        var sectorShape = layout;\n        return {\n          cx: coordLayout.cx,\n          cy: coordLayout.cy,\n          r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n          r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n          startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n          endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n        };\n      }\n    }\n\n    function createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n      var ElementClz = coord.type === 'polar' ? Sector : Rect;\n      return new ElementClz({\n        shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n        silent: true,\n        z2: 0\n      });\n    }\n\n    function install$3(registers) {\n      registers.registerChartView(BarView);\n      registers.registerSeriesModel(BarSeriesModel);\n      registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, 'bar'));\n      registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout);\n      registers.registerVisual({\n        seriesType: 'bar',\n        reset: function (seriesModel) {\n          seriesModel.getData().setVisual('legendSymbol', 'roundRect');\n        }\n      });\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('bar'));\n      registers.registerAction({\n        type: 'changeAxisOrder',\n        event: 'changeAxisOrder',\n        update: 'update'\n      }, function (payload, ecModel) {\n        var componentType = payload.componentType || 'series';\n        ecModel.eachComponent({\n          mainType: componentType,\n          query: payload\n        }, function (componentModel) {\n          if (payload.sortInfo) {\n            componentModel.axis.setCategorySortInfo(payload.sortInfo);\n          }\n        });\n      });\n    }\n\n    var PI2$8 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    function getViewRect(seriesModel, api) {\n      return getLayoutRect(seriesModel.getBoxLayoutParams(), {\n        width: api.getWidth(),\n        height: api.getHeight()\n      });\n    }\n\n    function pieLayout(seriesType, ecModel, api) {\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        var data = seriesModel.getData();\n        var valueDim = data.mapDimension('value');\n        var viewRect = getViewRect(seriesModel, api);\n        var center = seriesModel.get('center');\n        var radius = seriesModel.get('radius');\n\n        if (!isArray(radius)) {\n          radius = [0, radius];\n        }\n\n        if (!isArray(center)) {\n          center = [center, center];\n        }\n\n        var width = parsePercent$1(viewRect.width, api.getWidth());\n        var height = parsePercent$1(viewRect.height, api.getHeight());\n        var size = Math.min(width, height);\n        var cx = parsePercent$1(center[0], width) + viewRect.x;\n        var cy = parsePercent$1(center[1], height) + viewRect.y;\n        var r0 = parsePercent$1(radius[0], size / 2);\n        var r = parsePercent$1(radius[1], size / 2);\n        var startAngle = -seriesModel.get('startAngle') * RADIAN;\n        var minAngle = seriesModel.get('minAngle') * RADIAN;\n        var validDataCount = 0;\n        data.each(valueDim, function (value) {\n          !isNaN(value) && validDataCount++;\n        });\n        var sum = data.getSum(valueDim);\n        var unitRadian = Math.PI / (sum || validDataCount) * 2;\n        var clockwise = seriesModel.get('clockwise');\n        var roseType = seriesModel.get('roseType');\n        var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n        var extent = data.getDataExtent(valueDim);\n        extent[0] = 0;\n        var restAngle = PI2$8;\n        var valueSumLargerThanMinAngle = 0;\n        var currentAngle = startAngle;\n        var dir = clockwise ? 1 : -1;\n        data.setLayout({\n          viewRect: viewRect,\n          r: r\n        });\n        data.each(valueDim, function (value, idx) {\n          var angle;\n\n          if (isNaN(value)) {\n            data.setItemLayout(idx, {\n              angle: NaN,\n              startAngle: NaN,\n              endAngle: NaN,\n              clockwise: clockwise,\n              cx: cx,\n              cy: cy,\n              r0: r0,\n              r: roseType ? NaN : r\n            });\n            return;\n          }\n\n          if (roseType !== 'area') {\n            angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n          } else {\n            angle = PI2$8 / validDataCount;\n          }\n\n          if (angle < minAngle) {\n            angle = minAngle;\n            restAngle -= minAngle;\n          } else {\n            valueSumLargerThanMinAngle += value;\n          }\n\n          var endAngle = currentAngle + dir * angle;\n          data.setItemLayout(idx, {\n            angle: angle,\n            startAngle: currentAngle,\n            endAngle: endAngle,\n            clockwise: clockwise,\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: roseType ? linearMap(value, extent, [r0, r]) : r\n          });\n          currentAngle = endAngle;\n        });\n\n        if (restAngle < PI2$8 && validDataCount) {\n          if (restAngle <= 1e-3) {\n            var angle_1 = PI2$8 / validDataCount;\n            data.each(valueDim, function (value, idx) {\n              if (!isNaN(value)) {\n                var layout_1 = data.getItemLayout(idx);\n                layout_1.angle = angle_1;\n                layout_1.startAngle = startAngle + dir * idx * angle_1;\n                layout_1.endAngle = startAngle + dir * (idx + 1) * angle_1;\n              }\n            });\n          } else {\n            unitRadian = restAngle / valueSumLargerThanMinAngle;\n            currentAngle = startAngle;\n            data.each(valueDim, function (value, idx) {\n              if (!isNaN(value)) {\n                var layout_2 = data.getItemLayout(idx);\n                var angle = layout_2.angle === minAngle ? minAngle : value * unitRadian;\n                layout_2.startAngle = currentAngle;\n                layout_2.endAngle = currentAngle + dir * angle;\n                currentAngle += dir * angle;\n              }\n            });\n          }\n        }\n      });\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function dataFilter(seriesType) {\n      return {\n        seriesType: seriesType,\n        reset: function (seriesModel, ecModel) {\n          var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n          });\n\n          if (!legendModels || !legendModels.length) {\n            return;\n          }\n\n          var data = seriesModel.getData();\n          data.filterSelf(function (idx) {\n            var name = data.getName(idx);\n\n            for (var i = 0; i < legendModels.length; i++) {\n              if (!legendModels[i].isSelected(name)) {\n                return false;\n              }\n            }\n\n            return true;\n          });\n        }\n      };\n    }\n\n    var RADIAN$1 = Math.PI / 180;\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n      if (list.length < 2) {\n        return;\n      }\n\n      function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n        var rB = semi.rB;\n        var rB2 = rB * rB;\n\n        for (var i = 0; i < semi.list.length; i++) {\n          var item = semi.list[i];\n          var dy = Math.abs(item.label.y - cy);\n          var rA = r + item.len;\n          var rA2 = rA * rA;\n          var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);\n          item.label.x = cx + (dx + item.len2) * dir;\n        }\n      }\n\n      function recalculateX(items) {\n        var topSemi = {\n          list: [],\n          maxY: 0\n        };\n        var bottomSemi = {\n          list: [],\n          maxY: 0\n        };\n\n        for (var i = 0; i < items.length; i++) {\n          if (items[i].labelAlignTo !== 'none') {\n            continue;\n          }\n\n          var item = items[i];\n          var semi = item.label.y > cy ? bottomSemi : topSemi;\n          var dy = Math.abs(item.label.y - cy);\n\n          if (dy > semi.maxY) {\n            var dx = item.label.x - cx - item.len2 * dir;\n            var rA = r + item.len;\n            var rB = dx < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n            semi.rB = rB;\n            semi.maxY = dy;\n          }\n\n          semi.list.push(item);\n        }\n\n        recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n        recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n      }\n\n      var len = list.length;\n\n      for (var i = 0; i < len; i++) {\n        if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n          var dx = list[i].label.x - farthestX;\n          list[i].linePoints[1][0] += dx;\n          list[i].label.x = farthestX;\n        }\n      }\n\n      if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {\n        recalculateX(list);\n      }\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n      var leftList = [];\n      var rightList = [];\n      var leftmostX = Number.MAX_VALUE;\n      var rightmostX = -Number.MAX_VALUE;\n\n      for (var i = 0; i < labelLayoutList.length; i++) {\n        var label = labelLayoutList[i].label;\n\n        if (isPositionCenter(labelLayoutList[i])) {\n          continue;\n        }\n\n        if (label.x < cx) {\n          leftmostX = Math.min(leftmostX, label.x);\n          leftList.push(labelLayoutList[i]);\n        } else {\n          rightmostX = Math.max(rightmostX, label.x);\n          rightList.push(labelLayoutList[i]);\n        }\n      }\n\n      adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n      adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n\n      for (var i = 0; i < labelLayoutList.length; i++) {\n        var layout = labelLayoutList[i];\n        var label = layout.label;\n\n        if (isPositionCenter(layout)) {\n          continue;\n        }\n\n        var linePoints = layout.linePoints;\n\n        if (linePoints) {\n          var isAlignToEdge = layout.labelAlignTo === 'edge';\n          var realTextWidth = layout.rect.width;\n          var targetTextWidth = void 0;\n\n          if (isAlignToEdge) {\n            if (label.x < cx) {\n              targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n            } else {\n              targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n            }\n          } else {\n            if (label.x < cx) {\n              targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n            } else {\n              targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n            }\n          }\n\n          if (targetTextWidth < layout.rect.width) {\n            layout.label.style.width = targetTextWidth;\n\n            if (layout.labelAlignTo === 'edge') {\n              realTextWidth = targetTextWidth;\n            }\n          }\n\n          var dist = linePoints[1][0] - linePoints[2][0];\n\n          if (isAlignToEdge) {\n            if (label.x < cx) {\n              linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n            } else {\n              linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n            }\n          } else {\n            if (label.x < cx) {\n              linePoints[2][0] = label.x + layout.labelDistance;\n            } else {\n              linePoints[2][0] = label.x - layout.labelDistance;\n            }\n\n            linePoints[1][0] = linePoints[2][0] + dist;\n          }\n\n          linePoints[1][1] = linePoints[2][1] = label.y;\n        }\n      }\n    }\n\n    function isPositionCenter(sectorShape) {\n      return sectorShape.position === 'center';\n    }\n\n    function pieLabelLayout(seriesModel) {\n      var data = seriesModel.getData();\n      var labelLayoutList = [];\n      var cx;\n      var cy;\n      var hasLabelRotate = false;\n      var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN$1;\n      var viewRect = data.getLayout('viewRect');\n      var r = data.getLayout('r');\n      var viewWidth = viewRect.width;\n      var viewLeft = viewRect.x;\n      var viewTop = viewRect.y;\n      var viewHeight = viewRect.height;\n\n      function setNotShow(el) {\n        el.ignore = true;\n      }\n\n      function isLabelShown(label) {\n        if (!label.ignore) {\n          return true;\n        }\n\n        for (var key in label.states) {\n          if (label.states[key].ignore === false) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      data.each(function (idx) {\n        var sector = data.getItemGraphicEl(idx);\n        var sectorShape = sector.shape;\n        var label = sector.getTextContent();\n        var labelLine = sector.getTextGuideLine();\n        var itemModel = data.getItemModel(idx);\n        var labelModel = itemModel.getModel('label');\n        var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n        var labelDistance = labelModel.get('distanceToLabelLine');\n        var labelAlignTo = labelModel.get('alignTo');\n        var edgeDistance = parsePercent$1(labelModel.get('edgeDistance'), viewWidth);\n        var bleedMargin = labelModel.get('bleedMargin');\n        var labelLineModel = itemModel.getModel('labelLine');\n        var labelLineLen = labelLineModel.get('length');\n        labelLineLen = parsePercent$1(labelLineLen, viewWidth);\n        var labelLineLen2 = labelLineModel.get('length2');\n        labelLineLen2 = parsePercent$1(labelLineLen2, viewWidth);\n\n        if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n          each(label.states, setNotShow);\n          label.ignore = true;\n          return;\n        }\n\n        if (!isLabelShown(label)) {\n          return;\n        }\n\n        var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n        var nx = Math.cos(midAngle);\n        var ny = Math.sin(midAngle);\n        var textX;\n        var textY;\n        var linePoints;\n        var textAlign;\n        cx = sectorShape.cx;\n        cy = sectorShape.cy;\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n        if (labelPosition === 'center') {\n          textX = sectorShape.cx;\n          textY = sectorShape.cy;\n          textAlign = 'center';\n        } else {\n          var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n          var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n          textX = x1 + nx * 3;\n          textY = y1 + ny * 3;\n\n          if (!isLabelInside) {\n            var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n            var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n            var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n            var y3 = y2;\n\n            if (labelAlignTo === 'edge') {\n              textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n            } else {\n              textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n            }\n\n            textY = y3;\n            linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n          }\n\n          textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n        }\n\n        var labelRotate;\n        var rotate = labelModel.get('rotate');\n\n        if (typeof rotate === 'number') {\n          labelRotate = rotate * (Math.PI / 180);\n        } else {\n          labelRotate = rotate ? nx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n        }\n\n        hasLabelRotate = !!labelRotate;\n        label.x = textX;\n        label.y = textY;\n        label.rotation = labelRotate;\n        label.setStyle({\n          verticalAlign: 'middle'\n        });\n\n        if (!isLabelInside) {\n          var textRect = label.getBoundingRect().clone();\n          textRect.applyTransform(label.getComputedTransform());\n          var margin = (label.style.margin || 0) + 2.1;\n          textRect.y -= margin / 2;\n          textRect.height += margin;\n          labelLayoutList.push({\n            label: label,\n            labelLine: labelLine,\n            position: labelPosition,\n            len: labelLineLen,\n            len2: labelLineLen2,\n            minTurnAngle: labelLineModel.get('minTurnAngle'),\n            maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n            surfaceNormal: new Point(nx, ny),\n            linePoints: linePoints,\n            textAlign: textAlign,\n            labelDistance: labelDistance,\n            labelAlignTo: labelAlignTo,\n            edgeDistance: edgeDistance,\n            bleedMargin: bleedMargin,\n            rect: textRect\n          });\n        } else {\n          label.setStyle({\n            align: textAlign\n          });\n          var selectState = label.states.select;\n\n          if (selectState) {\n            selectState.x += label.x;\n            selectState.y += label.y;\n          }\n        }\n\n        sector.setTextConfig({\n          inside: isLabelInside\n        });\n      });\n\n      if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n        avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n      }\n\n      for (var i = 0; i < labelLayoutList.length; i++) {\n        var layout = labelLayoutList[i];\n        var label = layout.label;\n        var labelLine = layout.labelLine;\n        var notShowLabel = isNaN(label.x) || isNaN(label.y);\n\n        if (label) {\n          label.setStyle({\n            align: layout.textAlign\n          });\n\n          if (notShowLabel) {\n            each(label.states, setNotShow);\n            label.ignore = true;\n          }\n\n          var selectState = label.states.select;\n\n          if (selectState) {\n            selectState.x += label.x;\n            selectState.y += label.y;\n          }\n        }\n\n        if (labelLine) {\n          var linePoints = layout.linePoints;\n\n          if (notShowLabel || !linePoints) {\n            each(labelLine.states, setNotShow);\n            labelLine.ignore = true;\n          } else {\n            limitTurnAngle(linePoints, layout.minTurnAngle);\n            limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n            labelLine.setShape({\n              points: linePoints\n            });\n            label.__hostTarget.textGuideLineConfig = {\n              anchor: new Point(linePoints[0][0], linePoints[0][1])\n            };\n          }\n        }\n      }\n    }\n\n    function getSectorCornerRadius(model, shape) {\n      var cornerRadius = model.get('borderRadius');\n\n      if (cornerRadius == null) {\n        return null;\n      }\n\n      if (!isArray(cornerRadius)) {\n        cornerRadius = [cornerRadius, cornerRadius];\n      }\n\n      return {\n        innerCornerRadius: parsePercent(cornerRadius[0], shape.r0),\n        cornerRadius: parsePercent(cornerRadius[1], shape.r)\n      };\n    }\n\n    var PiePiece = function (_super) {\n      __extends(PiePiece, _super);\n\n      function PiePiece(data, idx, startAngle) {\n        var _this = _super.call(this) || this;\n\n        _this.z2 = 2;\n        var polyline = new Polyline();\n        var text = new ZRText();\n\n        _this.setTextGuideLine(polyline);\n\n        _this.setTextContent(text);\n\n        _this.updateData(data, idx, startAngle, true);\n\n        return _this;\n      }\n\n      PiePiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {\n        var sector = this;\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var layout = data.getItemLayout(idx);\n        var sectorShape = extend(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout) || {}, layout);\n\n        if (firstCreate) {\n          sector.setShape(sectorShape);\n          var animationType = seriesModel.getShallow('animationType');\n\n          if (animationType === 'scale') {\n            sector.shape.r = layout.r0;\n            initProps(sector, {\n              shape: {\n                r: layout.r\n              }\n            }, seriesModel, idx);\n          } else {\n            if (startAngle != null) {\n              sector.setShape({\n                startAngle: startAngle,\n                endAngle: startAngle\n              });\n              initProps(sector, {\n                shape: {\n                  startAngle: layout.startAngle,\n                  endAngle: layout.endAngle\n                }\n              }, seriesModel, idx);\n            } else {\n              sector.shape.endAngle = layout.startAngle;\n              updateProps(sector, {\n                shape: {\n                  endAngle: layout.endAngle\n                }\n              }, seriesModel, idx);\n            }\n          }\n        } else {\n          updateProps(sector, {\n            shape: sectorShape\n          }, seriesModel, idx);\n        }\n\n        sector.useStyle(data.getItemVisual(idx, 'style'));\n        setStatesStylesFromModel(sector, itemModel);\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var offset = seriesModel.get('selectedOffset');\n        var dx = Math.cos(midAngle) * offset;\n        var dy = Math.sin(midAngle) * offset;\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && sector.attr('cursor', cursorStyle);\n\n        this._updateLabel(seriesModel, data, idx);\n\n        sector.ensureState('emphasis').shape = __assign({\n          r: layout.r + (emphasisModel.get('scale') ? emphasisModel.get('scaleSize') || 0 : 0)\n        }, getSectorCornerRadius(emphasisModel.getModel('itemStyle'), layout));\n        extend(sector.ensureState('select'), {\n          x: dx,\n          y: dy,\n          shape: getSectorCornerRadius(itemModel.getModel(['select', 'itemStyle']), layout)\n        });\n        extend(sector.ensureState('blur'), {\n          shape: getSectorCornerRadius(itemModel.getModel(['blur', 'itemStyle']), layout)\n        });\n        var labelLine = sector.getTextGuideLine();\n        var labelText = sector.getTextContent();\n        extend(labelLine.ensureState('select'), {\n          x: dx,\n          y: dy\n        });\n        extend(labelText.ensureState('select'), {\n          x: dx,\n          y: dy\n        });\n        enableHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n      };\n\n      PiePiece.prototype._updateLabel = function (seriesModel, data, idx) {\n        var sector = this;\n        var itemModel = data.getItemModel(idx);\n        var labelLineModel = itemModel.getModel('labelLine');\n        var style = data.getItemVisual(idx, 'style');\n        var visualColor = style && style.fill;\n        var visualOpacity = style && style.opacity;\n        setLabelStyle(sector, getLabelStatesModels(itemModel), {\n          labelFetcher: data.hostModel,\n          labelDataIndex: idx,\n          inheritColor: visualColor,\n          defaultOpacity: visualOpacity,\n          defaultText: seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx)\n        });\n        var labelText = sector.getTextContent();\n        sector.setTextConfig({\n          position: null,\n          rotation: null\n        });\n        labelText.attr({\n          z2: 10\n        });\n        setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {\n          stroke: visualColor,\n          opacity: retrieve3(labelLineModel.get(['lineStyle', 'opacity']), visualOpacity, 1)\n        });\n      };\n\n      return PiePiece;\n    }(Sector);\n\n    var PieView = function (_super) {\n      __extends(PieView, _super);\n\n      function PieView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.ignoreLabelLineUpdate = true;\n        return _this;\n      }\n\n      PieView.prototype.init = function () {\n        var sectorGroup = new Group();\n        this._sectorGroup = sectorGroup;\n      };\n\n      PieView.prototype.render = function (seriesModel, ecModel, api, payload) {\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var group = this.group;\n        var startAngle;\n\n        if (!oldData && data.count() > 0) {\n          var shape = data.getItemLayout(0);\n\n          for (var s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {\n            shape = data.getItemLayout(s);\n          }\n\n          if (shape) {\n            startAngle = shape.startAngle;\n          }\n        }\n\n        data.diff(oldData).add(function (idx) {\n          var piePiece = new PiePiece(data, idx, startAngle);\n          data.setItemGraphicEl(idx, piePiece);\n          group.add(piePiece);\n        }).update(function (newIdx, oldIdx) {\n          var piePiece = oldData.getItemGraphicEl(oldIdx);\n          piePiece.updateData(data, newIdx, startAngle);\n          piePiece.off('click');\n          group.add(piePiece);\n          data.setItemGraphicEl(newIdx, piePiece);\n        }).remove(function (idx) {\n          var piePiece = oldData.getItemGraphicEl(idx);\n          removeElementWithFadeOut(piePiece, seriesModel, idx);\n        }).execute();\n        pieLabelLayout(seriesModel);\n\n        if (seriesModel.get('animationTypeUpdate') !== 'expansion') {\n          this._data = data;\n        }\n      };\n\n      PieView.prototype.dispose = function () {};\n\n      PieView.prototype.containPoint = function (point, seriesModel) {\n        var data = seriesModel.getData();\n        var itemLayout = data.getItemLayout(0);\n\n        if (itemLayout) {\n          var dx = point[0] - itemLayout.cx;\n          var dy = point[1] - itemLayout.cy;\n          var radius = Math.sqrt(dx * dx + dy * dy);\n          return radius <= itemLayout.r && radius >= itemLayout.r0;\n        }\n      };\n\n      PieView.type = 'pie';\n      return PieView;\n    }(ChartView);\n\n    function createListSimply(seriesModel, opt, nameList) {\n      opt = isArray(opt) && {\n        coordDimensions: opt\n      } || extend({}, opt);\n      var source = seriesModel.getSource();\n      var dimensionsInfo = createDimensions(source, opt);\n      var list = new List(dimensionsInfo, seriesModel);\n      list.initData(source, nameList);\n      return list;\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var LegendVisualProvider = function () {\n      function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {\n        this._getDataWithEncodedVisual = getDataWithEncodedVisual;\n        this._getRawData = getRawData;\n      }\n\n      LegendVisualProvider.prototype.getAllNames = function () {\n        var rawData = this._getRawData();\n\n        return rawData.mapArray(rawData.getName);\n      };\n\n      LegendVisualProvider.prototype.containName = function (name) {\n        var rawData = this._getRawData();\n\n        return rawData.indexOfName(name) >= 0;\n      };\n\n      LegendVisualProvider.prototype.indexOfName = function (name) {\n        var dataWithEncodedVisual = this._getDataWithEncodedVisual();\n\n        return dataWithEncodedVisual.indexOfName(name);\n      };\n\n      LegendVisualProvider.prototype.getItemVisual = function (dataIndex, key) {\n        var dataWithEncodedVisual = this._getDataWithEncodedVisual();\n\n        return dataWithEncodedVisual.getItemVisual(dataIndex, key);\n      };\n\n      return LegendVisualProvider;\n    }();\n\n    var PieSeriesModel = function (_super) {\n      __extends(PieSeriesModel, _super);\n\n      function PieSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.useColorPaletteOnData = true;\n        return _this;\n      }\n\n      PieSeriesModel.prototype.init = function (option) {\n        _super.prototype.init.apply(this, arguments);\n\n        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this));\n\n        this._defaultLabelLine(option);\n      };\n\n      PieSeriesModel.prototype.mergeOption = function () {\n        _super.prototype.mergeOption.apply(this, arguments);\n      };\n\n      PieSeriesModel.prototype.getInitialData = function () {\n        return createListSimply(this, {\n          coordDimensions: ['value'],\n          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)\n        });\n      };\n\n      PieSeriesModel.prototype.getDataParams = function (dataIndex) {\n        var data = this.getData();\n\n        var params = _super.prototype.getDataParams.call(this, dataIndex);\n\n        var valueList = [];\n        data.each(data.mapDimension('value'), function (value) {\n          valueList.push(value);\n        });\n        params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'));\n        params.$vars.push('percent');\n        return params;\n      };\n\n      PieSeriesModel.prototype._defaultLabelLine = function (option) {\n        defaultEmphasis(option, 'labelLine', ['show']);\n        var labelLineNormalOpt = option.labelLine;\n        var labelLineEmphasisOpt = option.emphasis.labelLine;\n        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n      };\n\n      PieSeriesModel.type = 'series.pie';\n      PieSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        center: ['50%', '50%'],\n        radius: [0, '75%'],\n        clockwise: true,\n        startAngle: 90,\n        minAngle: 0,\n        minShowLabelAngle: 0,\n        selectedOffset: 10,\n        percentPrecision: 2,\n        stillShowZeroSum: true,\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        width: null,\n        height: null,\n        label: {\n          rotate: 0,\n          show: true,\n          overflow: 'truncate',\n          position: 'outer',\n          alignTo: 'none',\n          edgeDistance: '25%',\n          bleedMargin: 10,\n          distanceToLabelLine: 5\n        },\n        labelLine: {\n          show: true,\n          length: 15,\n          length2: 15,\n          smooth: false,\n          minTurnAngle: 90,\n          maxSurfaceAngle: 90,\n          lineStyle: {\n            width: 1,\n            type: 'solid'\n          }\n        },\n        itemStyle: {\n          borderWidth: 1\n        },\n        labelLayout: {\n          hideOverlap: true\n        },\n        emphasis: {\n          scale: true,\n          scaleSize: 5\n        },\n        avoidLabelOverlap: true,\n        animationType: 'expansion',\n        animationDuration: 1000,\n        animationTypeUpdate: 'transition',\n        animationEasingUpdate: 'cubicInOut',\n        animationDurationUpdate: 500,\n        animationEasing: 'cubicInOut'\n      };\n      return PieSeriesModel;\n    }(SeriesModel);\n\n    function install$4(registers) {\n      registers.registerChartView(PieView);\n      registers.registerSeriesModel(PieSeriesModel);\n      createLegacyDataSelectAction('pie', registers.registerAction);\n      registers.registerLayout(curry(pieLayout, 'pie'));\n      registers.registerProcessor(dataFilter('pie'));\n    }\n\n    var ScatterSeriesModel = function (_super) {\n      __extends(ScatterSeriesModel, _super);\n\n      function ScatterSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ScatterSeriesModel.type;\n        _this.hasSymbolVisual = true;\n        return _this;\n      }\n\n      ScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: true\n        });\n      };\n\n      ScatterSeriesModel.prototype.getProgressive = function () {\n        var progressive = this.option.progressive;\n\n        if (progressive == null) {\n          return this.option.large ? 5e3 : this.get('progressive');\n        }\n\n        return progressive;\n      };\n\n      ScatterSeriesModel.prototype.getProgressiveThreshold = function () {\n        var progressiveThreshold = this.option.progressiveThreshold;\n\n        if (progressiveThreshold == null) {\n          return this.option.large ? 1e4 : this.get('progressiveThreshold');\n        }\n\n        return progressiveThreshold;\n      };\n\n      ScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n        return selectors.point(data.getItemLayout(dataIndex));\n      };\n\n      ScatterSeriesModel.type = 'series.scatter';\n      ScatterSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n      ScatterSeriesModel.defaultOption = {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        symbolSize: 10,\n        large: false,\n        largeThreshold: 2000,\n        itemStyle: {\n          opacity: 0.8\n        },\n        emphasis: {\n          scale: true\n        },\n        clip: true,\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        }\n      };\n      return ScatterSeriesModel;\n    }(SeriesModel);\n\n    var BOOST_SIZE_THRESHOLD = 4;\n\n    var LargeSymbolPathShape = function () {\n      function LargeSymbolPathShape() {}\n\n      return LargeSymbolPathShape;\n    }();\n\n    var LargeSymbolPath = function (_super) {\n      __extends(LargeSymbolPath, _super);\n\n      function LargeSymbolPath(opts) {\n        return _super.call(this, opts) || this;\n      }\n\n      LargeSymbolPath.prototype.getDefaultShape = function () {\n        return new LargeSymbolPathShape();\n      };\n\n      LargeSymbolPath.prototype.buildPath = function (path, shape) {\n        var points = shape.points;\n        var size = shape.size;\n        var symbolProxy = this.symbolProxy;\n        var symbolProxyShape = symbolProxy.shape;\n        var ctx = path.getContext ? path.getContext() : path;\n        var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;\n\n        if (canBoost) {\n          this._ctx = ctx;\n          return;\n        }\n\n        this._ctx = null;\n\n        for (var i = 0; i < points.length;) {\n          var x = points[i++];\n          var y = points[i++];\n\n          if (isNaN(x) || isNaN(y)) {\n            continue;\n          }\n\n          if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n            continue;\n          }\n\n          symbolProxyShape.x = x - size[0] / 2;\n          symbolProxyShape.y = y - size[1] / 2;\n          symbolProxyShape.width = size[0];\n          symbolProxyShape.height = size[1];\n          symbolProxy.buildPath(path, symbolProxyShape, true);\n        }\n      };\n\n      LargeSymbolPath.prototype.afterBrush = function () {\n        var shape = this.shape;\n        var points = shape.points;\n        var size = shape.size;\n        var ctx = this._ctx;\n\n        if (!ctx) {\n          return;\n        }\n\n        for (var i = 0; i < points.length;) {\n          var x = points[i++];\n          var y = points[i++];\n\n          if (isNaN(x) || isNaN(y)) {\n            continue;\n          }\n\n          if (this.softClipShape && !this.softClipShape.contain(x, y)) {\n            continue;\n          }\n\n          ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);\n        }\n      };\n\n      LargeSymbolPath.prototype.findDataIndex = function (x, y) {\n        var shape = this.shape;\n        var points = shape.points;\n        var size = shape.size;\n        var w = Math.max(size[0], 4);\n        var h = Math.max(size[1], 4);\n\n        for (var idx = points.length / 2 - 1; idx >= 0; idx--) {\n          var i = idx * 2;\n          var x0 = points[i] - w / 2;\n          var y0 = points[i + 1] - h / 2;\n\n          if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {\n            return idx;\n          }\n        }\n\n        return -1;\n      };\n\n      return LargeSymbolPath;\n    }(Path);\n\n    var LargeSymbolDraw = function () {\n      function LargeSymbolDraw() {\n        this.group = new Group();\n      }\n\n      LargeSymbolDraw.prototype.isPersistent = function () {\n        return !this._incremental;\n      };\n\n      LargeSymbolDraw.prototype.updateData = function (data, opt) {\n        this.group.removeAll();\n        var symbolEl = new LargeSymbolPath({\n          rectHover: true,\n          cursor: 'default'\n        });\n        symbolEl.setShape({\n          points: data.getLayout('points')\n        });\n\n        this._setCommon(symbolEl, data, false, opt);\n\n        this.group.add(symbolEl);\n        this._incremental = null;\n      };\n\n      LargeSymbolDraw.prototype.updateLayout = function (data) {\n        if (this._incremental) {\n          return;\n        }\n\n        var points = data.getLayout('points');\n        this.group.eachChild(function (child) {\n          if (child.startIndex != null) {\n            var len = (child.endIndex - child.startIndex) * 2;\n            var byteOffset = child.startIndex * 4 * 2;\n            points = new Float32Array(points.buffer, byteOffset, len);\n          }\n\n          child.setShape('points', points);\n        });\n      };\n\n      LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {\n        this.group.removeAll();\n\n        this._clearIncremental();\n\n        if (data.count() > 2e6) {\n          if (!this._incremental) {\n            this._incremental = new IncrementalDisplayable({\n              silent: true\n            });\n          }\n\n          this.group.add(this._incremental);\n        } else {\n          this._incremental = null;\n        }\n      };\n\n      LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {\n        var symbolEl;\n\n        if (this._incremental) {\n          symbolEl = new LargeSymbolPath();\n\n          this._incremental.addDisplayable(symbolEl, true);\n        } else {\n          symbolEl = new LargeSymbolPath({\n            rectHover: true,\n            cursor: 'default',\n            startIndex: taskParams.start,\n            endIndex: taskParams.end\n          });\n          symbolEl.incremental = true;\n          this.group.add(symbolEl);\n        }\n\n        symbolEl.setShape({\n          points: data.getLayout('points')\n        });\n\n        this._setCommon(symbolEl, data, !!this._incremental, opt);\n      };\n\n      LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, isIncremental, opt) {\n        var hostModel = data.hostModel;\n        opt = opt || {};\n        var size = data.getVisual('symbolSize');\n        symbolEl.setShape('size', size instanceof Array ? size : [size, size]);\n        symbolEl.softClipShape = opt.clipShape || null;\n        symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0);\n        symbolEl.setColor = symbolEl.symbolProxy.setColor;\n        var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;\n        symbolEl.useStyle(hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']));\n        var globalStyle = data.getVisual('style');\n        var visualColor = globalStyle && globalStyle.fill;\n\n        if (visualColor) {\n          symbolEl.setColor(visualColor);\n        }\n\n        if (!isIncremental) {\n          var ecData_1 = getECData(symbolEl);\n          ecData_1.seriesIndex = hostModel.seriesIndex;\n          symbolEl.on('mousemove', function (e) {\n            ecData_1.dataIndex = null;\n            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);\n\n            if (dataIndex >= 0) {\n              ecData_1.dataIndex = dataIndex + (symbolEl.startIndex || 0);\n            }\n          });\n        }\n      };\n\n      LargeSymbolDraw.prototype.remove = function () {\n        this._clearIncremental();\n\n        this._incremental = null;\n        this.group.removeAll();\n      };\n\n      LargeSymbolDraw.prototype._clearIncremental = function () {\n        var incremental = this._incremental;\n\n        if (incremental) {\n          incremental.clearDisplaybles();\n        }\n      };\n\n      return LargeSymbolDraw;\n    }();\n\n    var ScatterView = function (_super) {\n      __extends(ScatterView, _super);\n\n      function ScatterView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ScatterView.type;\n        return _this;\n      }\n\n      ScatterView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n\n        var symbolDraw = this._updateSymbolDraw(data, seriesModel);\n\n        symbolDraw.updateData(data, {\n          clipShape: this._getClipShape(seriesModel)\n        });\n        this._finished = true;\n      };\n\n      ScatterView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n\n        var symbolDraw = this._updateSymbolDraw(data, seriesModel);\n\n        symbolDraw.incrementalPrepareUpdate(data);\n        this._finished = false;\n      };\n\n      ScatterView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n        this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {\n          clipShape: this._getClipShape(seriesModel)\n        });\n\n        this._finished = taskParams.end === seriesModel.getData().count();\n      };\n\n      ScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        this.group.dirty();\n\n        if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {\n          return {\n            update: true\n          };\n        } else {\n          var res = pointsLayout('').reset(seriesModel, ecModel, api);\n\n          if (res.progress) {\n            res.progress({\n              start: 0,\n              end: data.count(),\n              count: data.count()\n            }, data);\n          }\n\n          this._symbolDraw.updateLayout(data);\n        }\n      };\n\n      ScatterView.prototype._getClipShape = function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var clipArea = coordSys && coordSys.getArea && coordSys.getArea();\n        return seriesModel.get('clip', true) ? clipArea : null;\n      };\n\n      ScatterView.prototype._updateSymbolDraw = function (data, seriesModel) {\n        var symbolDraw = this._symbolDraw;\n        var pipelineContext = seriesModel.pipelineContext;\n        var isLargeDraw = pipelineContext.large;\n\n        if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {\n          symbolDraw && symbolDraw.remove();\n          symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();\n          this._isLargeDraw = isLargeDraw;\n          this.group.removeAll();\n        }\n\n        this.group.add(symbolDraw.group);\n        return symbolDraw;\n      };\n\n      ScatterView.prototype.remove = function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove(true);\n        this._symbolDraw = null;\n      };\n\n      ScatterView.prototype.dispose = function () {};\n\n      ScatterView.type = 'scatter';\n      return ScatterView;\n    }(ChartView);\n\n    var GridModel = function (_super) {\n      __extends(GridModel, _super);\n\n      function GridModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GridModel.type = 'grid';\n      GridModel.dependencies = ['xAxis', 'yAxis'];\n      GridModel.layoutMode = 'box';\n      GridModel.defaultOption = {\n        show: false,\n        zlevel: 0,\n        z: 0,\n        left: '10%',\n        top: 60,\n        right: '10%',\n        bottom: 70,\n        containLabel: false,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderWidth: 1,\n        borderColor: '#ccc'\n      };\n      return GridModel;\n    }(ComponentModel);\n\n    var CartesianAxisModel = function (_super) {\n      __extends(CartesianAxisModel, _super);\n\n      function CartesianAxisModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      CartesianAxisModel.prototype.getCoordSysModel = function () {\n        return this.getReferringComponents('grid', SINGLE_REFERRING).models[0];\n      };\n\n      CartesianAxisModel.type = 'cartesian2dAxis';\n      return CartesianAxisModel;\n    }(ComponentModel);\n    mixin(CartesianAxisModel, AxisModelCommonMixin);\n\n    var defaultOption = {\n      show: true,\n      zlevel: 0,\n      z: 0,\n      inverse: false,\n      name: '',\n      nameLocation: 'end',\n      nameRotate: null,\n      nameTruncate: {\n        maxWidth: null,\n        ellipsis: '...',\n        placeholder: '.'\n      },\n      nameTextStyle: {},\n      nameGap: 15,\n      silent: false,\n      triggerEvent: false,\n      tooltip: {\n        show: false\n      },\n      axisPointer: {},\n      axisLine: {\n        show: true,\n        onZero: true,\n        onZeroAxisIndex: null,\n        lineStyle: {\n          color: '#6E7079',\n          width: 1,\n          type: 'solid'\n        },\n        symbol: ['none', 'none'],\n        symbolSize: [10, 15]\n      },\n      axisTick: {\n        show: true,\n        inside: false,\n        length: 5,\n        lineStyle: {\n          width: 1\n        }\n      },\n      axisLabel: {\n        show: true,\n        inside: false,\n        rotate: 0,\n        showMinLabel: null,\n        showMaxLabel: null,\n        margin: 8,\n        fontSize: 12\n      },\n      splitLine: {\n        show: true,\n        lineStyle: {\n          color: ['#E0E6F1'],\n          width: 1,\n          type: 'solid'\n        }\n      },\n      splitArea: {\n        show: false,\n        areaStyle: {\n          color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']\n        }\n      }\n    };\n    var categoryAxis = merge({\n      boundaryGap: true,\n      deduplication: null,\n      splitLine: {\n        show: false\n      },\n      axisTick: {\n        alignWithLabel: false,\n        interval: 'auto'\n      },\n      axisLabel: {\n        interval: 'auto'\n      }\n    }, defaultOption);\n    var valueAxis = merge({\n      boundaryGap: [0, 0],\n      axisLine: {\n        show: 'auto'\n      },\n      axisTick: {\n        show: 'auto'\n      },\n      splitNumber: 5,\n      minorTick: {\n        show: false,\n        splitNumber: 5,\n        length: 3,\n        lineStyle: {}\n      },\n      minorSplitLine: {\n        show: false,\n        lineStyle: {\n          color: '#F4F7FD',\n          width: 1\n        }\n      }\n    }, defaultOption);\n    var timeAxis = merge({\n      scale: true,\n      splitNumber: 6,\n      axisLabel: {\n        showMinLabel: false,\n        showMaxLabel: false,\n        rich: {\n          primary: {\n            fontWeight: 'bold'\n          }\n        }\n      },\n      splitLine: {\n        show: false\n      }\n    }, valueAxis);\n    var logAxis = defaults({\n      scale: true,\n      logBase: 10\n    }, valueAxis);\n    var axisDefault = {\n      category: categoryAxis,\n      value: valueAxis,\n      time: timeAxis,\n      log: logAxis\n    };\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var AXIS_TYPES = {\n      value: 1,\n      category: 1,\n      time: 1,\n      log: 1\n    };\n\n    function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {\n      each(AXIS_TYPES, function (v, axisType) {\n        var defaultOption = merge(merge({}, axisDefault[axisType], true), extraDefaultOption, true);\n\n        var AxisModel = function (_super) {\n          __extends(AxisModel, _super);\n\n          function AxisModel() {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            var _this = _super.apply(this, args) || this;\n\n            _this.type = axisName + 'Axis.' + axisType;\n            return _this;\n          }\n\n          AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {\n            var layoutMode = fetchLayoutMode(this);\n            var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n            var themeModel = ecModel.getTheme();\n            merge(option, themeModel.get(axisType + 'Axis'));\n            merge(option, this.getDefaultOption());\n            option.type = getAxisType(option);\n\n            if (layoutMode) {\n              mergeLayoutParam(option, inputPositionParams, layoutMode);\n            }\n          };\n\n          AxisModel.prototype.optionUpdated = function () {\n            var thisOption = this.option;\n\n            if (thisOption.type === 'category') {\n              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n            }\n          };\n\n          AxisModel.prototype.getCategories = function (rawData) {\n            var option = this.option;\n\n            if (option.type === 'category') {\n              if (rawData) {\n                return option.data;\n              }\n\n              return this.__ordinalMeta.categories;\n            }\n          };\n\n          AxisModel.prototype.getOrdinalMeta = function () {\n            return this.__ordinalMeta;\n          };\n\n          AxisModel.type = axisName + 'Axis.' + axisType;\n          AxisModel.defaultOption = defaultOption;\n          return AxisModel;\n        }(BaseAxisModelClass);\n\n        registers.registerComponentModel(AxisModel);\n      });\n      registers.registerSubTypeDefaulter(axisName + 'Axis', getAxisType);\n    }\n\n    function getAxisType(option) {\n      return option.type || (option.data ? 'category' : 'value');\n    }\n\n    var Cartesian = function () {\n      function Cartesian(name) {\n        this.type = 'cartesian';\n        this._dimList = [];\n        this._axes = {};\n        this.name = name || '';\n      }\n\n      Cartesian.prototype.getAxis = function (dim) {\n        return this._axes[dim];\n      };\n\n      Cartesian.prototype.getAxes = function () {\n        return map(this._dimList, function (dim) {\n          return this._axes[dim];\n        }, this);\n      };\n\n      Cartesian.prototype.getAxesByScale = function (scaleType) {\n        scaleType = scaleType.toLowerCase();\n        return filter(this.getAxes(), function (axis) {\n          return axis.scale.type === scaleType;\n        });\n      };\n\n      Cartesian.prototype.addAxis = function (axis) {\n        var dim = axis.dim;\n        this._axes[dim] = axis;\n\n        this._dimList.push(dim);\n      };\n\n      return Cartesian;\n    }();\n\n    var cartesian2DDimensions = ['x', 'y'];\n\n    function canCalculateAffineTransform(scale) {\n      return scale.type === 'interval' || scale.type === 'time';\n    }\n\n    var Cartesian2D = function (_super) {\n      __extends(Cartesian2D, _super);\n\n      function Cartesian2D() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'cartesian2d';\n        _this.dimensions = cartesian2DDimensions;\n        return _this;\n      }\n\n      Cartesian2D.prototype.calcAffineTransform = function () {\n        this._transform = this._invTransform = null;\n        var xAxisScale = this.getAxis('x').scale;\n        var yAxisScale = this.getAxis('y').scale;\n\n        if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n          return;\n        }\n\n        var xScaleExtent = xAxisScale.getExtent();\n        var yScaleExtent = yAxisScale.getExtent();\n        var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n        var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n        var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n        var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n        if (!xScaleSpan || !yScaleSpan) {\n          return;\n        }\n\n        var scaleX = (end[0] - start[0]) / xScaleSpan;\n        var scaleY = (end[1] - start[1]) / yScaleSpan;\n        var translateX = start[0] - xScaleExtent[0] * scaleX;\n        var translateY = start[1] - yScaleExtent[0] * scaleY;\n        var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n        this._invTransform = invert([], m);\n      };\n\n      Cartesian2D.prototype.getBaseAxis = function () {\n        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n      };\n\n      Cartesian2D.prototype.containPoint = function (point) {\n        var axisX = this.getAxis('x');\n        var axisY = this.getAxis('y');\n        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n      };\n\n      Cartesian2D.prototype.containData = function (data) {\n        return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n      };\n\n      Cartesian2D.prototype.dataToPoint = function (data, reserved, out) {\n        out = out || [];\n        var xVal = data[0];\n        var yVal = data[1];\n\n        if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n          return applyTransform(out, data, this._transform);\n        }\n\n        var xAxis = this.getAxis('x');\n        var yAxis = this.getAxis('y');\n        out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal));\n        out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal));\n        return out;\n      };\n\n      Cartesian2D.prototype.clampData = function (data, out) {\n        var xScale = this.getAxis('x').scale;\n        var yScale = this.getAxis('y').scale;\n        var xAxisExtent = xScale.getExtent();\n        var yAxisExtent = yScale.getExtent();\n        var x = xScale.parse(data[0]);\n        var y = yScale.parse(data[1]);\n        out = out || [];\n        out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n        out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n        return out;\n      };\n\n      Cartesian2D.prototype.pointToData = function (point, out) {\n        out = out || [];\n\n        if (this._invTransform) {\n          return applyTransform(out, point, this._invTransform);\n        }\n\n        var xAxis = this.getAxis('x');\n        var yAxis = this.getAxis('y');\n        out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n        out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n        return out;\n      };\n\n      Cartesian2D.prototype.getOtherAxis = function (axis) {\n        return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n      };\n\n      Cartesian2D.prototype.getArea = function () {\n        var xExtent = this.getAxis('x').getGlobalExtent();\n        var yExtent = this.getAxis('y').getGlobalExtent();\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        return new BoundingRect(x, y, width, height);\n      };\n\n      return Cartesian2D;\n    }(Cartesian);\n\n    var Axis2D = function (_super) {\n      __extends(Axis2D, _super);\n\n      function Axis2D(dim, scale, coordExtent, axisType, position) {\n        var _this = _super.call(this, dim, scale, coordExtent) || this;\n\n        _this.index = 0;\n        _this.type = axisType || 'value';\n        _this.position = position || 'bottom';\n        return _this;\n      }\n\n      Axis2D.prototype.isHorizontal = function () {\n        var position = this.position;\n        return position === 'top' || position === 'bottom';\n      };\n\n      Axis2D.prototype.getGlobalExtent = function (asc) {\n        var ret = this.getExtent();\n        ret[0] = this.toGlobalCoord(ret[0]);\n        ret[1] = this.toGlobalCoord(ret[1]);\n        asc && ret[0] > ret[1] && ret.reverse();\n        return ret;\n      };\n\n      Axis2D.prototype.pointToData = function (point, clamp) {\n        return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n      };\n\n      Axis2D.prototype.setCategorySortInfo = function (info) {\n        if (this.type !== 'category') {\n          return false;\n        }\n\n        this.model.option.categorySortInfo = info;\n        this.scale.setSortInfo(info);\n      };\n\n      return Axis2D;\n    }(Axis);\n\n    function layout$1(gridModel, axisModel, opt) {\n      opt = opt || {};\n      var grid = gridModel.coordinateSystem;\n      var axis = axisModel.axis;\n      var layout = {};\n      var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];\n      var rawAxisPosition = axis.position;\n      var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;\n      var axisDim = axis.dim;\n      var rect = grid.getRect();\n      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n      var idx = {\n        left: 0,\n        right: 1,\n        top: 0,\n        bottom: 1,\n        onZero: 2\n      };\n      var axisOffset = axisModel.get('offset') || 0;\n      var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];\n\n      if (otherAxisOnZeroOf) {\n        var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));\n        posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);\n      }\n\n      layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]];\n      layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n      var dirMap = {\n        top: -1,\n        bottom: 1,\n        left: -1,\n        right: 1\n      };\n      layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n      layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;\n\n      if (axisModel.get(['axisTick', 'inside'])) {\n        layout.tickDirection = -layout.tickDirection;\n      }\n\n      if (retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {\n        layout.labelDirection = -layout.labelDirection;\n      }\n\n      var labelRotate = axisModel.get(['axisLabel', 'rotate']);\n      layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;\n      layout.z2 = 1;\n      return layout;\n    }\n    function isCartesian2DSeries(seriesModel) {\n      return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n    function findAxisModels(seriesModel) {\n      var axisModelMap = {\n        xAxisModel: null,\n        yAxisModel: null\n      };\n      each(axisModelMap, function (v, key) {\n        var axisType = key.replace(/Model$/, '');\n        var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];\n\n        if (\"development\" !== 'production') {\n          if (!axisModel) {\n            throw new Error(axisType + ' \"' + retrieve3(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '\" not found');\n          }\n        }\n\n        axisModelMap[key] = axisModel;\n      });\n      return axisModelMap;\n    }\n\n    var Grid = function () {\n      function Grid(gridModel, ecModel, api) {\n        this.type = 'grid';\n        this._coordsMap = {};\n        this._coordsList = [];\n        this._axesMap = {};\n        this._axesList = [];\n        this.axisPointerEnabled = true;\n        this.dimensions = cartesian2DDimensions;\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this.model = gridModel;\n      }\n\n      Grid.prototype.getRect = function () {\n        return this._rect;\n      };\n\n      Grid.prototype.update = function (ecModel, api) {\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this.model);\n\n        each(axesMap.x, function (xAxis) {\n          niceScaleExtent(xAxis.scale, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n          niceScaleExtent(yAxis.scale, yAxis.model);\n        });\n        var onZeroRecords = {};\n        each(axesMap.x, function (xAxis) {\n          fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);\n        });\n        each(axesMap.y, function (yAxis) {\n          fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);\n        });\n        this.resize(this.model, api);\n      };\n\n      Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {\n        var boxLayoutParams = gridModel.getBoxLayoutParams();\n        var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');\n        var gridRect = getLayoutRect(boxLayoutParams, {\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n        this._rect = gridRect;\n        var axesList = this._axesList;\n        adjustAxes();\n\n        if (isContainLabel) {\n          each(axesList, function (axis) {\n            if (!axis.model.get(['axisLabel', 'inside'])) {\n              var labelUnionRect = estimateLabelUnionRect(axis);\n\n              if (labelUnionRect) {\n                var dim = axis.isHorizontal() ? 'height' : 'width';\n                var margin = axis.model.get(['axisLabel', 'margin']);\n                gridRect[dim] -= labelUnionRect[dim] + margin;\n\n                if (axis.position === 'top') {\n                  gridRect.y += labelUnionRect.height + margin;\n                } else if (axis.position === 'left') {\n                  gridRect.x += labelUnionRect.width + margin;\n                }\n              }\n            }\n          });\n          adjustAxes();\n        }\n\n        each(this._coordsList, function (coord) {\n          coord.calcAffineTransform();\n        });\n\n        function adjustAxes() {\n          each(axesList, function (axis) {\n            var isHorizontal = axis.isHorizontal();\n            var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n            var idx = axis.inverse ? 1 : 0;\n            axis.setExtent(extent[idx], extent[1 - idx]);\n            updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n          });\n        }\n      };\n\n      Grid.prototype.getAxis = function (dim, axisIndex) {\n        var axesMapOnDim = this._axesMap[dim];\n\n        if (axesMapOnDim != null) {\n          return axesMapOnDim[axisIndex || 0];\n        }\n      };\n\n      Grid.prototype.getAxes = function () {\n        return this._axesList.slice();\n      };\n\n      Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n          var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n          return this._coordsMap[key];\n        }\n\n        if (isObject(xAxisIndex)) {\n          yAxisIndex = xAxisIndex.yAxisIndex;\n          xAxisIndex = xAxisIndex.xAxisIndex;\n        }\n\n        for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n          if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n            return coordList[i];\n          }\n        }\n      };\n\n      Grid.prototype.getCartesians = function () {\n        return this._coordsList.slice();\n      };\n\n      Grid.prototype.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(finder);\n\n        return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n      };\n\n      Grid.prototype.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(finder);\n\n        return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n      };\n\n      Grid.prototype._findConvertTarget = function (finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n        var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n          cartesian = seriesModel.coordinateSystem;\n          indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        } else if (xAxisModel && yAxisModel) {\n          cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        } else if (xAxisModel) {\n          axis = this.getAxis('x', xAxisModel.componentIndex);\n        } else if (yAxisModel) {\n          axis = this.getAxis('y', yAxisModel.componentIndex);\n        } else if (gridModel) {\n          var grid = gridModel.coordinateSystem;\n\n          if (grid === this) {\n            cartesian = this._coordsList[0];\n          }\n        }\n\n        return {\n          cartesian: cartesian,\n          axis: axis\n        };\n      };\n\n      Grid.prototype.containPoint = function (point) {\n        var coord = this._coordsList[0];\n\n        if (coord) {\n          return coord.containPoint(point);\n        }\n      };\n\n      Grid.prototype._initCartesian = function (gridModel, ecModel, api) {\n        var _this = this;\n\n        var grid = this;\n        var axisPositionUsed = {\n          left: false,\n          right: false,\n          top: false,\n          bottom: false\n        };\n        var axesMap = {\n          x: {},\n          y: {}\n        };\n        var axesCount = {\n          x: 0,\n          y: 0\n        };\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n          this._axesMap = {};\n          this._axesList = [];\n          return;\n        }\n\n        this._axesMap = axesMap;\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n          each(axesMap.y, function (yAxis, yAxisIndex) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            var cartesian = new Cartesian2D(key);\n            cartesian.master = _this;\n            cartesian.model = gridModel;\n            _this._coordsMap[key] = cartesian;\n\n            _this._coordsList.push(cartesian);\n\n            cartesian.addAxis(xAxis);\n            cartesian.addAxis(yAxis);\n          });\n        });\n\n        function createAxisCreator(dimName) {\n          return function (axisModel, idx) {\n            if (!isAxisUsedInTheGrid(axisModel, gridModel)) {\n              return;\n            }\n\n            var axisPosition = axisModel.get('position');\n\n            if (dimName === 'x') {\n              if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';\n              }\n            } else {\n              if (axisPosition !== 'left' && axisPosition !== 'right') {\n                axisPosition = axisPositionUsed.left ? 'right' : 'left';\n              }\n            }\n\n            axisPositionUsed[axisPosition] = true;\n            var axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n            var isCategory = axis.type === 'category';\n            axis.onBand = isCategory && axisModel.get('boundaryGap');\n            axis.inverse = axisModel.get('inverse');\n            axisModel.axis = axis;\n            axis.model = axisModel;\n            axis.grid = grid;\n            axis.index = idx;\n\n            grid._axesList.push(axis);\n\n            axesMap[dimName][idx] = axis;\n            axesCount[dimName]++;\n          };\n        }\n      };\n\n      Grid.prototype._updateScale = function (ecModel, gridModel) {\n        each(this._axesList, function (axis) {\n          axis.scale.setExtent(Infinity, -Infinity);\n\n          if (axis.type === 'category') {\n            var categorySortInfo = axis.model.get('categorySortInfo');\n            axis.scale.setSortInfo(categorySortInfo);\n          }\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          if (isCartesian2DSeries(seriesModel)) {\n            var axesModelMap = findAxisModels(seriesModel);\n            var xAxisModel = axesModelMap.xAxisModel;\n            var yAxisModel = axesModelMap.yAxisModel;\n\n            if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {\n              return;\n            }\n\n            var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n            var data = seriesModel.getData();\n            var xAxis = cartesian.getAxis('x');\n            var yAxis = cartesian.getAxis('y');\n\n            if (data.type === 'list') {\n              unionExtent(data, xAxis);\n              unionExtent(data, yAxis);\n            }\n          }\n        }, this);\n\n        function unionExtent(data, axis) {\n          each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {\n            axis.scale.unionExtentFromData(data, dim);\n          });\n        }\n      };\n\n      Grid.prototype.getTooltipAxes = function (dim) {\n        var baseAxes = [];\n        var otherAxes = [];\n        each(this.getCartesians(), function (cartesian) {\n          var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n          var otherAxis = cartesian.getOtherAxis(baseAxis);\n          indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n          indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n        });\n        return {\n          baseAxes: baseAxes,\n          otherAxes: otherAxes\n        };\n      };\n\n      Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n          var grid = new Grid(gridModel, ecModel, api);\n          grid.name = 'grid_' + idx;\n          grid.resize(gridModel, api, true);\n          gridModel.coordinateSystem = grid;\n          grids.push(grid);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          if (!isCartesian2DSeries(seriesModel)) {\n            return;\n          }\n\n          var axesModelMap = findAxisModels(seriesModel);\n          var xAxisModel = axesModelMap.xAxisModel;\n          var yAxisModel = axesModelMap.yAxisModel;\n          var gridModel = xAxisModel.getCoordSysModel();\n\n          if (\"development\" !== 'production') {\n            if (!gridModel) {\n              throw new Error('Grid \"' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '\" not found');\n            }\n\n            if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {\n              throw new Error('xAxis and yAxis must use the same grid');\n            }\n          }\n\n          var grid = gridModel.coordinateSystem;\n          seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        });\n        return grids;\n      };\n\n      Grid.dimensions = cartesian2DDimensions;\n      return Grid;\n    }();\n\n    function isAxisUsedInTheGrid(axisModel, gridModel) {\n      return axisModel.getCoordSysModel() === gridModel;\n    }\n\n    function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {\n      axis.getAxesOnZeroOf = function () {\n        return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];\n      };\n\n      var otherAxes = axesMap[otherAxisDim];\n      var otherAxisOnZeroOf;\n      var axisModel = axis.model;\n      var onZero = axisModel.get(['axisLine', 'onZero']);\n      var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);\n\n      if (!onZero) {\n        return;\n      }\n\n      if (onZeroAxisIndex != null) {\n        if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n          otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];\n        }\n      } else {\n        for (var idx in otherAxes) {\n          if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {\n            otherAxisOnZeroOf = otherAxes[idx];\n            break;\n          }\n        }\n      }\n\n      if (otherAxisOnZeroOf) {\n        onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;\n      }\n\n      function getOnZeroRecordKey(axis) {\n        return axis.dim + '_' + axis.index;\n      }\n    }\n\n    function canOnZeroToAxis(axis) {\n      return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n    }\n\n    function updateAxisTransform(axis, coordBase) {\n      var axisExtent = axis.getExtent();\n      var axisExtentSum = axisExtent[0] + axisExtent[1];\n      axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n        return coord + coordBase;\n      } : function (coord) {\n        return axisExtentSum - coord + coordBase;\n      };\n      axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n        return coord - coordBase;\n      } : function (coord) {\n        return axisExtentSum - coord + coordBase;\n      };\n    }\n\n    var PI$5 = Math.PI;\n\n    var AxisBuilder = function () {\n      function AxisBuilder(axisModel, opt) {\n        this.group = new Group();\n        this.opt = opt;\n        this.axisModel = axisModel;\n        defaults(opt, {\n          labelOffset: 0,\n          nameDirection: 1,\n          tickDirection: 1,\n          labelDirection: 1,\n          silent: true,\n          handleAutoShown: function () {\n            return true;\n          }\n        });\n        var transformGroup = new Group({\n          x: opt.position[0],\n          y: opt.position[1],\n          rotation: opt.rotation\n        });\n        transformGroup.updateTransform();\n        this._transformGroup = transformGroup;\n      }\n\n      AxisBuilder.prototype.hasBuilder = function (name) {\n        return !!builders[name];\n      };\n\n      AxisBuilder.prototype.add = function (name) {\n        builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n      };\n\n      AxisBuilder.prototype.getGroup = function () {\n        return this.group;\n      };\n\n      AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - axisRotation);\n        var textAlign;\n        var textVerticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) {\n          textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n          textAlign = 'center';\n        } else if (isRadianAroundZero(rotationDiff - PI$5)) {\n          textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n          textAlign = 'center';\n        } else {\n          textVerticalAlign = 'middle';\n\n          if (rotationDiff > 0 && rotationDiff < PI$5) {\n            textAlign = direction > 0 ? 'right' : 'left';\n          } else {\n            textAlign = direction > 0 ? 'left' : 'right';\n          }\n        }\n\n        return {\n          rotation: rotationDiff,\n          textAlign: textAlign,\n          textVerticalAlign: textVerticalAlign\n        };\n      };\n\n      AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n        var eventData = {\n          componentType: axisModel.mainType,\n          componentIndex: axisModel.componentIndex\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n      };\n\n      AxisBuilder.isLabelSilent = function (axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n      };\n\n      return AxisBuilder;\n    }();\n    var builders = {\n      axisLine: function (opt, axisModel, group, transformGroup) {\n        var shown = axisModel.get(['axisLine', 'show']);\n\n        if (shown === 'auto' && opt.handleAutoShown) {\n          shown = opt.handleAutoShown('axisLine');\n        }\n\n        if (!shown) {\n          return;\n        }\n\n        var extent = axisModel.axis.getExtent();\n        var matrix = transformGroup.transform;\n        var pt1 = [extent[0], 0];\n        var pt2 = [extent[1], 0];\n\n        if (matrix) {\n          applyTransform(pt1, pt1, matrix);\n          applyTransform(pt2, pt2, matrix);\n        }\n\n        var lineStyle = extend({\n          lineCap: 'round'\n        }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n        var line = new Line({\n          subPixelOptimize: true,\n          shape: {\n            x1: pt1[0],\n            y1: pt1[1],\n            x2: pt2[0],\n            y2: pt2[1]\n          },\n          style: lineStyle,\n          strokeContainThreshold: opt.strokeContainThreshold || 5,\n          silent: true,\n          z2: 1\n        });\n        line.anid = 'line';\n        group.add(line);\n        var arrows = axisModel.get(['axisLine', 'symbol']);\n        var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n        var arrowOffset = axisModel.get(['axisLine', 'symbolOffset']) || 0;\n\n        if (typeof arrowOffset === 'number') {\n          arrowOffset = [arrowOffset, arrowOffset];\n        }\n\n        if (arrows != null) {\n          if (typeof arrows === 'string') {\n            arrows = [arrows, arrows];\n          }\n\n          if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n            arrowSize = [arrowSize, arrowSize];\n          }\n\n          var symbolWidth_1 = arrowSize[0];\n          var symbolHeight_1 = arrowSize[1];\n          each([{\n            rotate: opt.rotation + Math.PI / 2,\n            offset: arrowOffset[0],\n            r: 0\n          }, {\n            rotate: opt.rotation - Math.PI / 2,\n            offset: arrowOffset[1],\n            r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n          }], function (point, index) {\n            if (arrows[index] !== 'none' && arrows[index] != null) {\n              var symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);\n              var r = point.r + point.offset;\n              symbol.attr({\n                rotation: point.rotate,\n                x: pt1[0] + r * Math.cos(opt.rotation),\n                y: pt1[1] - r * Math.sin(opt.rotation),\n                silent: true,\n                z2: 11\n              });\n              group.add(symbol);\n            }\n          });\n        }\n      },\n      axisTickLabel: function (opt, axisModel, group, transformGroup) {\n        var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n        var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n        fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n        buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);\n      },\n      axisName: function (opt, axisModel, group, transformGroup) {\n        var name = retrieve(opt.axisName, axisModel.get('name'));\n\n        if (!name) {\n          return;\n        }\n\n        var nameLocation = axisModel.get('nameLocation');\n        var nameDirection = opt.nameDirection;\n        var textStyleModel = axisModel.getModel('nameTextStyle');\n        var gap = axisModel.get('nameGap') || 0;\n        var extent = axisModel.axis.getExtent();\n        var gapSignal = extent[0] > extent[1] ? -1 : 1;\n        var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n        var labelLayout;\n        var nameRotation = axisModel.get('nameRotate');\n\n        if (nameRotation != null) {\n          nameRotation = nameRotation * PI$5 / 180;\n        }\n\n        var axisNameAvailableWidth;\n\n        if (isNameLocationCenter(nameLocation)) {\n          labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n        } else {\n          labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n          axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n          if (axisNameAvailableWidth != null) {\n            axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n            !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n          }\n        }\n\n        var textFont = textStyleModel.getFont();\n        var truncateOpt = axisModel.get('nameTruncate', true) || {};\n        var ellipsis = truncateOpt.ellipsis;\n        var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n        var tooltipOpt = axisModel.get('tooltip', true);\n        var mainType = axisModel.mainType;\n        var formatterParams = {\n          componentType: mainType,\n          name: name,\n          $vars: ['name']\n        };\n        formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n        var textEl = new ZRText({\n          x: pos[0],\n          y: pos[1],\n          rotation: labelLayout.rotation,\n          silent: AxisBuilder.isLabelSilent(axisModel),\n          style: createTextStyle(textStyleModel, {\n            text: name,\n            font: textFont,\n            overflow: 'truncate',\n            width: maxWidth,\n            ellipsis: ellipsis,\n            fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n            align: textStyleModel.get('align') || labelLayout.textAlign,\n            verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n          }),\n          z2: 1\n        });\n        textEl.tooltip = tooltipOpt && tooltipOpt.show ? extend({\n          content: name,\n          formatter: function () {\n            return name;\n          },\n          formatterParams: formatterParams\n        }, tooltipOpt) : null;\n        textEl.__fullText = name;\n        textEl.anid = 'name';\n\n        if (axisModel.get('triggerEvent')) {\n          var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n          eventData.targetType = 'axisName';\n          eventData.name = name;\n          getECData(textEl).eventData = eventData;\n        }\n\n        transformGroup.add(textEl);\n        textEl.updateTransform();\n        group.add(textEl);\n        textEl.decomposeTransform();\n      }\n    };\n\n    function endTextLayout(rotation, textPosition, textRotate, extent) {\n      var rotationDiff = remRadian(textRotate - rotation);\n      var textAlign;\n      var textVerticalAlign;\n      var inverse = extent[0] > extent[1];\n      var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n      if (isRadianAroundZero(rotationDiff - PI$5 / 2)) {\n        textVerticalAlign = onLeft ? 'bottom' : 'top';\n        textAlign = 'center';\n      } else if (isRadianAroundZero(rotationDiff - PI$5 * 1.5)) {\n        textVerticalAlign = onLeft ? 'top' : 'bottom';\n        textAlign = 'center';\n      } else {\n        textVerticalAlign = 'middle';\n\n        if (rotationDiff < PI$5 * 1.5 && rotationDiff > PI$5 / 2) {\n          textAlign = onLeft ? 'left' : 'right';\n        } else {\n          textAlign = onLeft ? 'right' : 'left';\n        }\n      }\n\n      return {\n        rotation: rotationDiff,\n        textAlign: textAlign,\n        textVerticalAlign: textVerticalAlign\n      };\n    }\n\n    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n      if (shouldShowAllLabels(axisModel.axis)) {\n        return;\n      }\n\n      var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n      var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']);\n      labelEls = labelEls || [];\n      tickEls = tickEls || [];\n      var firstLabel = labelEls[0];\n      var nextLabel = labelEls[1];\n      var lastLabel = labelEls[labelEls.length - 1];\n      var prevLabel = labelEls[labelEls.length - 2];\n      var firstTick = tickEls[0];\n      var nextTick = tickEls[1];\n      var lastTick = tickEls[tickEls.length - 1];\n      var prevTick = tickEls[tickEls.length - 2];\n\n      if (showMinLabel === false) {\n        ignoreEl(firstLabel);\n        ignoreEl(firstTick);\n      } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n        if (showMinLabel) {\n          ignoreEl(nextLabel);\n          ignoreEl(nextTick);\n        } else {\n          ignoreEl(firstLabel);\n          ignoreEl(firstTick);\n        }\n      }\n\n      if (showMaxLabel === false) {\n        ignoreEl(lastLabel);\n        ignoreEl(lastTick);\n      } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n        if (showMaxLabel) {\n          ignoreEl(prevLabel);\n          ignoreEl(prevTick);\n        } else {\n          ignoreEl(lastLabel);\n          ignoreEl(lastTick);\n        }\n      }\n    }\n\n    function ignoreEl(el) {\n      el && (el.ignore = true);\n    }\n\n    function isTwoLabelOverlapped(current, next) {\n      var firstRect = current && current.getBoundingRect().clone();\n      var nextRect = next && next.getBoundingRect().clone();\n\n      if (!firstRect || !nextRect) {\n        return;\n      }\n\n      var mRotationBack = identity([]);\n      rotate(mRotationBack, mRotationBack, -current.rotation);\n      firstRect.applyTransform(mul$1([], mRotationBack, current.getLocalTransform()));\n      nextRect.applyTransform(mul$1([], mRotationBack, next.getLocalTransform()));\n      return firstRect.intersect(nextRect);\n    }\n\n    function isNameLocationCenter(nameLocation) {\n      return nameLocation === 'middle' || nameLocation === 'center';\n    }\n\n    function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n      var tickEls = [];\n      var pt1 = [];\n      var pt2 = [];\n\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var tickCoord = ticksCoords[i].coord;\n        pt1[0] = tickCoord;\n        pt1[1] = 0;\n        pt2[0] = tickCoord;\n        pt2[1] = tickEndCoord;\n\n        if (tickTransform) {\n          applyTransform(pt1, pt1, tickTransform);\n          applyTransform(pt2, pt2, tickTransform);\n        }\n\n        var tickEl = new Line({\n          subPixelOptimize: true,\n          shape: {\n            x1: pt1[0],\n            y1: pt1[1],\n            x2: pt2[0],\n            y2: pt2[1]\n          },\n          style: tickLineStyle,\n          z2: 2,\n          autoBatch: true,\n          silent: true\n        });\n        tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n        tickEls.push(tickEl);\n      }\n\n      return tickEls;\n    }\n\n    function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n      var axis = axisModel.axis;\n      var tickModel = axisModel.getModel('axisTick');\n      var shown = tickModel.get('show');\n\n      if (shown === 'auto' && opt.handleAutoShown) {\n        shown = opt.handleAutoShown('axisTick');\n      }\n\n      if (!shown || axis.scale.isBlank()) {\n        return;\n      }\n\n      var lineStyleModel = tickModel.getModel('lineStyle');\n      var tickEndCoord = opt.tickDirection * tickModel.get('length');\n      var ticksCoords = axis.getTicksCoords();\n      var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n      }), 'ticks');\n\n      for (var i = 0; i < ticksEls.length; i++) {\n        group.add(ticksEls[i]);\n      }\n\n      return ticksEls;\n    }\n\n    function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n      var axis = axisModel.axis;\n      var minorTickModel = axisModel.getModel('minorTick');\n\n      if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n        return;\n      }\n\n      var minorTicksCoords = axis.getMinorTicksCoords();\n\n      if (!minorTicksCoords.length) {\n        return;\n      }\n\n      var lineStyleModel = minorTickModel.getModel('lineStyle');\n      var tickEndCoord = tickDirection * minorTickModel.get('length');\n      var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {\n        stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n      }));\n\n      for (var i = 0; i < minorTicksCoords.length; i++) {\n        var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n        for (var k = 0; k < minorTicksEls.length; k++) {\n          group.add(minorTicksEls[k]);\n        }\n      }\n    }\n\n    function buildAxisLabel(group, transformGroup, axisModel, opt) {\n      var axis = axisModel.axis;\n      var show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n      if (!show || axis.scale.isBlank()) {\n        return;\n      }\n\n      var labelModel = axisModel.getModel('axisLabel');\n      var labelMargin = labelModel.get('margin');\n      var labels = axis.getViewLabels();\n      var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI$5 / 180;\n      var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n      var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n      var labelEls = [];\n      var silent = AxisBuilder.isLabelSilent(axisModel);\n      var triggerEvent = axisModel.get('triggerEvent');\n      each(labels, function (labelItem, index) {\n        var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n        var formattedLabel = labelItem.formattedLabel;\n        var rawLabel = labelItem.rawLabel;\n        var itemLabelModel = labelModel;\n\n        if (rawCategoryData && rawCategoryData[tickValue]) {\n          var rawCategoryItem = rawCategoryData[tickValue];\n\n          if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n            itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n          }\n        }\n\n        var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n        var tickCoord = axis.dataToCoord(tickValue);\n        var textEl = new ZRText({\n          x: tickCoord,\n          y: opt.labelOffset + opt.labelDirection * labelMargin,\n          rotation: labelLayout.rotation,\n          silent: silent,\n          z2: 10,\n          style: createTextStyle(itemLabelModel, {\n            text: formattedLabel,\n            align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n            verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n            fill: typeof textColor === 'function' ? textColor(axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n          })\n        });\n        textEl.anid = 'label_' + tickValue;\n\n        if (triggerEvent) {\n          var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n          eventData.targetType = 'axisLabel';\n          eventData.value = rawLabel;\n          getECData(textEl).eventData = eventData;\n        }\n\n        transformGroup.add(textEl);\n        textEl.updateTransform();\n        labelEls.push(textEl);\n        group.add(textEl);\n        textEl.decomposeTransform();\n      });\n      return labelEls;\n    }\n\n    function collect(ecModel, api) {\n      var result = {\n        axesInfo: {},\n        seriesInvolved: false,\n        coordSysAxesInfo: {},\n        coordSysMap: {}\n      };\n      collectAxesInfo(result, ecModel, api);\n      result.seriesInvolved && collectSeriesInfo(result, ecModel);\n      return result;\n    }\n\n    function collectAxesInfo(result, ecModel, api) {\n      var globalTooltipModel = ecModel.getComponent('tooltip');\n      var globalAxisPointerModel = ecModel.getComponent('axisPointer');\n      var linksOption = globalAxisPointerModel.get('link', true) || [];\n      var linkGroups = [];\n      each(api.getCoordinateSystems(), function (coordSys) {\n        if (!coordSys.axisPointerEnabled) {\n          return;\n        }\n\n        var coordSysKey = makeKey(coordSys.model);\n        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};\n        result.coordSysMap[coordSysKey] = coordSys;\n        var coordSysModel = coordSys.model;\n        var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);\n        each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));\n\n        if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get('show')) {\n          var triggerAxis = baseTooltipModel.get('trigger') === 'axis';\n          var cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross';\n          var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']));\n\n          if (triggerAxis || cross) {\n            each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));\n          }\n\n          if (cross) {\n            each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false));\n          }\n        }\n\n        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {\n          var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);\n          var axisPointerShow = axisPointerModel.get('show');\n\n          if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {\n            return;\n          }\n\n          if (triggerTooltip == null) {\n            triggerTooltip = axisPointerModel.get('triggerTooltip');\n          }\n\n          axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;\n          var snap = axisPointerModel.get('snap');\n          var axisKey = makeKey(axis.model);\n          var involveSeries = triggerTooltip || snap || axis.type === 'category';\n          var axisInfo = result.axesInfo[axisKey] = {\n            key: axisKey,\n            axis: axis,\n            coordSys: coordSys,\n            axisPointerModel: axisPointerModel,\n            triggerTooltip: triggerTooltip,\n            involveSeries: involveSeries,\n            snap: snap,\n            useHandle: isHandleTrigger(axisPointerModel),\n            seriesModels: [],\n            linkGroup: null\n          };\n          axesInfoInCoordSys[axisKey] = axisInfo;\n          result.seriesInvolved = result.seriesInvolved || involveSeries;\n          var groupIndex = getLinkGroupIndex(linksOption, axis);\n\n          if (groupIndex != null) {\n            var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {\n              axesInfo: {}\n            });\n            linkGroup.axesInfo[axisKey] = axisInfo;\n            linkGroup.mapper = linksOption[groupIndex].mapper;\n            axisInfo.linkGroup = linkGroup;\n          }\n        }\n      });\n    }\n\n    function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {\n      var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');\n      var fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'];\n      var volatileOption = {};\n      each(fields, function (field) {\n        volatileOption[field] = clone(tooltipAxisPointerModel.get(field));\n      });\n      volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;\n\n      if (tooltipAxisPointerModel.get('type') === 'cross') {\n        volatileOption.type = 'line';\n      }\n\n      var labelOption = volatileOption.label || (volatileOption.label = {});\n      labelOption.show == null && (labelOption.show = false);\n\n      if (fromTooltip === 'cross') {\n        var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show']);\n        labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;\n\n        if (!triggerTooltip) {\n          var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');\n          crossStyle && defaults(labelOption, crossStyle.textStyle);\n        }\n      }\n\n      return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel));\n    }\n\n    function collectSeriesInfo(result, ecModel) {\n      ecModel.eachSeries(function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true);\n        var seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true);\n\n        if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {\n          return;\n        }\n\n        each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {\n          var axis = axisInfo.axis;\n\n          if (coordSys.getAxis(axis.dim) === axis) {\n            axisInfo.seriesModels.push(seriesModel);\n            axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);\n            axisInfo.seriesDataCount += seriesModel.getData().count();\n          }\n        });\n      });\n    }\n\n    function getLinkGroupIndex(linksOption, axis) {\n      var axisModel = axis.model;\n      var dim = axis.dim;\n\n      for (var i = 0; i < linksOption.length; i++) {\n        var linkOption = linksOption[i] || {};\n\n        if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {\n          return i;\n        }\n      }\n    }\n\n    function checkPropInLink(linkPropValue, axisPropValue) {\n      return linkPropValue === 'all' || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;\n    }\n\n    function fixValue(axisModel) {\n      var axisInfo = getAxisInfo(axisModel);\n\n      if (!axisInfo) {\n        return;\n      }\n\n      var axisPointerModel = axisInfo.axisPointerModel;\n      var scale = axisInfo.axis.scale;\n      var option = axisPointerModel.option;\n      var status = axisPointerModel.get('status');\n      var value = axisPointerModel.get('value');\n\n      if (value != null) {\n        value = scale.parse(value);\n      }\n\n      var useHandle = isHandleTrigger(axisPointerModel);\n\n      if (status == null) {\n        option.status = useHandle ? 'show' : 'hide';\n      }\n\n      var extent = scale.getExtent().slice();\n      extent[0] > extent[1] && extent.reverse();\n\n      if (value == null || value > extent[1]) {\n        value = extent[1];\n      }\n\n      if (value < extent[0]) {\n        value = extent[0];\n      }\n\n      option.value = value;\n\n      if (useHandle) {\n        option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';\n      }\n    }\n    function getAxisInfo(axisModel) {\n      var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;\n      return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];\n    }\n    function getAxisPointerModel(axisModel) {\n      var axisInfo = getAxisInfo(axisModel);\n      return axisInfo && axisInfo.axisPointerModel;\n    }\n\n    function isHandleTrigger(axisPointerModel) {\n      return !!axisPointerModel.get(['handle', 'show']);\n    }\n\n    function makeKey(model) {\n      return model.type + '||' + model.id;\n    }\n\n    var axisPointerClazz = {};\n\n    var AxisView = function (_super) {\n      __extends(AxisView, _super);\n\n      function AxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = AxisView.type;\n        return _this;\n      }\n\n      AxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n        this.axisPointerClass && fixValue(axisModel);\n\n        _super.prototype.render.apply(this, arguments);\n\n        this._doUpdateAxisPointerClass(axisModel, api, true);\n      };\n\n      AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {\n        this._doUpdateAxisPointerClass(axisModel, api, false);\n      };\n\n      AxisView.prototype.remove = function (ecModel, api) {\n        var axisPointer = this._axisPointer;\n        axisPointer && axisPointer.remove(api);\n      };\n\n      AxisView.prototype.dispose = function (ecModel, api) {\n        this._disposeAxisPointer(api);\n\n        _super.prototype.dispose.apply(this, arguments);\n      };\n\n      AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {\n        var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);\n\n        if (!Clazz) {\n          return;\n        }\n\n        var axisPointerModel = getAxisPointerModel(axisModel);\n        axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);\n      };\n\n      AxisView.prototype._disposeAxisPointer = function (api) {\n        this._axisPointer && this._axisPointer.dispose(api);\n        this._axisPointer = null;\n      };\n\n      AxisView.registerAxisPointerClass = function (type, clazz) {\n        if (\"development\" !== 'production') {\n          if (axisPointerClazz[type]) {\n            throw new Error('axisPointer ' + type + ' exists');\n          }\n        }\n\n        axisPointerClazz[type] = clazz;\n      };\n\n      AxisView.getAxisPointerClass = function (type) {\n        return type && axisPointerClazz[type];\n      };\n      AxisView.type = 'axis';\n      return AxisView;\n    }(ComponentView);\n\n    var inner$5 = makeInner();\n    function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {\n      var axis = axisModel.axis;\n\n      if (axis.scale.isBlank()) {\n        return;\n      }\n\n      var splitAreaModel = axisModel.getModel('splitArea');\n      var areaStyleModel = splitAreaModel.getModel('areaStyle');\n      var areaColors = areaStyleModel.get('color');\n      var gridRect = gridModel.coordinateSystem.getRect();\n      var ticksCoords = axis.getTicksCoords({\n        tickModel: splitAreaModel,\n        clamp: true\n      });\n\n      if (!ticksCoords.length) {\n        return;\n      }\n\n      var areaColorsLen = areaColors.length;\n      var lastSplitAreaColors = inner$5(axisView).splitAreaColors;\n      var newSplitAreaColors = createHashMap();\n      var colorIndex = 0;\n\n      if (lastSplitAreaColors) {\n        for (var i = 0; i < ticksCoords.length; i++) {\n          var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n          if (cIndex != null) {\n            colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n            break;\n          }\n        }\n      }\n\n      var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n      var areaStyle = areaStyleModel.getAreaStyle();\n      areaColors = isArray(areaColors) ? areaColors : [areaColors];\n\n      for (var i = 1; i < ticksCoords.length; i++) {\n        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n        var x = void 0;\n        var y = void 0;\n        var width = void 0;\n        var height = void 0;\n\n        if (axis.isHorizontal()) {\n          x = prev;\n          y = gridRect.y;\n          width = tickCoord - x;\n          height = gridRect.height;\n          prev = x + width;\n        } else {\n          x = gridRect.x;\n          y = prev;\n          width = gridRect.width;\n          height = tickCoord - y;\n          prev = y + height;\n        }\n\n        var tickValue = ticksCoords[i - 1].tickValue;\n        tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n        axisGroup.add(new Rect({\n          anid: tickValue != null ? 'area_' + tickValue : null,\n          shape: {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n          },\n          style: defaults({\n            fill: areaColors[colorIndex]\n          }, areaStyle),\n          autoBatch: true,\n          silent: true\n        }));\n        colorIndex = (colorIndex + 1) % areaColorsLen;\n      }\n\n      inner$5(axisView).splitAreaColors = newSplitAreaColors;\n    }\n    function rectCoordAxisHandleRemove(axisView) {\n      inner$5(axisView).splitAreaColors = null;\n    }\n\n    var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\n    var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];\n\n    var CartesianAxisView = function (_super) {\n      __extends(CartesianAxisView, _super);\n\n      function CartesianAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CartesianAxisView.type;\n        _this.axisPointerClass = 'CartesianAxisPointer';\n        return _this;\n      }\n\n      CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n        this.group.removeAll();\n        var oldAxisGroup = this._axisGroup;\n        this._axisGroup = new Group();\n        this.group.add(this._axisGroup);\n\n        if (!axisModel.get('show')) {\n          return;\n        }\n\n        var gridModel = axisModel.getCoordSysModel();\n        var layout = layout$1(gridModel, axisModel);\n        var axisBuilder = new AxisBuilder(axisModel, extend({\n          handleAutoShown: function (elementType) {\n            var cartesians = gridModel.coordinateSystem.getCartesians();\n\n            for (var i = 0; i < cartesians.length; i++) {\n              var otherAxisType = cartesians[i].getOtherAxis(axisModel.axis).type;\n\n              if (otherAxisType === 'value' || otherAxisType === 'log') {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        }, layout));\n        each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n        this._axisGroup.add(axisBuilder.getGroup());\n\n        each(selfBuilderAttrs, function (name) {\n          if (axisModel.get([name, 'show'])) {\n            axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);\n          }\n        }, this);\n        groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n        _super.prototype.render.call(this, axisModel, ecModel, api, payload);\n      };\n\n      CartesianAxisView.prototype.remove = function () {\n        rectCoordAxisHandleRemove(this);\n      };\n\n      CartesianAxisView.type = 'cartesianAxis';\n      return CartesianAxisView;\n    }(AxisView);\n\n    var axisElementBuilders = {\n      splitLine: function (axisView, axisGroup, axisModel, gridModel) {\n        var axis = axisModel.axis;\n\n        if (axis.scale.isBlank()) {\n          return;\n        }\n\n        var splitLineModel = axisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        lineColors = isArray(lineColors) ? lineColors : [lineColors];\n        var gridRect = gridModel.coordinateSystem.getRect();\n        var isHorizontal = axis.isHorizontal();\n        var lineCount = 0;\n        var ticksCoords = axis.getTicksCoords({\n          tickModel: splitLineModel\n        });\n        var p1 = [];\n        var p2 = [];\n        var lineStyle = lineStyleModel.getLineStyle();\n\n        for (var i = 0; i < ticksCoords.length; i++) {\n          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n          if (isHorizontal) {\n            p1[0] = tickCoord;\n            p1[1] = gridRect.y;\n            p2[0] = tickCoord;\n            p2[1] = gridRect.y + gridRect.height;\n          } else {\n            p1[0] = gridRect.x;\n            p1[1] = tickCoord;\n            p2[0] = gridRect.x + gridRect.width;\n            p2[1] = tickCoord;\n          }\n\n          var colorIndex = lineCount++ % lineColors.length;\n          var tickValue = ticksCoords[i].tickValue;\n          axisGroup.add(new Line({\n            anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n            subPixelOptimize: true,\n            autoBatch: true,\n            shape: {\n              x1: p1[0],\n              y1: p1[1],\n              x2: p2[0],\n              y2: p2[1]\n            },\n            style: defaults({\n              stroke: lineColors[colorIndex]\n            }, lineStyle),\n            silent: true\n          }));\n        }\n      },\n      minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {\n        var axis = axisModel.axis;\n        var minorSplitLineModel = axisModel.getModel('minorSplitLine');\n        var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n        var gridRect = gridModel.coordinateSystem.getRect();\n        var isHorizontal = axis.isHorizontal();\n        var minorTicksCoords = axis.getMinorTicksCoords();\n\n        if (!minorTicksCoords.length) {\n          return;\n        }\n\n        var p1 = [];\n        var p2 = [];\n        var lineStyle = lineStyleModel.getLineStyle();\n\n        for (var i = 0; i < minorTicksCoords.length; i++) {\n          for (var k = 0; k < minorTicksCoords[i].length; k++) {\n            var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);\n\n            if (isHorizontal) {\n              p1[0] = tickCoord;\n              p1[1] = gridRect.y;\n              p2[0] = tickCoord;\n              p2[1] = gridRect.y + gridRect.height;\n            } else {\n              p1[0] = gridRect.x;\n              p1[1] = tickCoord;\n              p2[0] = gridRect.x + gridRect.width;\n              p2[1] = tickCoord;\n            }\n\n            axisGroup.add(new Line({\n              anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,\n              subPixelOptimize: true,\n              autoBatch: true,\n              shape: {\n                x1: p1[0],\n                y1: p1[1],\n                x2: p2[0],\n                y2: p2[1]\n              },\n              style: lineStyle,\n              silent: true\n            }));\n          }\n        }\n      },\n      splitArea: function (axisView, axisGroup, axisModel, gridModel) {\n        rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);\n      }\n    };\n\n    var CartesianXAxisView = function (_super) {\n      __extends(CartesianXAxisView, _super);\n\n      function CartesianXAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CartesianXAxisView.type;\n        return _this;\n      }\n\n      CartesianXAxisView.type = 'xAxis';\n      return CartesianXAxisView;\n    }(CartesianAxisView);\n\n    var CartesianYAxisView = function (_super) {\n      __extends(CartesianYAxisView, _super);\n\n      function CartesianYAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CartesianXAxisView.type;\n        return _this;\n      }\n\n      CartesianYAxisView.type = 'yAxis';\n      return CartesianYAxisView;\n    }(CartesianAxisView);\n\n    var GridView = function (_super) {\n      __extends(GridView, _super);\n\n      function GridView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'grid';\n        return _this;\n      }\n\n      GridView.prototype.render = function (gridModel, ecModel) {\n        this.group.removeAll();\n\n        if (gridModel.get('show')) {\n          this.group.add(new Rect({\n            shape: gridModel.coordinateSystem.getRect(),\n            style: defaults({\n              fill: gridModel.get('backgroundColor')\n            }, gridModel.getItemStyle()),\n            silent: true,\n            z2: -1\n          }));\n        }\n      };\n\n      GridView.type = 'grid';\n      return GridView;\n    }(ComponentView);\n\n    var extraOption = {\n      offset: 0\n    };\n    function install$5(registers) {\n      registers.registerComponentView(GridView);\n      registers.registerComponentModel(GridModel);\n      registers.registerCoordinateSystem('cartesian2d', Grid);\n      axisModelCreator(registers, 'x', CartesianAxisModel, extraOption);\n      axisModelCreator(registers, 'y', CartesianAxisModel, extraOption);\n      registers.registerComponentView(CartesianXAxisView);\n      registers.registerComponentView(CartesianYAxisView);\n      registers.registerPreprocessor(function (option) {\n        if (option.xAxis && option.yAxis && !option.grid) {\n          option.grid = {};\n        }\n      });\n    }\n\n    function install$6(registers) {\n      use(install$5);\n      registers.registerSeriesModel(ScatterSeriesModel);\n      registers.registerChartView(ScatterView);\n      registers.registerLayout(pointsLayout('scatter'));\n    }\n\n    function radarLayout(ecModel) {\n      ecModel.eachSeriesByType('radar', function (seriesModel) {\n        var data = seriesModel.getData();\n        var points = [];\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (!coordSys) {\n          return;\n        }\n\n        var axes = coordSys.getIndicatorAxes();\n        each(axes, function (axis, axisIndex) {\n          data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {\n            points[dataIndex] = points[dataIndex] || [];\n            var point = coordSys.dataToPoint(val, axisIndex);\n            points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);\n          });\n        });\n        data.each(function (idx) {\n          var firstPoint = find(points[idx], function (point) {\n            return isValidPoint(point);\n          }) || getValueMissingPoint(coordSys);\n          points[idx].push(firstPoint.slice());\n          data.setItemLayout(idx, points[idx]);\n        });\n      });\n    }\n\n    function isValidPoint(point) {\n      return !isNaN(point[0]) && !isNaN(point[1]);\n    }\n\n    function getValueMissingPoint(coordSys) {\n      return [coordSys.cx, coordSys.cy];\n    }\n\n    function radarBackwardCompat(option) {\n      var polarOptArr = option.polar;\n\n      if (polarOptArr) {\n        if (!isArray(polarOptArr)) {\n          polarOptArr = [polarOptArr];\n        }\n\n        var polarNotRadar_1 = [];\n        each(polarOptArr, function (polarOpt, idx) {\n          if (polarOpt.indicator) {\n            if (polarOpt.type && !polarOpt.shape) {\n              polarOpt.shape = polarOpt.type;\n            }\n\n            option.radar = option.radar || [];\n\n            if (!isArray(option.radar)) {\n              option.radar = [option.radar];\n            }\n\n            option.radar.push(polarOpt);\n          } else {\n            polarNotRadar_1.push(polarOpt);\n          }\n        });\n        option.polar = polarNotRadar_1;\n      }\n\n      each(option.series, function (seriesOpt) {\n        if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {\n          seriesOpt.radarIndex = seriesOpt.polarIndex;\n        }\n      });\n    }\n\n    function normalizeSymbolSize(symbolSize) {\n      if (!isArray(symbolSize)) {\n        symbolSize = [+symbolSize, +symbolSize];\n      }\n\n      return symbolSize;\n    }\n\n    var RadarView = function (_super) {\n      __extends(RadarView, _super);\n\n      function RadarView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadarView.type;\n        return _this;\n      }\n\n      RadarView.prototype.render = function (seriesModel, ecModel, api) {\n        var polar = seriesModel.coordinateSystem;\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n\n        function createSymbol$1(data, idx) {\n          var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n\n          if (symbolType === 'none') {\n            return;\n          }\n\n          var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n          var symbolPath = createSymbol(symbolType, -1, -1, 2, 2);\n          var symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0;\n          symbolPath.attr({\n            style: {\n              strokeNoScale: true\n            },\n            z2: 100,\n            scaleX: symbolSize[0] / 2,\n            scaleY: symbolSize[1] / 2,\n            rotation: symbolRotate * Math.PI / 180 || 0\n          });\n          return symbolPath;\n        }\n\n        function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {\n          symbolGroup.removeAll();\n\n          for (var i = 0; i < newPoints.length - 1; i++) {\n            var symbolPath = createSymbol$1(data, idx);\n\n            if (symbolPath) {\n              symbolPath.__dimIdx = i;\n\n              if (oldPoints[i]) {\n                symbolPath.setPosition(oldPoints[i]);\n                graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {\n                  x: newPoints[i][0],\n                  y: newPoints[i][1]\n                }, seriesModel, idx);\n              } else {\n                symbolPath.setPosition(newPoints[i]);\n              }\n\n              symbolGroup.add(symbolPath);\n            }\n          }\n        }\n\n        function getInitialPoints(points) {\n          return map(points, function (pt) {\n            return [polar.cx, polar.cy];\n          });\n        }\n\n        data.diff(oldData).add(function (idx) {\n          var points = data.getItemLayout(idx);\n\n          if (!points) {\n            return;\n          }\n\n          var polygon = new Polygon();\n          var polyline = new Polyline();\n          var target = {\n            shape: {\n              points: points\n            }\n          };\n          polygon.shape.points = getInitialPoints(points);\n          polyline.shape.points = getInitialPoints(points);\n          initProps(polygon, target, seriesModel, idx);\n          initProps(polyline, target, seriesModel, idx);\n          var itemGroup = new Group();\n          var symbolGroup = new Group();\n          itemGroup.add(polyline);\n          itemGroup.add(polygon);\n          itemGroup.add(symbolGroup);\n          updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);\n          data.setItemGraphicEl(idx, itemGroup);\n        }).update(function (newIdx, oldIdx) {\n          var itemGroup = oldData.getItemGraphicEl(oldIdx);\n          var polyline = itemGroup.childAt(0);\n          var polygon = itemGroup.childAt(1);\n          var symbolGroup = itemGroup.childAt(2);\n          var target = {\n            shape: {\n              points: data.getItemLayout(newIdx)\n            }\n          };\n\n          if (!target.shape.points) {\n            return;\n          }\n\n          updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);\n          updateProps(polyline, target, seriesModel);\n          updateProps(polygon, target, seriesModel);\n          data.setItemGraphicEl(newIdx, itemGroup);\n        }).remove(function (idx) {\n          group.remove(oldData.getItemGraphicEl(idx));\n        }).execute();\n        data.eachItemGraphicEl(function (itemGroup, idx) {\n          var itemModel = data.getItemModel(idx);\n          var polyline = itemGroup.childAt(0);\n          var polygon = itemGroup.childAt(1);\n          var symbolGroup = itemGroup.childAt(2);\n          var itemStyle = data.getItemVisual(idx, 'style');\n          var color = itemStyle.fill;\n          group.add(itemGroup);\n          polyline.useStyle(defaults(itemModel.getModel('lineStyle').getLineStyle(), {\n            fill: 'none',\n            stroke: color\n          }));\n          setStatesStylesFromModel(polyline, itemModel, 'lineStyle');\n          setStatesStylesFromModel(polygon, itemModel, 'areaStyle');\n          var areaStyleModel = itemModel.getModel('areaStyle');\n          var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();\n          polygon.ignore = polygonIgnore;\n          each(['emphasis', 'select', 'blur'], function (stateName) {\n            var stateModel = itemModel.getModel([stateName, 'areaStyle']);\n            var stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();\n            polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;\n          });\n          polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {\n            fill: color,\n            opacity: 0.7,\n            decal: itemStyle.decal\n          }));\n          var emphasisModel = itemModel.getModel('emphasis');\n          var itemHoverStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n          symbolGroup.eachChild(function (symbolPath) {\n            if (symbolPath instanceof ZRImage) {\n              var pathStyle = symbolPath.style;\n              symbolPath.useStyle(extend({\n                image: pathStyle.image,\n                x: pathStyle.x,\n                y: pathStyle.y,\n                width: pathStyle.width,\n                height: pathStyle.height\n              }, itemStyle));\n            } else {\n              symbolPath.useStyle(itemStyle);\n              symbolPath.setColor(color);\n            }\n\n            var pathEmphasisState = symbolPath.ensureState('emphasis');\n            pathEmphasisState.style = clone(itemHoverStyle);\n            var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);\n            (defaultText == null || isNaN(defaultText)) && (defaultText = '');\n            setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {\n              labelFetcher: data.hostModel,\n              labelDataIndex: idx,\n              labelDimIndex: symbolPath.__dimIdx,\n              defaultText: defaultText,\n              inheritColor: color,\n              defaultOpacity: itemStyle.opacity\n            });\n          });\n          enableHoverEmphasis(itemGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        });\n        this._data = data;\n      };\n\n      RadarView.prototype.remove = function () {\n        this.group.removeAll();\n        this._data = null;\n      };\n\n      RadarView.type = 'radar';\n      return RadarView;\n    }(ChartView);\n\n    var RadarSeriesModel = function (_super) {\n      __extends(RadarSeriesModel, _super);\n\n      function RadarSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadarSeriesModel.type;\n        _this.useColorPaletteOnData = true;\n        _this.hasSymbolVisual = true;\n        return _this;\n      }\n\n      RadarSeriesModel.prototype.init = function (option) {\n        _super.prototype.init.apply(this, arguments);\n\n        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this));\n      };\n\n      RadarSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListSimply(this, {\n          generateCoord: 'indicator_',\n          generateCoordCount: Infinity\n        });\n      };\n\n      RadarSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var coordSys = this.coordinateSystem;\n        var indicatorAxes = coordSys.getIndicatorAxes();\n        var name = this.getData().getName(dataIndex);\n        var nameToDisplay = name === '' ? this.name : name;\n        var markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);\n        return createTooltipMarkup('section', {\n          header: nameToDisplay,\n          sortBlocks: true,\n          blocks: map(indicatorAxes, function (axis) {\n            var val = data.get(data.mapDimension(axis.dim), dataIndex);\n            return createTooltipMarkup('nameValue', {\n              markerType: 'subItem',\n              markerColor: markerColor,\n              name: axis.name,\n              value: val,\n              sortParam: val\n            });\n          })\n        });\n      };\n\n      RadarSeriesModel.prototype.getTooltipPosition = function (dataIndex) {\n        if (dataIndex != null) {\n          var data_1 = this.getData();\n          var coordSys = this.coordinateSystem;\n          var values = data_1.getValues(map(coordSys.dimensions, function (dim) {\n            return data_1.mapDimension(dim);\n          }), dataIndex);\n\n          for (var i = 0, len = values.length; i < len; i++) {\n            if (!isNaN(values[i])) {\n              var indicatorAxes = coordSys.getIndicatorAxes();\n              return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);\n            }\n          }\n        }\n      };\n\n      RadarSeriesModel.type = 'series.radar';\n      RadarSeriesModel.dependencies = ['radar'];\n      RadarSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'radar',\n        legendHoverLink: true,\n        radarIndex: 0,\n        lineStyle: {\n          width: 2,\n          type: 'solid'\n        },\n        label: {\n          position: 'top'\n        },\n        symbol: 'emptyCircle',\n        symbolSize: 4\n      };\n      return RadarSeriesModel;\n    }(SeriesModel);\n\n    var valueAxisDefault = axisDefault.value;\n\n    function defaultsShow(opt, show) {\n      return defaults({\n        show: show\n      }, opt);\n    }\n\n    var RadarModel = function (_super) {\n      __extends(RadarModel, _super);\n\n      function RadarModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadarModel.type;\n        return _this;\n      }\n\n      RadarModel.prototype.optionUpdated = function () {\n        var boundaryGap = this.get('boundaryGap');\n        var splitNumber = this.get('splitNumber');\n        var scale = this.get('scale');\n        var axisLine = this.get('axisLine');\n        var axisTick = this.get('axisTick');\n        var axisLabel = this.get('axisLabel');\n        var nameTextStyle = this.get('axisName');\n        var showName = this.get(['axisName', 'show']);\n        var nameFormatter = this.get(['axisName', 'formatter']);\n        var nameGap = this.get('axisNameGap');\n        var triggerEvent = this.get('triggerEvent');\n        var indicatorModels = map(this.get('indicator') || [], function (indicatorOpt) {\n          if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {\n            indicatorOpt.min = 0;\n          } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {\n            indicatorOpt.max = 0;\n          }\n\n          var iNameTextStyle = nameTextStyle;\n\n          if (indicatorOpt.color != null) {\n            iNameTextStyle = defaults({\n              color: indicatorOpt.color\n            }, nameTextStyle);\n          }\n\n          var innerIndicatorOpt = merge(clone(indicatorOpt), {\n            boundaryGap: boundaryGap,\n            splitNumber: splitNumber,\n            scale: scale,\n            axisLine: axisLine,\n            axisTick: axisTick,\n            axisLabel: axisLabel,\n            name: indicatorOpt.text,\n            nameLocation: 'end',\n            nameGap: nameGap,\n            nameTextStyle: iNameTextStyle,\n            triggerEvent: triggerEvent\n          }, false);\n\n          if (!showName) {\n            innerIndicatorOpt.name = '';\n          }\n\n          if (typeof nameFormatter === 'string') {\n            var indName = innerIndicatorOpt.name;\n            innerIndicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');\n          } else if (typeof nameFormatter === 'function') {\n            innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);\n          }\n\n          var model = new Model(innerIndicatorOpt, null, this.ecModel);\n          mixin(model, AxisModelCommonMixin.prototype);\n          model.mainType = 'radar';\n          model.componentIndex = this.componentIndex;\n          return model;\n        }, this);\n        this._indicatorModels = indicatorModels;\n      };\n\n      RadarModel.prototype.getIndicatorModels = function () {\n        return this._indicatorModels;\n      };\n\n      RadarModel.type = 'radar';\n      RadarModel.defaultOption = {\n        zlevel: 0,\n        z: 0,\n        center: ['50%', '50%'],\n        radius: '75%',\n        startAngle: 90,\n        axisName: {\n          show: true\n        },\n        boundaryGap: [0, 0],\n        splitNumber: 5,\n        axisNameGap: 15,\n        scale: false,\n        shape: 'polygon',\n        axisLine: merge({\n          lineStyle: {\n            color: '#bbb'\n          }\n        }, valueAxisDefault.axisLine),\n        axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),\n        axisTick: defaultsShow(valueAxisDefault.axisTick, false),\n        splitLine: defaultsShow(valueAxisDefault.splitLine, true),\n        splitArea: defaultsShow(valueAxisDefault.splitArea, true),\n        indicator: []\n      };\n      return RadarModel;\n    }(ComponentModel);\n\n    var axisBuilderAttrs$1 = ['axisLine', 'axisTickLabel', 'axisName'];\n\n    var RadarView$1 = function (_super) {\n      __extends(RadarView, _super);\n\n      function RadarView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadarView.type;\n        return _this;\n      }\n\n      RadarView.prototype.render = function (radarModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n\n        this._buildAxes(radarModel);\n\n        this._buildSplitLineAndArea(radarModel);\n      };\n\n      RadarView.prototype._buildAxes = function (radarModel) {\n        var radar = radarModel.coordinateSystem;\n        var indicatorAxes = radar.getIndicatorAxes();\n        var axisBuilders = map(indicatorAxes, function (indicatorAxis) {\n          var axisBuilder = new AxisBuilder(indicatorAxis.model, {\n            position: [radar.cx, radar.cy],\n            rotation: indicatorAxis.angle,\n            labelDirection: -1,\n            tickDirection: -1,\n            nameDirection: 1\n          });\n          return axisBuilder;\n        });\n        each(axisBuilders, function (axisBuilder) {\n          each(axisBuilderAttrs$1, axisBuilder.add, axisBuilder);\n          this.group.add(axisBuilder.getGroup());\n        }, this);\n      };\n\n      RadarView.prototype._buildSplitLineAndArea = function (radarModel) {\n        var radar = radarModel.coordinateSystem;\n        var indicatorAxes = radar.getIndicatorAxes();\n\n        if (!indicatorAxes.length) {\n          return;\n        }\n\n        var shape = radarModel.get('shape');\n        var splitLineModel = radarModel.getModel('splitLine');\n        var splitAreaModel = radarModel.getModel('splitArea');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var showSplitLine = splitLineModel.get('show');\n        var showSplitArea = splitAreaModel.get('show');\n        var splitLineColors = lineStyleModel.get('color');\n        var splitAreaColors = areaStyleModel.get('color');\n        var splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];\n        var splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];\n        var splitLines = [];\n        var splitAreas = [];\n\n        function getColorIndex(areaOrLine, areaOrLineColorList, idx) {\n          var colorIndex = idx % areaOrLineColorList.length;\n          areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];\n          return colorIndex;\n        }\n\n        if (shape === 'circle') {\n          var ticksRadius = indicatorAxes[0].getTicksCoords();\n          var cx = radar.cx;\n          var cy = radar.cy;\n\n          for (var i = 0; i < ticksRadius.length; i++) {\n            if (showSplitLine) {\n              var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);\n              splitLines[colorIndex].push(new Circle({\n                shape: {\n                  cx: cx,\n                  cy: cy,\n                  r: ticksRadius[i].coord\n                }\n              }));\n            }\n\n            if (showSplitArea && i < ticksRadius.length - 1) {\n              var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);\n              splitAreas[colorIndex].push(new Ring({\n                shape: {\n                  cx: cx,\n                  cy: cy,\n                  r0: ticksRadius[i].coord,\n                  r: ticksRadius[i + 1].coord\n                }\n              }));\n            }\n          }\n        } else {\n          var realSplitNumber_1;\n          var axesTicksPoints = map(indicatorAxes, function (indicatorAxis, idx) {\n            var ticksCoords = indicatorAxis.getTicksCoords();\n            realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1);\n            return map(ticksCoords, function (tickCoord) {\n              return radar.coordToPoint(tickCoord.coord, idx);\n            });\n          });\n          var prevPoints = [];\n\n          for (var i = 0; i <= realSplitNumber_1; i++) {\n            var points = [];\n\n            for (var j = 0; j < indicatorAxes.length; j++) {\n              points.push(axesTicksPoints[j][i]);\n            }\n\n            if (points[0]) {\n              points.push(points[0].slice());\n            } else {\n              if (\"development\" !== 'production') {\n                console.error('Can\\'t draw value axis ' + i);\n              }\n            }\n\n            if (showSplitLine) {\n              var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);\n              splitLines[colorIndex].push(new Polyline({\n                shape: {\n                  points: points\n                }\n              }));\n            }\n\n            if (showSplitArea && prevPoints) {\n              var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);\n              splitAreas[colorIndex].push(new Polygon({\n                shape: {\n                  points: points.concat(prevPoints)\n                }\n              }));\n            }\n\n            prevPoints = points.slice().reverse();\n          }\n        }\n\n        var lineStyle = lineStyleModel.getLineStyle();\n        var areaStyle = areaStyleModel.getAreaStyle();\n        each(splitAreas, function (splitAreas, idx) {\n          this.group.add(mergePath$1(splitAreas, {\n            style: defaults({\n              stroke: 'none',\n              fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]\n            }, areaStyle),\n            silent: true\n          }));\n        }, this);\n        each(splitLines, function (splitLines, idx) {\n          this.group.add(mergePath$1(splitLines, {\n            style: defaults({\n              fill: 'none',\n              stroke: splitLineColorsArr[idx % splitLineColorsArr.length]\n            }, lineStyle),\n            silent: true\n          }));\n        }, this);\n      };\n\n      RadarView.type = 'radar';\n      return RadarView;\n    }(ComponentView);\n\n    var IndicatorAxis = function (_super) {\n      __extends(IndicatorAxis, _super);\n\n      function IndicatorAxis(dim, scale, radiusExtent) {\n        var _this = _super.call(this, dim, scale, radiusExtent) || this;\n\n        _this.type = 'value';\n        _this.angle = 0;\n        _this.name = '';\n        return _this;\n      }\n\n      return IndicatorAxis;\n    }(Axis);\n\n    var Radar = function () {\n      function Radar(radarModel, ecModel, api) {\n        this.dimensions = [];\n        this._model = radarModel;\n        this._indicatorAxes = map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n          var dim = 'indicator_' + idx;\n          var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n          indicatorAxis.name = indicatorModel.get('name');\n          indicatorAxis.model = indicatorModel;\n          indicatorModel.axis = indicatorAxis;\n          this.dimensions.push(dim);\n          return indicatorAxis;\n        }, this);\n        this.resize(radarModel, api);\n      }\n\n      Radar.prototype.getIndicatorAxes = function () {\n        return this._indicatorAxes;\n      };\n\n      Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n      };\n\n      Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n        var indicatorAxis = this._indicatorAxes[indicatorIndex];\n        var angle = indicatorAxis.angle;\n        var x = this.cx + coord * Math.cos(angle);\n        var y = this.cy - coord * Math.sin(angle);\n        return [x, y];\n      };\n\n      Radar.prototype.pointToData = function (pt) {\n        var dx = pt[0] - this.cx;\n        var dy = pt[1] - this.cy;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n        var radian = Math.atan2(-dy, dx);\n        var minRadianDiff = Infinity;\n        var closestAxis;\n        var closestAxisIdx = -1;\n\n        for (var i = 0; i < this._indicatorAxes.length; i++) {\n          var indicatorAxis = this._indicatorAxes[i];\n          var diff = Math.abs(radian - indicatorAxis.angle);\n\n          if (diff < minRadianDiff) {\n            closestAxis = indicatorAxis;\n            closestAxisIdx = i;\n            minRadianDiff = diff;\n          }\n        }\n\n        return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];\n      };\n\n      Radar.prototype.resize = function (radarModel, api) {\n        var center = radarModel.get('center');\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n        var viewSize = Math.min(viewWidth, viewHeight) / 2;\n        this.cx = parsePercent$1(center[0], viewWidth);\n        this.cy = parsePercent$1(center[1], viewHeight);\n        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n        var radius = radarModel.get('radius');\n\n        if (typeof radius === 'string' || typeof radius === 'number') {\n          radius = [0, radius];\n        }\n\n        this.r0 = parsePercent$1(radius[0], viewSize);\n        this.r = parsePercent$1(radius[1], viewSize);\n        each(this._indicatorAxes, function (indicatorAxis, idx) {\n          indicatorAxis.setExtent(this.r0, this.r);\n          var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;\n          angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n          indicatorAxis.angle = angle;\n        }, this);\n      };\n\n      Radar.prototype.update = function (ecModel, api) {\n        var indicatorAxes = this._indicatorAxes;\n        var radarModel = this._model;\n        each(indicatorAxes, function (indicatorAxis) {\n          indicatorAxis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n          if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n            return;\n          }\n\n          var data = radarSeries.getData();\n          each(indicatorAxes, function (indicatorAxis) {\n            indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n          });\n        }, this);\n        var splitNumber = radarModel.get('splitNumber');\n\n        function increaseInterval(interval) {\n          var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n          var f = interval / exp10;\n\n          if (f === 2) {\n            f = 5;\n          } else {\n            f *= 2;\n          }\n\n          return f * exp10;\n        }\n\n        each(indicatorAxes, function (indicatorAxis, idx) {\n          var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;\n          niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n          var axisModel = indicatorAxis.model;\n          var scale = indicatorAxis.scale;\n          var fixedMin = parseAxisModelMinMax(scale, axisModel.get('min', true));\n          var fixedMax = parseAxisModelMinMax(scale, axisModel.get('max', true));\n          var interval = scale.getInterval();\n\n          if (fixedMin != null && fixedMax != null) {\n            scale.setExtent(+fixedMin, +fixedMax);\n            scale.setInterval((fixedMax - fixedMin) / splitNumber);\n          } else if (fixedMin != null) {\n            var max = void 0;\n\n            do {\n              max = fixedMin + interval * splitNumber;\n              scale.setExtent(+fixedMin, max);\n              scale.setInterval(interval);\n              interval = increaseInterval(interval);\n            } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n          } else if (fixedMax != null) {\n            var min = void 0;\n\n            do {\n              min = fixedMax - interval * splitNumber;\n              scale.setExtent(min, +fixedMax);\n              scale.setInterval(interval);\n              interval = increaseInterval(interval);\n            } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n          } else {\n            var nicedSplitNumber = scale.getTicks().length - 1;\n\n            if (nicedSplitNumber > splitNumber) {\n              interval = increaseInterval(interval);\n            }\n\n            var max = Math.ceil(rawExtent[1] / interval) * interval;\n            var min = round(max - interval * splitNumber);\n            scale.setExtent(min, max);\n            scale.setInterval(interval);\n          }\n        });\n      };\n\n      Radar.prototype.convertToPixel = function (ecModel, finder, value) {\n        console.warn('Not implemented.');\n        return null;\n      };\n\n      Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        console.warn('Not implemented.');\n        return null;\n      };\n\n      Radar.prototype.containPoint = function (point) {\n        console.warn('Not implemented.');\n        return false;\n      };\n\n      Radar.create = function (ecModel, api) {\n        var radarList = [];\n        ecModel.eachComponent('radar', function (radarModel) {\n          var radar = new Radar(radarModel, ecModel, api);\n          radarList.push(radar);\n          radarModel.coordinateSystem = radar;\n        });\n        ecModel.eachSeriesByType('radar', function (radarSeries) {\n          if (radarSeries.get('coordinateSystem') === 'radar') {\n            radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n          }\n        });\n        return radarList;\n      };\n\n      Radar.dimensions = [];\n      return Radar;\n    }();\n\n    function install$7(registers) {\n      registers.registerCoordinateSystem('radar', Radar);\n      registers.registerComponentModel(RadarModel);\n      registers.registerComponentView(RadarView$1);\n    }\n\n    function install$8(registers) {\n      use(install$7);\n      registers.registerChartView(RadarView);\n      registers.registerSeriesModel(RadarSeriesModel);\n      registers.registerLayout(radarLayout);\n      registers.registerProcessor(dataFilter('radar'));\n      registers.registerPreprocessor(radarBackwardCompat);\n    }\n\n    var ATTR = '\\0_ec_interaction_mutex';\n    function take(zr, resourceKey, userKey) {\n      var store = getStore(zr);\n      store[resourceKey] = userKey;\n    }\n    function release(zr, resourceKey, userKey) {\n      var store = getStore(zr);\n      var uKey = store[resourceKey];\n\n      if (uKey === userKey) {\n        store[resourceKey] = null;\n      }\n    }\n    function isTaken(zr, resourceKey) {\n      return !!getStore(zr)[resourceKey];\n    }\n\n    function getStore(zr) {\n      return zr[ATTR] || (zr[ATTR] = {});\n    }\n\n    registerAction({\n      type: 'takeGlobalCursor',\n      event: 'globalCursorTaken',\n      update: 'update'\n    }, function () {});\n\n    var RoamController = function (_super) {\n      __extends(RoamController, _super);\n\n      function RoamController(zr) {\n        var _this = _super.call(this) || this;\n\n        _this._zr = zr;\n        var mousedownHandler = bind(_this._mousedownHandler, _this);\n        var mousemoveHandler = bind(_this._mousemoveHandler, _this);\n        var mouseupHandler = bind(_this._mouseupHandler, _this);\n        var mousewheelHandler = bind(_this._mousewheelHandler, _this);\n        var pinchHandler = bind(_this._pinchHandler, _this);\n\n        _this.enable = function (controlType, opt) {\n          this.disable();\n          this._opt = defaults(clone(opt) || {}, {\n            zoomOnMouseWheel: true,\n            moveOnMouseMove: true,\n            moveOnMouseWheel: false,\n            preventDefaultMouseMove: true\n          });\n\n          if (controlType == null) {\n            controlType = true;\n          }\n\n          if (controlType === true || controlType === 'move' || controlType === 'pan') {\n            zr.on('mousedown', mousedownHandler);\n            zr.on('mousemove', mousemoveHandler);\n            zr.on('mouseup', mouseupHandler);\n          }\n\n          if (controlType === true || controlType === 'scale' || controlType === 'zoom') {\n            zr.on('mousewheel', mousewheelHandler);\n            zr.on('pinch', pinchHandler);\n          }\n        };\n\n        _this.disable = function () {\n          zr.off('mousedown', mousedownHandler);\n          zr.off('mousemove', mousemoveHandler);\n          zr.off('mouseup', mouseupHandler);\n          zr.off('mousewheel', mousewheelHandler);\n          zr.off('pinch', pinchHandler);\n        };\n\n        return _this;\n      }\n\n      RoamController.prototype.isDragging = function () {\n        return this._dragging;\n      };\n\n      RoamController.prototype.isPinching = function () {\n        return this._pinching;\n      };\n\n      RoamController.prototype.setPointerChecker = function (pointerChecker) {\n        this.pointerChecker = pointerChecker;\n      };\n\n      RoamController.prototype.dispose = function () {\n        this.disable();\n      };\n\n      RoamController.prototype._mousedownHandler = function (e) {\n        if (isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {\n          return;\n        }\n\n        var x = e.offsetX;\n        var y = e.offsetY;\n\n        if (this.pointerChecker && this.pointerChecker(e, x, y)) {\n          this._x = x;\n          this._y = y;\n          this._dragging = true;\n        }\n      };\n\n      RoamController.prototype._mousemoveHandler = function (e) {\n        if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || isTaken(this._zr, 'globalPan')) {\n          return;\n        }\n\n        var x = e.offsetX;\n        var y = e.offsetY;\n        var oldX = this._x;\n        var oldY = this._y;\n        var dx = x - oldX;\n        var dy = y - oldY;\n        this._x = x;\n        this._y = y;\n        this._opt.preventDefaultMouseMove && stop(e.event);\n        trigger(this, 'pan', 'moveOnMouseMove', e, {\n          dx: dx,\n          dy: dy,\n          oldX: oldX,\n          oldY: oldY,\n          newX: x,\n          newY: y,\n          isAvailableBehavior: null\n        });\n      };\n\n      RoamController.prototype._mouseupHandler = function (e) {\n        if (!isMiddleOrRightButtonOnMouseUpDown(e)) {\n          this._dragging = false;\n        }\n      };\n\n      RoamController.prototype._mousewheelHandler = function (e) {\n        var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);\n        var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);\n        var wheelDelta = e.wheelDelta;\n        var absWheelDeltaDelta = Math.abs(wheelDelta);\n        var originX = e.offsetX;\n        var originY = e.offsetY;\n\n        if (wheelDelta === 0 || !shouldZoom && !shouldMove) {\n          return;\n        }\n\n        if (shouldZoom) {\n          var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;\n          var scale = wheelDelta > 0 ? factor : 1 / factor;\n          checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {\n            scale: scale,\n            originX: originX,\n            originY: originY,\n            isAvailableBehavior: null\n          });\n        }\n\n        if (shouldMove) {\n          var absDelta = Math.abs(wheelDelta);\n          var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);\n          checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {\n            scrollDelta: scrollDelta,\n            originX: originX,\n            originY: originY,\n            isAvailableBehavior: null\n          });\n        }\n      };\n\n      RoamController.prototype._pinchHandler = function (e) {\n        if (isTaken(this._zr, 'globalPan')) {\n          return;\n        }\n\n        var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;\n        checkPointerAndTrigger(this, 'zoom', null, e, {\n          scale: scale,\n          originX: e.pinchX,\n          originY: e.pinchY,\n          isAvailableBehavior: null\n        });\n      };\n\n      return RoamController;\n    }(Eventful);\n\n    function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n      if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {\n        stop(e.event);\n        trigger(controller, eventName, behaviorToCheck, e, contollerEvent);\n      }\n    }\n\n    function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {\n      contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e);\n      controller.trigger(eventName, contollerEvent);\n    }\n\n    function isAvailableBehavior(behaviorToCheck, e, settings) {\n      var setting = settings[behaviorToCheck];\n      return !behaviorToCheck || setting && (!isString(setting) || e.event[setting + 'Key']);\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function updateViewOnPan(controllerHost, dx, dy) {\n      var target = controllerHost.target;\n      target.x += dx;\n      target.y += dy;\n      target.dirty();\n    }\n    function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {\n      var target = controllerHost.target;\n      var zoomLimit = controllerHost.zoomLimit;\n      var newZoom = controllerHost.zoom = controllerHost.zoom || 1;\n      newZoom *= zoomDelta;\n\n      if (zoomLimit) {\n        var zoomMin = zoomLimit.min || 0;\n        var zoomMax = zoomLimit.max || Infinity;\n        newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);\n      }\n\n      var zoomScale = newZoom / controllerHost.zoom;\n      controllerHost.zoom = newZoom;\n      target.x -= (zoomX - target.x) * (zoomScale - 1);\n      target.y -= (zoomY - target.y) * (zoomScale - 1);\n      target.scaleX *= zoomScale;\n      target.scaleY *= zoomScale;\n      target.dirty();\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var IRRELEVANT_EXCLUDES = {\n      'axisPointer': 1,\n      'tooltip': 1,\n      'brush': 1\n    };\n    function onIrrelevantElement(e, api, targetCoordSysModel) {\n      var model = api.getComponentByElement(e.topTarget);\n      var coordSys = model && model.coordinateSystem;\n      return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel;\n    }\n\n    var geoCoord = [126, 25];\n    var points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];\n\n    for (var i = 0; i < points$1.length; i++) {\n      for (var k = 0; k < points$1[i].length; k++) {\n        points$1[i][k][0] /= 10.5;\n        points$1[i][k][1] /= -10.5 / 0.75;\n        points$1[i][k][0] += geoCoord[0];\n        points$1[i][k][1] += geoCoord[1];\n      }\n    }\n\n    function fixNanhai(mapType, regions) {\n      if (mapType === 'china') {\n        regions.push(new Region('', map(points$1, function (exterior) {\n          return {\n            type: 'polygon',\n            exterior: exterior\n          };\n        }), geoCoord));\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var coordsOffsetMap = {\n      '': [32, 80],\n      '': [0, -10],\n      '': [10, 5],\n      '': [-10, 10],\n      '': [5, 5]\n    };\n    function fixTextCoords(mapType, region) {\n      if (mapType === 'china') {\n        var coordFix = coordsOffsetMap[region.name];\n\n        if (coordFix) {\n          var cp = region.center;\n          cp[0] += coordFix[0] / 10.5;\n          cp[1] += -coordFix[1] / (10.5 / 0.75);\n        }\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var geoCoordMap = {\n      'Russia': [100, 60],\n      'United States': [-99, 38],\n      'United States of America': [-99, 38]\n    };\n    function fixGeoCoords(mapType, region) {\n      if (mapType === 'world') {\n        var geoCoord = geoCoordMap[region.name];\n\n        if (geoCoord) {\n          var cp = region.center;\n          cp[0] = geoCoord[0];\n          cp[1] = geoCoord[1];\n        }\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var points$2 = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];\n    function fixDiaoyuIsland(mapType, region) {\n      if (mapType === 'china' && region.name === '') {\n        region.geometries.push({\n          type: 'polygon',\n          exterior: points$2[0]\n        });\n      }\n    }\n\n    var inner$6 = makeInner();\n    var geoJSONLoader = {\n      load: function (mapName, mapRecord, nameProperty) {\n        var parsed = inner$6(mapRecord).parsed;\n\n        if (parsed) {\n          return parsed;\n        }\n\n        var specialAreas = mapRecord.specialAreas || {};\n        var geoJSON = mapRecord.geoJSON;\n        var regions;\n\n        try {\n          regions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];\n        } catch (e) {\n          throw new Error('Invalid geoJson format\\n' + e.message);\n        }\n\n        fixNanhai(mapName, regions);\n        each(regions, function (region) {\n          var regionName = region.name;\n          fixTextCoords(mapName, region);\n          fixGeoCoords(mapName, region);\n          fixDiaoyuIsland(mapName, region);\n          var specialArea = specialAreas[regionName];\n\n          if (specialArea) {\n            region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);\n          }\n        });\n        return inner$6(mapRecord).parsed = {\n          regions: regions,\n          boundingRect: getBoundingRect$1(regions)\n        };\n      }\n    };\n\n    function getBoundingRect$1(regions) {\n      var rect;\n\n      for (var i = 0; i < regions.length; i++) {\n        var regionRect = regions[i].getBoundingRect();\n        rect = rect || regionRect.clone();\n        rect.union(regionRect);\n      }\n\n      return rect;\n    }\n\n    var DILIMITER_REG = /[\\s,]+/;\n    var nodeParsers;\n    var SVGParser = (function () {\n        function SVGParser() {\n            this._defs = {};\n            this._root = null;\n            this._isDefine = false;\n            this._isText = false;\n        }\n        SVGParser.prototype.parse = function (xml, opt) {\n            opt = opt || {};\n            var svg = parseXML(xml);\n            if (!svg) {\n                throw new Error('Illegal svg');\n            }\n            var root = new Group();\n            this._root = root;\n            var viewBox = svg.getAttribute('viewBox') || '';\n            var width = parseFloat((svg.getAttribute('width') || opt.width));\n            var height = parseFloat((svg.getAttribute('height') || opt.height));\n            isNaN(width) && (width = null);\n            isNaN(height) && (height = null);\n            parseAttributes(svg, root, null, true);\n            var child = svg.firstChild;\n            while (child) {\n                this._parseNode(child, root);\n                child = child.nextSibling;\n            }\n            var viewBoxRect;\n            var viewBoxTransform;\n            if (viewBox) {\n                var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n                if (viewBoxArr.length >= 4) {\n                    viewBoxRect = {\n                        x: parseFloat((viewBoxArr[0] || 0)),\n                        y: parseFloat((viewBoxArr[1] || 0)),\n                        width: parseFloat(viewBoxArr[2]),\n                        height: parseFloat(viewBoxArr[3])\n                    };\n                }\n            }\n            if (viewBoxRect && width != null && height != null) {\n                viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n                if (!opt.ignoreViewBox) {\n                    var elRoot = root;\n                    root = new Group();\n                    root.add(elRoot);\n                    elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                    elRoot.x = viewBoxTransform.x;\n                    elRoot.y = viewBoxTransform.y;\n                }\n            }\n            if (!opt.ignoreRootClip && width != null && height != null) {\n                root.setClipPath(new Rect({\n                    shape: { x: 0, y: 0, width: width, height: height }\n                }));\n            }\n            return {\n                root: root,\n                width: width,\n                height: height,\n                viewBoxRect: viewBoxRect,\n                viewBoxTransform: viewBoxTransform\n            };\n        };\n        SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n            var nodeName = xmlNode.nodeName.toLowerCase();\n            if (nodeName === 'defs') {\n                this._isDefine = true;\n            }\n            else if (nodeName === 'text') {\n                this._isText = true;\n            }\n            var el;\n            if (this._isDefine) {\n                var parser = defineParsers[nodeName];\n                if (parser) {\n                    var def = parser.call(this, xmlNode);\n                    var id = xmlNode.getAttribute('id');\n                    if (id) {\n                        this._defs[id] = def;\n                    }\n                }\n            }\n            else {\n                var parser = nodeParsers[nodeName];\n                if (parser) {\n                    el = parser.call(this, xmlNode, parentGroup);\n                    parentGroup.add(el);\n                }\n            }\n            if (el) {\n                var child = xmlNode.firstChild;\n                while (child) {\n                    if (child.nodeType === 1) {\n                        this._parseNode(child, el);\n                    }\n                    if (child.nodeType === 3 && this._isText) {\n                        this._parseText(child, el);\n                    }\n                    child = child.nextSibling;\n                }\n            }\n            if (nodeName === 'defs') {\n                this._isDefine = false;\n            }\n            else if (nodeName === 'text') {\n                this._isText = false;\n            }\n        };\n        SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n            if (xmlNode.nodeType === 1) {\n                var dx = xmlNode.getAttribute('dx') || 0;\n                var dy = xmlNode.getAttribute('dy') || 0;\n                this._textX += parseFloat(dx);\n                this._textY += parseFloat(dy);\n            }\n            var text = new TSpan({\n                style: {\n                    text: xmlNode.textContent\n                },\n                x: this._textX || 0,\n                y: this._textY || 0\n            });\n            inheritStyle(parentGroup, text);\n            parseAttributes(xmlNode, text, this._defs);\n            var textStyle = text.style;\n            var fontSize = textStyle.fontSize;\n            if (fontSize && fontSize < 9) {\n                textStyle.fontSize = 9;\n                text.scaleX *= fontSize / 9;\n                text.scaleY *= fontSize / 9;\n            }\n            var font = (textStyle.fontSize || textStyle.fontFamily) && [\n                textStyle.fontStyle,\n                textStyle.fontWeight,\n                (textStyle.fontSize || 12) + 'px',\n                textStyle.fontFamily || 'sans-serif'\n            ].join(' ');\n            textStyle.font = font;\n            var rect = text.getBoundingRect();\n            this._textX += rect.width;\n            parentGroup.add(text);\n            return text;\n        };\n        SVGParser.internalField = (function () {\n            nodeParsers = {\n                'g': function (xmlNode, parentGroup) {\n                    var g = new Group();\n                    inheritStyle(parentGroup, g);\n                    parseAttributes(xmlNode, g, this._defs);\n                    return g;\n                },\n                'rect': function (xmlNode, parentGroup) {\n                    var rect = new Rect();\n                    inheritStyle(parentGroup, rect);\n                    parseAttributes(xmlNode, rect, this._defs);\n                    rect.setShape({\n                        x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                        y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                        width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                        height: parseFloat(xmlNode.getAttribute('height') || '0')\n                    });\n                    return rect;\n                },\n                'circle': function (xmlNode, parentGroup) {\n                    var circle = new Circle();\n                    inheritStyle(parentGroup, circle);\n                    parseAttributes(xmlNode, circle, this._defs);\n                    circle.setShape({\n                        cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                        cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                        r: parseFloat(xmlNode.getAttribute('r') || '0')\n                    });\n                    return circle;\n                },\n                'line': function (xmlNode, parentGroup) {\n                    var line = new Line();\n                    inheritStyle(parentGroup, line);\n                    parseAttributes(xmlNode, line, this._defs);\n                    line.setShape({\n                        x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                        y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                        x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                        y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                    });\n                    return line;\n                },\n                'ellipse': function (xmlNode, parentGroup) {\n                    var ellipse = new Ellipse();\n                    inheritStyle(parentGroup, ellipse);\n                    parseAttributes(xmlNode, ellipse, this._defs);\n                    ellipse.setShape({\n                        cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                        cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                        rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                        ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                    });\n                    return ellipse;\n                },\n                'polygon': function (xmlNode, parentGroup) {\n                    var pointsStr = xmlNode.getAttribute('points');\n                    var pointsArr;\n                    if (pointsStr) {\n                        pointsArr = parsePoints(pointsStr);\n                    }\n                    var polygon = new Polygon({\n                        shape: {\n                            points: pointsArr || []\n                        }\n                    });\n                    inheritStyle(parentGroup, polygon);\n                    parseAttributes(xmlNode, polygon, this._defs);\n                    return polygon;\n                },\n                'polyline': function (xmlNode, parentGroup) {\n                    var path = new Path();\n                    inheritStyle(parentGroup, path);\n                    parseAttributes(xmlNode, path, this._defs);\n                    var pointsStr = xmlNode.getAttribute('points');\n                    var pointsArr;\n                    if (pointsStr) {\n                        pointsArr = parsePoints(pointsStr);\n                    }\n                    var polyline = new Polyline({\n                        shape: {\n                            points: pointsArr || []\n                        }\n                    });\n                    return polyline;\n                },\n                'image': function (xmlNode, parentGroup) {\n                    var img = new ZRImage();\n                    inheritStyle(parentGroup, img);\n                    parseAttributes(xmlNode, img, this._defs);\n                    img.setStyle({\n                        image: xmlNode.getAttribute('xlink:href'),\n                        x: +xmlNode.getAttribute('x'),\n                        y: +xmlNode.getAttribute('y'),\n                        width: +xmlNode.getAttribute('width'),\n                        height: +xmlNode.getAttribute('height')\n                    });\n                    return img;\n                },\n                'text': function (xmlNode, parentGroup) {\n                    var x = xmlNode.getAttribute('x') || '0';\n                    var y = xmlNode.getAttribute('y') || '0';\n                    var dx = xmlNode.getAttribute('dx') || '0';\n                    var dy = xmlNode.getAttribute('dy') || '0';\n                    this._textX = parseFloat(x) + parseFloat(dx);\n                    this._textY = parseFloat(y) + parseFloat(dy);\n                    var g = new Group();\n                    inheritStyle(parentGroup, g);\n                    parseAttributes(xmlNode, g, this._defs);\n                    return g;\n                },\n                'tspan': function (xmlNode, parentGroup) {\n                    var x = xmlNode.getAttribute('x');\n                    var y = xmlNode.getAttribute('y');\n                    if (x != null) {\n                        this._textX = parseFloat(x);\n                    }\n                    if (y != null) {\n                        this._textY = parseFloat(y);\n                    }\n                    var dx = xmlNode.getAttribute('dx') || 0;\n                    var dy = xmlNode.getAttribute('dy') || 0;\n                    var g = new Group();\n                    inheritStyle(parentGroup, g);\n                    parseAttributes(xmlNode, g, this._defs);\n                    this._textX += dx;\n                    this._textY += dy;\n                    return g;\n                },\n                'path': function (xmlNode, parentGroup) {\n                    var d = xmlNode.getAttribute('d') || '';\n                    var path = createFromString(d);\n                    inheritStyle(parentGroup, path);\n                    parseAttributes(xmlNode, path, this._defs);\n                    return path;\n                }\n            };\n        })();\n        return SVGParser;\n    }());\n    var defineParsers = {\n        'lineargradient': function (xmlNode) {\n            var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n            var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n            var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n            var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n            var gradient = new LinearGradient(x1, y1, x2, y2);\n            _parseGradientColorStops(xmlNode, gradient);\n            return gradient;\n        }\n    };\n    function _parseGradientColorStops(xmlNode, gradient) {\n        var stop = xmlNode.firstChild;\n        while (stop) {\n            if (stop.nodeType === 1) {\n                var offsetStr = stop.getAttribute('offset');\n                var offset = void 0;\n                if (offsetStr.indexOf('%') > 0) {\n                    offset = parseInt(offsetStr, 10) / 100;\n                }\n                else if (offsetStr) {\n                    offset = parseFloat(offsetStr);\n                }\n                else {\n                    offset = 0;\n                }\n                var stopColor = stop.getAttribute('stop-color') || '#000000';\n                gradient.colorStops.push({\n                    offset: offset,\n                    color: stopColor\n                });\n            }\n            stop = stop.nextSibling;\n        }\n    }\n    function inheritStyle(parent, child) {\n        if (parent && parent.__inheritedStyle) {\n            if (!child.__inheritedStyle) {\n                child.__inheritedStyle = {};\n            }\n            defaults(child.__inheritedStyle, parent.__inheritedStyle);\n        }\n    }\n    function parsePoints(pointsString) {\n        var list = trim(pointsString).split(DILIMITER_REG);\n        var points = [];\n        for (var i = 0; i < list.length; i += 2) {\n            var x = parseFloat(list[i]);\n            var y = parseFloat(list[i + 1]);\n            points.push([x, y]);\n        }\n        return points;\n    }\n    var attributesMap = {\n        'fill': 'fill',\n        'stroke': 'stroke',\n        'stroke-width': 'lineWidth',\n        'opacity': 'opacity',\n        'fill-opacity': 'fillOpacity',\n        'stroke-opacity': 'strokeOpacity',\n        'stroke-dasharray': 'lineDash',\n        'stroke-dashoffset': 'lineDashOffset',\n        'stroke-linecap': 'lineCap',\n        'stroke-linejoin': 'lineJoin',\n        'stroke-miterlimit': 'miterLimit',\n        'font-family': 'fontFamily',\n        'font-size': 'fontSize',\n        'font-style': 'fontStyle',\n        'font-weight': 'fontWeight',\n        'text-align': 'textAlign',\n        'alignment-baseline': 'textBaseline'\n    };\n    function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n        var disp = el;\n        var zrStyle = disp.__inheritedStyle || {};\n        if (xmlNode.nodeType === 1) {\n            parseTransformAttribute(xmlNode, el);\n            extend(zrStyle, parseStyleAttribute(xmlNode));\n            if (!onlyInlineStyle) {\n                for (var svgAttrName in attributesMap) {\n                    if (attributesMap.hasOwnProperty(svgAttrName)) {\n                        var attrValue = xmlNode.getAttribute(svgAttrName);\n                        if (attrValue != null) {\n                            zrStyle[attributesMap[svgAttrName]] = attrValue;\n                        }\n                    }\n                }\n            }\n        }\n        disp.style = disp.style || {};\n        zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n        zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n        each([\n            'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n        ], function (propName) {\n            zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n        });\n        if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n            zrStyle.textBaseline = 'alphabetic';\n        }\n        if (zrStyle.textBaseline === 'alphabetic') {\n            zrStyle.textBaseline = 'bottom';\n        }\n        if (zrStyle.textAlign === 'start') {\n            zrStyle.textAlign = 'left';\n        }\n        if (zrStyle.textAlign === 'end') {\n            zrStyle.textAlign = 'right';\n        }\n        each(['lineDashOffset', 'lineCap', 'lineJoin',\n            'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'\n        ], function (propName) {\n            zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n        });\n        if (zrStyle.lineDash) {\n            disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n                return parseFloat(str);\n            });\n        }\n        disp.__inheritedStyle = zrStyle;\n    }\n    var urlRegex = /url\\(\\s*#(.*?)\\)/;\n    function getPaint(str, defs) {\n        var urlMatch = defs && str && str.match(urlRegex);\n        if (urlMatch) {\n            var url = trim(urlMatch[1]);\n            var def = defs[url];\n            return def;\n        }\n        return str;\n    }\n    var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n    function parseTransformAttribute(xmlNode, node) {\n        var transform = xmlNode.getAttribute('transform');\n        if (transform) {\n            transform = transform.replace(/,/g, ' ');\n            var transformOps_1 = [];\n            var m = null;\n            transform.replace(transformRegex, function (str, type, value) {\n                transformOps_1.push(type, value);\n                return '';\n            });\n            for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n                var value = transformOps_1[i];\n                var type = transformOps_1[i - 1];\n                var valueArr = void 0;\n                m = m || create$1();\n                switch (type) {\n                    case 'translate':\n                        valueArr = trim(value).split(DILIMITER_REG);\n                        translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                        break;\n                    case 'scale':\n                        valueArr = trim(value).split(DILIMITER_REG);\n                        scale$1(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                        break;\n                    case 'rotate':\n                        valueArr = trim(value).split(DILIMITER_REG);\n                        rotate(m, m, parseFloat(valueArr[0]));\n                        break;\n                    case 'skew':\n                        valueArr = trim(value).split(DILIMITER_REG);\n                        console.warn('Skew transform is not supported yet');\n                        break;\n                    case 'matrix':\n                        valueArr = trim(value).split(DILIMITER_REG);\n                        m[0] = parseFloat(valueArr[0]);\n                        m[1] = parseFloat(valueArr[1]);\n                        m[2] = parseFloat(valueArr[2]);\n                        m[3] = parseFloat(valueArr[3]);\n                        m[4] = parseFloat(valueArr[4]);\n                        m[5] = parseFloat(valueArr[5]);\n                        break;\n                }\n            }\n            node.setLocalTransform(m);\n        }\n    }\n    var styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n    function parseStyleAttribute(xmlNode) {\n        var style = xmlNode.getAttribute('style');\n        var result = {};\n        if (!style) {\n            return result;\n        }\n        var styleList = {};\n        styleRegex.lastIndex = 0;\n        var styleRegResult;\n        while ((styleRegResult = styleRegex.exec(style)) != null) {\n            styleList[styleRegResult[1]] = styleRegResult[2];\n        }\n        for (var svgAttrName in attributesMap) {\n            if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n                result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n            }\n        }\n        return result;\n    }\n    function makeViewBoxTransform(viewBoxRect, width, height) {\n        var scaleX = width / viewBoxRect.width;\n        var scaleY = height / viewBoxRect.height;\n        var scale = Math.min(scaleX, scaleY);\n        return {\n            scale: scale,\n            x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n            y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n        };\n    }\n    function parseSVG(xml, opt) {\n        var parser = new SVGParser();\n        return parser.parse(xml, opt);\n    }\n\n    var inner$7 = makeInner();\n    var geoSVGLoader = {\n      load: function (mapName, mapRecord) {\n        var originRoot = inner$7(mapRecord).originRoot;\n\n        if (originRoot) {\n          return {\n            root: originRoot,\n            boundingRect: inner$7(mapRecord).boundingRect\n          };\n        }\n\n        var graphic = buildGraphic(mapRecord);\n        inner$7(mapRecord).originRoot = graphic.root;\n        inner$7(mapRecord).boundingRect = graphic.boundingRect;\n        return graphic;\n      },\n      makeGraphic: function (mapName, mapRecord, hostKey) {\n        var field = inner$7(mapRecord);\n        var rootMap = field.rootMap || (field.rootMap = createHashMap());\n        var root = rootMap.get(hostKey);\n\n        if (root) {\n          return root;\n        }\n\n        var originRoot = field.originRoot;\n        var boundingRect = field.boundingRect;\n\n        if (!field.originRootHostKey) {\n          field.originRootHostKey = hostKey;\n          root = originRoot;\n        } else {\n          root = buildGraphic(mapRecord, boundingRect).root;\n        }\n\n        return rootMap.set(hostKey, root);\n      },\n      removeGraphic: function (mapName, mapRecord, hostKey) {\n        var field = inner$7(mapRecord);\n        var rootMap = field.rootMap;\n        rootMap && rootMap.removeKey(hostKey);\n\n        if (hostKey === field.originRootHostKey) {\n          field.originRootHostKey = null;\n        }\n      }\n    };\n\n    function buildGraphic(mapRecord, boundingRect) {\n      var svgXML = mapRecord.svgXML;\n      var result;\n      var root;\n\n      try {\n        result = svgXML && parseSVG(svgXML, {\n          ignoreViewBox: true,\n          ignoreRootClip: true\n        }) || {};\n        root = result.root;\n        assert(root != null);\n      } catch (e) {\n        throw new Error('Invalid svg format\\n' + e.message);\n      }\n\n      var svgWidth = result.width;\n      var svgHeight = result.height;\n      var viewBoxRect = result.viewBoxRect;\n\n      if (!boundingRect) {\n        boundingRect = svgWidth == null || svgHeight == null ? root.getBoundingRect() : new BoundingRect(0, 0, 0, 0);\n\n        if (svgWidth != null) {\n          boundingRect.width = svgWidth;\n        }\n\n        if (svgHeight != null) {\n          boundingRect.height = svgHeight;\n        }\n      }\n\n      if (viewBoxRect) {\n        var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect.width, boundingRect.height);\n        var elRoot = root;\n        root = new Group();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n\n      root.setClipPath(new Rect({\n        shape: boundingRect.plain()\n      }));\n      return {\n        root: root,\n        boundingRect: boundingRect\n      };\n    }\n\n    var loaders = {\n      geoJSON: geoJSONLoader,\n      svg: geoSVGLoader\n    };\n    var geoSourceManager = {\n      load: function (mapName, nameMap, nameProperty) {\n        var regions = [];\n        var regionsMap = createHashMap();\n        var nameCoordMap = createHashMap();\n        var boundingRect;\n        var mapRecords = retrieveMap(mapName);\n        each(mapRecords, function (record) {\n          var singleSource = loaders[record.type].load(mapName, record, nameProperty);\n          each(singleSource.regions, function (region) {\n            var regionName = region.name;\n\n            if (nameMap && nameMap.hasOwnProperty(regionName)) {\n              region = region.cloneShallow(regionName = nameMap[regionName]);\n            }\n\n            regions.push(region);\n            regionsMap.set(regionName, region);\n            nameCoordMap.set(regionName, region.center);\n          });\n          var rect = singleSource.boundingRect;\n\n          if (rect) {\n            boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();\n          }\n        });\n        return {\n          regions: regions,\n          regionsMap: regionsMap,\n          nameCoordMap: nameCoordMap,\n          boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)\n        };\n      },\n      makeGraphic: function (mapName, hostKey) {\n        var mapRecords = retrieveMap(mapName);\n        var results = [];\n        each(mapRecords, function (record) {\n          var method = loaders[record.type].makeGraphic;\n          method && results.push(method(mapName, record, hostKey));\n        });\n        return results;\n      },\n      removeGraphic: function (mapName, hostKey) {\n        var mapRecords = retrieveMap(mapName);\n        each(mapRecords, function (record) {\n          var method = loaders[record.type].makeGraphic;\n          method && method(mapName, record, hostKey);\n        });\n      }\n    };\n\n    function mapNotExistsError(mapName) {\n      if (\"development\" !== 'production') {\n        console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.');\n      }\n    }\n\n    function retrieveMap(mapName) {\n      var mapRecords = mapDataStorage.retrieveMap(mapName) || [];\n\n      if (\"development\" !== 'production') {\n        if (!mapRecords.length) {\n          mapNotExistsError(mapName);\n        }\n      }\n\n      return mapRecords;\n    }\n\n    function getFixedItemStyle(model) {\n      var itemStyle = model.getItemStyle();\n      var areaColor = model.get('areaColor');\n\n      if (areaColor != null) {\n        itemStyle.fill = areaColor;\n      }\n\n      return itemStyle;\n    }\n\n    var MapDraw = function () {\n      function MapDraw(api) {\n        var group = new Group();\n        this.uid = getUID('ec_map_draw');\n        this._controller = new RoamController(api.getZr());\n        this._controllerHost = {\n          target: group\n        };\n        this.group = group;\n        group.add(this._regionsGroup = new Group());\n        group.add(this._backgroundGroup = new Group());\n      }\n\n      MapDraw.prototype.draw = function (mapOrGeoModel, ecModel, api, fromView, payload) {\n        var isGeo = mapOrGeoModel.mainType === 'geo';\n        var data = mapOrGeoModel.getData && mapOrGeoModel.getData();\n        isGeo && ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'map'\n        }, function (mapSeries) {\n          if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {\n            data = mapSeries.getData();\n          }\n        });\n        var geo = mapOrGeoModel.coordinateSystem;\n\n        this._updateBackground(geo);\n\n        var regionsGroup = this._regionsGroup;\n        var group = this.group;\n        var transformInfo = geo.getTransformInfo();\n        var isFirstDraw = !regionsGroup.childAt(0) || payload;\n        var targetScaleX;\n        var targetScaleY;\n\n        if (isFirstDraw) {\n          group.transform = transformInfo.roamTransform;\n          group.decomposeTransform();\n          group.dirty();\n        } else {\n          var target = new Transformable();\n          target.transform = transformInfo.roamTransform;\n          target.decomposeTransform();\n          var props = {\n            scaleX: target.scaleX,\n            scaleY: target.scaleY,\n            x: target.x,\n            y: target.y\n          };\n          targetScaleX = target.scaleX;\n          targetScaleY = target.scaleY;\n          updateProps(group, props, mapOrGeoModel);\n        }\n\n        regionsGroup.removeAll();\n        var nameMap = createHashMap();\n        var isVisualEncodedByVisualMap = data && data.getVisual('visualMeta') && data.getVisual('visualMeta').length > 0;\n        each(geo.regions, function (region) {\n          var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new Group());\n          var compoundPath = new CompoundPath({\n            segmentIgnoreThreshold: 1,\n            shape: {\n              paths: []\n            }\n          });\n          regionGroup.add(compoundPath);\n          var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;\n          var itemStyleModel = regionModel.getModel('itemStyle');\n          var emphasisModel = regionModel.getModel('emphasis');\n          var emphasisItemStyleModel = emphasisModel.getModel('itemStyle');\n          var blurItemStyleModel = regionModel.getModel(['blur', 'itemStyle']);\n          var selectItemStyleModel = regionModel.getModel(['select', 'itemStyle']);\n          var itemStyle = getFixedItemStyle(itemStyleModel);\n          var emphasisItemStyle = getFixedItemStyle(emphasisItemStyleModel);\n          var blurItemStyle = getFixedItemStyle(blurItemStyleModel);\n          var selectItemStyle = getFixedItemStyle(selectItemStyleModel);\n          var dataIdx;\n\n          if (data) {\n            dataIdx = data.indexOfName(region.name);\n            var style = data.getItemVisual(dataIdx, 'style');\n            var decal = data.getItemVisual(dataIdx, 'decal');\n\n            if (isVisualEncodedByVisualMap && style.fill) {\n              itemStyle.fill = style.fill;\n            }\n\n            if (decal) {\n              itemStyle.decal = createOrUpdatePatternFromDecal(decal, api);\n            }\n          }\n\n          var sx = transformInfo.rawScaleX;\n          var sy = transformInfo.rawScaleY;\n          var offsetX = transformInfo.rawX;\n          var offsetY = transformInfo.rawY;\n\n          var transformPoint = function (point) {\n            return [point[0] * sx + offsetX, point[1] * sy + offsetY];\n          };\n\n          each(region.geometries, function (geometry) {\n            if (geometry.type !== 'polygon') {\n              return;\n            }\n\n            var points = [];\n\n            for (var i = 0; i < geometry.exterior.length; ++i) {\n              points.push(transformPoint(geometry.exterior[i]));\n            }\n\n            compoundPath.shape.paths.push(new Polygon({\n              segmentIgnoreThreshold: 1,\n              shape: {\n                points: points\n              }\n            }));\n\n            for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {\n              var interior = geometry.interiors[i];\n              var points_1 = [];\n\n              for (var j = 0; j < interior.length; ++j) {\n                points_1.push(transformPoint(interior[j]));\n              }\n\n              compoundPath.shape.paths.push(new Polygon({\n                segmentIgnoreThreshold: 1,\n                shape: {\n                  points: points_1\n                }\n              }));\n            }\n          });\n          compoundPath.setStyle(itemStyle);\n          compoundPath.style.strokeNoScale = true;\n          compoundPath.culling = true;\n          compoundPath.ensureState('emphasis').style = emphasisItemStyle;\n          compoundPath.ensureState('blur').style = blurItemStyle;\n          compoundPath.ensureState('select').style = selectItemStyle;\n          var showLabel = false;\n\n          for (var i = 0; i < DISPLAY_STATES.length; i++) {\n            var stateName = DISPLAY_STATES[i];\n\n            if (regionModel.get(stateName === 'normal' ? ['label', 'show'] : [stateName, 'label', 'show'])) {\n              showLabel = true;\n              break;\n            }\n          }\n\n          var isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx));\n          var itemLayout = data && data.getItemLayout(dataIdx);\n\n          if (isGeo || isDataNaN && showLabel || itemLayout && itemLayout.showLabel) {\n            var query = !isGeo ? dataIdx : region.name;\n            var labelFetcher = void 0;\n\n            if (!data || dataIdx >= 0) {\n              labelFetcher = mapOrGeoModel;\n            }\n\n            var centerPt = transformPoint(region.center);\n            var textEl = new ZRText({\n              x: centerPt[0],\n              y: centerPt[1],\n              scaleX: 1 / group.scaleX,\n              scaleY: 1 / group.scaleY,\n              z2: 10,\n              silent: true\n            });\n            setLabelStyle(textEl, getLabelStatesModels(regionModel), {\n              labelFetcher: labelFetcher,\n              labelDataIndex: query,\n              defaultText: region.name\n            }, {\n              normal: {\n                align: 'center',\n                verticalAlign: 'middle'\n              }\n            });\n            compoundPath.setTextContent(textEl);\n            compoundPath.setTextConfig({\n              local: true\n            });\n            compoundPath.disableLabelAnimation = true;\n\n            if (!isFirstDraw) {\n              updateProps(textEl, {\n                scaleX: 1 / targetScaleX,\n                scaleY: 1 / targetScaleY\n              }, mapOrGeoModel);\n            }\n          }\n\n          if (data) {\n            data.setItemGraphicEl(dataIdx, regionGroup);\n          } else {\n            var regionModel_1 = mapOrGeoModel.getRegionModel(region.name);\n            getECData(compoundPath).eventData = {\n              componentType: 'geo',\n              componentIndex: mapOrGeoModel.componentIndex,\n              geoIndex: mapOrGeoModel.componentIndex,\n              name: region.name,\n              region: regionModel_1 && regionModel_1.option || {}\n            };\n          }\n\n          var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);\n          groupRegions.push(region);\n          regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode');\n          enableHoverEmphasis(regionGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n          regionsGroup.add(regionGroup);\n        });\n\n        this._updateController(mapOrGeoModel, ecModel, api);\n\n        this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView);\n      };\n\n      MapDraw.prototype.remove = function () {\n        this._regionsGroup.removeAll();\n\n        this._backgroundGroup.removeAll();\n\n        this._controller.dispose();\n\n        this._mapName && geoSourceManager.removeGraphic(this._mapName, this.uid);\n        this._mapName = null;\n        this._controllerHost = null;\n      };\n\n      MapDraw.prototype._updateBackground = function (geo) {\n        var mapName = geo.map;\n\n        if (this._mapName !== mapName) {\n          each(geoSourceManager.makeGraphic(mapName, this.uid), function (root) {\n            this._backgroundGroup.add(root);\n          }, this);\n        }\n\n        this._mapName = mapName;\n      };\n\n      MapDraw.prototype._updateController = function (mapOrGeoModel, ecModel, api) {\n        var geo = mapOrGeoModel.coordinateSystem;\n        var controller = this._controller;\n        var controllerHost = this._controllerHost;\n        controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit');\n        controllerHost.zoom = geo.getZoom();\n        controller.enable(mapOrGeoModel.get('roam') || false);\n        var mainType = mapOrGeoModel.mainType;\n\n        function makeActionBase() {\n          var action = {\n            type: 'geoRoam',\n            componentType: mainType\n          };\n          action[mainType + 'Id'] = mapOrGeoModel.id;\n          return action;\n        }\n\n        controller.off('pan').on('pan', function (e) {\n          this._mouseDownFlag = false;\n          updateViewOnPan(controllerHost, e.dx, e.dy);\n          api.dispatchAction(extend(makeActionBase(), {\n            dx: e.dx,\n            dy: e.dy\n          }));\n        }, this);\n        controller.off('zoom').on('zoom', function (e) {\n          this._mouseDownFlag = false;\n          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);\n          api.dispatchAction(extend(makeActionBase(), {\n            zoom: e.scale,\n            originX: e.originX,\n            originY: e.originY\n          }));\n          var group = this.group;\n\n          this._regionsGroup.traverse(function (el) {\n            var textContent = el.getTextContent();\n\n            if (textContent) {\n              textContent.scaleX = 1 / group.scaleX;\n              textContent.scaleY = 1 / group.scaleY;\n              textContent.markRedraw();\n            }\n          });\n        }, this);\n        controller.setPointerChecker(function (e, x, y) {\n          return geo.getViewRectAfterRoam().contain(x, y) && !onIrrelevantElement(e, api, mapOrGeoModel);\n        });\n      };\n\n      MapDraw.prototype._updateMapSelectHandler = function (mapOrGeoModel, regionsGroup, api, fromView) {\n        var mapDraw = this;\n        regionsGroup.off('mousedown');\n\n        if (mapOrGeoModel.get('selectedMode')) {\n          regionsGroup.on('mousedown', function () {\n            mapDraw._mouseDownFlag = true;\n          });\n          regionsGroup.on('click', function (e) {\n            if (!mapDraw._mouseDownFlag) {\n              return;\n            }\n\n            mapDraw._mouseDownFlag = false;\n          });\n        }\n      };\n\n      return MapDraw;\n    }();\n\n    var MapView = function (_super) {\n      __extends(MapView, _super);\n\n      function MapView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MapView.type;\n        return _this;\n      }\n\n      MapView.prototype.render = function (mapModel, ecModel, api, payload) {\n        if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {\n          return;\n        }\n\n        var group = this.group;\n        group.removeAll();\n\n        if (mapModel.getHostGeoModel()) {\n          return;\n        }\n\n        if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {\n          if (mapModel.needsDrawMap) {\n            var mapDraw = this._mapDraw || new MapDraw(api);\n            group.add(mapDraw.group);\n            mapDraw.draw(mapModel, ecModel, api, this, payload);\n            this._mapDraw = mapDraw;\n          } else {\n            this._mapDraw && this._mapDraw.remove();\n            this._mapDraw = null;\n          }\n        } else {\n          var mapDraw = this._mapDraw;\n          mapDraw && group.add(mapDraw.group);\n        }\n\n        mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);\n      };\n\n      MapView.prototype.remove = function () {\n        this._mapDraw && this._mapDraw.remove();\n        this._mapDraw = null;\n        this.group.removeAll();\n      };\n\n      MapView.prototype.dispose = function () {\n        this._mapDraw && this._mapDraw.remove();\n        this._mapDraw = null;\n      };\n\n      MapView.prototype._renderSymbols = function (mapModel, ecModel, api) {\n        var originalData = mapModel.originalData;\n        var group = this.group;\n        originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {\n          if (isNaN(value)) {\n            return;\n          }\n\n          var layout = originalData.getItemLayout(originalDataIndex);\n\n          if (!layout || !layout.point) {\n            return;\n          }\n\n          var point = layout.point;\n          var offset = layout.offset;\n          var circle = new Circle({\n            style: {\n              fill: mapModel.getData().getVisual('style').fill\n            },\n            shape: {\n              cx: point[0] + offset * 9,\n              cy: point[1],\n              r: 3\n            },\n            silent: true,\n            z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)\n          });\n\n          if (!offset) {\n            var fullData = mapModel.mainSeries.getData();\n            var name_1 = originalData.getName(originalDataIndex);\n            var fullIndex_1 = fullData.indexOfName(name_1);\n            var itemModel = originalData.getItemModel(originalDataIndex);\n            var labelModel = itemModel.getModel('label');\n            var regionGroup = fullData.getItemGraphicEl(fullIndex_1);\n            setLabelStyle(circle, getLabelStatesModels(itemModel), {\n              labelFetcher: {\n                getFormattedLabel: function (idx, state) {\n                  return mapModel.getFormattedLabel(fullIndex_1, state);\n                }\n              }\n            });\n            circle.disableLabelAnimation = true;\n\n            if (!labelModel.get('position')) {\n              circle.setTextConfig({\n                position: 'bottom'\n              });\n            }\n\n            regionGroup.onHoverStateChange = function (toState) {\n              circle.useState(toState);\n            };\n          }\n\n          group.add(circle);\n        });\n      };\n\n      MapView.type = 'map';\n      return MapView;\n    }(ChartView);\n\n    var MapSeries = function (_super) {\n      __extends(MapSeries, _super);\n\n      function MapSeries() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MapSeries.type;\n        _this.needsDrawMap = false;\n        _this.seriesGroup = [];\n\n        _this.getTooltipPosition = function (dataIndex) {\n          if (dataIndex != null) {\n            var name_1 = this.getData().getName(dataIndex);\n            var geo = this.coordinateSystem;\n            var region = geo.getRegion(name_1);\n            return region && geo.dataToPoint(region.center);\n          }\n        };\n\n        return _this;\n      }\n\n      MapSeries.prototype.getInitialData = function (option) {\n        var data = createListSimply(this, {\n          coordDimensions: ['value'],\n          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)\n        });\n        var dataNameMap = createHashMap();\n        var toAppendNames = [];\n\n        for (var i = 0, len = data.count(); i < len; i++) {\n          var name_2 = data.getName(i);\n          dataNameMap.set(name_2, true);\n        }\n\n        var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);\n        each(geoSource.regions, function (region) {\n          var name = region.name;\n\n          if (!dataNameMap.get(name)) {\n            toAppendNames.push(name);\n          }\n        });\n        data.appendValues([], toAppendNames);\n        return data;\n      };\n\n      MapSeries.prototype.getHostGeoModel = function () {\n        var geoIndex = this.option.geoIndex;\n        return geoIndex != null ? this.ecModel.getComponent('geo', geoIndex) : null;\n      };\n\n      MapSeries.prototype.getMapType = function () {\n        return (this.getHostGeoModel() || this).option.map;\n      };\n\n      MapSeries.prototype.getRawValue = function (dataIndex) {\n        var data = this.getData();\n        return data.get(data.mapDimension('value'), dataIndex);\n      };\n\n      MapSeries.prototype.getRegionModel = function (regionName) {\n        var data = this.getData();\n        return data.getItemModel(data.indexOfName(regionName));\n      };\n\n      MapSeries.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var value = this.getRawValue(dataIndex);\n        var name = data.getName(dataIndex);\n        var seriesGroup = this.seriesGroup;\n        var seriesNames = [];\n\n        for (var i = 0; i < seriesGroup.length; i++) {\n          var otherIndex = seriesGroup[i].originalData.indexOfName(name);\n          var valueDim = data.mapDimension('value');\n\n          if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {\n            seriesNames.push(seriesGroup[i].name);\n          }\n        }\n\n        return createTooltipMarkup('section', {\n          header: seriesNames.join(', '),\n          noHeader: !seriesNames.length,\n          blocks: [createTooltipMarkup('nameValue', {\n            name: name,\n            value: value\n          })]\n        });\n      };\n\n      MapSeries.prototype.setZoom = function (zoom) {\n        this.option.zoom = zoom;\n      };\n\n      MapSeries.prototype.setCenter = function (center) {\n        this.option.center = center;\n      };\n\n      MapSeries.type = 'series.map';\n      MapSeries.dependencies = ['geo'];\n      MapSeries.layoutMode = 'box';\n      MapSeries.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'geo',\n        map: '',\n        left: 'center',\n        top: 'center',\n        aspectScale: 0.75,\n        showLegendSymbol: true,\n        boundingCoords: null,\n        center: null,\n        zoom: 1,\n        scaleLimit: null,\n        selectedMode: true,\n        label: {\n          show: false,\n          color: '#000'\n        },\n        itemStyle: {\n          borderWidth: 0.5,\n          borderColor: '#444',\n          areaColor: '#eee'\n        },\n        emphasis: {\n          label: {\n            show: true,\n            color: 'rgb(100,0,0)'\n          },\n          itemStyle: {\n            areaColor: 'rgba(255,215,0,0.8)'\n          }\n        },\n        select: {\n          label: {\n            show: true,\n            color: 'rgb(100,0,0)'\n          },\n          itemStyle: {\n            color: 'rgba(255,215,0,0.8)'\n          }\n        },\n        nameProperty: 'name'\n      };\n      return MapSeries;\n    }(SeriesModel);\n\n    function dataStatistics(datas, statisticType) {\n      var dataNameMap = {};\n      each(datas, function (data) {\n        data.each(data.mapDimension('value'), function (value, idx) {\n          var mapKey = 'ec-' + data.getName(idx);\n          dataNameMap[mapKey] = dataNameMap[mapKey] || [];\n\n          if (!isNaN(value)) {\n            dataNameMap[mapKey].push(value);\n          }\n        });\n      });\n      return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {\n        var mapKey = 'ec-' + datas[0].getName(idx);\n        var sum = 0;\n        var min = Infinity;\n        var max = -Infinity;\n        var len = dataNameMap[mapKey].length;\n\n        for (var i = 0; i < len; i++) {\n          min = Math.min(min, dataNameMap[mapKey][i]);\n          max = Math.max(max, dataNameMap[mapKey][i]);\n          sum += dataNameMap[mapKey][i];\n        }\n\n        var result;\n\n        if (statisticType === 'min') {\n          result = min;\n        } else if (statisticType === 'max') {\n          result = max;\n        } else if (statisticType === 'average') {\n          result = sum / len;\n        } else {\n          result = sum;\n        }\n\n        return len === 0 ? NaN : result;\n      });\n    }\n\n    function mapDataStatistic(ecModel) {\n      var seriesGroups = {};\n      ecModel.eachSeriesByType('map', function (seriesModel) {\n        var hostGeoModel = seriesModel.getHostGeoModel();\n        var key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();\n        (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);\n      });\n      each(seriesGroups, function (seriesList, key) {\n        var data = dataStatistics(map(seriesList, function (seriesModel) {\n          return seriesModel.getData();\n        }), seriesList[0].get('mapValueCalculation'));\n\n        for (var i = 0; i < seriesList.length; i++) {\n          seriesList[i].originalData = seriesList[i].getData();\n        }\n\n        for (var i = 0; i < seriesList.length; i++) {\n          seriesList[i].seriesGroup = seriesList;\n          seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();\n          seriesList[i].setData(data.cloneShallow());\n          seriesList[i].mainSeries = seriesList[0];\n        }\n      });\n    }\n\n    function mapSymbolLayout(ecModel) {\n      var processedMapType = {};\n      ecModel.eachSeriesByType('map', function (mapSeries) {\n        var mapType = mapSeries.getMapType();\n\n        if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {\n          return;\n        }\n\n        var mapSymbolOffsets = {};\n        each(mapSeries.seriesGroup, function (subMapSeries) {\n          var geo = subMapSeries.coordinateSystem;\n          var data = subMapSeries.originalData;\n\n          if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {\n            data.each(data.mapDimension('value'), function (value, idx) {\n              var name = data.getName(idx);\n              var region = geo.getRegion(name);\n\n              if (!region || isNaN(value)) {\n                return;\n              }\n\n              var offset = mapSymbolOffsets[name] || 0;\n              var point = geo.dataToPoint(region.center);\n              mapSymbolOffsets[name] = offset + 1;\n              data.setItemLayout(idx, {\n                point: point,\n                offset: offset\n              });\n            });\n          }\n        });\n        var data = mapSeries.getData();\n        data.each(function (idx) {\n          var name = data.getName(idx);\n          var layout = data.getItemLayout(idx) || {};\n          layout.showLabel = !mapSymbolOffsets[name];\n          data.setItemLayout(idx, layout);\n        });\n        processedMapType[mapType] = true;\n      });\n    }\n\n    function install$9(registers) {\n      registers.registerChartView(MapView);\n      registers.registerSeriesModel(MapSeries);\n      registers.registerLayout(mapSymbolLayout);\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);\n      createLegacyDataSelectAction('map', registers.registerAction);\n    }\n\n    function init$2(inRoot) {\n      var root = inRoot;\n      root.hierNode = {\n        defaultAncestor: null,\n        ancestor: root,\n        prelim: 0,\n        modifier: 0,\n        change: 0,\n        shift: 0,\n        i: 0,\n        thread: null\n      };\n      var nodes = [root];\n      var node;\n      var children;\n\n      while (node = nodes.pop()) {\n        children = node.children;\n\n        if (node.isExpand && children.length) {\n          var n = children.length;\n\n          for (var i = n - 1; i >= 0; i--) {\n            var child = children[i];\n            child.hierNode = {\n              defaultAncestor: null,\n              ancestor: child,\n              prelim: 0,\n              modifier: 0,\n              change: 0,\n              shift: 0,\n              i: i,\n              thread: null\n            };\n            nodes.push(child);\n          }\n        }\n      }\n    }\n    function firstWalk(node, separation) {\n      var children = node.isExpand ? node.children : [];\n      var siblings = node.parentNode.children;\n      var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;\n\n      if (children.length) {\n        executeShifts(node);\n        var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;\n\n        if (subtreeW) {\n          node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n          node.hierNode.modifier = node.hierNode.prelim - midPoint;\n        } else {\n          node.hierNode.prelim = midPoint;\n        }\n      } else if (subtreeW) {\n        node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW);\n      }\n\n      node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation);\n    }\n    function secondWalk(node) {\n      var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;\n      node.setLayout({\n        x: nodeX\n      }, true);\n      node.hierNode.modifier += node.parentNode.hierNode.modifier;\n    }\n    function separation(cb) {\n      return arguments.length ? cb : defaultSeparation;\n    }\n    function radialCoordinate(rad, r) {\n      rad -= Math.PI / 2;\n      return {\n        x: r * Math.cos(rad),\n        y: r * Math.sin(rad)\n      };\n    }\n    function getViewRect$1(seriesModel, api) {\n      return getLayoutRect(seriesModel.getBoxLayoutParams(), {\n        width: api.getWidth(),\n        height: api.getHeight()\n      });\n    }\n\n    function executeShifts(node) {\n      var children = node.children;\n      var n = children.length;\n      var shift = 0;\n      var change = 0;\n\n      while (--n >= 0) {\n        var child = children[n];\n        child.hierNode.prelim += shift;\n        child.hierNode.modifier += shift;\n        change += child.hierNode.change;\n        shift += child.hierNode.shift + change;\n      }\n    }\n\n    function apportion(subtreeV, subtreeW, ancestor, separation) {\n      if (subtreeW) {\n        var nodeOutRight = subtreeV;\n        var nodeInRight = subtreeV;\n        var nodeOutLeft = nodeInRight.parentNode.children[0];\n        var nodeInLeft = subtreeW;\n        var sumOutRight = nodeOutRight.hierNode.modifier;\n        var sumInRight = nodeInRight.hierNode.modifier;\n        var sumOutLeft = nodeOutLeft.hierNode.modifier;\n        var sumInLeft = nodeInLeft.hierNode.modifier;\n\n        while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {\n          nodeOutRight = nextRight(nodeOutRight);\n          nodeOutLeft = nextLeft(nodeOutLeft);\n          nodeOutRight.hierNode.ancestor = subtreeV;\n          var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation(nodeInLeft, nodeInRight);\n\n          if (shift > 0) {\n            moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);\n            sumInRight += shift;\n            sumOutRight += shift;\n          }\n\n          sumInLeft += nodeInLeft.hierNode.modifier;\n          sumInRight += nodeInRight.hierNode.modifier;\n          sumOutRight += nodeOutRight.hierNode.modifier;\n          sumOutLeft += nodeOutLeft.hierNode.modifier;\n        }\n\n        if (nodeInLeft && !nextRight(nodeOutRight)) {\n          nodeOutRight.hierNode.thread = nodeInLeft;\n          nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;\n        }\n\n        if (nodeInRight && !nextLeft(nodeOutLeft)) {\n          nodeOutLeft.hierNode.thread = nodeInRight;\n          nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;\n          ancestor = subtreeV;\n        }\n      }\n\n      return ancestor;\n    }\n\n    function nextRight(node) {\n      var children = node.children;\n      return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;\n    }\n\n    function nextLeft(node) {\n      var children = node.children;\n      return children.length && node.isExpand ? children[0] : node.hierNode.thread;\n    }\n\n    function nextAncestor(nodeInLeft, node, ancestor) {\n      return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;\n    }\n\n    function moveSubtree(wl, wr, shift) {\n      var change = shift / (wr.hierNode.i - wl.hierNode.i);\n      wr.hierNode.change -= change;\n      wr.hierNode.shift += shift;\n      wr.hierNode.modifier += shift;\n      wr.hierNode.prelim += shift;\n      wl.hierNode.change += change;\n    }\n\n    function defaultSeparation(node1, node2) {\n      return node1.parentNode === node2.parentNode ? 1 : 2;\n    }\n\n    var v2ApplyTransform = applyTransform;\n\n    var View = function (_super) {\n      __extends(View, _super);\n\n      function View(name) {\n        var _this = _super.call(this) || this;\n\n        _this.type = 'view';\n        _this.dimensions = ['x', 'y'];\n        _this._roamTransformable = new Transformable();\n        _this._rawTransformable = new Transformable();\n        _this.name = name;\n        return _this;\n      }\n\n      View.prototype.setBoundingRect = function (x, y, width, height) {\n        this._rect = new BoundingRect(x, y, width, height);\n        return this._rect;\n      };\n\n      View.prototype.getBoundingRect = function () {\n        return this._rect;\n      };\n\n      View.prototype.setViewRect = function (x, y, width, height) {\n        this.transformTo(x, y, width, height);\n        this._viewRect = new BoundingRect(x, y, width, height);\n      };\n\n      View.prototype.transformTo = function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n        var rawTransform = this._rawTransformable;\n        rawTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n        rawTransform.decomposeTransform();\n\n        this._updateTransform();\n      };\n\n      View.prototype.setCenter = function (centerCoord) {\n        if (!centerCoord) {\n          return;\n        }\n\n        this._center = centerCoord;\n\n        this._updateCenterAndZoom();\n      };\n\n      View.prototype.setZoom = function (zoom) {\n        zoom = zoom || 1;\n        var zoomLimit = this.zoomLimit;\n\n        if (zoomLimit) {\n          if (zoomLimit.max != null) {\n            zoom = Math.min(zoomLimit.max, zoom);\n          }\n\n          if (zoomLimit.min != null) {\n            zoom = Math.max(zoomLimit.min, zoom);\n          }\n        }\n\n        this._zoom = zoom;\n\n        this._updateCenterAndZoom();\n      };\n\n      View.prototype.getDefaultCenter = function () {\n        var rawRect = this.getBoundingRect();\n        var cx = rawRect.x + rawRect.width / 2;\n        var cy = rawRect.y + rawRect.height / 2;\n        return [cx, cy];\n      };\n\n      View.prototype.getCenter = function () {\n        return this._center || this.getDefaultCenter();\n      };\n\n      View.prototype.getZoom = function () {\n        return this._zoom || 1;\n      };\n\n      View.prototype.getRoamTransform = function () {\n        return this._roamTransformable.getLocalTransform();\n      };\n\n      View.prototype._updateCenterAndZoom = function () {\n        var rawTransformMatrix = this._rawTransformable.getLocalTransform();\n\n        var roamTransform = this._roamTransformable;\n        var defaultCenter = this.getDefaultCenter();\n        var center = this.getCenter();\n        var zoom = this.getZoom();\n        center = applyTransform([], center, rawTransformMatrix);\n        defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix);\n        roamTransform.originX = center[0];\n        roamTransform.originY = center[1];\n        roamTransform.x = defaultCenter[0] - center[0];\n        roamTransform.y = defaultCenter[1] - center[1];\n        roamTransform.scaleX = roamTransform.scaleY = zoom;\n\n        this._updateTransform();\n      };\n\n      View.prototype._updateTransform = function () {\n        var roamTransformable = this._roamTransformable;\n        var rawTransformable = this._rawTransformable;\n        rawTransformable.parent = roamTransformable;\n        roamTransformable.updateTransform();\n        rawTransformable.updateTransform();\n        copy$1(this.transform || (this.transform = []), rawTransformable.transform || create$1());\n        this._rawTransform = rawTransformable.getLocalTransform();\n        this.invTransform = this.invTransform || [];\n        invert(this.invTransform, this.transform);\n        this.decomposeTransform();\n      };\n\n      View.prototype.getTransformInfo = function () {\n        var roamTransform = this._roamTransformable.transform;\n        var rawTransformable = this._rawTransformable;\n        return {\n          roamTransform: roamTransform ? slice(roamTransform) : create$1(),\n          rawScaleX: rawTransformable.scaleX,\n          rawScaleY: rawTransformable.scaleY,\n          rawX: rawTransformable.x,\n          rawY: rawTransformable.y\n        };\n      };\n\n      View.prototype.getViewRect = function () {\n        return this._viewRect;\n      };\n\n      View.prototype.getViewRectAfterRoam = function () {\n        var rect = this.getBoundingRect().clone();\n        rect.applyTransform(this.transform);\n        return rect;\n      };\n\n      View.prototype.dataToPoint = function (data, noRoam, out) {\n        var transform = noRoam ? this._rawTransform : this.transform;\n        out = out || [];\n        return transform ? v2ApplyTransform(out, data, transform) : copy(out, data);\n      };\n\n      View.prototype.pointToData = function (point) {\n        var invTransform = this.invTransform;\n        return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];\n      };\n\n      View.prototype.convertToPixel = function (ecModel, finder, value) {\n        var coordSys = getCoordSys(finder);\n        return coordSys === this ? coordSys.dataToPoint(value) : null;\n      };\n\n      View.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        var coordSys = getCoordSys(finder);\n        return coordSys === this ? coordSys.pointToData(pixel) : null;\n      };\n\n      View.prototype.containPoint = function (point) {\n        return this.getViewRectAfterRoam().contain(point[0], point[1]);\n      };\n\n      View.dimensions = ['x', 'y'];\n      return View;\n    }(Transformable);\n\n    function getCoordSys(finder) {\n      var seriesModel = finder.seriesModel;\n      return seriesModel ? seriesModel.coordinateSystem : null;\n    }\n\n    var TreeEdgeShape = function () {\n      function TreeEdgeShape() {\n        this.parentPoint = [];\n        this.childPoints = [];\n      }\n\n      return TreeEdgeShape;\n    }();\n\n    var TreePath = function (_super) {\n      __extends(TreePath, _super);\n\n      function TreePath(opts) {\n        return _super.call(this, opts) || this;\n      }\n\n      TreePath.prototype.getDefaultStyle = function () {\n        return {\n          stroke: '#000',\n          fill: null\n        };\n      };\n\n      TreePath.prototype.getDefaultShape = function () {\n        return new TreeEdgeShape();\n      };\n\n      TreePath.prototype.buildPath = function (ctx, shape) {\n        var childPoints = shape.childPoints;\n        var childLen = childPoints.length;\n        var parentPoint = shape.parentPoint;\n        var firstChildPos = childPoints[0];\n        var lastChildPos = childPoints[childLen - 1];\n\n        if (childLen === 1) {\n          ctx.moveTo(parentPoint[0], parentPoint[1]);\n          ctx.lineTo(firstChildPos[0], firstChildPos[1]);\n          return;\n        }\n\n        var orient = shape.orient;\n        var forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1;\n        var otherDim = 1 - forkDim;\n        var forkPosition = parsePercent$1(shape.forkPosition, 1);\n        var tmpPoint = [];\n        tmpPoint[forkDim] = parentPoint[forkDim];\n        tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;\n        ctx.moveTo(parentPoint[0], parentPoint[1]);\n        ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n        ctx.moveTo(firstChildPos[0], firstChildPos[1]);\n        tmpPoint[forkDim] = firstChildPos[forkDim];\n        ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n        tmpPoint[forkDim] = lastChildPos[forkDim];\n        ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n        ctx.lineTo(lastChildPos[0], lastChildPos[1]);\n\n        for (var i = 1; i < childLen - 1; i++) {\n          var point = childPoints[i];\n          ctx.moveTo(point[0], point[1]);\n          tmpPoint[forkDim] = point[forkDim];\n          ctx.lineTo(tmpPoint[0], tmpPoint[1]);\n        }\n      };\n\n      return TreePath;\n    }(Path);\n\n    var TreeView = function (_super) {\n      __extends(TreeView, _super);\n\n      function TreeView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TreeView.type;\n        _this._mainGroup = new Group();\n        return _this;\n      }\n\n      TreeView.prototype.init = function (ecModel, api) {\n        this._controller = new RoamController(api.getZr());\n        this._controllerHost = {\n          target: this.group\n        };\n        this.group.add(this._mainGroup);\n      };\n\n      TreeView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var layoutInfo = seriesModel.layoutInfo;\n        var group = this._mainGroup;\n        var layout = seriesModel.get('layout');\n\n        if (layout === 'radial') {\n          group.x = layoutInfo.x + layoutInfo.width / 2;\n          group.y = layoutInfo.y + layoutInfo.height / 2;\n        } else {\n          group.x = layoutInfo.x;\n          group.y = layoutInfo.y;\n        }\n\n        this._updateViewCoordSys(seriesModel);\n\n        this._updateController(seriesModel, ecModel, api);\n\n        var oldData = this._data;\n        data.diff(oldData).add(function (newIdx) {\n          if (symbolNeedsDraw$1(data, newIdx)) {\n            updateNode(data, newIdx, null, group, seriesModel);\n          }\n        }).update(function (newIdx, oldIdx) {\n          var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\n          if (!symbolNeedsDraw$1(data, newIdx)) {\n            symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);\n            return;\n          }\n\n          updateNode(data, newIdx, symbolEl, group, seriesModel);\n        }).remove(function (oldIdx) {\n          var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\n          if (symbolEl) {\n            removeNode(oldData, oldIdx, symbolEl, group, seriesModel);\n          }\n        }).execute();\n        this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');\n\n        this._updateNodeAndLinkScale(seriesModel);\n\n        if (seriesModel.get('expandAndCollapse') === true) {\n          data.eachItemGraphicEl(function (el, dataIndex) {\n            el.off('click').on('click', function () {\n              api.dispatchAction({\n                type: 'treeExpandAndCollapse',\n                seriesId: seriesModel.id,\n                dataIndex: dataIndex\n              });\n            });\n          });\n        }\n\n        this._data = data;\n      };\n\n      TreeView.prototype._updateViewCoordSys = function (seriesModel) {\n        var data = seriesModel.getData();\n        var points = [];\n        data.each(function (idx) {\n          var layout = data.getItemLayout(idx);\n\n          if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {\n            points.push([+layout.x, +layout.y]);\n          }\n        });\n        var min = [];\n        var max = [];\n        fromPoints(points, min, max);\n        var oldMin = this._min;\n        var oldMax = this._max;\n\n        if (max[0] - min[0] === 0) {\n          min[0] = oldMin ? oldMin[0] : min[0] - 1;\n          max[0] = oldMax ? oldMax[0] : max[0] + 1;\n        }\n\n        if (max[1] - min[1] === 0) {\n          min[1] = oldMin ? oldMin[1] : min[1] - 1;\n          max[1] = oldMax ? oldMax[1] : max[1] + 1;\n        }\n\n        var viewCoordSys = seriesModel.coordinateSystem = new View();\n        viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n        viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n        viewCoordSys.setCenter(seriesModel.get('center'));\n        viewCoordSys.setZoom(seriesModel.get('zoom'));\n        this.group.attr({\n          x: viewCoordSys.x,\n          y: viewCoordSys.y,\n          scaleX: viewCoordSys.scaleX,\n          scaleY: viewCoordSys.scaleY\n        });\n        this._min = min;\n        this._max = max;\n      };\n\n      TreeView.prototype._updateController = function (seriesModel, ecModel, api) {\n        var _this = this;\n\n        var controller = this._controller;\n        var controllerHost = this._controllerHost;\n        var group = this.group;\n        controller.setPointerChecker(function (e, x, y) {\n          var rect = group.getBoundingRect();\n          rect.applyTransform(group.transform);\n          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);\n        });\n        controller.enable(seriesModel.get('roam'));\n        controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n        controller.off('pan').off('zoom').on('pan', function (e) {\n          updateViewOnPan(controllerHost, e.dx, e.dy);\n          api.dispatchAction({\n            seriesId: seriesModel.id,\n            type: 'treeRoam',\n            dx: e.dx,\n            dy: e.dy\n          });\n        }).on('zoom', function (e) {\n          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);\n          api.dispatchAction({\n            seriesId: seriesModel.id,\n            type: 'treeRoam',\n            zoom: e.scale,\n            originX: e.originX,\n            originY: e.originY\n          });\n\n          _this._updateNodeAndLinkScale(seriesModel);\n\n          api.updateLabelLayout();\n        });\n      };\n\n      TreeView.prototype._updateNodeAndLinkScale = function (seriesModel) {\n        var data = seriesModel.getData();\n\n        var nodeScale = this._getNodeGlobalScale(seriesModel);\n\n        data.eachItemGraphicEl(function (el, idx) {\n          el.setSymbolScale(nodeScale);\n        });\n      };\n\n      TreeView.prototype._getNodeGlobalScale = function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys.type !== 'view') {\n          return 1;\n        }\n\n        var nodeScaleRatio = this._nodeScaleRatio;\n        var groupZoom = coordSys.scaleX || 1;\n        var roamZoom = coordSys.getZoom();\n        var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n        return nodeScale / groupZoom;\n      };\n\n      TreeView.prototype.dispose = function () {\n        this._controller && this._controller.dispose();\n        this._controllerHost = null;\n      };\n\n      TreeView.prototype.remove = function () {\n        this._mainGroup.removeAll();\n\n        this._data = null;\n      };\n\n      TreeView.type = 'tree';\n      return TreeView;\n    }(ChartView);\n\n    function symbolNeedsDraw$1(data, dataIndex) {\n      var layout = data.getItemLayout(dataIndex);\n      return layout && !isNaN(layout.x) && !isNaN(layout.y);\n    }\n\n    function updateNode(data, dataIndex, symbolEl, group, seriesModel) {\n      var isInit = !symbolEl;\n      var node = data.tree.getNodeByDataIndex(dataIndex);\n      var itemModel = node.getModel();\n      var visualColor = node.getVisual('style').fill;\n      var symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : '#fff';\n      var virtualRoot = data.tree.root;\n      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n      var sourceLayout = source.getLayout();\n      var sourceOldLayout = sourceSymbolEl ? {\n        x: sourceSymbolEl.__oldX,\n        y: sourceSymbolEl.__oldY,\n        rawX: sourceSymbolEl.__radialOldRawX,\n        rawY: sourceSymbolEl.__radialOldRawY\n      } : sourceLayout;\n      var targetLayout = node.getLayout();\n\n      if (isInit) {\n        symbolEl = new Symbol(data, dataIndex, null, {\n          symbolInnerColor: symbolInnerColor,\n          useNameLabel: true\n        });\n        symbolEl.x = sourceOldLayout.x;\n        symbolEl.y = sourceOldLayout.y;\n      } else {\n        symbolEl.updateData(data, dataIndex, null, {\n          symbolInnerColor: symbolInnerColor,\n          useNameLabel: true\n        });\n      }\n\n      symbolEl.__radialOldRawX = symbolEl.__radialRawX;\n      symbolEl.__radialOldRawY = symbolEl.__radialRawY;\n      symbolEl.__radialRawX = targetLayout.rawX;\n      symbolEl.__radialRawY = targetLayout.rawY;\n      group.add(symbolEl);\n      data.setItemGraphicEl(dataIndex, symbolEl);\n      symbolEl.__oldX = symbolEl.x;\n      symbolEl.__oldY = symbolEl.y;\n      updateProps(symbolEl, {\n        x: targetLayout.x,\n        y: targetLayout.y\n      }, seriesModel);\n      var symbolPath = symbolEl.getSymbolPath();\n\n      if (seriesModel.get('layout') === 'radial') {\n        var realRoot = virtualRoot.children[0];\n        var rootLayout = realRoot.getLayout();\n        var length_1 = realRoot.children.length;\n        var rad = void 0;\n        var isLeft = void 0;\n\n        if (targetLayout.x === rootLayout.x && node.isExpand === true) {\n          var center = {\n            x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,\n            y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2\n          };\n          rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);\n\n          if (rad < 0) {\n            rad = Math.PI * 2 + rad;\n          }\n\n          isLeft = center.x < rootLayout.x;\n\n          if (isLeft) {\n            rad = rad - Math.PI;\n          }\n        } else {\n          rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);\n\n          if (rad < 0) {\n            rad = Math.PI * 2 + rad;\n          }\n\n          if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {\n            isLeft = targetLayout.x < rootLayout.x;\n\n            if (isLeft) {\n              rad = rad - Math.PI;\n            }\n          } else {\n            isLeft = targetLayout.x > rootLayout.x;\n\n            if (!isLeft) {\n              rad = rad - Math.PI;\n            }\n          }\n        }\n\n        var textPosition = isLeft ? 'left' : 'right';\n        var normalLabelModel = itemModel.getModel('label');\n        var rotate = normalLabelModel.get('rotate');\n        var labelRotateRadian = rotate * (Math.PI / 180);\n        var textContent = symbolPath.getTextContent();\n\n        if (textContent) {\n          symbolPath.setTextConfig({\n            position: normalLabelModel.get('position') || textPosition,\n            rotation: rotate == null ? -rad : labelRotateRadian,\n            origin: 'center'\n          });\n          textContent.setStyle('verticalAlign', 'middle');\n        }\n      }\n\n      var focus = itemModel.get(['emphasis', 'focus']);\n      var focusDataIndices = focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null;\n\n      if (focusDataIndices) {\n        getECData(symbolEl).focus = focusDataIndices;\n      }\n\n      drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);\n\n      if (symbolEl.__edge) {\n        symbolEl.onHoverStateChange = function (toState) {\n          if (toState !== 'blur') {\n            var parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);\n\n            if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {\n              setStatesFlag(symbolEl.__edge, toState);\n            }\n          }\n        };\n      }\n    }\n\n    function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {\n      var itemModel = node.getModel();\n      var edgeShape = seriesModel.get('edgeShape');\n      var layout = seriesModel.get('layout');\n      var orient = seriesModel.getOrient();\n      var curvature = seriesModel.get(['lineStyle', 'curveness']);\n      var edgeForkPosition = seriesModel.get('edgeForkPosition');\n      var lineStyle = itemModel.getModel('lineStyle').getLineStyle();\n      var edge = symbolEl.__edge;\n\n      if (edgeShape === 'curve') {\n        if (node.parentNode && node.parentNode !== virtualRoot) {\n          if (!edge) {\n            edge = symbolEl.__edge = new BezierCurve({\n              shape: getEdgeShape(layout, orient, curvature, sourceOldLayout, sourceOldLayout)\n            });\n          }\n\n          updateProps(edge, {\n            shape: getEdgeShape(layout, orient, curvature, sourceLayout, targetLayout)\n          }, seriesModel);\n        }\n      } else if (edgeShape === 'polyline') {\n        if (layout === 'orthogonal') {\n          if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {\n            var children = node.children;\n            var childPoints = [];\n\n            for (var i = 0; i < children.length; i++) {\n              var childLayout = children[i].getLayout();\n              childPoints.push([childLayout.x, childLayout.y]);\n            }\n\n            if (!edge) {\n              edge = symbolEl.__edge = new TreePath({\n                shape: {\n                  parentPoint: [targetLayout.x, targetLayout.y],\n                  childPoints: [[targetLayout.x, targetLayout.y]],\n                  orient: orient,\n                  forkPosition: edgeForkPosition\n                }\n              });\n            }\n\n            updateProps(edge, {\n              shape: {\n                parentPoint: [targetLayout.x, targetLayout.y],\n                childPoints: childPoints\n              }\n            }, seriesModel);\n          }\n        } else {\n          if (\"development\" !== 'production') {\n            throw new Error('The polyline edgeShape can only be used in orthogonal layout');\n          }\n        }\n      }\n\n      if (edge) {\n        edge.useStyle(defaults({\n          strokeNoScale: true,\n          fill: null\n        }, lineStyle));\n        setStatesStylesFromModel(edge, itemModel, 'lineStyle');\n        setDefaultStateProxy(edge);\n        group.add(edge);\n      }\n    }\n\n    function removeNode(data, dataIndex, symbolEl, group, seriesModel) {\n      var node = data.tree.getNodeByDataIndex(dataIndex);\n      var virtualRoot = data.tree.root;\n      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;\n      var sourceLayout;\n\n      while (sourceLayout = source.getLayout(), sourceLayout == null) {\n        source = source.parentNode === virtualRoot ? source : source.parentNode || source;\n      }\n\n      var removeAnimationOpt = {\n        duration: seriesModel.get('animationDurationUpdate'),\n        easing: seriesModel.get('animationEasingUpdate')\n      };\n      removeElement(symbolEl, {\n        x: sourceLayout.x + 1,\n        y: sourceLayout.y + 1\n      }, seriesModel, {\n        cb: function () {\n          group.remove(symbolEl);\n          data.setItemGraphicEl(dataIndex, null);\n        },\n        removeOpt: removeAnimationOpt\n      });\n      symbolEl.fadeOut(null, {\n        fadeLabel: true,\n        animation: removeAnimationOpt\n      });\n      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);\n      var sourceEdge = sourceSymbolEl.__edge;\n      var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined);\n      var edgeShape = seriesModel.get('edgeShape');\n      var layoutOpt = seriesModel.get('layout');\n      var orient = seriesModel.get('orient');\n      var curvature = seriesModel.get(['lineStyle', 'curveness']);\n\n      if (edge) {\n        if (edgeShape === 'curve') {\n          removeElement(edge, {\n            shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),\n            style: {\n              opacity: 0\n            }\n          }, seriesModel, {\n            cb: function () {\n              group.remove(edge);\n            },\n            removeOpt: removeAnimationOpt\n          });\n        } else if (edgeShape === 'polyline' && seriesModel.get('layout') === 'orthogonal') {\n          removeElement(edge, {\n            shape: {\n              parentPoint: [sourceLayout.x, sourceLayout.y],\n              childPoints: [[sourceLayout.x, sourceLayout.y]]\n            },\n            style: {\n              opacity: 0\n            }\n          }, seriesModel, {\n            cb: function () {\n              group.remove(edge);\n            },\n            removeOpt: removeAnimationOpt\n          });\n        }\n      }\n    }\n\n    function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {\n      var cpx1;\n      var cpy1;\n      var cpx2;\n      var cpy2;\n      var x1;\n      var x2;\n      var y1;\n      var y2;\n\n      if (layoutOpt === 'radial') {\n        x1 = sourceLayout.rawX;\n        y1 = sourceLayout.rawY;\n        x2 = targetLayout.rawX;\n        y2 = targetLayout.rawY;\n        var radialCoor1 = radialCoordinate(x1, y1);\n        var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);\n        var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);\n        var radialCoor4 = radialCoordinate(x2, y2);\n        return {\n          x1: radialCoor1.x || 0,\n          y1: radialCoor1.y || 0,\n          x2: radialCoor4.x || 0,\n          y2: radialCoor4.y || 0,\n          cpx1: radialCoor2.x || 0,\n          cpy1: radialCoor2.y || 0,\n          cpx2: radialCoor3.x || 0,\n          cpy2: radialCoor3.y || 0\n        };\n      } else {\n        x1 = sourceLayout.x;\n        y1 = sourceLayout.y;\n        x2 = targetLayout.x;\n        y2 = targetLayout.y;\n\n        if (orient === 'LR' || orient === 'RL') {\n          cpx1 = x1 + (x2 - x1) * curvature;\n          cpy1 = y1;\n          cpx2 = x2 + (x1 - x2) * curvature;\n          cpy2 = y2;\n        }\n\n        if (orient === 'TB' || orient === 'BT') {\n          cpx1 = x1;\n          cpy1 = y1 + (y2 - y1) * curvature;\n          cpx2 = x2;\n          cpy2 = y2 + (y1 - y2) * curvature;\n        }\n      }\n\n      return {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        cpx1: cpx1,\n        cpy1: cpy1,\n        cpx2: cpx2,\n        cpy2: cpy2\n      };\n    }\n\n    var inner$8 = makeInner();\n\n    function linkList(opt) {\n      var mainData = opt.mainData;\n      var datas = opt.datas;\n\n      if (!datas) {\n        datas = {\n          main: mainData\n        };\n        opt.datasAttr = {\n          main: 'data'\n        };\n      }\n\n      opt.datas = opt.mainData = null;\n      linkAll(mainData, datas, opt);\n      each(datas, function (data) {\n        each(mainData.TRANSFERABLE_METHODS, function (methodName) {\n          data.wrapMethod(methodName, curry(transferInjection, opt));\n        });\n      });\n      mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt));\n      each(mainData.CHANGABLE_METHODS, function (methodName) {\n        mainData.wrapMethod(methodName, curry(changeInjection, opt));\n      });\n      assert(datas[mainData.dataType] === mainData);\n    }\n\n    function transferInjection(opt, res) {\n      if (isMainData(this)) {\n        var datas = extend({}, inner$8(this).datas);\n        datas[this.dataType] = res;\n        linkAll(res, datas, opt);\n      } else {\n        linkSingle(res, this.dataType, inner$8(this).mainData, opt);\n      }\n\n      return res;\n    }\n\n    function changeInjection(opt, res) {\n      opt.struct && opt.struct.update();\n      return res;\n    }\n\n    function cloneShallowInjection(opt, res) {\n      each(inner$8(res).datas, function (data, dataType) {\n        data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);\n      });\n      return res;\n    }\n\n    function getLinkedData(dataType) {\n      var mainData = inner$8(this).mainData;\n      return dataType == null || mainData == null ? mainData : inner$8(mainData).datas[dataType];\n    }\n\n    function getLinkedDataAll() {\n      var mainData = inner$8(this).mainData;\n      return mainData == null ? [{\n        data: mainData\n      }] : map(keys(inner$8(mainData).datas), function (type) {\n        return {\n          type: type,\n          data: inner$8(mainData).datas[type]\n        };\n      });\n    }\n\n    function isMainData(data) {\n      return inner$8(data).mainData === data;\n    }\n\n    function linkAll(mainData, datas, opt) {\n      inner$8(mainData).datas = {};\n      each(datas, function (data, dataType) {\n        linkSingle(data, dataType, mainData, opt);\n      });\n    }\n\n    function linkSingle(data, dataType, mainData, opt) {\n      inner$8(mainData).datas[dataType] = data;\n      inner$8(data).mainData = mainData;\n      data.dataType = dataType;\n\n      if (opt.struct) {\n        data[opt.structAttr] = opt.struct;\n        opt.struct[opt.datasAttr[dataType]] = data;\n      }\n\n      data.getLinkedData = getLinkedData;\n      data.getLinkedDataAll = getLinkedDataAll;\n    }\n\n    var TreeNode = function () {\n      function TreeNode(name, hostTree) {\n        this.depth = 0;\n        this.height = 0;\n        this.dataIndex = -1;\n        this.children = [];\n        this.viewChildren = [];\n        this.isExpand = false;\n        this.name = name || '';\n        this.hostTree = hostTree;\n      }\n\n      TreeNode.prototype.isRemoved = function () {\n        return this.dataIndex < 0;\n      };\n\n      TreeNode.prototype.eachNode = function (options, cb, context) {\n        if (typeof options === 'function') {\n          context = cb;\n          cb = options;\n          options = null;\n        }\n\n        options = options || {};\n\n        if (isString(options)) {\n          options = {\n            order: options\n          };\n        }\n\n        var order = options.order || 'preorder';\n        var children = this[options.attr || 'children'];\n        var suppressVisitSub;\n        order === 'preorder' && (suppressVisitSub = cb.call(context, this));\n\n        for (var i = 0; !suppressVisitSub && i < children.length; i++) {\n          children[i].eachNode(options, cb, context);\n        }\n\n        order === 'postorder' && cb.call(context, this);\n      };\n\n      TreeNode.prototype.updateDepthAndHeight = function (depth) {\n        var height = 0;\n        this.depth = depth;\n\n        for (var i = 0; i < this.children.length; i++) {\n          var child = this.children[i];\n          child.updateDepthAndHeight(depth + 1);\n\n          if (child.height > height) {\n            height = child.height;\n          }\n        }\n\n        this.height = height + 1;\n      };\n\n      TreeNode.prototype.getNodeById = function (id) {\n        if (this.getId() === id) {\n          return this;\n        }\n\n        for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n          var res = children[i].getNodeById(id);\n\n          if (res) {\n            return res;\n          }\n        }\n      };\n\n      TreeNode.prototype.contains = function (node) {\n        if (node === this) {\n          return true;\n        }\n\n        for (var i = 0, children = this.children, len = children.length; i < len; i++) {\n          var res = children[i].contains(node);\n\n          if (res) {\n            return res;\n          }\n        }\n      };\n\n      TreeNode.prototype.getAncestors = function (includeSelf) {\n        var ancestors = [];\n        var node = includeSelf ? this : this.parentNode;\n\n        while (node) {\n          ancestors.push(node);\n          node = node.parentNode;\n        }\n\n        ancestors.reverse();\n        return ancestors;\n      };\n\n      TreeNode.prototype.getAncestorsIndices = function () {\n        var indices = [];\n        var currNode = this;\n\n        while (currNode) {\n          indices.push(currNode.dataIndex);\n          currNode = currNode.parentNode;\n        }\n\n        indices.reverse();\n        return indices;\n      };\n\n      TreeNode.prototype.getDescendantIndices = function () {\n        var indices = [];\n        this.eachNode(function (childNode) {\n          indices.push(childNode.dataIndex);\n        });\n        return indices;\n      };\n\n      TreeNode.prototype.getValue = function (dimension) {\n        var data = this.hostTree.data;\n        return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n      };\n\n      TreeNode.prototype.setLayout = function (layout, merge) {\n        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);\n      };\n\n      TreeNode.prototype.getLayout = function () {\n        return this.hostTree.data.getItemLayout(this.dataIndex);\n      };\n\n      TreeNode.prototype.getModel = function (path) {\n        if (this.dataIndex < 0) {\n          return;\n        }\n\n        var hostTree = this.hostTree;\n        var itemModel = hostTree.data.getItemModel(this.dataIndex);\n        return itemModel.getModel(path);\n      };\n\n      TreeNode.prototype.getLevelModel = function () {\n        return (this.hostTree.levelModels || [])[this.depth];\n      };\n\n      TreeNode.prototype.setVisual = function (key, value) {\n        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);\n      };\n\n      TreeNode.prototype.getVisual = function (key) {\n        return this.hostTree.data.getItemVisual(this.dataIndex, key);\n      };\n\n      TreeNode.prototype.getRawIndex = function () {\n        return this.hostTree.data.getRawIndex(this.dataIndex);\n      };\n\n      TreeNode.prototype.getId = function () {\n        return this.hostTree.data.getId(this.dataIndex);\n      };\n\n      TreeNode.prototype.isAncestorOf = function (node) {\n        var parent = node.parentNode;\n\n        while (parent) {\n          if (parent === this) {\n            return true;\n          }\n\n          parent = parent.parentNode;\n        }\n\n        return false;\n      };\n\n      TreeNode.prototype.isDescendantOf = function (node) {\n        return node !== this && node.isAncestorOf(this);\n      };\n\n      return TreeNode;\n    }();\n\n    var Tree = function () {\n      function Tree(hostModel) {\n        this.type = 'tree';\n        this._nodes = [];\n        this.hostModel = hostModel;\n      }\n\n      Tree.prototype.eachNode = function (options, cb, context) {\n        this.root.eachNode(options, cb, context);\n      };\n\n      Tree.prototype.getNodeByDataIndex = function (dataIndex) {\n        var rawIndex = this.data.getRawIndex(dataIndex);\n        return this._nodes[rawIndex];\n      };\n\n      Tree.prototype.getNodeById = function (name) {\n        return this.root.getNodeById(name);\n      };\n\n      Tree.prototype.update = function () {\n        var data = this.data;\n        var nodes = this._nodes;\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n          nodes[i].dataIndex = -1;\n        }\n\n        for (var i = 0, len = data.count(); i < len; i++) {\n          nodes[data.getRawIndex(i)].dataIndex = i;\n        }\n      };\n\n      Tree.prototype.clearLayouts = function () {\n        this.data.clearItemLayouts();\n      };\n\n      Tree.createTree = function (dataRoot, hostModel, beforeLink) {\n        var tree = new Tree(hostModel);\n        var listData = [];\n        var dimMax = 1;\n        buildHierarchy(dataRoot);\n\n        function buildHierarchy(dataNode, parentNode) {\n          var value = dataNode.value;\n          dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);\n          listData.push(dataNode);\n          var node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree);\n          parentNode ? addChild(node, parentNode) : tree.root = node;\n\n          tree._nodes.push(node);\n\n          var children = dataNode.children;\n\n          if (children) {\n            for (var i = 0; i < children.length; i++) {\n              buildHierarchy(children[i], node);\n            }\n          }\n        }\n\n        tree.root.updateDepthAndHeight(0);\n        var dimensionsInfo = createDimensions(listData, {\n          coordDimensions: ['value'],\n          dimensionsCount: dimMax\n        });\n        var list = new List(dimensionsInfo, hostModel);\n        list.initData(listData);\n        beforeLink && beforeLink(list);\n        linkList({\n          mainData: list,\n          struct: tree,\n          structAttr: 'tree'\n        });\n        tree.update();\n        return tree;\n      };\n\n      return Tree;\n    }();\n\n    function addChild(child, node) {\n      var children = node.children;\n\n      if (child.parentNode === node) {\n        return;\n      }\n\n      children.push(child);\n      child.parentNode = node;\n    }\n\n    var TreeSeriesModel = function (_super) {\n      __extends(TreeSeriesModel, _super);\n\n      function TreeSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.hasSymbolVisual = true;\n        _this.ignoreStyleOnData = true;\n        return _this;\n      }\n\n      TreeSeriesModel.prototype.getInitialData = function (option) {\n        var root = {\n          name: option.name,\n          children: option.data\n        };\n        var leaves = option.leaves || {};\n        var leavesModel = new Model(leaves, this, this.ecModel);\n        var tree = Tree.createTree(root, this, beforeLink);\n\n        function beforeLink(nodeData) {\n          nodeData.wrapMethod('getItemModel', function (model, idx) {\n            var node = tree.getNodeByDataIndex(idx);\n\n            if (!node.children.length || !node.isExpand) {\n              model.parentModel = leavesModel;\n            }\n\n            return model;\n          });\n        }\n\n        var treeDepth = 0;\n        tree.eachNode('preorder', function (node) {\n          if (node.depth > treeDepth) {\n            treeDepth = node.depth;\n          }\n        });\n        var expandAndCollapse = option.expandAndCollapse;\n        var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;\n        tree.root.eachNode('preorder', function (node) {\n          var item = node.hostTree.data.getRawDataItem(node.dataIndex);\n          node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;\n        });\n        return tree.data;\n      };\n\n      TreeSeriesModel.prototype.getOrient = function () {\n        var orient = this.get('orient');\n\n        if (orient === 'horizontal') {\n          orient = 'LR';\n        } else if (orient === 'vertical') {\n          orient = 'TB';\n        }\n\n        return orient;\n      };\n\n      TreeSeriesModel.prototype.setZoom = function (zoom) {\n        this.option.zoom = zoom;\n      };\n\n      TreeSeriesModel.prototype.setCenter = function (center) {\n        this.option.center = center;\n      };\n\n      TreeSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var tree = this.getData().tree;\n        var realRoot = tree.root.children[0];\n        var node = tree.getNodeByDataIndex(dataIndex);\n        var value = node.getValue();\n        var name = node.name;\n\n        while (node && node !== realRoot) {\n          name = node.parentNode.name + '.' + name;\n          node = node.parentNode;\n        }\n\n        return createTooltipMarkup('nameValue', {\n          name: name,\n          value: value,\n          noValue: isNaN(value) || value == null\n        });\n      };\n\n      TreeSeriesModel.type = 'series.tree';\n      TreeSeriesModel.layoutMode = 'box';\n      TreeSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'view',\n        left: '12%',\n        top: '12%',\n        right: '12%',\n        bottom: '12%',\n        layout: 'orthogonal',\n        edgeShape: 'curve',\n        edgeForkPosition: '50%',\n        roam: false,\n        nodeScaleRatio: 0.4,\n        center: null,\n        zoom: 1,\n        orient: 'LR',\n        symbol: 'emptyCircle',\n        symbolSize: 7,\n        expandAndCollapse: true,\n        initialTreeDepth: 2,\n        lineStyle: {\n          color: '#ccc',\n          width: 1.5,\n          curveness: 0.5\n        },\n        itemStyle: {\n          color: 'lightsteelblue',\n          borderColor: '#c23531',\n          borderWidth: 1.5\n        },\n        label: {\n          show: true\n        },\n        animationEasing: 'linear',\n        animationDuration: 700,\n        animationDurationUpdate: 500\n      };\n      return TreeSeriesModel;\n    }(SeriesModel);\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function eachAfter(root, callback, separation) {\n      var nodes = [root];\n      var next = [];\n      var node;\n\n      while (node = nodes.pop()) {\n        next.push(node);\n\n        if (node.isExpand) {\n          var children = node.children;\n\n          if (children.length) {\n            for (var i = 0; i < children.length; i++) {\n              nodes.push(children[i]);\n            }\n          }\n        }\n      }\n\n      while (node = next.pop()) {\n        callback(node, separation);\n      }\n    }\n\n    function eachBefore(root, callback) {\n      var nodes = [root];\n      var node;\n\n      while (node = nodes.pop()) {\n        callback(node);\n\n        if (node.isExpand) {\n          var children = node.children;\n\n          if (children.length) {\n            for (var i = children.length - 1; i >= 0; i--) {\n              nodes.push(children[i]);\n            }\n          }\n        }\n      }\n    }\n\n    function treeLayout(ecModel, api) {\n      ecModel.eachSeriesByType('tree', function (seriesModel) {\n        commonLayout(seriesModel, api);\n      });\n    }\n\n    function commonLayout(seriesModel, api) {\n      var layoutInfo = getViewRect$1(seriesModel, api);\n      seriesModel.layoutInfo = layoutInfo;\n      var layout = seriesModel.get('layout');\n      var width = 0;\n      var height = 0;\n      var separation$1 = null;\n\n      if (layout === 'radial') {\n        width = 2 * Math.PI;\n        height = Math.min(layoutInfo.height, layoutInfo.width) / 2;\n        separation$1 = separation(function (node1, node2) {\n          return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;\n        });\n      } else {\n        width = layoutInfo.width;\n        height = layoutInfo.height;\n        separation$1 = separation();\n      }\n\n      var virtualRoot = seriesModel.getData().tree.root;\n      var realRoot = virtualRoot.children[0];\n\n      if (realRoot) {\n        init$2(virtualRoot);\n        eachAfter(realRoot, firstWalk, separation$1);\n        virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;\n        eachBefore(realRoot, secondWalk);\n        var left_1 = realRoot;\n        var right_1 = realRoot;\n        var bottom_1 = realRoot;\n        eachBefore(realRoot, function (node) {\n          var x = node.getLayout().x;\n\n          if (x < left_1.getLayout().x) {\n            left_1 = node;\n          }\n\n          if (x > right_1.getLayout().x) {\n            right_1 = node;\n          }\n\n          if (node.depth > bottom_1.depth) {\n            bottom_1 = node;\n          }\n        });\n        var delta = left_1 === right_1 ? 1 : separation$1(left_1, right_1) / 2;\n        var tx_1 = delta - left_1.getLayout().x;\n        var kx_1 = 0;\n        var ky_1 = 0;\n        var coorX_1 = 0;\n        var coorY_1 = 0;\n\n        if (layout === 'radial') {\n          kx_1 = width / (right_1.getLayout().x + delta + tx_1);\n          ky_1 = height / (bottom_1.depth - 1 || 1);\n          eachBefore(realRoot, function (node) {\n            coorX_1 = (node.getLayout().x + tx_1) * kx_1;\n            coorY_1 = (node.depth - 1) * ky_1;\n            var finalCoor = radialCoordinate(coorX_1, coorY_1);\n            node.setLayout({\n              x: finalCoor.x,\n              y: finalCoor.y,\n              rawX: coorX_1,\n              rawY: coorY_1\n            }, true);\n          });\n        } else {\n          var orient_1 = seriesModel.getOrient();\n\n          if (orient_1 === 'RL' || orient_1 === 'LR') {\n            ky_1 = height / (right_1.getLayout().x + delta + tx_1);\n            kx_1 = width / (bottom_1.depth - 1 || 1);\n            eachBefore(realRoot, function (node) {\n              coorY_1 = (node.getLayout().x + tx_1) * ky_1;\n              coorX_1 = orient_1 === 'LR' ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1;\n              node.setLayout({\n                x: coorX_1,\n                y: coorY_1\n              }, true);\n            });\n          } else if (orient_1 === 'TB' || orient_1 === 'BT') {\n            kx_1 = width / (right_1.getLayout().x + delta + tx_1);\n            ky_1 = height / (bottom_1.depth - 1 || 1);\n            eachBefore(realRoot, function (node) {\n              coorX_1 = (node.getLayout().x + tx_1) * kx_1;\n              coorY_1 = orient_1 === 'TB' ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1;\n              node.setLayout({\n                x: coorX_1,\n                y: coorY_1\n              }, true);\n            });\n          }\n        }\n      }\n    }\n\n    function treeVisual(ecModel) {\n      ecModel.eachSeriesByType('tree', function (seriesModel) {\n        var data = seriesModel.getData();\n        var tree = data.tree;\n        tree.eachNode(function (node) {\n          var model = node.getModel();\n          var style = model.getModel('itemStyle').getItemStyle();\n          var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n          extend(existsStyle, style);\n        });\n      });\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function updateCenterAndZoom(view, payload, zoomLimit) {\n      var previousZoom = view.getZoom();\n      var center = view.getCenter();\n      var zoom = payload.zoom;\n      var point = view.dataToPoint(center);\n\n      if (payload.dx != null && payload.dy != null) {\n        point[0] -= payload.dx;\n        point[1] -= payload.dy;\n        view.setCenter(view.pointToData(point));\n      }\n\n      if (zoom != null) {\n        if (zoomLimit) {\n          var zoomMin = zoomLimit.min || 0;\n          var zoomMax = zoomLimit.max || Infinity;\n          zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;\n        }\n\n        view.scaleX *= zoom;\n        view.scaleY *= zoom;\n        var fixX = (payload.originX - view.x) * (zoom - 1);\n        var fixY = (payload.originY - view.y) * (zoom - 1);\n        view.x -= fixX;\n        view.y -= fixY;\n        view.updateTransform();\n        view.setCenter(view.pointToData(point));\n        view.setZoom(zoom * previousZoom);\n      }\n\n      return {\n        center: view.getCenter(),\n        zoom: view.getZoom()\n      };\n    }\n\n    function installTreeAction(registers) {\n      registers.registerAction({\n        type: 'treeExpandAndCollapse',\n        event: 'treeExpandAndCollapse',\n        update: 'update'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'tree',\n          query: payload\n        }, function (seriesModel) {\n          var dataIndex = payload.dataIndex;\n          var tree = seriesModel.getData().tree;\n          var node = tree.getNodeByDataIndex(dataIndex);\n          node.isExpand = !node.isExpand;\n        });\n      });\n      registers.registerAction({\n        type: 'treeRoam',\n        event: 'treeRoam',\n        update: 'none'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'tree',\n          query: payload\n        }, function (seriesModel) {\n          var coordSys = seriesModel.coordinateSystem;\n          var res = updateCenterAndZoom(coordSys, payload);\n          seriesModel.setCenter && seriesModel.setCenter(res.center);\n          seriesModel.setZoom && seriesModel.setZoom(res.zoom);\n        });\n      });\n    }\n\n    function install$a(registers) {\n      registers.registerChartView(TreeView);\n      registers.registerSeriesModel(TreeSeriesModel);\n      registers.registerLayout(treeLayout);\n      registers.registerVisual(treeVisual);\n      installTreeAction(registers);\n    }\n\n    function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {\n      if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {\n        var root = seriesModel.getData().tree.root;\n        var targetNode = payload.targetNode;\n\n        if (typeof targetNode === 'string') {\n          targetNode = root.getNodeById(targetNode);\n        }\n\n        if (targetNode && root.contains(targetNode)) {\n          return {\n            node: targetNode\n          };\n        }\n\n        var targetNodeId = payload.targetNodeId;\n\n        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {\n          return {\n            node: targetNode\n          };\n        }\n      }\n    }\n    function getPathToRoot(node) {\n      var path = [];\n\n      while (node) {\n        node = node.parentNode;\n        node && path.push(node);\n      }\n\n      return path.reverse();\n    }\n    function aboveViewRoot(viewRoot, node) {\n      var viewPath = getPathToRoot(viewRoot);\n      return indexOf(viewPath, node) >= 0;\n    }\n    function wrapTreePathInfo(node, seriesModel) {\n      var treePathInfo = [];\n\n      while (node) {\n        var nodeDataIndex = node.dataIndex;\n        treePathInfo.push({\n          name: node.name,\n          dataIndex: nodeDataIndex,\n          value: seriesModel.getRawValue(nodeDataIndex)\n        });\n        node = node.parentNode;\n      }\n\n      treePathInfo.reverse();\n      return treePathInfo;\n    }\n\n    var noop$1 = function () {};\n\n    var actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove'];\n    function installTreemapAction(registers) {\n      for (var i = 0; i < actionTypes.length; i++) {\n        registers.registerAction({\n          type: actionTypes[i],\n          update: 'updateView'\n        }, noop$1);\n      }\n\n      registers.registerAction({\n        type: 'treemapRootToNode',\n        update: 'updateView'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'treemap',\n          query: payload\n        }, handleRootToNode);\n\n        function handleRootToNode(model, index) {\n          var types = ['treemapZoomToNode', 'treemapRootToNode'];\n          var targetInfo = retrieveTargetInfo(payload, types, model);\n\n          if (targetInfo) {\n            var originViewRoot = model.getViewRoot();\n\n            if (originViewRoot) {\n              payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n            }\n\n            model.resetViewRoot(targetInfo.node);\n          }\n        }\n      });\n    }\n\n    function enableAriaDecalForTree(seriesModel) {\n      var data = seriesModel.getData();\n      var tree = data.tree;\n      var decalPaletteScope = {};\n      tree.eachNode(function (node) {\n        var current = node;\n\n        while (current && current.depth > 1) {\n          current = current.parentNode;\n        }\n\n        var decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + '', decalPaletteScope);\n        node.setVisual('decal', decal);\n      });\n    }\n\n    var TreemapSeriesModel = function (_super) {\n      __extends(TreemapSeriesModel, _super);\n\n      function TreemapSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TreemapSeriesModel.type;\n        _this.preventUsingHoverLayer = true;\n        return _this;\n      }\n\n      TreemapSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        var root = {\n          name: option.name,\n          children: option.data\n        };\n        completeTreeValue(root);\n        var levels = option.levels || [];\n        var designatedVisualItemStyle = this.designatedVisualItemStyle = {};\n        var designatedVisualModel = new Model({\n          itemStyle: designatedVisualItemStyle\n        }, this, ecModel);\n        levels = option.levels = setDefault(levels, ecModel);\n        var levelModels = map(levels || [], function (levelDefine) {\n          return new Model(levelDefine, designatedVisualModel, ecModel);\n        }, this);\n        var tree = Tree.createTree(root, this, beforeLink);\n\n        function beforeLink(nodeData) {\n          nodeData.wrapMethod('getItemModel', function (model, idx) {\n            var node = tree.getNodeByDataIndex(idx);\n            var levelModel = levelModels[node.depth];\n            model.parentModel = levelModel || designatedVisualModel;\n            return model;\n          });\n        }\n\n        return tree.data;\n      };\n\n      TreemapSeriesModel.prototype.optionUpdated = function () {\n        this.resetViewRoot();\n      };\n\n      TreemapSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var value = this.getRawValue(dataIndex);\n        var name = data.getName(dataIndex);\n        return createTooltipMarkup('nameValue', {\n          name: name,\n          value: value\n        });\n      };\n\n      TreemapSeriesModel.prototype.getDataParams = function (dataIndex) {\n        var params = _super.prototype.getDataParams.apply(this, arguments);\n\n        var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n        params.treePathInfo = wrapTreePathInfo(node, this);\n        return params;\n      };\n\n      TreemapSeriesModel.prototype.setLayoutInfo = function (layoutInfo) {\n        this.layoutInfo = this.layoutInfo || {};\n        extend(this.layoutInfo, layoutInfo);\n      };\n\n      TreemapSeriesModel.prototype.mapIdToIndex = function (id) {\n        var idIndexMap = this._idIndexMap;\n\n        if (!idIndexMap) {\n          idIndexMap = this._idIndexMap = createHashMap();\n          this._idIndexMapCount = 0;\n        }\n\n        var index = idIndexMap.get(id);\n\n        if (index == null) {\n          idIndexMap.set(id, index = this._idIndexMapCount++);\n        }\n\n        return index;\n      };\n\n      TreemapSeriesModel.prototype.getViewRoot = function () {\n        return this._viewRoot;\n      };\n\n      TreemapSeriesModel.prototype.resetViewRoot = function (viewRoot) {\n        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n        var root = this.getRawData().tree.root;\n\n        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n          this._viewRoot = root;\n        }\n      };\n\n      TreemapSeriesModel.prototype.enableAriaDecal = function () {\n        enableAriaDecalForTree(this);\n      };\n\n      TreemapSeriesModel.type = 'series.treemap';\n      TreemapSeriesModel.layoutMode = 'box';\n      TreemapSeriesModel.defaultOption = {\n        progressive: 0,\n        left: 'center',\n        top: 'middle',\n        width: '80%',\n        height: '80%',\n        sort: true,\n        clipWindow: 'origin',\n        squareRatio: 0.5 * (1 + Math.sqrt(5)),\n        leafDepth: null,\n        drillDownIcon: '',\n        zoomToNodeRatio: 0.32 * 0.32,\n        roam: true,\n        nodeClick: 'zoomToNode',\n        animation: true,\n        animationDurationUpdate: 900,\n        animationEasing: 'quinticInOut',\n        breadcrumb: {\n          show: true,\n          height: 22,\n          left: 'center',\n          top: 'bottom',\n          emptyItemWidth: 25,\n          itemStyle: {\n            color: 'rgba(0,0,0,0.7)',\n            textStyle: {\n              color: '#fff'\n            }\n          }\n        },\n        label: {\n          show: true,\n          distance: 0,\n          padding: 5,\n          position: 'inside',\n          color: '#fff',\n          overflow: 'truncate'\n        },\n        upperLabel: {\n          show: false,\n          position: [0, '50%'],\n          height: 20,\n          overflow: 'truncate',\n          verticalAlign: 'middle'\n        },\n        itemStyle: {\n          color: null,\n          colorAlpha: null,\n          colorSaturation: null,\n          borderWidth: 0,\n          gapWidth: 0,\n          borderColor: '#fff',\n          borderColorSaturation: null\n        },\n        emphasis: {\n          upperLabel: {\n            show: true,\n            position: [0, '50%'],\n            ellipsis: true,\n            verticalAlign: 'middle'\n          }\n        },\n        visualDimension: 0,\n        visualMin: null,\n        visualMax: null,\n        color: [],\n        colorAlpha: null,\n        colorSaturation: null,\n        colorMappingBy: 'index',\n        visibleMin: 10,\n        childrenVisibleMin: null,\n        levels: []\n      };\n      return TreemapSeriesModel;\n    }(SeriesModel);\n\n    function completeTreeValue(dataNode) {\n      var sum = 0;\n      each(dataNode.children, function (child) {\n        completeTreeValue(child);\n        var childValue = child.value;\n        isArray(childValue) && (childValue = childValue[0]);\n        sum += childValue;\n      });\n      var thisValue = dataNode.value;\n\n      if (isArray(thisValue)) {\n        thisValue = thisValue[0];\n      }\n\n      if (thisValue == null || isNaN(thisValue)) {\n        thisValue = sum;\n      }\n\n      if (thisValue < 0) {\n        thisValue = 0;\n      }\n\n      isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n    }\n\n    function setDefault(levels, ecModel) {\n      var globalColorList = normalizeToArray(ecModel.get('color'));\n      var globalDecalList = normalizeToArray(ecModel.get(['aria', 'decal', 'decals']));\n\n      if (!globalColorList) {\n        return;\n      }\n\n      levels = levels || [];\n      var hasColorDefine;\n      var hasDecalDefine;\n      each(levels, function (levelDefine) {\n        var model = new Model(levelDefine);\n        var modelColor = model.get('color');\n        var modelDecal = model.get('decal');\n\n        if (model.get(['itemStyle', 'color']) || modelColor && modelColor !== 'none') {\n          hasColorDefine = true;\n        }\n\n        if (model.get(['itemStyle', 'decal']) || modelDecal && modelDecal !== 'none') {\n          hasDecalDefine = true;\n        }\n      });\n      var level0 = levels[0] || (levels[0] = {});\n\n      if (!hasColorDefine) {\n        level0.color = globalColorList.slice();\n      }\n\n      if (!hasDecalDefine && globalDecalList) {\n        level0.decal = globalDecalList.slice();\n      }\n\n      return levels;\n    }\n\n    var TEXT_PADDING = 8;\n    var ITEM_GAP = 8;\n    var ARRAY_LENGTH = 5;\n\n    var Breadcrumb = function () {\n      function Breadcrumb(containerGroup) {\n        this.group = new Group();\n        containerGroup.add(this.group);\n      }\n\n      Breadcrumb.prototype.render = function (seriesModel, api, targetNode, onSelect) {\n        var model = seriesModel.getModel('breadcrumb');\n        var thisGroup = this.group;\n        thisGroup.removeAll();\n\n        if (!model.get('show') || !targetNode) {\n          return;\n        }\n\n        var normalStyleModel = model.getModel('itemStyle');\n        var textStyleModel = normalStyleModel.getModel('textStyle');\n        var layoutParam = {\n          pos: {\n            left: model.get('left'),\n            right: model.get('right'),\n            top: model.get('top'),\n            bottom: model.get('bottom')\n          },\n          box: {\n            width: api.getWidth(),\n            height: api.getHeight()\n          },\n          emptyItemWidth: model.get('emptyItemWidth'),\n          totalWidth: 0,\n          renderList: []\n        };\n\n        this._prepare(targetNode, layoutParam, textStyleModel);\n\n        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);\n\n        positionElement(thisGroup, layoutParam.pos, layoutParam.box);\n      };\n\n      Breadcrumb.prototype._prepare = function (targetNode, layoutParam, textStyleModel) {\n        for (var node = targetNode; node; node = node.parentNode) {\n          var text = convertOptionIdName(node.getModel().get('name'), '');\n          var textRect = textStyleModel.getTextRect(text);\n          var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);\n          layoutParam.totalWidth += itemWidth + ITEM_GAP;\n          layoutParam.renderList.push({\n            node: node,\n            text: text,\n            width: itemWidth\n          });\n        }\n      };\n\n      Breadcrumb.prototype._renderContent = function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {\n        var lastX = 0;\n        var emptyItemWidth = layoutParam.emptyItemWidth;\n        var height = seriesModel.get(['breadcrumb', 'height']);\n        var availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);\n        var totalWidth = layoutParam.totalWidth;\n        var renderList = layoutParam.renderList;\n\n        for (var i = renderList.length - 1; i >= 0; i--) {\n          var item = renderList[i];\n          var itemNode = item.node;\n          var itemWidth = item.width;\n          var text = item.text;\n\n          if (totalWidth > availableSize.width) {\n            totalWidth -= itemWidth - emptyItemWidth;\n            itemWidth = emptyItemWidth;\n            text = null;\n          }\n\n          var el = new Polygon({\n            shape: {\n              points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)\n            },\n            style: defaults(normalStyleModel.getItemStyle(), {\n              lineJoin: 'bevel'\n            }),\n            textContent: new ZRText({\n              style: {\n                text: text,\n                fill: textStyleModel.getTextColor(),\n                font: textStyleModel.getFont()\n              }\n            }),\n            textConfig: {\n              position: 'inside'\n            },\n            z: 10,\n            onclick: curry(onSelect, itemNode)\n          });\n          el.disableLabelAnimation = true;\n          this.group.add(el);\n          packEventData(el, seriesModel, itemNode);\n          lastX += itemWidth + ITEM_GAP;\n        }\n      };\n\n      Breadcrumb.prototype.remove = function () {\n        this.group.removeAll();\n      };\n\n      return Breadcrumb;\n    }();\n\n    function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {\n      var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];\n      !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);\n      !head && points.push([x, y + itemHeight / 2]);\n      return points;\n    }\n\n    function packEventData(el, seriesModel, itemNode) {\n      getECData(el).eventData = {\n        componentType: 'series',\n        componentSubType: 'treemap',\n        componentIndex: seriesModel.componentIndex,\n        seriesIndex: seriesModel.componentIndex,\n        seriesName: seriesModel.name,\n        seriesType: 'treemap',\n        selfType: 'breadcrumb',\n        nodeData: {\n          dataIndex: itemNode && itemNode.dataIndex,\n          name: itemNode && itemNode.name\n        },\n        treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)\n      };\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var AnimationWrap = function () {\n      function AnimationWrap() {\n        this._storage = [];\n        this._elExistsMap = {};\n      }\n\n      AnimationWrap.prototype.add = function (el, target, duration, delay, easing) {\n        if (this._elExistsMap[el.id]) {\n          return false;\n        }\n\n        this._elExistsMap[el.id] = true;\n\n        this._storage.push({\n          el: el,\n          target: target,\n          duration: duration,\n          delay: delay,\n          easing: easing\n        });\n\n        return true;\n      };\n\n      AnimationWrap.prototype.finished = function (callback) {\n        this._finishedCallback = callback;\n        return this;\n      };\n\n      AnimationWrap.prototype.start = function () {\n        var _this = this;\n\n        var count = this._storage.length;\n\n        var checkTerminate = function () {\n          count--;\n\n          if (count <= 0) {\n            _this._storage.length = 0;\n            _this._elExistsMap = {};\n            _this._finishedCallback && _this._finishedCallback();\n          }\n        };\n\n        for (var i = 0, len = this._storage.length; i < len; i++) {\n          var item = this._storage[i];\n          item.el.animateTo(item.target, {\n            duration: item.duration,\n            delay: item.delay,\n            easing: item.easing,\n            setToFinal: true,\n            done: checkTerminate,\n            aborted: checkTerminate\n          });\n        }\n\n        return this;\n      };\n\n      return AnimationWrap;\n    }();\n\n    function createWrap() {\n      return new AnimationWrap();\n    }\n\n    var Group$1 = Group;\n    var Rect$1 = Rect;\n    var DRAG_THRESHOLD = 3;\n    var PATH_LABEL_NOAMAL = 'label';\n    var PATH_UPPERLABEL_NORMAL = 'upperLabel';\n    var Z_BASE = 10;\n    var Z_BG = 1;\n    var Z_CONTENT = 2;\n    var getStateItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\n\n    var getItemStyleNormal = function (model) {\n      var itemStyle = getStateItemStyle(model);\n      itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;\n      return itemStyle;\n    };\n\n    var inner$9 = makeInner();\n\n    var TreemapView = function (_super) {\n      __extends(TreemapView, _super);\n\n      function TreemapView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TreemapView.type;\n        _this._state = 'ready';\n        _this._storage = createStorage();\n        return _this;\n      }\n\n      TreemapView.prototype.render = function (seriesModel, ecModel, api, payload) {\n        var models = ecModel.findComponents({\n          mainType: 'series',\n          subType: 'treemap',\n          query: payload\n        });\n\n        if (indexOf(models, seriesModel) < 0) {\n          return;\n        }\n\n        this.seriesModel = seriesModel;\n        this.api = api;\n        this.ecModel = ecModel;\n        var types = ['treemapZoomToNode', 'treemapRootToNode'];\n        var targetInfo = retrieveTargetInfo(payload, types, seriesModel);\n        var payloadType = payload && payload.type;\n        var layoutInfo = seriesModel.layoutInfo;\n        var isInit = !this._oldTree;\n        var thisStorage = this._storage;\n        var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {\n          rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],\n          direction: payload.direction\n        } : null;\n\n        var containerGroup = this._giveContainerGroup(layoutInfo);\n\n        var renderResult = this._doRender(containerGroup, seriesModel, reRoot);\n\n        !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();\n\n        this._resetController(api);\n\n        this._renderBreadcrumb(seriesModel, api, targetInfo);\n      };\n\n      TreemapView.prototype._giveContainerGroup = function (layoutInfo) {\n        var containerGroup = this._containerGroup;\n\n        if (!containerGroup) {\n          containerGroup = this._containerGroup = new Group$1();\n\n          this._initEvents(containerGroup);\n\n          this.group.add(containerGroup);\n        }\n\n        containerGroup.x = layoutInfo.x;\n        containerGroup.y = layoutInfo.y;\n        return containerGroup;\n      };\n\n      TreemapView.prototype._doRender = function (containerGroup, seriesModel, reRoot) {\n        var thisTree = seriesModel.getData().tree;\n        var oldTree = this._oldTree;\n        var lastsForAnimation = createStorage();\n        var thisStorage = createStorage();\n        var oldStorage = this._storage;\n        var willInvisibleEls = [];\n\n        function doRenderNode(thisNode, oldNode, parentGroup, depth) {\n          return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);\n        }\n\n        dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);\n        var willDeleteEls = clearStorage(oldStorage);\n        this._oldTree = thisTree;\n        this._storage = thisStorage;\n        return {\n          lastsForAnimation: lastsForAnimation,\n          willDeleteEls: willDeleteEls,\n          renderFinally: renderFinally\n        };\n\n        function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {\n          if (sameTree) {\n            oldViewChildren = thisViewChildren;\n            each(thisViewChildren, function (child, index) {\n              !child.isRemoved() && processNode(index, index);\n            });\n          } else {\n            new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(curry(processNode, null)).execute();\n          }\n\n          function getKey(node) {\n            return node.getId();\n          }\n\n          function processNode(newIndex, oldIndex) {\n            var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;\n            var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;\n            var group = doRenderNode(thisNode, oldNode, parentGroup, depth);\n            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);\n          }\n        }\n\n        function clearStorage(storage) {\n          var willDeleteEls = createStorage();\n          storage && each(storage, function (store, storageName) {\n            var delEls = willDeleteEls[storageName];\n            each(store, function (el) {\n              el && (delEls.push(el), inner$9(el).willDelete = true);\n            });\n          });\n          return willDeleteEls;\n        }\n\n        function renderFinally() {\n          each(willDeleteEls, function (els) {\n            each(els, function (el) {\n              el.parent && el.parent.remove(el);\n            });\n          });\n          each(willInvisibleEls, function (el) {\n            el.invisible = true;\n            el.dirty();\n          });\n        }\n      };\n\n      TreemapView.prototype._doAnimation = function (containerGroup, renderResult, seriesModel, reRoot) {\n        if (!seriesModel.get('animation')) {\n          return;\n        }\n\n        var durationOption = seriesModel.get('animationDurationUpdate');\n        var easingOption = seriesModel.get('animationEasing');\n        var duration = (isFunction(durationOption) ? 0 : durationOption) || 0;\n        var easing = (isFunction(easingOption) ? null : easingOption) || 'cubicOut';\n        var animationWrap = createWrap();\n        each(renderResult.willDeleteEls, function (store, storageName) {\n          each(store, function (el, rawIndex) {\n            if (el.invisible) {\n              return;\n            }\n\n            var parent = el.parent;\n            var target;\n            var innerStore = inner$9(parent);\n\n            if (reRoot && reRoot.direction === 'drillDown') {\n              target = parent === reRoot.rootNodeGroup ? {\n                shape: {\n                  x: 0,\n                  y: 0,\n                  width: innerStore.nodeWidth,\n                  height: innerStore.nodeHeight\n                },\n                style: {\n                  opacity: 0\n                }\n              } : {\n                style: {\n                  opacity: 0\n                }\n              };\n            } else {\n              var targetX = 0;\n              var targetY = 0;\n\n              if (!innerStore.willDelete) {\n                targetX = innerStore.nodeWidth / 2;\n                targetY = innerStore.nodeHeight / 2;\n              }\n\n              target = storageName === 'nodeGroup' ? {\n                x: targetX,\n                y: targetY,\n                style: {\n                  opacity: 0\n                }\n              } : {\n                shape: {\n                  x: targetX,\n                  y: targetY,\n                  width: 0,\n                  height: 0\n                },\n                style: {\n                  opacity: 0\n                }\n              };\n            }\n\n            target && animationWrap.add(el, target, duration, 0, easing);\n          });\n        });\n        each(this._storage, function (store, storageName) {\n          each(store, function (el, rawIndex) {\n            var last = renderResult.lastsForAnimation[storageName][rawIndex];\n            var target = {};\n\n            if (!last) {\n              return;\n            }\n\n            if (el instanceof Group) {\n              if (last.oldX != null) {\n                target.x = el.x;\n                target.y = el.y;\n                el.x = last.oldX;\n                el.y = last.oldY;\n              }\n            } else {\n              if (last.oldShape) {\n                target.shape = extend({}, el.shape);\n                el.setShape(last.oldShape);\n              }\n\n              if (last.fadein) {\n                el.setStyle('opacity', 0);\n                target.style = {\n                  opacity: 1\n                };\n              } else if (el.style.opacity !== 1) {\n                target.style = {\n                  opacity: 1\n                };\n              }\n            }\n\n            animationWrap.add(el, target, duration, 0, easing);\n          });\n        }, this);\n        this._state = 'animating';\n        animationWrap.finished(bind(function () {\n          this._state = 'ready';\n          renderResult.renderFinally();\n        }, this)).start();\n      };\n\n      TreemapView.prototype._resetController = function (api) {\n        var controller = this._controller;\n\n        if (!controller) {\n          controller = this._controller = new RoamController(api.getZr());\n          controller.enable(this.seriesModel.get('roam'));\n          controller.on('pan', bind(this._onPan, this));\n          controller.on('zoom', bind(this._onZoom, this));\n        }\n\n        var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());\n        controller.setPointerChecker(function (e, x, y) {\n          return rect.contain(x, y);\n        });\n      };\n\n      TreemapView.prototype._clearController = function () {\n        var controller = this._controller;\n\n        if (controller) {\n          controller.dispose();\n          controller = null;\n        }\n      };\n\n      TreemapView.prototype._onPan = function (e) {\n        if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {\n          var root = this.seriesModel.getData().tree.root;\n\n          if (!root) {\n            return;\n          }\n\n          var rootLayout = root.getLayout();\n\n          if (!rootLayout) {\n            return;\n          }\n\n          this.api.dispatchAction({\n            type: 'treemapMove',\n            from: this.uid,\n            seriesId: this.seriesModel.id,\n            rootRect: {\n              x: rootLayout.x + e.dx,\n              y: rootLayout.y + e.dy,\n              width: rootLayout.width,\n              height: rootLayout.height\n            }\n          });\n        }\n      };\n\n      TreemapView.prototype._onZoom = function (e) {\n        var mouseX = e.originX;\n        var mouseY = e.originY;\n\n        if (this._state !== 'animating') {\n          var root = this.seriesModel.getData().tree.root;\n\n          if (!root) {\n            return;\n          }\n\n          var rootLayout = root.getLayout();\n\n          if (!rootLayout) {\n            return;\n          }\n\n          var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);\n          var layoutInfo = this.seriesModel.layoutInfo;\n          mouseX -= layoutInfo.x;\n          mouseY -= layoutInfo.y;\n          var m = create$1();\n          translate(m, m, [-mouseX, -mouseY]);\n          scale$1(m, m, [e.scale, e.scale]);\n          translate(m, m, [mouseX, mouseY]);\n          rect.applyTransform(m);\n          this.api.dispatchAction({\n            type: 'treemapRender',\n            from: this.uid,\n            seriesId: this.seriesModel.id,\n            rootRect: {\n              x: rect.x,\n              y: rect.y,\n              width: rect.width,\n              height: rect.height\n            }\n          });\n        }\n      };\n\n      TreemapView.prototype._initEvents = function (containerGroup) {\n        var _this = this;\n\n        containerGroup.on('click', function (e) {\n          if (_this._state !== 'ready') {\n            return;\n          }\n\n          var nodeClick = _this.seriesModel.get('nodeClick', true);\n\n          if (!nodeClick) {\n            return;\n          }\n\n          var targetInfo = _this.findTarget(e.offsetX, e.offsetY);\n\n          if (!targetInfo) {\n            return;\n          }\n\n          var node = targetInfo.node;\n\n          if (node.getLayout().isLeafRoot) {\n            _this._rootToNode(targetInfo);\n          } else {\n            if (nodeClick === 'zoomToNode') {\n              _this._zoomToNode(targetInfo);\n            } else if (nodeClick === 'link') {\n              var itemModel = node.hostTree.data.getItemModel(node.dataIndex);\n              var link = itemModel.get('link', true);\n              var linkTarget = itemModel.get('target', true) || 'blank';\n              link && windowOpen(link, linkTarget);\n            }\n          }\n        }, this);\n      };\n\n      TreemapView.prototype._renderBreadcrumb = function (seriesModel, api, targetInfo) {\n        var _this = this;\n\n        if (!targetInfo) {\n          targetInfo = seriesModel.get('leafDepth', true) != null ? {\n            node: seriesModel.getViewRoot()\n          } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);\n\n          if (!targetInfo) {\n            targetInfo = {\n              node: seriesModel.getData().tree.root\n            };\n          }\n        }\n\n        (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, function (node) {\n          if (_this._state !== 'animating') {\n            aboveViewRoot(seriesModel.getViewRoot(), node) ? _this._rootToNode({\n              node: node\n            }) : _this._zoomToNode({\n              node: node\n            });\n          }\n        });\n      };\n\n      TreemapView.prototype.remove = function () {\n        this._clearController();\n\n        this._containerGroup && this._containerGroup.removeAll();\n        this._storage = createStorage();\n        this._state = 'ready';\n        this._breadcrumb && this._breadcrumb.remove();\n      };\n\n      TreemapView.prototype.dispose = function () {\n        this._clearController();\n      };\n\n      TreemapView.prototype._zoomToNode = function (targetInfo) {\n        this.api.dispatchAction({\n          type: 'treemapZoomToNode',\n          from: this.uid,\n          seriesId: this.seriesModel.id,\n          targetNode: targetInfo.node\n        });\n      };\n\n      TreemapView.prototype._rootToNode = function (targetInfo) {\n        this.api.dispatchAction({\n          type: 'treemapRootToNode',\n          from: this.uid,\n          seriesId: this.seriesModel.id,\n          targetNode: targetInfo.node\n        });\n      };\n\n      TreemapView.prototype.findTarget = function (x, y) {\n        var targetInfo;\n        var viewRoot = this.seriesModel.getViewRoot();\n        viewRoot.eachNode({\n          attr: 'viewChildren',\n          order: 'preorder'\n        }, function (node) {\n          var bgEl = this._storage.background[node.getRawIndex()];\n\n          if (bgEl) {\n            var point = bgEl.transformCoordToLocal(x, y);\n            var shape = bgEl.shape;\n\n            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {\n              targetInfo = {\n                node: node,\n                offsetX: point[0],\n                offsetY: point[1]\n              };\n            } else {\n              return false;\n            }\n          }\n        }, this);\n        return targetInfo;\n      };\n\n      TreemapView.type = 'treemap';\n      return TreemapView;\n    }(ChartView);\n\n    function createStorage() {\n      return {\n        nodeGroup: [],\n        background: [],\n        content: []\n      };\n    }\n\n    function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {\n      if (!thisNode) {\n        return;\n      }\n\n      var thisLayout = thisNode.getLayout();\n      var data = seriesModel.getData();\n      var nodeModel = thisNode.getModel();\n      data.setItemGraphicEl(thisNode.dataIndex, null);\n\n      if (!thisLayout || !thisLayout.isInView) {\n        return;\n      }\n\n      var thisWidth = thisLayout.width;\n      var thisHeight = thisLayout.height;\n      var borderWidth = thisLayout.borderWidth;\n      var thisInvisible = thisLayout.invisible;\n      var thisRawIndex = thisNode.getRawIndex();\n      var oldRawIndex = oldNode && oldNode.getRawIndex();\n      var thisViewChildren = thisNode.viewChildren;\n      var upperHeight = thisLayout.upperHeight;\n      var isParent = thisViewChildren && thisViewChildren.length;\n      var itemStyleNormalModel = nodeModel.getModel('itemStyle');\n      var itemStyleEmphasisModel = nodeModel.getModel(['emphasis', 'itemStyle']);\n      var itemStyleBlurModel = nodeModel.getModel(['blur', 'itemStyle']);\n      var itemStyleSelectModel = nodeModel.getModel(['select', 'itemStyle']);\n      var borderRadius = itemStyleNormalModel.get('borderRadius') || 0;\n      var group = giveGraphic('nodeGroup', Group$1);\n\n      if (!group) {\n        return;\n      }\n\n      parentGroup.add(group);\n      group.x = thisLayout.x || 0;\n      group.y = thisLayout.y || 0;\n      group.markRedraw();\n      inner$9(group).nodeWidth = thisWidth;\n      inner$9(group).nodeHeight = thisHeight;\n\n      if (thisLayout.isAboveViewRoot) {\n        return group;\n      }\n\n      var bg = giveGraphic('background', Rect$1, depth, Z_BG);\n      bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);\n      var focus = nodeModel.get(['emphasis', 'focus']);\n      var blurScope = nodeModel.get(['emphasis', 'blurScope']);\n      var focusDataIndices = focus === 'ancestor' ? thisNode.getAncestorsIndices() : focus === 'descendant' ? thisNode.getDescendantIndices() : null;\n\n      if (isParent) {\n        if (isHighDownDispatcher(group)) {\n          setAsHighDownDispatcher(group, false);\n        }\n\n        if (bg) {\n          setAsHighDownDispatcher(bg, true);\n          data.setItemGraphicEl(thisNode.dataIndex, bg);\n          enableHoverFocus(bg, focusDataIndices || focus, blurScope);\n        }\n      } else {\n        var content = giveGraphic('content', Rect$1, depth, Z_CONTENT);\n        content && renderContent(group, content);\n\n        if (bg && isHighDownDispatcher(bg)) {\n          setAsHighDownDispatcher(bg, false);\n        }\n\n        setAsHighDownDispatcher(group, true);\n        data.setItemGraphicEl(thisNode.dataIndex, group);\n        enableHoverFocus(group, focusDataIndices || focus, blurScope);\n      }\n\n      return group;\n\n      function renderBackground(group, bg, useUpperLabel) {\n        var ecData = getECData(bg);\n        ecData.dataIndex = thisNode.dataIndex;\n        ecData.seriesIndex = seriesModel.seriesIndex;\n        bg.setShape({\n          x: 0,\n          y: 0,\n          width: thisWidth,\n          height: thisHeight,\n          r: borderRadius\n        });\n\n        if (thisInvisible) {\n          processInvisible(bg);\n        } else {\n          bg.invisible = false;\n          var style = thisNode.getVisual('style');\n          var visualBorderColor = style.stroke;\n          var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n          normalStyle.fill = visualBorderColor;\n          var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);\n          emphasisStyle.fill = itemStyleEmphasisModel.get('borderColor');\n          var blurStyle = getStateItemStyle(itemStyleBlurModel);\n          blurStyle.fill = itemStyleBlurModel.get('borderColor');\n          var selectStyle = getStateItemStyle(itemStyleSelectModel);\n          selectStyle.fill = itemStyleSelectModel.get('borderColor');\n\n          if (useUpperLabel) {\n            var upperLabelWidth = thisWidth - 2 * borderWidth;\n            prepareText(bg, visualBorderColor, upperLabelWidth, upperHeight, style.opacity, {\n              x: borderWidth,\n              y: 0,\n              width: upperLabelWidth,\n              height: upperHeight\n            });\n          } else {\n            bg.removeTextContent();\n          }\n\n          bg.setStyle(normalStyle);\n          bg.ensureState('emphasis').style = emphasisStyle;\n          bg.ensureState('blur').style = blurStyle;\n          bg.ensureState('select').style = selectStyle;\n          setDefaultStateProxy(bg);\n        }\n\n        group.add(bg);\n      }\n\n      function renderContent(group, content) {\n        var ecData = getECData(content);\n        ecData.dataIndex = thisNode.dataIndex;\n        ecData.seriesIndex = seriesModel.seriesIndex;\n        var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);\n        var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);\n        content.culling = true;\n        content.setShape({\n          x: borderWidth,\n          y: borderWidth,\n          width: contentWidth,\n          height: contentHeight,\n          r: borderRadius\n        });\n\n        if (thisInvisible) {\n          processInvisible(content);\n        } else {\n          content.invisible = false;\n          var nodeStyle = thisNode.getVisual('style');\n          var visualColor = nodeStyle.fill;\n          var normalStyle = getItemStyleNormal(itemStyleNormalModel);\n          normalStyle.fill = visualColor;\n          normalStyle.decal = nodeStyle.decal;\n          var emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);\n          var blurStyle = getStateItemStyle(itemStyleBlurModel);\n          var selectStyle = getStateItemStyle(itemStyleSelectModel);\n          prepareText(content, visualColor, contentWidth, nodeStyle.opacity);\n          content.setStyle(normalStyle);\n          content.ensureState('emphasis').style = emphasisStyle;\n          content.ensureState('blur').style = blurStyle;\n          content.ensureState('select').style = selectStyle;\n          setDefaultStateProxy(content);\n        }\n\n        group.add(content);\n      }\n\n      function processInvisible(element) {\n        !element.invisible && willInvisibleEls.push(element);\n      }\n\n      function prepareText(rectEl, visualColor, visualOpacity, width, height, upperLabelRect) {\n        var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);\n        var text = retrieve(seriesModel.getFormattedLabel(thisNode.dataIndex, 'normal', null, null, normalLabelModel.get('formatter')), convertOptionIdName(nodeModel.get('name'), null));\n\n        if (!upperLabelRect && thisLayout.isLeafRoot) {\n          var iconChar = seriesModel.get('drillDownIcon', true);\n          text = iconChar ? iconChar + ' ' + text : text;\n        }\n\n        var isShow = normalLabelModel.getShallow('show');\n        setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {\n          defaultText: isShow ? text : null,\n          inheritColor: visualColor,\n          defaultOpacity: visualOpacity,\n          labelFetcher: seriesModel,\n          labelDataIndex: thisNode.dataIndex\n        });\n        var textEl = rectEl.getTextContent();\n        var textStyle = textEl.style;\n        var textPadding = normalizeCssArray(textStyle.padding || 0);\n\n        if (upperLabelRect) {\n          rectEl.setTextConfig({\n            layoutRect: upperLabelRect\n          });\n          textEl.disableLabelLayout = true;\n        }\n\n        textEl.beforeUpdate = function () {\n          var width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);\n          var height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);\n\n          if (textStyle.width !== width || textStyle.height !== height) {\n            textEl.setStyle({\n              width: width,\n              height: height\n            });\n          }\n        };\n\n        textStyle.truncateMinChar = 2;\n        textStyle.lineOverflow = 'truncate';\n        addDrillDownIcon(textStyle, upperLabelRect, thisLayout);\n        var textEmphasisState = textEl.getState('emphasis');\n        addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);\n      }\n\n      function addDrillDownIcon(style, upperLabelRect, thisLayout) {\n        var text = style ? style.text : null;\n\n        if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {\n          var iconChar = seriesModel.get('drillDownIcon', true);\n          style.text = iconChar ? iconChar + ' ' + text : text;\n        }\n      }\n\n      function giveGraphic(storageName, Ctor, depth, z) {\n        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];\n        var lasts = lastsForAnimation[storageName];\n\n        if (element) {\n          oldStorage[storageName][oldRawIndex] = null;\n          prepareAnimationWhenHasOld(lasts, element);\n        } else if (!thisInvisible) {\n          element = new Ctor();\n\n          if (element instanceof Displayable) {\n            element.z = calculateZ(depth, z);\n          }\n\n          prepareAnimationWhenNoOld(lasts, element);\n        }\n\n        return thisStorage[storageName][thisRawIndex] = element;\n      }\n\n      function prepareAnimationWhenHasOld(lasts, element) {\n        var lastCfg = lasts[thisRawIndex] = {};\n\n        if (element instanceof Group$1) {\n          lastCfg.oldX = element.x;\n          lastCfg.oldY = element.y;\n        } else {\n          lastCfg.oldShape = extend({}, element.shape);\n        }\n      }\n\n      function prepareAnimationWhenNoOld(lasts, element) {\n        var lastCfg = lasts[thisRawIndex] = {};\n        var parentNode = thisNode.parentNode;\n        var isGroup = element instanceof Group;\n\n        if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {\n          var parentOldX = 0;\n          var parentOldY = 0;\n          var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];\n\n          if (!reRoot && parentOldBg && parentOldBg.oldShape) {\n            parentOldX = parentOldBg.oldShape.width;\n            parentOldY = parentOldBg.oldShape.height;\n          }\n\n          if (isGroup) {\n            lastCfg.oldX = 0;\n            lastCfg.oldY = parentOldY;\n          } else {\n            lastCfg.oldShape = {\n              x: parentOldX,\n              y: parentOldY,\n              width: 0,\n              height: 0\n            };\n          }\n        }\n\n        lastCfg.fadein = !isGroup;\n      }\n    }\n\n    function calculateZ(depth, zInLevel) {\n      var zb = depth * Z_BASE + zInLevel;\n      return (zb - 1) / zb;\n    }\n\n    var each$4 = each;\n    var isObject$4 = isObject;\n    var CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\n    var VisualMapping = function () {\n      function VisualMapping(option) {\n        var mappingMethod = option.mappingMethod;\n        var visualType = option.type;\n        var thisOption = this.option = clone(option);\n        this.type = visualType;\n        this.mappingMethod = mappingMethod;\n        this._normalizeData = normalizers[mappingMethod];\n        var visualHandler = VisualMapping.visualHandlers[visualType];\n        this.applyVisual = visualHandler.applyVisual;\n        this.getColorMapper = visualHandler.getColorMapper;\n        this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n        if (mappingMethod === 'piecewise') {\n          normalizeVisualRange(thisOption);\n          preprocessForPiecewise(thisOption);\n        } else if (mappingMethod === 'category') {\n          thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);\n        } else {\n          assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n          normalizeVisualRange(thisOption);\n        }\n      }\n\n      VisualMapping.prototype.mapValueToVisual = function (value) {\n        var normalized = this._normalizeData(value);\n\n        return this._normalizedToVisual(normalized, value);\n      };\n\n      VisualMapping.prototype.getNormalizer = function () {\n        return bind(this._normalizeData, this);\n      };\n\n      VisualMapping.listVisualTypes = function () {\n        return keys(VisualMapping.visualHandlers);\n      };\n\n      VisualMapping.isValidType = function (visualType) {\n        return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n      };\n\n      VisualMapping.eachVisual = function (visual, callback, context) {\n        if (isObject(visual)) {\n          each(visual, callback, context);\n        } else {\n          callback.call(context, visual);\n        }\n      };\n\n      VisualMapping.mapVisual = function (visual, callback, context) {\n        var isPrimary;\n        var newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null);\n        VisualMapping.eachVisual(visual, function (v, key) {\n          var newVal = callback.call(context, v, key);\n          isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n        });\n        return newVisual;\n      };\n\n      VisualMapping.retrieveVisuals = function (obj) {\n        var ret = {};\n        var hasVisual;\n        obj && each$4(VisualMapping.visualHandlers, function (h, visualType) {\n          if (obj.hasOwnProperty(visualType)) {\n            ret[visualType] = obj[visualType];\n            hasVisual = true;\n          }\n        });\n        return hasVisual ? ret : null;\n      };\n\n      VisualMapping.prepareVisualTypes = function (visualTypes) {\n        if (isArray(visualTypes)) {\n          visualTypes = visualTypes.slice();\n        } else if (isObject$4(visualTypes)) {\n          var types_1 = [];\n          each$4(visualTypes, function (item, type) {\n            types_1.push(type);\n          });\n          visualTypes = types_1;\n        } else {\n          return [];\n        }\n\n        visualTypes.sort(function (type1, type2) {\n          return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n        });\n        return visualTypes;\n      };\n\n      VisualMapping.dependsOn = function (visualType1, visualType2) {\n        return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n      };\n\n      VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n        var possibleI;\n        var abs = Infinity;\n\n        for (var i = 0, len = pieceList.length; i < len; i++) {\n          var pieceValue = pieceList[i].value;\n\n          if (pieceValue != null) {\n            if (pieceValue === value || typeof pieceValue === 'string' && pieceValue === value + '') {\n              return i;\n            }\n\n            findClosestWhenOutside && updatePossible(pieceValue, i);\n          }\n        }\n\n        for (var i = 0, len = pieceList.length; i < len; i++) {\n          var piece = pieceList[i];\n          var interval = piece.interval;\n          var close_1 = piece.close;\n\n          if (interval) {\n            if (interval[0] === -Infinity) {\n              if (littleThan(close_1[1], value, interval[1])) {\n                return i;\n              }\n            } else if (interval[1] === Infinity) {\n              if (littleThan(close_1[0], interval[0], value)) {\n                return i;\n              }\n            } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n              return i;\n            }\n\n            findClosestWhenOutside && updatePossible(interval[0], i);\n            findClosestWhenOutside && updatePossible(interval[1], i);\n          }\n        }\n\n        if (findClosestWhenOutside) {\n          return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n        }\n\n        function updatePossible(val, index) {\n          var newAbs = Math.abs(val - value);\n\n          if (newAbs < abs) {\n            abs = newAbs;\n            possibleI = index;\n          }\n        }\n      };\n\n      VisualMapping.visualHandlers = {\n        color: {\n          applyVisual: makeApplyVisual('color'),\n          getColorMapper: function () {\n            var thisOption = this.option;\n            return bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n              !isNormalized && (value = this._normalizeData(value));\n              return doMapCategory.call(this, value);\n            } : function (value, isNormalized, out) {\n              var returnRGBArray = !!out;\n              !isNormalized && (value = this._normalizeData(value));\n              out = fastLerp(value, thisOption.parsedVisual, out);\n              return returnRGBArray ? out : stringify(out, 'rgba');\n            }, this);\n          },\n          _normalizedToVisual: {\n            linear: function (normalized) {\n              return stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba');\n            },\n            category: doMapCategory,\n            piecewise: function (normalized, value) {\n              var result = getSpecifiedVisual.call(this, value);\n\n              if (result == null) {\n                result = stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba');\n              }\n\n              return result;\n            },\n            fixed: doMapFixed\n          }\n        },\n        colorHue: makePartialColorVisualHandler(function (color$1, value) {\n          return modifyHSL(color$1, value);\n        }),\n        colorSaturation: makePartialColorVisualHandler(function (color$1, value) {\n          return modifyHSL(color$1, null, value);\n        }),\n        colorLightness: makePartialColorVisualHandler(function (color$1, value) {\n          return modifyHSL(color$1, null, null, value);\n        }),\n        colorAlpha: makePartialColorVisualHandler(function (color$1, value) {\n          return modifyAlpha(color$1, value);\n        }),\n        decal: {\n          applyVisual: makeApplyVisual('decal'),\n          _normalizedToVisual: {\n            linear: null,\n            category: doMapCategory,\n            piecewise: null,\n            fixed: null\n          }\n        },\n        opacity: {\n          applyVisual: makeApplyVisual('opacity'),\n          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n        },\n        liftZ: {\n          applyVisual: makeApplyVisual('liftZ'),\n          _normalizedToVisual: {\n            linear: doMapFixed,\n            category: doMapFixed,\n            piecewise: doMapFixed,\n            fixed: doMapFixed\n          }\n        },\n        symbol: {\n          applyVisual: function (value, getter, setter) {\n            var symbolCfg = this.mapValueToVisual(value);\n            setter('symbol', symbolCfg);\n          },\n          _normalizedToVisual: {\n            linear: doMapToArray,\n            category: doMapCategory,\n            piecewise: function (normalized, value) {\n              var result = getSpecifiedVisual.call(this, value);\n\n              if (result == null) {\n                result = doMapToArray.call(this, normalized);\n              }\n\n              return result;\n            },\n            fixed: doMapFixed\n          }\n        },\n        symbolSize: {\n          applyVisual: makeApplyVisual('symbolSize'),\n          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n        }\n      };\n      return VisualMapping;\n    }();\n\n    function preprocessForPiecewise(thisOption) {\n      var pieceList = thisOption.pieceList;\n      thisOption.hasSpecialVisual = false;\n      each(pieceList, function (piece, index) {\n        piece.originIndex = index;\n\n        if (piece.visual != null) {\n          thisOption.hasSpecialVisual = true;\n        }\n      });\n    }\n\n    function preprocessForSpecifiedCategory(thisOption) {\n      var categories = thisOption.categories;\n      var categoryMap = thisOption.categoryMap = {};\n      var visual = thisOption.visual;\n      each$4(categories, function (cate, index) {\n        categoryMap[cate] = index;\n      });\n\n      if (!isArray(visual)) {\n        var visualArr_1 = [];\n\n        if (isObject(visual)) {\n          each$4(visual, function (v, cate) {\n            var index = categoryMap[cate];\n            visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n          });\n        } else {\n          visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n        }\n\n        visual = setVisualToOption(thisOption, visualArr_1);\n      }\n\n      for (var i = categories.length - 1; i >= 0; i--) {\n        if (visual[i] == null) {\n          delete categoryMap[categories[i]];\n          categories.pop();\n        }\n      }\n    }\n\n    function normalizeVisualRange(thisOption, isCategory) {\n      var visual = thisOption.visual;\n      var visualArr = [];\n\n      if (isObject(visual)) {\n        each$4(visual, function (v) {\n          visualArr.push(v);\n        });\n      } else if (visual != null) {\n        visualArr.push(visual);\n      }\n\n      var doNotNeedPair = {\n        color: 1,\n        symbol: 1\n      };\n\n      if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n        visualArr[1] = visualArr[0];\n      }\n\n      setVisualToOption(thisOption, visualArr);\n    }\n\n    function makePartialColorVisualHandler(applyValue) {\n      return {\n        applyVisual: function (value, getter, setter) {\n          var colorChannel = this.mapValueToVisual(value);\n          setter('color', applyValue(getter('color'), colorChannel));\n        },\n        _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n      };\n    }\n\n    function doMapToArray(normalized) {\n      var visual = this.option.visual;\n      return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n    }\n\n    function makeApplyVisual(visualType) {\n      return function (value, getter, setter) {\n        setter(visualType, this.mapValueToVisual(value));\n      };\n    }\n\n    function doMapCategory(normalized) {\n      var visual = this.option.visual;\n      return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n    }\n\n    function doMapFixed() {\n      return this.option.visual[0];\n    }\n\n    function createNormalizedToNumericVisual(sourceExtent) {\n      return {\n        linear: function (normalized) {\n          return linearMap(normalized, sourceExtent, this.option.visual, true);\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = linearMap(normalized, sourceExtent, this.option.visual, true);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      };\n    }\n\n    function getSpecifiedVisual(value) {\n      var thisOption = this.option;\n      var pieceList = thisOption.pieceList;\n\n      if (thisOption.hasSpecialVisual) {\n        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n        var piece = pieceList[pieceIndex];\n\n        if (piece && piece.visual) {\n          return piece.visual[this.type];\n        }\n      }\n    }\n\n    function setVisualToOption(thisOption, visualArr) {\n      thisOption.visual = visualArr;\n\n      if (thisOption.type === 'color') {\n        thisOption.parsedVisual = map(visualArr, function (item) {\n          return parse(item);\n        });\n      }\n\n      return visualArr;\n    }\n\n    var normalizers = {\n      linear: function (value) {\n        return linearMap(value, this.option.dataExtent, [0, 1], true);\n      },\n      piecewise: function (value) {\n        var pieceList = this.option.pieceList;\n        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n        if (pieceIndex != null) {\n          return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n        }\n      },\n      category: function (value) {\n        var index = this.option.categories ? this.option.categoryMap[value] : value;\n        return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n      },\n      fixed: noop\n    };\n\n    function littleThan(close, a, b) {\n      return close ? a <= b : a < b;\n    }\n\n    var ITEM_STYLE_NORMAL = 'itemStyle';\n    var inner$a = makeInner();\n    var treemapVisual = {\n      seriesType: 'treemap',\n      reset: function (seriesModel) {\n        var tree = seriesModel.getData().tree;\n        var root = tree.root;\n\n        if (root.isRemoved()) {\n          return;\n        }\n\n        travelTree(root, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);\n      }\n    };\n\n    function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {\n      var nodeModel = node.getModel();\n      var nodeLayout = node.getLayout();\n      var data = node.hostTree.data;\n\n      if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {\n        return;\n      }\n\n      var nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);\n      var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);\n      var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n      var borderColor = nodeItemStyleModel.get('borderColor');\n      var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');\n      var thisNodeColor;\n\n      if (borderColorSaturation != null) {\n        thisNodeColor = calculateColor(visuals);\n        borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);\n      }\n\n      existsStyle.stroke = borderColor;\n      var viewChildren = node.viewChildren;\n\n      if (!viewChildren || !viewChildren.length) {\n        thisNodeColor = calculateColor(visuals);\n        existsStyle.fill = thisNodeColor;\n      } else {\n        var mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);\n        each(viewChildren, function (child, index) {\n          if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {\n            var childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel);\n            travelTree(child, childVisual, viewRootAncestors, seriesModel);\n          }\n        });\n      }\n    }\n\n    function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {\n      var visuals = extend({}, designatedVisual);\n      var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;\n      each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {\n        designatedVisualItemStyle[visualName] = designatedVisual[visualName];\n        var val = nodeItemStyleModel.get(visualName);\n        designatedVisualItemStyle[visualName] = null;\n        val != null && (visuals[visualName] = val);\n      });\n      return visuals;\n    }\n\n    function calculateColor(visuals) {\n      var color = getValueVisualDefine(visuals, 'color');\n\n      if (color) {\n        var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');\n        var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');\n\n        if (colorSaturation) {\n          color = modifyHSL(color, null, null, colorSaturation);\n        }\n\n        if (colorAlpha) {\n          color = modifyAlpha(color, colorAlpha);\n        }\n\n        return color;\n      }\n    }\n\n    function calculateBorderColor(borderColorSaturation, thisNodeColor) {\n      return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;\n    }\n\n    function getValueVisualDefine(visuals, name) {\n      var value = visuals[name];\n\n      if (value != null && value !== 'none') {\n        return value;\n      }\n    }\n\n    function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {\n      if (!viewChildren || !viewChildren.length) {\n        return;\n      }\n\n      var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));\n\n      if (!rangeVisual) {\n        return;\n      }\n\n      var visualMin = nodeModel.get('visualMin');\n      var visualMax = nodeModel.get('visualMax');\n      var dataExtent = nodeLayout.dataExtent.slice();\n      visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);\n      visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);\n      var colorMappingBy = nodeModel.get('colorMappingBy');\n      var opt = {\n        type: rangeVisual.name,\n        dataExtent: dataExtent,\n        visual: rangeVisual.range\n      };\n\n      if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {\n        opt.mappingMethod = 'category';\n        opt.loop = true;\n      } else {\n        opt.mappingMethod = 'linear';\n      }\n\n      var mapping = new VisualMapping(opt);\n      inner$a(mapping).drColorMappingBy = colorMappingBy;\n      return mapping;\n    }\n\n    function getRangeVisual(nodeModel, name) {\n      var range = nodeModel.get(name);\n      return isArray(range) && range.length ? {\n        name: name,\n        range: range\n      } : null;\n    }\n\n    function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {\n      var childVisuals = extend({}, visuals);\n\n      if (mapping) {\n        var mappingType = mapping.type;\n        var colorMappingBy = mappingType === 'color' && inner$a(mapping).drColorMappingBy;\n        var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));\n        childVisuals[mappingType] = mapping.mapValueToVisual(value);\n      }\n\n      return childVisuals;\n    }\n\n    var mathMax$7 = Math.max;\n    var mathMin$7 = Math.min;\n    var retrieveValue = retrieve;\n    var each$5 = each;\n    var PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'];\n    var PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'];\n    var PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'];\n    var PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'];\n    var treemapLayout = {\n      seriesType: 'treemap',\n      reset: function (seriesModel, ecModel, api, payload) {\n        var ecWidth = api.getWidth();\n        var ecHeight = api.getHeight();\n        var seriesOption = seriesModel.option;\n        var layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n        var size = seriesOption.size || [];\n        var containerWidth = parsePercent$1(retrieveValue(layoutInfo.width, size[0]), ecWidth);\n        var containerHeight = parsePercent$1(retrieveValue(layoutInfo.height, size[1]), ecHeight);\n        var payloadType = payload && payload.type;\n        var types = ['treemapZoomToNode', 'treemapRootToNode'];\n        var targetInfo = retrieveTargetInfo(payload, types, seriesModel);\n        var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;\n        var viewRoot = seriesModel.getViewRoot();\n        var viewAbovePath = getPathToRoot(viewRoot);\n\n        if (payloadType !== 'treemapMove') {\n          var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];\n          var sort_1 = seriesOption.sort;\n\n          if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {\n            sort_1 = 'desc';\n          }\n\n          var options = {\n            squareRatio: seriesOption.squareRatio,\n            sort: sort_1,\n            leafDepth: seriesOption.leafDepth\n          };\n          viewRoot.hostTree.clearLayouts();\n          var viewRootLayout_1 = {\n            x: 0,\n            y: 0,\n            width: rootSize[0],\n            height: rootSize[1],\n            area: rootSize[0] * rootSize[1]\n          };\n          viewRoot.setLayout(viewRootLayout_1);\n          squarify(viewRoot, options, false, 0);\n          viewRootLayout_1 = viewRoot.getLayout();\n          each$5(viewAbovePath, function (node, index) {\n            var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();\n            node.setLayout(extend({\n              dataExtent: [childValue, childValue],\n              borderWidth: 0,\n              upperHeight: 0\n            }, viewRootLayout_1));\n          });\n        }\n\n        var treeRoot = seriesModel.getData().tree.root;\n        treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);\n        seriesModel.setLayoutInfo(layoutInfo);\n        prunning(treeRoot, new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);\n      }\n    };\n\n    function squarify(node, options, hideChildren, depth) {\n      var width;\n      var height;\n\n      if (node.isRemoved()) {\n        return;\n      }\n\n      var thisLayout = node.getLayout();\n      width = thisLayout.width;\n      height = thisLayout.height;\n      var nodeModel = node.getModel();\n      var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);\n      var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;\n      var upperLabelHeight = getUpperLabelHeight(nodeModel);\n      var upperHeight = Math.max(borderWidth, upperLabelHeight);\n      var layoutOffset = borderWidth - halfGapWidth;\n      var layoutOffsetUpper = upperHeight - halfGapWidth;\n      node.setLayout({\n        borderWidth: borderWidth,\n        upperHeight: upperHeight,\n        upperLabelHeight: upperLabelHeight\n      }, true);\n      width = mathMax$7(width - 2 * layoutOffset, 0);\n      height = mathMax$7(height - layoutOffset - layoutOffsetUpper, 0);\n      var totalArea = width * height;\n      var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);\n\n      if (!viewChildren.length) {\n        return;\n      }\n\n      var rect = {\n        x: layoutOffset,\n        y: layoutOffsetUpper,\n        width: width,\n        height: height\n      };\n      var rowFixedLength = mathMin$7(width, height);\n      var best = Infinity;\n      var row = [];\n      row.area = 0;\n\n      for (var i = 0, len = viewChildren.length; i < len;) {\n        var child = viewChildren[i];\n        row.push(child);\n        row.area += child.getLayout().area;\n        var score = worst(row, rowFixedLength, options.squareRatio);\n\n        if (score <= best) {\n          i++;\n          best = score;\n        } else {\n          row.area -= row.pop().getLayout().area;\n          position(row, rowFixedLength, rect, halfGapWidth, false);\n          rowFixedLength = mathMin$7(rect.width, rect.height);\n          row.length = row.area = 0;\n          best = Infinity;\n        }\n      }\n\n      if (row.length) {\n        position(row, rowFixedLength, rect, halfGapWidth, true);\n      }\n\n      if (!hideChildren) {\n        var childrenVisibleMin = nodeModel.get('childrenVisibleMin');\n\n        if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {\n          hideChildren = true;\n        }\n      }\n\n      for (var i = 0, len = viewChildren.length; i < len; i++) {\n        squarify(viewChildren[i], options, hideChildren, depth + 1);\n      }\n    }\n\n    function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {\n      var viewChildren = node.children || [];\n      var orderBy = options.sort;\n      orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);\n      var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;\n\n      if (hideChildren && !overLeafDepth) {\n        return node.viewChildren = [];\n      }\n\n      viewChildren = filter(viewChildren, function (child) {\n        return !child.isRemoved();\n      });\n      sort$1(viewChildren, orderBy);\n      var info = statistic(nodeModel, viewChildren, orderBy);\n\n      if (info.sum === 0) {\n        return node.viewChildren = [];\n      }\n\n      info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);\n\n      if (info.sum === 0) {\n        return node.viewChildren = [];\n      }\n\n      for (var i = 0, len = viewChildren.length; i < len; i++) {\n        var area = viewChildren[i].getValue() / info.sum * totalArea;\n        viewChildren[i].setLayout({\n          area: area\n        });\n      }\n\n      if (overLeafDepth) {\n        viewChildren.length && node.setLayout({\n          isLeafRoot: true\n        }, true);\n        viewChildren.length = 0;\n      }\n\n      node.viewChildren = viewChildren;\n      node.setLayout({\n        dataExtent: info.dataExtent\n      }, true);\n      return viewChildren;\n    }\n\n    function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {\n      if (!orderBy) {\n        return sum;\n      }\n\n      var visibleMin = nodeModel.get('visibleMin');\n      var len = orderedChildren.length;\n      var deletePoint = len;\n\n      for (var i = len - 1; i >= 0; i--) {\n        var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();\n\n        if (value / sum * totalArea < visibleMin) {\n          deletePoint = i;\n          sum -= value;\n        }\n      }\n\n      orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);\n      return sum;\n    }\n\n    function sort$1(viewChildren, orderBy) {\n      if (orderBy) {\n        viewChildren.sort(function (a, b) {\n          var diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();\n          return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;\n        });\n      }\n\n      return viewChildren;\n    }\n\n    function statistic(nodeModel, children, orderBy) {\n      var sum = 0;\n\n      for (var i = 0, len = children.length; i < len; i++) {\n        sum += children[i].getValue();\n      }\n\n      var dimension = nodeModel.get('visualDimension');\n      var dataExtent;\n\n      if (!children || !children.length) {\n        dataExtent = [NaN, NaN];\n      } else if (dimension === 'value' && orderBy) {\n        dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];\n        orderBy === 'asc' && dataExtent.reverse();\n      } else {\n        dataExtent = [Infinity, -Infinity];\n        each$5(children, function (child) {\n          var value = child.getValue(dimension);\n          value < dataExtent[0] && (dataExtent[0] = value);\n          value > dataExtent[1] && (dataExtent[1] = value);\n        });\n      }\n\n      return {\n        sum: sum,\n        dataExtent: dataExtent\n      };\n    }\n\n    function worst(row, rowFixedLength, ratio) {\n      var areaMax = 0;\n      var areaMin = Infinity;\n\n      for (var i = 0, area = void 0, len = row.length; i < len; i++) {\n        area = row[i].getLayout().area;\n\n        if (area) {\n          area < areaMin && (areaMin = area);\n          area > areaMax && (areaMax = area);\n        }\n      }\n\n      var squareArea = row.area * row.area;\n      var f = rowFixedLength * rowFixedLength * ratio;\n      return squareArea ? mathMax$7(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;\n    }\n\n    function position(row, rowFixedLength, rect, halfGapWidth, flush) {\n      var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;\n      var idx1WhenH = 1 - idx0WhenH;\n      var xy = ['x', 'y'];\n      var wh = ['width', 'height'];\n      var last = rect[xy[idx0WhenH]];\n      var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;\n\n      if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {\n        rowOtherLength = rect[wh[idx1WhenH]];\n      }\n\n      for (var i = 0, rowLen = row.length; i < rowLen; i++) {\n        var node = row[i];\n        var nodeLayout = {};\n        var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;\n        var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$7(rowOtherLength - 2 * halfGapWidth, 0);\n        var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;\n        var modWH = i === rowLen - 1 || remain < step ? remain : step;\n        var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$7(modWH - 2 * halfGapWidth, 0);\n        nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$7(halfGapWidth, wh1 / 2);\n        nodeLayout[xy[idx0WhenH]] = last + mathMin$7(halfGapWidth, wh0 / 2);\n        last += modWH;\n        node.setLayout(nodeLayout, true);\n      }\n\n      rect[xy[idx1WhenH]] += rowOtherLength;\n      rect[wh[idx1WhenH]] -= rowOtherLength;\n    }\n\n    function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {\n      var currNode = (targetInfo || {}).node;\n      var defaultSize = [containerWidth, containerHeight];\n\n      if (!currNode || currNode === viewRoot) {\n        return defaultSize;\n      }\n\n      var parent;\n      var viewArea = containerWidth * containerHeight;\n      var area = viewArea * seriesModel.option.zoomToNodeRatio;\n\n      while (parent = currNode.parentNode) {\n        var sum = 0;\n        var siblings = parent.children;\n\n        for (var i = 0, len = siblings.length; i < len; i++) {\n          sum += siblings[i].getValue();\n        }\n\n        var currNodeValue = currNode.getValue();\n\n        if (currNodeValue === 0) {\n          return defaultSize;\n        }\n\n        area *= sum / currNodeValue;\n        var parentModel = parent.getModel();\n        var borderWidth = parentModel.get(PATH_BORDER_WIDTH);\n        var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));\n        area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);\n        area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);\n        currNode = parent;\n      }\n\n      area < viewArea && (area = viewArea);\n      var scale = Math.pow(area / viewArea, 0.5);\n      return [containerWidth * scale, containerHeight * scale];\n    }\n\n    function calculateRootPosition(layoutInfo, rootRect, targetInfo) {\n      if (rootRect) {\n        return {\n          x: rootRect.x,\n          y: rootRect.y\n        };\n      }\n\n      var defaultPosition = {\n        x: 0,\n        y: 0\n      };\n\n      if (!targetInfo) {\n        return defaultPosition;\n      }\n\n      var targetNode = targetInfo.node;\n      var layout = targetNode.getLayout();\n\n      if (!layout) {\n        return defaultPosition;\n      }\n\n      var targetCenter = [layout.width / 2, layout.height / 2];\n      var node = targetNode;\n\n      while (node) {\n        var nodeLayout = node.getLayout();\n        targetCenter[0] += nodeLayout.x;\n        targetCenter[1] += nodeLayout.y;\n        node = node.parentNode;\n      }\n\n      return {\n        x: layoutInfo.width / 2 - targetCenter[0],\n        y: layoutInfo.height / 2 - targetCenter[1]\n      };\n    }\n\n    function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {\n      var nodeLayout = node.getLayout();\n      var nodeInViewAbovePath = viewAbovePath[depth];\n      var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;\n\n      if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {\n        return;\n      }\n\n      node.setLayout({\n        isInView: true,\n        invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),\n        isAboveViewRoot: isAboveViewRoot\n      }, true);\n      var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);\n      each$5(node.viewChildren || [], function (child) {\n        prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);\n      });\n    }\n\n    function getUpperLabelHeight(model) {\n      return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;\n    }\n\n    function install$b(registers) {\n      registers.registerSeriesModel(TreemapSeriesModel);\n      registers.registerChartView(TreemapView);\n      registers.registerVisual(treemapVisual);\n      registers.registerLayout(treemapLayout);\n      installTreemapAction(registers);\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function categoryFilter(ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (!legendModels || !legendModels.length) {\n        return;\n      }\n\n      ecModel.eachSeriesByType('graph', function (graphSeries) {\n        var categoriesData = graphSeries.getCategoriesData();\n        var graph = graphSeries.getGraph();\n        var data = graph.data;\n        var categoryNames = categoriesData.mapArray(categoriesData.getName);\n        data.filterSelf(function (idx) {\n          var model = data.getItemModel(idx);\n          var category = model.getShallow('category');\n\n          if (category != null) {\n            if (typeof category === 'number') {\n              category = categoryNames[category];\n            }\n\n            for (var i = 0; i < legendModels.length; i++) {\n              if (!legendModels[i].isSelected(category)) {\n                return false;\n              }\n            }\n          }\n\n          return true;\n        });\n      });\n    }\n\n    function categoryVisual(ecModel) {\n      var paletteScope = {};\n      ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var categoriesData = seriesModel.getCategoriesData();\n        var data = seriesModel.getData();\n        var categoryNameIdxMap = {};\n        categoriesData.each(function (idx) {\n          var name = categoriesData.getName(idx);\n          categoryNameIdxMap['ec-' + name] = idx;\n          var itemModel = categoriesData.getItemModel(idx);\n          var style = itemModel.getModel('itemStyle').getItemStyle();\n\n          if (!style.fill) {\n            style.fill = seriesModel.getColorFromPalette(name, paletteScope);\n          }\n\n          categoriesData.setItemVisual(idx, 'style', style);\n          var symbolVisualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];\n\n          for (var i = 0; i < symbolVisualList.length; i++) {\n            var symbolVisual = itemModel.getShallow(symbolVisualList[i], true);\n\n            if (symbolVisual != null) {\n              categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);\n            }\n          }\n        });\n\n        if (categoriesData.count()) {\n          data.each(function (idx) {\n            var model = data.getItemModel(idx);\n            var categoryIdx = model.getShallow('category');\n\n            if (categoryIdx != null) {\n              if (typeof categoryIdx === 'string') {\n                categoryIdx = categoryNameIdxMap['ec-' + categoryIdx];\n              }\n\n              var categoryStyle = categoriesData.getItemVisual(categoryIdx, 'style');\n              var style = data.ensureUniqueItemVisual(idx, 'style');\n              extend(style, categoryStyle);\n              var visualList = ['symbol', 'symbolSize', 'symbolKeepAspect'];\n\n              for (var i = 0; i < visualList.length; i++) {\n                data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));\n              }\n            }\n          });\n        }\n      });\n    }\n\n    function normalize$2(a) {\n      if (!(a instanceof Array)) {\n        a = [a, a];\n      }\n\n      return a;\n    }\n\n    function graphEdgeVisual(ecModel) {\n      ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var graph = seriesModel.getGraph();\n        var edgeData = seriesModel.getEdgeData();\n        var symbolType = normalize$2(seriesModel.get('edgeSymbol'));\n        var symbolSize = normalize$2(seriesModel.get('edgeSymbolSize'));\n        edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);\n        edgeData.setVisual('toSymbol', symbolType && symbolType[1]);\n        edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n        edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n        edgeData.setVisual('style', seriesModel.getModel('lineStyle').getLineStyle());\n        edgeData.each(function (idx) {\n          var itemModel = edgeData.getItemModel(idx);\n          var edge = graph.getEdgeByIndex(idx);\n          var symbolType = normalize$2(itemModel.getShallow('symbol', true));\n          var symbolSize = normalize$2(itemModel.getShallow('symbolSize', true));\n          var style = itemModel.getModel('lineStyle').getLineStyle();\n          var existsStyle = edgeData.ensureUniqueItemVisual(idx, 'style');\n          extend(existsStyle, style);\n\n          switch (existsStyle.stroke) {\n            case 'source':\n              {\n                var nodeStyle = edge.node1.getVisual('style');\n                existsStyle.stroke = nodeStyle && nodeStyle.fill;\n                break;\n              }\n\n            case 'target':\n              {\n                var nodeStyle = edge.node2.getVisual('style');\n                existsStyle.stroke = nodeStyle && nodeStyle.fill;\n                break;\n              }\n          }\n\n          symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);\n          symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);\n          symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);\n          symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);\n        });\n      });\n    }\n\n    var KEY_DELIMITER = '-->';\n\n    var getAutoCurvenessParams = function (seriesModel) {\n      return seriesModel.get('autoCurveness') || null;\n    };\n\n    var createCurveness = function (seriesModel, appendLength) {\n      var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);\n      var length = 20;\n      var curvenessList = [];\n\n      if (typeof autoCurvenessParmas === 'number') {\n        length = autoCurvenessParmas;\n      } else if (isArray(autoCurvenessParmas)) {\n        seriesModel.__curvenessList = autoCurvenessParmas;\n        return;\n      }\n\n      if (appendLength > length) {\n        length = appendLength;\n      }\n\n      var len = length % 2 ? length + 2 : length + 3;\n      curvenessList = [];\n\n      for (var i = 0; i < len; i++) {\n        curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));\n      }\n\n      seriesModel.__curvenessList = curvenessList;\n    };\n\n    var getKeyOfEdges = function (n1, n2, seriesModel) {\n      var source = [n1.id, n1.dataIndex].join('.');\n      var target = [n2.id, n2.dataIndex].join('.');\n      return [seriesModel.uid, source, target].join(KEY_DELIMITER);\n    };\n\n    var getOppositeKey = function (key) {\n      var keys = key.split(KEY_DELIMITER);\n      return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);\n    };\n\n    var getEdgeFromMap = function (edge, seriesModel) {\n      var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n      return seriesModel.__edgeMap[key];\n    };\n\n    var getTotalLengthBetweenNodes = function (edge, seriesModel) {\n      var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);\n      var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);\n      return len + lenV;\n    };\n\n    var getEdgeMapLengthWithKey = function (key, seriesModel) {\n      var edgeMap = seriesModel.__edgeMap;\n      return edgeMap[key] ? edgeMap[key].length : 0;\n    };\n\n    function initCurvenessList(seriesModel) {\n      if (!getAutoCurvenessParams(seriesModel)) {\n        return;\n      }\n\n      seriesModel.__curvenessList = [];\n      seriesModel.__edgeMap = {};\n      createCurveness(seriesModel);\n    }\n    function createEdgeMapForCurveness(n1, n2, seriesModel, index) {\n      if (!getAutoCurvenessParams(seriesModel)) {\n        return;\n      }\n\n      var key = getKeyOfEdges(n1, n2, seriesModel);\n      var edgeMap = seriesModel.__edgeMap;\n      var oppositeEdges = edgeMap[getOppositeKey(key)];\n\n      if (edgeMap[key] && !oppositeEdges) {\n        edgeMap[key].isForward = true;\n      } else if (oppositeEdges && edgeMap[key]) {\n        oppositeEdges.isForward = true;\n        edgeMap[key].isForward = false;\n      }\n\n      edgeMap[key] = edgeMap[key] || [];\n      edgeMap[key].push(index);\n    }\n    function getCurvenessForEdge(edge, seriesModel, index, needReverse) {\n      var autoCurvenessParams = getAutoCurvenessParams(seriesModel);\n      var isArrayParam = isArray(autoCurvenessParams);\n\n      if (!autoCurvenessParams) {\n        return null;\n      }\n\n      var edgeArray = getEdgeFromMap(edge, seriesModel);\n\n      if (!edgeArray) {\n        return null;\n      }\n\n      var edgeIndex = -1;\n\n      for (var i = 0; i < edgeArray.length; i++) {\n        if (edgeArray[i] === index) {\n          edgeIndex = i;\n          break;\n        }\n      }\n\n      var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);\n      createCurveness(seriesModel, totalLen);\n      edge.lineStyle = edge.lineStyle || {};\n      var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);\n      var curvenessList = seriesModel.__curvenessList;\n      var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;\n\n      if (!edgeArray.isForward) {\n        var oppositeKey = getOppositeKey(curKey);\n        var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);\n        var resValue = curvenessList[edgeIndex + len + parityCorrection];\n\n        if (needReverse) {\n          if (isArrayParam) {\n            if (autoCurvenessParams && autoCurvenessParams[0] === 0) {\n              return (len + parityCorrection) % 2 ? resValue : -resValue;\n            } else {\n              return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;\n            }\n          } else {\n            return (len + parityCorrection) % 2 ? resValue : -resValue;\n          }\n        } else {\n          return curvenessList[edgeIndex + len + parityCorrection];\n        }\n      } else {\n        return curvenessList[parityCorrection + edgeIndex];\n      }\n    }\n\n    function simpleLayout(seriesModel) {\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (coordSys && coordSys.type !== 'view') {\n        return;\n      }\n\n      var graph = seriesModel.getGraph();\n      graph.eachNode(function (node) {\n        var model = node.getModel();\n        node.setLayout([+model.get('x'), +model.get('y')]);\n      });\n      simpleLayoutEdge(graph, seriesModel);\n    }\n    function simpleLayoutEdge(graph, seriesModel) {\n      graph.eachEdge(function (edge, index) {\n        var curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -getCurvenessForEdge(edge, seriesModel, index, true), 0);\n        var p1 = clone$1(edge.node1.getLayout());\n        var p2 = clone$1(edge.node2.getLayout());\n        var points = [p1, p2];\n\n        if (+curveness) {\n          points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);\n        }\n\n        edge.setLayout(points);\n      });\n    }\n\n    function graphSimpleLayout(ecModel, api) {\n      ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var layout = seriesModel.get('layout');\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys && coordSys.type !== 'view') {\n          var data_1 = seriesModel.getData();\n          var dimensions_1 = [];\n          each(coordSys.dimensions, function (coordDim) {\n            dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim));\n          });\n\n          for (var dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {\n            var value = [];\n            var hasValue = false;\n\n            for (var i = 0; i < dimensions_1.length; i++) {\n              var val = data_1.get(dimensions_1[i], dataIndex);\n\n              if (!isNaN(val)) {\n                hasValue = true;\n              }\n\n              value.push(val);\n            }\n\n            if (hasValue) {\n              data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value));\n            } else {\n              data_1.setItemLayout(dataIndex, [NaN, NaN]);\n            }\n          }\n\n          simpleLayoutEdge(data_1.graph, seriesModel);\n        } else if (!layout || layout === 'none') {\n          simpleLayout(seriesModel);\n        }\n      });\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function getNodeGlobalScale(seriesModel) {\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (coordSys.type !== 'view') {\n        return 1;\n      }\n\n      var nodeScaleRatio = seriesModel.option.nodeScaleRatio;\n      var groupZoom = coordSys.scaleX;\n      var roamZoom = coordSys.getZoom();\n      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;\n      return nodeScale / groupZoom;\n    }\n    function getSymbolSize(node) {\n      var symbolSize = node.getVisual('symbolSize');\n\n      if (symbolSize instanceof Array) {\n        symbolSize = (symbolSize[0] + symbolSize[1]) / 2;\n      }\n\n      return +symbolSize;\n    }\n\n    var PI$6 = Math.PI;\n    var _symbolRadiansHalf = [];\n    function circularLayout(seriesModel, basedOn) {\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (coordSys && coordSys.type !== 'view') {\n        return;\n      }\n\n      var rect = coordSys.getBoundingRect();\n      var nodeData = seriesModel.getData();\n      var graph = nodeData.graph;\n      var cx = rect.width / 2 + rect.x;\n      var cy = rect.height / 2 + rect.y;\n      var r = Math.min(rect.width, rect.height) / 2;\n      var count = nodeData.count();\n      nodeData.setLayout({\n        cx: cx,\n        cy: cy\n      });\n\n      if (!count) {\n        return;\n      }\n\n      _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count);\n\n      graph.eachEdge(function (edge, index) {\n        var curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), getCurvenessForEdge(edge, seriesModel, index), 0);\n        var p1 = clone$1(edge.node1.getLayout());\n        var p2 = clone$1(edge.node2.getLayout());\n        var cp1;\n        var x12 = (p1[0] + p2[0]) / 2;\n        var y12 = (p1[1] + p2[1]) / 2;\n\n        if (+curveness) {\n          curveness *= 3;\n          cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];\n        }\n\n        edge.setLayout([p1, p2, cp1]);\n      });\n    }\n    var _layoutNodesBasedOn = {\n      value: function (seriesModel, graph, nodeData, r, cx, cy, count) {\n        var angle = 0;\n        var sum = nodeData.getSum('value');\n        var unitAngle = Math.PI * 2 / (sum || count);\n        graph.eachNode(function (node) {\n          var value = node.getValue('value');\n          var radianHalf = unitAngle * (sum ? value : 1) / 2;\n          angle += radianHalf;\n          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);\n          angle += radianHalf;\n        });\n      },\n      symbolSize: function (seriesModel, graph, nodeData, r, cx, cy, count) {\n        var sumRadian = 0;\n        _symbolRadiansHalf.length = count;\n        var nodeScale = getNodeGlobalScale(seriesModel);\n        graph.eachNode(function (node) {\n          var symbolSize = getSymbolSize(node);\n          isNaN(symbolSize) && (symbolSize = 2);\n          symbolSize < 0 && (symbolSize = 0);\n          symbolSize *= nodeScale;\n          var symbolRadianHalf = Math.asin(symbolSize / 2 / r);\n          isNaN(symbolRadianHalf) && (symbolRadianHalf = PI$6 / 2);\n          _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;\n          sumRadian += symbolRadianHalf * 2;\n        });\n        var halfRemainRadian = (2 * PI$6 - sumRadian) / count / 2;\n        var angle = 0;\n        graph.eachNode(function (node) {\n          var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];\n          angle += radianHalf;\n          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);\n          angle += radianHalf;\n        });\n      }\n    };\n\n    function graphCircularLayout(ecModel) {\n      ecModel.eachSeriesByType('graph', function (seriesModel) {\n        if (seriesModel.get('layout') === 'circular') {\n          circularLayout(seriesModel, 'symbolSize');\n        }\n      });\n    }\n\n    var scaleAndAdd$1 = scaleAndAdd;\n    function forceLayout(inNodes, inEdges, opts) {\n      var nodes = inNodes;\n      var edges = inEdges;\n      var rect = opts.rect;\n      var width = rect.width;\n      var height = rect.height;\n      var center = [rect.x + width / 2, rect.y + height / 2];\n      var gravity = opts.gravity == null ? 0.1 : opts.gravity;\n\n      for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n\n        if (!n.p) {\n          n.p = create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);\n        }\n\n        n.pp = clone$1(n.p);\n        n.edges = null;\n      }\n\n      var initialFriction = opts.friction == null ? 0.6 : opts.friction;\n      var friction = initialFriction;\n      var beforeStepCallback;\n      var afterStepCallback;\n      return {\n        warmUp: function () {\n          friction = initialFriction * 0.8;\n        },\n        setFixed: function (idx) {\n          nodes[idx].fixed = true;\n        },\n        setUnfixed: function (idx) {\n          nodes[idx].fixed = false;\n        },\n        beforeStep: function (cb) {\n          beforeStepCallback = cb;\n        },\n        afterStep: function (cb) {\n          afterStepCallback = cb;\n        },\n        step: function (cb) {\n          beforeStepCallback && beforeStepCallback(nodes, edges);\n          var v12 = [];\n          var nLen = nodes.length;\n\n          for (var i = 0; i < edges.length; i++) {\n            var e = edges[i];\n\n            if (e.ignoreForceLayout) {\n              continue;\n            }\n\n            var n1 = e.n1;\n            var n2 = e.n2;\n            sub(v12, n2.p, n1.p);\n            var d = len(v12) - e.d;\n            var w = n2.w / (n1.w + n2.w);\n\n            if (isNaN(w)) {\n              w = 0;\n            }\n\n            normalize(v12, v12);\n            !n1.fixed && scaleAndAdd$1(n1.p, n1.p, v12, w * d * friction);\n            !n2.fixed && scaleAndAdd$1(n2.p, n2.p, v12, -(1 - w) * d * friction);\n          }\n\n          for (var i = 0; i < nLen; i++) {\n            var n = nodes[i];\n\n            if (!n.fixed) {\n              sub(v12, center, n.p);\n              scaleAndAdd$1(n.p, n.p, v12, gravity * friction);\n            }\n          }\n\n          for (var i = 0; i < nLen; i++) {\n            var n1 = nodes[i];\n\n            for (var j = i + 1; j < nLen; j++) {\n              var n2 = nodes[j];\n              sub(v12, n2.p, n1.p);\n              var d = len(v12);\n\n              if (d === 0) {\n                set(v12, Math.random() - 0.5, Math.random() - 0.5);\n                d = 1;\n              }\n\n              var repFact = (n1.rep + n2.rep) / d / d;\n              !n1.fixed && scaleAndAdd$1(n1.pp, n1.pp, v12, repFact);\n              !n2.fixed && scaleAndAdd$1(n2.pp, n2.pp, v12, -repFact);\n            }\n          }\n\n          var v = [];\n\n          for (var i = 0; i < nLen; i++) {\n            var n = nodes[i];\n\n            if (!n.fixed) {\n              sub(v, n.p, n.pp);\n              scaleAndAdd$1(n.p, n.p, v, friction);\n              copy(n.pp, n.p);\n            }\n          }\n\n          friction = friction * 0.992;\n          var finished = friction < 0.01;\n          afterStepCallback && afterStepCallback(nodes, edges, finished);\n          cb && cb(finished);\n        }\n      };\n    }\n\n    function graphForceLayout(ecModel) {\n      ecModel.eachSeriesByType('graph', function (graphSeries) {\n        var coordSys = graphSeries.coordinateSystem;\n\n        if (coordSys && coordSys.type !== 'view') {\n          return;\n        }\n\n        if (graphSeries.get('layout') === 'force') {\n          var preservedPoints_1 = graphSeries.preservedPoints || {};\n          var graph_1 = graphSeries.getGraph();\n          var nodeData_1 = graph_1.data;\n          var edgeData = graph_1.edgeData;\n          var forceModel = graphSeries.getModel('force');\n          var initLayout = forceModel.get('initLayout');\n\n          if (graphSeries.preservedPoints) {\n            nodeData_1.each(function (idx) {\n              var id = nodeData_1.getId(idx);\n              nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN]);\n            });\n          } else if (!initLayout || initLayout === 'none') {\n            simpleLayout(graphSeries);\n          } else if (initLayout === 'circular') {\n            circularLayout(graphSeries, 'value');\n          }\n\n          var nodeDataExtent_1 = nodeData_1.getDataExtent('value');\n          var edgeDataExtent_1 = edgeData.getDataExtent('value');\n          var repulsion = forceModel.get('repulsion');\n          var edgeLength = forceModel.get('edgeLength');\n          var repulsionArr_1 = isArray(repulsion) ? repulsion : [repulsion, repulsion];\n          var edgeLengthArr_1 = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];\n          edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]];\n          var nodes_1 = nodeData_1.mapArray('value', function (value, idx) {\n            var point = nodeData_1.getItemLayout(idx);\n            var rep = linearMap(value, nodeDataExtent_1, repulsionArr_1);\n\n            if (isNaN(rep)) {\n              rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2;\n            }\n\n            return {\n              w: rep,\n              rep: rep,\n              fixed: nodeData_1.getItemModel(idx).get('fixed'),\n              p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point\n            };\n          });\n          var edges = edgeData.mapArray('value', function (value, idx) {\n            var edge = graph_1.getEdgeByIndex(idx);\n            var d = linearMap(value, edgeDataExtent_1, edgeLengthArr_1);\n\n            if (isNaN(d)) {\n              d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2;\n            }\n\n            var edgeModel = edge.getModel();\n            var curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);\n            return {\n              n1: nodes_1[edge.node1.dataIndex],\n              n2: nodes_1[edge.node2.dataIndex],\n              d: d,\n              curveness: curveness,\n              ignoreForceLayout: edgeModel.get('ignoreForceLayout')\n            };\n          });\n          var rect = coordSys.getBoundingRect();\n          var forceInstance = forceLayout(nodes_1, edges, {\n            rect: rect,\n            gravity: forceModel.get('gravity'),\n            friction: forceModel.get('friction')\n          });\n          forceInstance.beforeStep(function (nodes, edges) {\n            for (var i = 0, l = nodes.length; i < l; i++) {\n              if (nodes[i].fixed) {\n                copy(nodes[i].p, graph_1.getNodeByIndex(i).getLayout());\n              }\n            }\n          });\n          forceInstance.afterStep(function (nodes, edges, stopped) {\n            for (var i = 0, l = nodes.length; i < l; i++) {\n              if (!nodes[i].fixed) {\n                graph_1.getNodeByIndex(i).setLayout(nodes[i].p);\n              }\n\n              preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p;\n            }\n\n            for (var i = 0, l = edges.length; i < l; i++) {\n              var e = edges[i];\n              var edge = graph_1.getEdgeByIndex(i);\n              var p1 = e.n1.p;\n              var p2 = e.n2.p;\n              var points = edge.getLayout();\n              points = points ? points.slice() : [];\n              points[0] = points[0] || [];\n              points[1] = points[1] || [];\n              copy(points[0], p1);\n              copy(points[1], p2);\n\n              if (+e.curveness) {\n                points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];\n              }\n\n              edge.setLayout(points);\n            }\n          });\n          graphSeries.forceLayout = forceInstance;\n          graphSeries.preservedPoints = preservedPoints_1;\n          forceInstance.step();\n        } else {\n          graphSeries.forceLayout = null;\n        }\n      });\n    }\n\n    function getViewRect$2(seriesModel, api, aspect) {\n      var option = extend(seriesModel.getBoxLayoutParams(), {\n        aspect: aspect\n      });\n      return getLayoutRect(option, {\n        width: api.getWidth(),\n        height: api.getHeight()\n      });\n    }\n\n    function createViewCoordSys(ecModel, api) {\n      var viewList = [];\n      ecModel.eachSeriesByType('graph', function (seriesModel) {\n        var coordSysType = seriesModel.get('coordinateSystem');\n\n        if (!coordSysType || coordSysType === 'view') {\n          var data_1 = seriesModel.getData();\n          var positions = data_1.mapArray(function (idx) {\n            var itemModel = data_1.getItemModel(idx);\n            return [+itemModel.get('x'), +itemModel.get('y')];\n          });\n          var min = [];\n          var max = [];\n          fromPoints(positions, min, max);\n\n          if (max[0] - min[0] === 0) {\n            max[0] += 1;\n            min[0] -= 1;\n          }\n\n          if (max[1] - min[1] === 0) {\n            max[1] += 1;\n            min[1] -= 1;\n          }\n\n          var aspect = (max[0] - min[0]) / (max[1] - min[1]);\n          var viewRect = getViewRect$2(seriesModel, api, aspect);\n\n          if (isNaN(aspect)) {\n            min = [viewRect.x, viewRect.y];\n            max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];\n          }\n\n          var bbWidth = max[0] - min[0];\n          var bbHeight = max[1] - min[1];\n          var viewWidth = viewRect.width;\n          var viewHeight = viewRect.height;\n          var viewCoordSys = seriesModel.coordinateSystem = new View();\n          viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');\n          viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);\n          viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);\n          viewCoordSys.setCenter(seriesModel.get('center'));\n          viewCoordSys.setZoom(seriesModel.get('zoom'));\n          viewList.push(viewCoordSys);\n        }\n      });\n      return viewList;\n    }\n\n    var straightLineProto = Line.prototype;\n    var bezierCurveProto = BezierCurve.prototype;\n\n    var StraightLineShape = function () {\n      function StraightLineShape() {\n        this.x1 = 0;\n        this.y1 = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this.percent = 1;\n      }\n\n      return StraightLineShape;\n    }();\n\n    var CurveShape = function (_super) {\n      __extends(CurveShape, _super);\n\n      function CurveShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      return CurveShape;\n    }(StraightLineShape);\n\n    function isStraightLine(shape) {\n      return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);\n    }\n\n    var ECLinePath = function (_super) {\n      __extends(ECLinePath, _super);\n\n      function ECLinePath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'ec-line';\n        return _this;\n      }\n\n      ECLinePath.prototype.getDefaultStyle = function () {\n        return {\n          stroke: '#000',\n          fill: null\n        };\n      };\n\n      ECLinePath.prototype.getDefaultShape = function () {\n        return new StraightLineShape();\n      };\n\n      ECLinePath.prototype.buildPath = function (ctx, shape) {\n        if (isStraightLine(shape)) {\n          straightLineProto.buildPath.call(this, ctx, shape);\n        } else {\n          bezierCurveProto.buildPath.call(this, ctx, shape);\n        }\n      };\n\n      ECLinePath.prototype.pointAt = function (t) {\n        if (isStraightLine(this.shape)) {\n          return straightLineProto.pointAt.call(this, t);\n        } else {\n          return bezierCurveProto.pointAt.call(this, t);\n        }\n      };\n\n      ECLinePath.prototype.tangentAt = function (t) {\n        var shape = this.shape;\n        var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);\n        return normalize(p, p);\n      };\n\n      return ECLinePath;\n    }(Path);\n\n    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];\n\n    function makeSymbolTypeKey(symbolCategory) {\n      return '_' + symbolCategory + 'Type';\n    }\n\n    function createSymbol$1(name, lineData, idx) {\n      var symbolType = lineData.getItemVisual(idx, name);\n\n      if (!symbolType || symbolType === 'none') {\n        return;\n      }\n\n      var symbolSize = lineData.getItemVisual(idx, name + 'Size');\n      var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');\n      var symbolSizeArr = isArray(symbolSize) ? symbolSize : [symbolSize, symbolSize];\n      var symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2, -symbolSizeArr[1] / 2, symbolSizeArr[0], symbolSizeArr[1]);\n      symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;\n      symbolPath.name = name;\n      return symbolPath;\n    }\n\n    function createLine(points) {\n      var line = new ECLinePath({\n        name: 'line',\n        subPixelOptimize: true\n      });\n      setLinePoints(line.shape, points);\n      return line;\n    }\n\n    function setLinePoints(targetShape, points) {\n      targetShape.x1 = points[0][0];\n      targetShape.y1 = points[0][1];\n      targetShape.x2 = points[1][0];\n      targetShape.y2 = points[1][1];\n      targetShape.percent = 1;\n      var cp1 = points[2];\n\n      if (cp1) {\n        targetShape.cpx1 = cp1[0];\n        targetShape.cpy1 = cp1[1];\n      } else {\n        targetShape.cpx1 = NaN;\n        targetShape.cpy1 = NaN;\n      }\n    }\n\n    var Line$1 = function (_super) {\n      __extends(Line, _super);\n\n      function Line(lineData, idx, seriesScope) {\n        var _this = _super.call(this) || this;\n\n        _this._createLine(lineData, idx, seriesScope);\n\n        return _this;\n      }\n\n      Line.prototype._createLine = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var linePoints = lineData.getItemLayout(idx);\n        var line = createLine(linePoints);\n        line.shape.percent = 0;\n        initProps(line, {\n          shape: {\n            percent: 1\n          }\n        }, seriesModel, idx);\n        this.add(line);\n        each(SYMBOL_CATEGORIES, function (symbolCategory) {\n          var symbol = createSymbol$1(symbolCategory, lineData, idx);\n          this.add(symbol);\n          this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n      };\n\n      Line.prototype.updateData = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var line = this.childOfName('line');\n        var linePoints = lineData.getItemLayout(idx);\n        var target = {\n          shape: {}\n        };\n        setLinePoints(target.shape, linePoints);\n        updateProps(line, target, seriesModel, idx);\n        each(SYMBOL_CATEGORIES, function (symbolCategory) {\n          var symbolType = lineData.getItemVisual(idx, symbolCategory);\n          var key = makeSymbolTypeKey(symbolCategory);\n\n          if (this[key] !== symbolType) {\n            this.remove(this.childOfName(symbolCategory));\n            var symbol = createSymbol$1(symbolCategory, lineData, idx);\n            this.add(symbol);\n          }\n\n          this[key] = symbolType;\n        }, this);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n      };\n\n      Line.prototype.getLinePath = function () {\n        return this.childAt(0);\n      };\n\n      Line.prototype._updateCommonStl = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var line = this.childOfName('line');\n        var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;\n        var blurLineStyle = seriesScope && seriesScope.blurLineStyle;\n        var selectLineStyle = seriesScope && seriesScope.selectLineStyle;\n        var labelStatesModels = seriesScope && seriesScope.labelStatesModels;\n\n        if (!seriesScope || lineData.hasItemOption) {\n          var itemModel = lineData.getItemModel(idx);\n          emphasisLineStyle = itemModel.getModel(['emphasis', 'lineStyle']).getLineStyle();\n          blurLineStyle = itemModel.getModel(['blur', 'lineStyle']).getLineStyle();\n          selectLineStyle = itemModel.getModel(['select', 'lineStyle']).getLineStyle();\n          labelStatesModels = getLabelStatesModels(itemModel);\n        }\n\n        var lineStyle = lineData.getItemVisual(idx, 'style');\n        var visualColor = lineStyle.stroke;\n        line.useStyle(lineStyle);\n        line.style.fill = null;\n        line.style.strokeNoScale = true;\n        line.ensureState('emphasis').style = emphasisLineStyle;\n        line.ensureState('blur').style = blurLineStyle;\n        line.ensureState('select').style = selectLineStyle;\n        each(SYMBOL_CATEGORIES, function (symbolCategory) {\n          var symbol = this.childOfName(symbolCategory);\n\n          if (symbol) {\n            symbol.setColor(visualColor);\n            symbol.style.opacity = lineStyle.opacity;\n\n            for (var i = 0; i < SPECIAL_STATES.length; i++) {\n              var stateName = SPECIAL_STATES[i];\n              var lineState = line.getState(stateName);\n\n              if (lineState) {\n                var lineStateStyle = lineState.style || {};\n                var state = symbol.ensureState(stateName);\n                var stateStyle = state.style || (state.style = {});\n\n                if (lineStateStyle.stroke != null) {\n                  stateStyle[symbol.__isEmptyBrush ? 'stroke' : 'fill'] = lineStateStyle.stroke;\n                }\n\n                if (lineStateStyle.opacity != null) {\n                  stateStyle.opacity = lineStateStyle.opacity;\n                }\n              }\n            }\n\n            symbol.markRedraw();\n          }\n        }, this);\n        var rawVal = seriesModel.getRawValue(idx);\n        setLabelStyle(this, labelStatesModels, {\n          labelDataIndex: idx,\n          labelFetcher: {\n            getFormattedLabel: function (dataIndex, stateName) {\n              return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);\n            }\n          },\n          inheritColor: visualColor || '#000',\n          defaultOpacity: lineStyle.opacity,\n          defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ''\n        });\n        var label = this.getTextContent();\n\n        if (label) {\n          var labelNormalModel = labelStatesModels.normal;\n          label.__align = label.style.align;\n          label.__verticalAlign = label.style.verticalAlign;\n          label.__position = labelNormalModel.get('position') || 'middle';\n          var distance = labelNormalModel.get('distance');\n\n          if (!isArray(distance)) {\n            distance = [distance, distance];\n          }\n\n          label.__labelDistance = distance;\n        }\n\n        this.setTextConfig({\n          position: null,\n          local: true,\n          inside: false\n        });\n        enableHoverEmphasis(this);\n      };\n\n      Line.prototype.highlight = function () {\n        enterEmphasis(this);\n      };\n\n      Line.prototype.downplay = function () {\n        leaveEmphasis(this);\n      };\n\n      Line.prototype.updateLayout = function (lineData, idx) {\n        this.setLinePoints(lineData.getItemLayout(idx));\n      };\n\n      Line.prototype.setLinePoints = function (points) {\n        var linePath = this.childOfName('line');\n        setLinePoints(linePath.shape, points);\n        linePath.dirty();\n      };\n\n      Line.prototype.beforeUpdate = function () {\n        var lineGroup = this;\n        var symbolFrom = lineGroup.childOfName('fromSymbol');\n        var symbolTo = lineGroup.childOfName('toSymbol');\n        var label = lineGroup.getTextContent();\n\n        if (!symbolFrom && !symbolTo && (!label || label.ignore)) {\n          return;\n        }\n\n        var invScale = 1;\n        var parentNode = this.parent;\n\n        while (parentNode) {\n          if (parentNode.scaleX) {\n            invScale /= parentNode.scaleX;\n          }\n\n          parentNode = parentNode.parent;\n        }\n\n        var line = lineGroup.childOfName('line');\n\n        if (!this.__dirty && !line.__dirty) {\n          return;\n        }\n\n        var percent = line.shape.percent;\n        var fromPos = line.pointAt(0);\n        var toPos = line.pointAt(percent);\n        var d = sub([], toPos, fromPos);\n        normalize(d, d);\n\n        function setSymbolRotation(symbol, percent) {\n          var specifiedRotation = symbol.__specifiedRotation;\n\n          if (specifiedRotation == null) {\n            var tangent = line.tangentAt(percent);\n            symbol.attr('rotation', (percent === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));\n          } else {\n            symbol.attr('rotation', specifiedRotation);\n          }\n        }\n\n        if (symbolFrom) {\n          symbolFrom.setPosition(fromPos);\n          setSymbolRotation(symbolFrom, 0);\n          symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;\n          symbolFrom.markRedraw();\n        }\n\n        if (symbolTo) {\n          symbolTo.setPosition(toPos);\n          setSymbolRotation(symbolTo, 1);\n          symbolTo.scaleX = symbolTo.scaleY = invScale * percent;\n          symbolTo.markRedraw();\n        }\n\n        if (label && !label.ignore) {\n          label.x = label.y = 0;\n          label.originX = label.originY = 0;\n          var textAlign = void 0;\n          var textVerticalAlign = void 0;\n          var distance = label.__labelDistance;\n          var distanceX = distance[0] * invScale;\n          var distanceY = distance[1] * invScale;\n          var halfPercent = percent / 2;\n          var tangent = line.tangentAt(halfPercent);\n          var n = [tangent[1], -tangent[0]];\n          var cp = line.pointAt(halfPercent);\n\n          if (n[1] > 0) {\n            n[0] = -n[0];\n            n[1] = -n[1];\n          }\n\n          var dir = tangent[0] < 0 ? -1 : 1;\n\n          if (label.__position !== 'start' && label.__position !== 'end') {\n            var rotation = -Math.atan2(tangent[1], tangent[0]);\n\n            if (toPos[0] < fromPos[0]) {\n              rotation = Math.PI + rotation;\n            }\n\n            label.rotation = rotation;\n          }\n\n          var dy = void 0;\n\n          switch (label.__position) {\n            case 'insideStartTop':\n            case 'insideMiddleTop':\n            case 'insideEndTop':\n            case 'middle':\n              dy = -distanceY;\n              textVerticalAlign = 'bottom';\n              break;\n\n            case 'insideStartBottom':\n            case 'insideMiddleBottom':\n            case 'insideEndBottom':\n              dy = distanceY;\n              textVerticalAlign = 'top';\n              break;\n\n            default:\n              dy = 0;\n              textVerticalAlign = 'middle';\n          }\n\n          switch (label.__position) {\n            case 'end':\n              label.x = d[0] * distanceX + toPos[0];\n              label.y = d[1] * distanceY + toPos[1];\n              textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';\n              textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';\n              break;\n\n            case 'start':\n              label.x = -d[0] * distanceX + fromPos[0];\n              label.y = -d[1] * distanceY + fromPos[1];\n              textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';\n              textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';\n              break;\n\n            case 'insideStartTop':\n            case 'insideStart':\n            case 'insideStartBottom':\n              label.x = distanceX * dir + fromPos[0];\n              label.y = fromPos[1] + dy;\n              textAlign = tangent[0] < 0 ? 'right' : 'left';\n              label.originX = -distanceX * dir;\n              label.originY = -dy;\n              break;\n\n            case 'insideMiddleTop':\n            case 'insideMiddle':\n            case 'insideMiddleBottom':\n            case 'middle':\n              label.x = cp[0];\n              label.y = cp[1] + dy;\n              textAlign = 'center';\n              label.originY = -dy;\n              break;\n\n            case 'insideEndTop':\n            case 'insideEnd':\n            case 'insideEndBottom':\n              label.x = -distanceX * dir + toPos[0];\n              label.y = toPos[1] + dy;\n              textAlign = tangent[0] >= 0 ? 'right' : 'left';\n              label.originX = distanceX * dir;\n              label.originY = -dy;\n              break;\n          }\n\n          label.scaleX = label.scaleY = invScale;\n          label.setStyle({\n            verticalAlign: label.__verticalAlign || textVerticalAlign,\n            align: label.__align || textAlign\n          });\n        }\n      };\n\n      return Line;\n    }(Group);\n\n    var LineDraw = function () {\n      function LineDraw(LineCtor) {\n        this.group = new Group();\n        this._LineCtor = LineCtor || Line$1;\n      }\n\n      LineDraw.prototype.isPersistent = function () {\n        return true;\n      };\n\n      LineDraw.prototype.updateData = function (lineData) {\n        var _this = this;\n\n        var lineDraw = this;\n        var group = lineDraw.group;\n        var oldLineData = lineDraw._lineData;\n        lineDraw._lineData = lineData;\n\n        if (!oldLineData) {\n          group.removeAll();\n        }\n\n        var seriesScope = makeSeriesScope$1(lineData);\n        lineData.diff(oldLineData).add(function (idx) {\n          _this._doAdd(lineData, idx, seriesScope);\n        }).update(function (newIdx, oldIdx) {\n          _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);\n        }).remove(function (idx) {\n          group.remove(oldLineData.getItemGraphicEl(idx));\n        }).execute();\n      };\n\n      LineDraw.prototype.updateLayout = function () {\n        var lineData = this._lineData;\n\n        if (!lineData) {\n          return;\n        }\n\n        lineData.eachItemGraphicEl(function (el, idx) {\n          el.updateLayout(lineData, idx);\n        }, this);\n      };\n\n      LineDraw.prototype.incrementalPrepareUpdate = function (lineData) {\n        this._seriesScope = makeSeriesScope$1(lineData);\n        this._lineData = null;\n        this.group.removeAll();\n      };\n\n      LineDraw.prototype.incrementalUpdate = function (taskParams, lineData) {\n        function updateIncrementalAndHover(el) {\n          if (!el.isGroup && !isEffectObject(el)) {\n            el.incremental = true;\n            el.ensureState('emphasis').hoverLayer = true;\n          }\n        }\n\n        for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n          var itemLayout = lineData.getItemLayout(idx);\n\n          if (lineNeedsDraw(itemLayout)) {\n            var el = new this._LineCtor(lineData, idx, this._seriesScope);\n            el.traverse(updateIncrementalAndHover);\n            this.group.add(el);\n            lineData.setItemGraphicEl(idx, el);\n          }\n        }\n      };\n\n      LineDraw.prototype.remove = function () {\n        this.group.removeAll();\n      };\n\n      LineDraw.prototype._doAdd = function (lineData, idx, seriesScope) {\n        var itemLayout = lineData.getItemLayout(idx);\n\n        if (!lineNeedsDraw(itemLayout)) {\n          return;\n        }\n\n        var el = new this._LineCtor(lineData, idx, seriesScope);\n        lineData.setItemGraphicEl(idx, el);\n        this.group.add(el);\n      };\n\n      LineDraw.prototype._doUpdate = function (oldLineData, newLineData, oldIdx, newIdx, seriesScope) {\n        var itemEl = oldLineData.getItemGraphicEl(oldIdx);\n\n        if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {\n          this.group.remove(itemEl);\n          return;\n        }\n\n        if (!itemEl) {\n          itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);\n        } else {\n          itemEl.updateData(newLineData, newIdx, seriesScope);\n        }\n\n        newLineData.setItemGraphicEl(newIdx, itemEl);\n        this.group.add(itemEl);\n      };\n\n      return LineDraw;\n    }();\n\n    function isEffectObject(el) {\n      return el.animators && el.animators.length > 0;\n    }\n\n    function makeSeriesScope$1(lineData) {\n      var hostModel = lineData.hostModel;\n      return {\n        lineStyle: hostModel.getModel('lineStyle').getLineStyle(),\n        emphasisLineStyle: hostModel.getModel(['emphasis', 'lineStyle']).getLineStyle(),\n        blurLineStyle: hostModel.getModel(['blur', 'lineStyle']).getLineStyle(),\n        selectLineStyle: hostModel.getModel(['select', 'lineStyle']).getLineStyle(),\n        labelStatesModels: getLabelStatesModels(hostModel)\n      };\n    }\n\n    function isPointNaN(pt) {\n      return isNaN(pt[0]) || isNaN(pt[1]);\n    }\n\n    function lineNeedsDraw(pts) {\n      return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);\n    }\n\n    var v1 = [];\n    var v2 = [];\n    var v3 = [];\n    var quadraticAt$1 = quadraticAt;\n    var v2DistSquare = distSquare;\n    var mathAbs$2 = Math.abs;\n\n    function intersectCurveCircle(curvePoints, center, radius) {\n      var p0 = curvePoints[0];\n      var p1 = curvePoints[1];\n      var p2 = curvePoints[2];\n      var d = Infinity;\n      var t;\n      var radiusSquare = radius * radius;\n      var interval = 0.1;\n\n      for (var _t = 0.1; _t <= 0.9; _t += 0.1) {\n        v1[0] = quadraticAt$1(p0[0], p1[0], p2[0], _t);\n        v1[1] = quadraticAt$1(p0[1], p1[1], p2[1], _t);\n        var diff = mathAbs$2(v2DistSquare(v1, center) - radiusSquare);\n\n        if (diff < d) {\n          d = diff;\n          t = _t;\n        }\n      }\n\n      for (var i = 0; i < 32; i++) {\n        var next = t + interval;\n        v2[0] = quadraticAt$1(p0[0], p1[0], p2[0], t);\n        v2[1] = quadraticAt$1(p0[1], p1[1], p2[1], t);\n        v3[0] = quadraticAt$1(p0[0], p1[0], p2[0], next);\n        v3[1] = quadraticAt$1(p0[1], p1[1], p2[1], next);\n        var diff = v2DistSquare(v2, center) - radiusSquare;\n\n        if (mathAbs$2(diff) < 1e-2) {\n          break;\n        }\n\n        var nextDiff = v2DistSquare(v3, center) - radiusSquare;\n        interval /= 2;\n\n        if (diff < 0) {\n          if (nextDiff >= 0) {\n            t = t + interval;\n          } else {\n            t = t - interval;\n          }\n        } else {\n          if (nextDiff >= 0) {\n            t = t - interval;\n          } else {\n            t = t + interval;\n          }\n        }\n      }\n\n      return t;\n    }\n\n    function adjustEdge(graph, scale) {\n      var tmp0 = [];\n      var quadraticSubdivide$1 = quadraticSubdivide;\n      var pts = [[], [], []];\n      var pts2 = [[], []];\n      var v = [];\n      scale /= 2;\n      graph.eachEdge(function (edge, idx) {\n        var linePoints = edge.getLayout();\n        var fromSymbol = edge.getVisual('fromSymbol');\n        var toSymbol = edge.getVisual('toSymbol');\n\n        if (!linePoints.__original) {\n          linePoints.__original = [clone$1(linePoints[0]), clone$1(linePoints[1])];\n\n          if (linePoints[2]) {\n            linePoints.__original.push(clone$1(linePoints[2]));\n          }\n        }\n\n        var originalPoints = linePoints.__original;\n\n        if (linePoints[2] != null) {\n          copy(pts[0], originalPoints[0]);\n          copy(pts[1], originalPoints[2]);\n          copy(pts[2], originalPoints[1]);\n\n          if (fromSymbol && fromSymbol !== 'none') {\n            var symbolSize = getSymbolSize(edge.node1);\n            var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);\n            quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n            pts[0][0] = tmp0[3];\n            pts[1][0] = tmp0[4];\n            quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n            pts[0][1] = tmp0[3];\n            pts[1][1] = tmp0[4];\n          }\n\n          if (toSymbol && toSymbol !== 'none') {\n            var symbolSize = getSymbolSize(edge.node2);\n            var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);\n            quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n            pts[1][0] = tmp0[1];\n            pts[2][0] = tmp0[2];\n            quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n            pts[1][1] = tmp0[1];\n            pts[2][1] = tmp0[2];\n          }\n\n          copy(linePoints[0], pts[0]);\n          copy(linePoints[1], pts[2]);\n          copy(linePoints[2], pts[1]);\n        } else {\n          copy(pts2[0], originalPoints[0]);\n          copy(pts2[1], originalPoints[1]);\n          sub(v, pts2[1], pts2[0]);\n          normalize(v, v);\n\n          if (fromSymbol && fromSymbol !== 'none') {\n            var symbolSize = getSymbolSize(edge.node1);\n            scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);\n          }\n\n          if (toSymbol && toSymbol !== 'none') {\n            var symbolSize = getSymbolSize(edge.node2);\n            scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);\n          }\n\n          copy(linePoints[0], pts2[0]);\n          copy(linePoints[1], pts2[1]);\n        }\n      });\n    }\n\n    function isViewCoordSys(coordSys) {\n      return coordSys.type === 'view';\n    }\n\n    var GraphView = function (_super) {\n      __extends(GraphView, _super);\n\n      function GraphView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GraphView.type;\n        return _this;\n      }\n\n      GraphView.prototype.init = function (ecModel, api) {\n        var symbolDraw = new SymbolDraw();\n        var lineDraw = new LineDraw();\n        var group = this.group;\n        this._controller = new RoamController(api.getZr());\n        this._controllerHost = {\n          target: group\n        };\n        group.add(symbolDraw.group);\n        group.add(lineDraw.group);\n        this._symbolDraw = symbolDraw;\n        this._lineDraw = lineDraw;\n        this._firstRender = true;\n      };\n\n      GraphView.prototype.render = function (seriesModel, ecModel, api) {\n        var _this = this;\n\n        var coordSys = seriesModel.coordinateSystem;\n        this._model = seriesModel;\n        var symbolDraw = this._symbolDraw;\n        var lineDraw = this._lineDraw;\n        var group = this.group;\n\n        if (isViewCoordSys(coordSys)) {\n          var groupNewProp = {\n            x: coordSys.x,\n            y: coordSys.y,\n            scaleX: coordSys.scaleX,\n            scaleY: coordSys.scaleY\n          };\n\n          if (this._firstRender) {\n            group.attr(groupNewProp);\n          } else {\n            updateProps(group, groupNewProp, seriesModel);\n          }\n        }\n\n        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n        var data = seriesModel.getData();\n        symbolDraw.updateData(data);\n        var edgeData = seriesModel.getEdgeData();\n        lineDraw.updateData(edgeData);\n\n        this._updateNodeAndLinkScale();\n\n        this._updateController(seriesModel, ecModel, api);\n\n        clearTimeout(this._layoutTimeout);\n        var forceLayout = seriesModel.forceLayout;\n        var layoutAnimation = seriesModel.get(['force', 'layoutAnimation']);\n\n        if (forceLayout) {\n          this._startForceLayoutIteration(forceLayout, layoutAnimation);\n        }\n\n        data.graph.eachNode(function (node) {\n          var idx = node.dataIndex;\n          var el = node.getGraphicEl();\n          var itemModel = node.getModel();\n          el.off('drag').off('dragend');\n          var draggable = itemModel.get('draggable');\n\n          if (draggable) {\n            el.on('drag', function () {\n              if (forceLayout) {\n                forceLayout.warmUp();\n                !_this._layouting && _this._startForceLayoutIteration(forceLayout, layoutAnimation);\n                forceLayout.setFixed(idx);\n                data.setItemLayout(idx, [el.x, el.y]);\n              }\n            }).on('dragend', function () {\n              if (forceLayout) {\n                forceLayout.setUnfixed(idx);\n              }\n            });\n          }\n\n          el.setDraggable(draggable && !!forceLayout);\n          var focus = itemModel.get(['emphasis', 'focus']);\n\n          if (focus === 'adjacency') {\n            getECData(el).focus = node.getAdjacentDataIndices();\n          }\n        });\n        data.graph.eachEdge(function (edge) {\n          var el = edge.getGraphicEl();\n          var focus = edge.getModel().get(['emphasis', 'focus']);\n\n          if (focus === 'adjacency') {\n            getECData(el).focus = {\n              edge: [edge.dataIndex],\n              node: [edge.node1.dataIndex, edge.node2.dataIndex]\n            };\n          }\n        });\n        var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get(['circular', 'rotateLabel']);\n        var cx = data.getLayout('cx');\n        var cy = data.getLayout('cy');\n        data.eachItemGraphicEl(function (el, idx) {\n          var itemModel = data.getItemModel(idx);\n          var labelRotate = itemModel.get(['label', 'rotate']) || 0;\n          var symbolPath = el.getSymbolPath();\n\n          if (circularRotateLabel) {\n            var pos = data.getItemLayout(idx);\n            var rad = Math.atan2(pos[1] - cy, pos[0] - cx);\n\n            if (rad < 0) {\n              rad = Math.PI * 2 + rad;\n            }\n\n            var isLeft = pos[0] < cx;\n\n            if (isLeft) {\n              rad = rad - Math.PI;\n            }\n\n            var textPosition = isLeft ? 'left' : 'right';\n            symbolPath.setTextConfig({\n              rotation: -rad,\n              position: textPosition,\n              origin: 'center'\n            });\n            var emphasisState = symbolPath.ensureState('emphasis');\n            extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {\n              position: textPosition\n            });\n          } else {\n            symbolPath.setTextConfig({\n              rotation: labelRotate *= Math.PI / 180\n            });\n          }\n        });\n        this._firstRender = false;\n      };\n\n      GraphView.prototype.dispose = function () {\n        this._controller && this._controller.dispose();\n        this._controllerHost = null;\n      };\n\n      GraphView.prototype._startForceLayoutIteration = function (forceLayout, layoutAnimation) {\n        var self = this;\n\n        (function step() {\n          forceLayout.step(function (stopped) {\n            self.updateLayout(self._model);\n            (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());\n          });\n        })();\n      };\n\n      GraphView.prototype._updateController = function (seriesModel, ecModel, api) {\n        var _this = this;\n\n        var controller = this._controller;\n        var controllerHost = this._controllerHost;\n        var group = this.group;\n        controller.setPointerChecker(function (e, x, y) {\n          var rect = group.getBoundingRect();\n          rect.applyTransform(group.transform);\n          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);\n        });\n\n        if (!isViewCoordSys(seriesModel.coordinateSystem)) {\n          controller.disable();\n          return;\n        }\n\n        controller.enable(seriesModel.get('roam'));\n        controllerHost.zoomLimit = seriesModel.get('scaleLimit');\n        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();\n        controller.off('pan').off('zoom').on('pan', function (e) {\n          updateViewOnPan(controllerHost, e.dx, e.dy);\n          api.dispatchAction({\n            seriesId: seriesModel.id,\n            type: 'graphRoam',\n            dx: e.dx,\n            dy: e.dy\n          });\n        }).on('zoom', function (e) {\n          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);\n          api.dispatchAction({\n            seriesId: seriesModel.id,\n            type: 'graphRoam',\n            zoom: e.scale,\n            originX: e.originX,\n            originY: e.originY\n          });\n\n          _this._updateNodeAndLinkScale();\n\n          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n\n          _this._lineDraw.updateLayout();\n\n          api.updateLabelLayout();\n        });\n      };\n\n      GraphView.prototype._updateNodeAndLinkScale = function () {\n        var seriesModel = this._model;\n        var data = seriesModel.getData();\n        var nodeScale = getNodeGlobalScale(seriesModel);\n        data.eachItemGraphicEl(function (el, idx) {\n          el.setSymbolScale(nodeScale);\n        });\n      };\n\n      GraphView.prototype.updateLayout = function (seriesModel) {\n        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));\n\n        this._symbolDraw.updateLayout();\n\n        this._lineDraw.updateLayout();\n      };\n\n      GraphView.prototype.remove = function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove();\n        this._lineDraw && this._lineDraw.remove();\n      };\n\n      GraphView.type = 'graph';\n      return GraphView;\n    }(ChartView);\n\n    function generateNodeKey(id) {\n      return '_EC_' + id;\n    }\n\n    var Graph = function () {\n      function Graph(directed) {\n        this.type = 'graph';\n        this.nodes = [];\n        this.edges = [];\n        this._nodesMap = {};\n        this._edgesMap = {};\n        this._directed = directed || false;\n      }\n\n      Graph.prototype.isDirected = function () {\n        return this._directed;\n      };\n\n      Graph.prototype.addNode = function (id, dataIndex) {\n        id = id == null ? '' + dataIndex : '' + id;\n        var nodesMap = this._nodesMap;\n\n        if (nodesMap[generateNodeKey(id)]) {\n          if (\"development\" !== 'production') {\n            console.error('Graph nodes have duplicate name or id');\n          }\n\n          return;\n        }\n\n        var node = new GraphNode(id, dataIndex);\n        node.hostGraph = this;\n        this.nodes.push(node);\n        nodesMap[generateNodeKey(id)] = node;\n        return node;\n      };\n\n      Graph.prototype.getNodeByIndex = function (dataIndex) {\n        var rawIdx = this.data.getRawIndex(dataIndex);\n        return this.nodes[rawIdx];\n      };\n\n      Graph.prototype.getNodeById = function (id) {\n        return this._nodesMap[generateNodeKey(id)];\n      };\n\n      Graph.prototype.addEdge = function (n1, n2, dataIndex) {\n        var nodesMap = this._nodesMap;\n        var edgesMap = this._edgesMap;\n\n        if (typeof n1 === 'number') {\n          n1 = this.nodes[n1];\n        }\n\n        if (typeof n2 === 'number') {\n          n2 = this.nodes[n2];\n        }\n\n        if (!(n1 instanceof GraphNode)) {\n          n1 = nodesMap[generateNodeKey(n1)];\n        }\n\n        if (!(n2 instanceof GraphNode)) {\n          n2 = nodesMap[generateNodeKey(n2)];\n        }\n\n        if (!n1 || !n2) {\n          return;\n        }\n\n        var key = n1.id + '-' + n2.id;\n        var edge = new GraphEdge(n1, n2, dataIndex);\n        edge.hostGraph = this;\n\n        if (this._directed) {\n          n1.outEdges.push(edge);\n          n2.inEdges.push(edge);\n        }\n\n        n1.edges.push(edge);\n\n        if (n1 !== n2) {\n          n2.edges.push(edge);\n        }\n\n        this.edges.push(edge);\n        edgesMap[key] = edge;\n        return edge;\n      };\n\n      Graph.prototype.getEdgeByIndex = function (dataIndex) {\n        var rawIdx = this.edgeData.getRawIndex(dataIndex);\n        return this.edges[rawIdx];\n      };\n\n      Graph.prototype.getEdge = function (n1, n2) {\n        if (n1 instanceof GraphNode) {\n          n1 = n1.id;\n        }\n\n        if (n2 instanceof GraphNode) {\n          n2 = n2.id;\n        }\n\n        var edgesMap = this._edgesMap;\n\n        if (this._directed) {\n          return edgesMap[n1 + '-' + n2];\n        } else {\n          return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];\n        }\n      };\n\n      Graph.prototype.eachNode = function (cb, context) {\n        var nodes = this.nodes;\n        var len = nodes.length;\n\n        for (var i = 0; i < len; i++) {\n          if (nodes[i].dataIndex >= 0) {\n            cb.call(context, nodes[i], i);\n          }\n        }\n      };\n\n      Graph.prototype.eachEdge = function (cb, context) {\n        var edges = this.edges;\n        var len = edges.length;\n\n        for (var i = 0; i < len; i++) {\n          if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {\n            cb.call(context, edges[i], i);\n          }\n        }\n      };\n\n      Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {\n        if (!(startNode instanceof GraphNode)) {\n          startNode = this._nodesMap[generateNodeKey(startNode)];\n        }\n\n        if (!startNode) {\n          return;\n        }\n\n        var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';\n\n        for (var i = 0; i < this.nodes.length; i++) {\n          this.nodes[i].__visited = false;\n        }\n\n        if (cb.call(context, startNode, null)) {\n          return;\n        }\n\n        var queue = [startNode];\n\n        while (queue.length) {\n          var currentNode = queue.shift();\n          var edges = currentNode[edgeType];\n\n          for (var i = 0; i < edges.length; i++) {\n            var e = edges[i];\n            var otherNode = e.node1 === currentNode ? e.node2 : e.node1;\n\n            if (!otherNode.__visited) {\n              if (cb.call(context, otherNode, currentNode)) {\n                return;\n              }\n\n              queue.push(otherNode);\n              otherNode.__visited = true;\n            }\n          }\n        }\n      };\n\n      Graph.prototype.update = function () {\n        var data = this.data;\n        var edgeData = this.edgeData;\n        var nodes = this.nodes;\n        var edges = this.edges;\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n          nodes[i].dataIndex = -1;\n        }\n\n        for (var i = 0, len = data.count(); i < len; i++) {\n          nodes[data.getRawIndex(i)].dataIndex = i;\n        }\n\n        edgeData.filterSelf(function (idx) {\n          var edge = edges[edgeData.getRawIndex(idx)];\n          return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;\n        });\n\n        for (var i = 0, len = edges.length; i < len; i++) {\n          edges[i].dataIndex = -1;\n        }\n\n        for (var i = 0, len = edgeData.count(); i < len; i++) {\n          edges[edgeData.getRawIndex(i)].dataIndex = i;\n        }\n      };\n\n      Graph.prototype.clone = function () {\n        var graph = new Graph(this._directed);\n        var nodes = this.nodes;\n        var edges = this.edges;\n\n        for (var i = 0; i < nodes.length; i++) {\n          graph.addNode(nodes[i].id, nodes[i].dataIndex);\n        }\n\n        for (var i = 0; i < edges.length; i++) {\n          var e = edges[i];\n          graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);\n        }\n\n        return graph;\n      };\n      return Graph;\n    }();\n\n    var GraphNode = function () {\n      function GraphNode(id, dataIndex) {\n        this.inEdges = [];\n        this.outEdges = [];\n        this.edges = [];\n        this.dataIndex = -1;\n        this.id = id == null ? '' : id;\n        this.dataIndex = dataIndex == null ? -1 : dataIndex;\n      }\n\n      GraphNode.prototype.degree = function () {\n        return this.edges.length;\n      };\n\n      GraphNode.prototype.inDegree = function () {\n        return this.inEdges.length;\n      };\n\n      GraphNode.prototype.outDegree = function () {\n        return this.outEdges.length;\n      };\n\n      GraphNode.prototype.getModel = function (path) {\n        if (this.dataIndex < 0) {\n          return;\n        }\n\n        var graph = this.hostGraph;\n        var itemModel = graph.data.getItemModel(this.dataIndex);\n        return itemModel.getModel(path);\n      };\n\n      GraphNode.prototype.getAdjacentDataIndices = function () {\n        var dataIndices = {\n          edge: [],\n          node: []\n        };\n\n        for (var i = 0; i < this.edges.length; i++) {\n          var adjacentEdge = this.edges[i];\n\n          if (adjacentEdge.dataIndex < 0) {\n            continue;\n          }\n\n          dataIndices.edge.push(adjacentEdge.dataIndex);\n          dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);\n        }\n\n        return dataIndices;\n      };\n\n      return GraphNode;\n    }();\n\n    var GraphEdge = function () {\n      function GraphEdge(n1, n2, dataIndex) {\n        this.dataIndex = -1;\n        this.node1 = n1;\n        this.node2 = n2;\n        this.dataIndex = dataIndex == null ? -1 : dataIndex;\n      }\n\n      GraphEdge.prototype.getModel = function (path) {\n        if (this.dataIndex < 0) {\n          return;\n        }\n\n        var graph = this.hostGraph;\n        var itemModel = graph.edgeData.getItemModel(this.dataIndex);\n        return itemModel.getModel(path);\n      };\n\n      GraphEdge.prototype.getAdjacentDataIndices = function () {\n        return {\n          edge: [this.dataIndex],\n          node: [this.node1.dataIndex, this.node2.dataIndex]\n        };\n      };\n\n      return GraphEdge;\n    }();\n\n    function createGraphDataProxyMixin(hostName, dataName) {\n      return {\n        getValue: function (dimension) {\n          var data = this[hostName][dataName];\n          return data.get(data.getDimension(dimension || 'value'), this.dataIndex);\n        },\n        setVisual: function (key, value) {\n          this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);\n        },\n        getVisual: function (key) {\n          return this[hostName][dataName].getItemVisual(this.dataIndex, key);\n        },\n        setLayout: function (layout, merge) {\n          this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);\n        },\n        getLayout: function () {\n          return this[hostName][dataName].getItemLayout(this.dataIndex);\n        },\n        getGraphicEl: function () {\n          return this[hostName][dataName].getItemGraphicEl(this.dataIndex);\n        },\n        getRawIndex: function () {\n          return this[hostName][dataName].getRawIndex(this.dataIndex);\n        }\n      };\n    }\n    mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'));\n    mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'));\n\n    function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {\n      var graph = new Graph(directed);\n\n      for (var i = 0; i < nodes.length; i++) {\n        graph.addNode(retrieve(nodes[i].id, nodes[i].name, i), i);\n      }\n\n      var linkNameList = [];\n      var validEdges = [];\n      var linkCount = 0;\n\n      for (var i = 0; i < edges.length; i++) {\n        var link = edges[i];\n        var source = link.source;\n        var target = link.target;\n\n        if (graph.addEdge(source, target, linkCount)) {\n          validEdges.push(link);\n          linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + ' > ' + target));\n          linkCount++;\n        }\n      }\n\n      var coordSys = seriesModel.get('coordinateSystem');\n      var nodeData;\n\n      if (coordSys === 'cartesian2d' || coordSys === 'polar') {\n        nodeData = createListFromArray(nodes, seriesModel);\n      } else {\n        var coordSysCtor = CoordinateSystemManager.get(coordSys);\n        var coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];\n\n        if (indexOf(coordDimensions, 'value') < 0) {\n          coordDimensions.concat(['value']);\n        }\n\n        var dimensionNames = createDimensions(nodes, {\n          coordDimensions: coordDimensions\n        });\n        nodeData = new List(dimensionNames, seriesModel);\n        nodeData.initData(nodes);\n      }\n\n      var edgeData = new List(['value'], seriesModel);\n      edgeData.initData(validEdges, linkNameList);\n      beforeLink && beforeLink(nodeData, edgeData);\n      linkList({\n        mainData: nodeData,\n        struct: graph,\n        structAttr: 'graph',\n        datas: {\n          node: nodeData,\n          edge: edgeData\n        },\n        datasAttr: {\n          node: 'data',\n          edge: 'edgeData'\n        }\n      });\n      graph.update();\n      return graph;\n    }\n\n    var GraphSeriesModel = function (_super) {\n      __extends(GraphSeriesModel, _super);\n\n      function GraphSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GraphSeriesModel.type;\n        _this.hasSymbolVisual = true;\n        return _this;\n      }\n\n      GraphSeriesModel.prototype.init = function (option) {\n        _super.prototype.init.apply(this, arguments);\n\n        var self = this;\n\n        function getCategoriesData() {\n          return self._categoriesData;\n        }\n\n        this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData);\n        this.fillDataTextStyle(option.edges || option.links);\n\n        this._updateCategoriesData();\n      };\n\n      GraphSeriesModel.prototype.mergeOption = function (option) {\n        _super.prototype.mergeOption.apply(this, arguments);\n\n        this.fillDataTextStyle(option.edges || option.links);\n\n        this._updateCategoriesData();\n      };\n\n      GraphSeriesModel.prototype.mergeDefaultAndTheme = function (option) {\n        _super.prototype.mergeDefaultAndTheme.apply(this, arguments);\n\n        defaultEmphasis(option, 'edgeLabel', ['show']);\n      };\n\n      GraphSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        var edges = option.edges || option.links || [];\n        var nodes = option.data || option.nodes || [];\n        var self = this;\n\n        if (nodes && edges) {\n          initCurvenessList(this);\n          var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);\n          each(graph.edges, function (edge) {\n            createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);\n          }, this);\n          return graph.data;\n        }\n\n        function beforeLink(nodeData, edgeData) {\n          nodeData.wrapMethod('getItemModel', function (model) {\n            var categoriesModels = self._categoriesModels;\n            var categoryIdx = model.getShallow('category');\n            var categoryModel = categoriesModels[categoryIdx];\n\n            if (categoryModel) {\n              categoryModel.parentModel = model.parentModel;\n              model.parentModel = categoryModel;\n            }\n\n            return model;\n          });\n          var oldGetModel = Model.prototype.getModel;\n\n          function newGetModel(path, parentModel) {\n            var model = oldGetModel.call(this, path, parentModel);\n            model.resolveParentPath = resolveParentPath;\n            return model;\n          }\n\n          edgeData.wrapMethod('getItemModel', function (model) {\n            model.resolveParentPath = resolveParentPath;\n            model.getModel = newGetModel;\n            return model;\n          });\n\n          function resolveParentPath(pathArr) {\n            if (pathArr && (pathArr[0] === 'label' || pathArr[1] === 'label')) {\n              var newPathArr = pathArr.slice();\n\n              if (pathArr[0] === 'label') {\n                newPathArr[0] = 'edgeLabel';\n              } else if (pathArr[1] === 'label') {\n                newPathArr[1] = 'edgeLabel';\n              }\n\n              return newPathArr;\n            }\n\n            return pathArr;\n          }\n        }\n      };\n\n      GraphSeriesModel.prototype.getGraph = function () {\n        return this.getData().graph;\n      };\n\n      GraphSeriesModel.prototype.getEdgeData = function () {\n        return this.getGraph().edgeData;\n      };\n\n      GraphSeriesModel.prototype.getCategoriesData = function () {\n        return this._categoriesData;\n      };\n\n      GraphSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        if (dataType === 'edge') {\n          var nodeData = this.getData();\n          var params = this.getDataParams(dataIndex, dataType);\n          var edge = nodeData.graph.getEdgeByIndex(dataIndex);\n          var sourceName = nodeData.getName(edge.node1.dataIndex);\n          var targetName = nodeData.getName(edge.node2.dataIndex);\n          var nameArr = [];\n          sourceName != null && nameArr.push(sourceName);\n          targetName != null && nameArr.push(targetName);\n          return createTooltipMarkup('nameValue', {\n            name: nameArr.join(' > '),\n            value: params.value,\n            noValue: params.value == null\n          });\n        }\n\n        var nodeMarkup = defaultSeriesFormatTooltip({\n          series: this,\n          dataIndex: dataIndex,\n          multipleSeries: multipleSeries\n        });\n        return nodeMarkup;\n      };\n\n      GraphSeriesModel.prototype._updateCategoriesData = function () {\n        var categories = map(this.option.categories || [], function (category) {\n          return category.value != null ? category : extend({\n            value: 0\n          }, category);\n        });\n        var categoriesData = new List(['value'], this);\n        categoriesData.initData(categories);\n        this._categoriesData = categoriesData;\n        this._categoriesModels = categoriesData.mapArray(function (idx) {\n          return categoriesData.getItemModel(idx);\n        });\n      };\n\n      GraphSeriesModel.prototype.setZoom = function (zoom) {\n        this.option.zoom = zoom;\n      };\n\n      GraphSeriesModel.prototype.setCenter = function (center) {\n        this.option.center = center;\n      };\n\n      GraphSeriesModel.prototype.isAnimationEnabled = function () {\n        return _super.prototype.isAnimationEnabled.call(this) && !(this.get('layout') === 'force' && this.get(['force', 'layoutAnimation']));\n      };\n\n      GraphSeriesModel.type = 'series.graph';\n      GraphSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n      GraphSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'view',\n        legendHoverLink: true,\n        layout: null,\n        focusNodeAdjacency: false,\n        circular: {\n          rotateLabel: false\n        },\n        force: {\n          initLayout: null,\n          repulsion: [0, 50],\n          gravity: 0.1,\n          friction: 0.6,\n          edgeLength: 30,\n          layoutAnimation: true\n        },\n        left: 'center',\n        top: 'center',\n        symbol: 'circle',\n        symbolSize: 10,\n        edgeSymbol: ['none', 'none'],\n        edgeSymbolSize: 10,\n        edgeLabel: {\n          position: 'middle',\n          distance: 5\n        },\n        draggable: false,\n        roam: false,\n        center: null,\n        zoom: 1,\n        nodeScaleRatio: 0.6,\n        label: {\n          show: false,\n          formatter: '{b}'\n        },\n        itemStyle: {},\n        lineStyle: {\n          color: '#aaa',\n          width: 1,\n          opacity: 0.5\n        },\n        emphasis: {\n          scale: true,\n          label: {\n            show: true\n          }\n        },\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        }\n      };\n      return GraphSeriesModel;\n    }(SeriesModel);\n\n    var actionInfo = {\n      type: 'graphRoam',\n      event: 'graphRoam',\n      update: 'none'\n    };\n    function install$c(registers) {\n      registers.registerChartView(GraphView);\n      registers.registerSeriesModel(GraphSeriesModel);\n      registers.registerProcessor(categoryFilter);\n      registers.registerVisual(categoryVisual);\n      registers.registerVisual(graphEdgeVisual);\n      registers.registerLayout(graphSimpleLayout);\n      registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);\n      registers.registerLayout(graphForceLayout);\n      registers.registerCoordinateSystem('graphView', {\n        dimensions: View.dimensions,\n        create: createViewCoordSys\n      });\n      registers.registerAction({\n        type: 'focusNodeAdjacency',\n        event: 'focusNodeAdjacency',\n        update: 'series:focusNodeAdjacency'\n      }, function () {});\n      registers.registerAction({\n        type: 'unfocusNodeAdjacency',\n        event: 'unfocusNodeAdjacency',\n        update: 'series:unfocusNodeAdjacency'\n      }, function () {});\n      registers.registerAction(actionInfo, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          query: payload\n        }, function (seriesModel) {\n          var coordSys = seriesModel.coordinateSystem;\n          var res = updateCenterAndZoom(coordSys, payload);\n          seriesModel.setCenter && seriesModel.setCenter(res.center);\n          seriesModel.setZoom && seriesModel.setZoom(res.zoom);\n        });\n      });\n    }\n\n    var PointerShape = function () {\n      function PointerShape() {\n        this.angle = 0;\n        this.width = 10;\n        this.r = 10;\n        this.x = 0;\n        this.y = 0;\n      }\n\n      return PointerShape;\n    }();\n\n    var PointerPath = function (_super) {\n      __extends(PointerPath, _super);\n\n      function PointerPath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'pointer';\n        return _this;\n      }\n\n      PointerPath.prototype.getDefaultShape = function () {\n        return new PointerShape();\n      };\n\n      PointerPath.prototype.buildPath = function (ctx, shape) {\n        var mathCos = Math.cos;\n        var mathSin = Math.sin;\n        var r = shape.r;\n        var width = shape.width;\n        var angle = shape.angle;\n        var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n        var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n        angle = shape.angle - Math.PI / 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);\n        ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);\n        ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);\n        ctx.lineTo(x, y);\n      };\n\n      return PointerPath;\n    }(Path);\n\n    function parsePosition(seriesModel, api) {\n      var center = seriesModel.get('center');\n      var width = api.getWidth();\n      var height = api.getHeight();\n      var size = Math.min(width, height);\n      var cx = parsePercent$1(center[0], api.getWidth());\n      var cy = parsePercent$1(center[1], api.getHeight());\n      var r = parsePercent$1(seriesModel.get('radius'), size / 2);\n      return {\n        cx: cx,\n        cy: cy,\n        r: r\n      };\n    }\n\n    function formatLabel(value, labelFormatter) {\n      var label = value == null ? '' : value + '';\n\n      if (labelFormatter) {\n        if (typeof labelFormatter === 'string') {\n          label = labelFormatter.replace('{value}', label);\n        } else if (typeof labelFormatter === 'function') {\n          label = labelFormatter(value);\n        }\n      }\n\n      return label;\n    }\n\n    var PI2$9 = Math.PI * 2;\n\n    var GaugeView = function (_super) {\n      __extends(GaugeView, _super);\n\n      function GaugeView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GaugeView.type;\n        return _this;\n      }\n\n      GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n        this.group.removeAll();\n        var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n        var posInfo = parsePosition(seriesModel, api);\n\n        this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n        this._data = seriesModel.getData();\n      };\n\n      GaugeView.prototype.dispose = function () {};\n\n      GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n        var group = this.group;\n        var clockwise = seriesModel.get('clockwise');\n        var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n        var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n        var axisLineModel = seriesModel.getModel('axisLine');\n        var roundCap = axisLineModel.get('roundCap');\n        var MainPath = roundCap ? SausagePath : Sector;\n        var showAxis = axisLineModel.get('show');\n        var lineStyleModel = axisLineModel.getModel('lineStyle');\n        var axisLineWidth = lineStyleModel.get('width');\n        var angleRangeSpan = !((endAngle - startAngle) % PI2$9) && endAngle !== startAngle ? PI2$9 : (endAngle - startAngle) % PI2$9;\n        var prevEndAngle = startAngle;\n\n        for (var i = 0; showAxis && i < colorList.length; i++) {\n          var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n          endAngle = startAngle + angleRangeSpan * percent;\n          var sector = new MainPath({\n            shape: {\n              startAngle: prevEndAngle,\n              endAngle: endAngle,\n              cx: posInfo.cx,\n              cy: posInfo.cy,\n              clockwise: clockwise,\n              r0: posInfo.r - axisLineWidth,\n              r: posInfo.r\n            },\n            silent: true\n          });\n          sector.setStyle({\n            fill: colorList[i][1]\n          });\n          sector.setStyle(lineStyleModel.getLineStyle(['color', 'width']));\n          group.add(sector);\n          prevEndAngle = endAngle;\n        }\n\n        var getColor = function (percent) {\n          if (percent <= 0) {\n            return colorList[0][1];\n          }\n\n          var i;\n\n          for (i = 0; i < colorList.length; i++) {\n            if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n              return colorList[i][1];\n            }\n          }\n\n          return colorList[i - 1][1];\n        };\n\n        if (!clockwise) {\n          var tmp = startAngle;\n          startAngle = endAngle;\n          endAngle = tmp;\n        }\n\n        this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n        this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n        this._renderAnchor(seriesModel, posInfo);\n\n        this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n      };\n\n      GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n        var group = this.group;\n        var cx = posInfo.cx;\n        var cy = posInfo.cy;\n        var r = posInfo.r;\n        var minVal = +seriesModel.get('min');\n        var maxVal = +seriesModel.get('max');\n        var splitLineModel = seriesModel.getModel('splitLine');\n        var tickModel = seriesModel.getModel('axisTick');\n        var labelModel = seriesModel.getModel('axisLabel');\n        var splitNumber = seriesModel.get('splitNumber');\n        var subSplitNumber = tickModel.get('splitNumber');\n        var splitLineLen = parsePercent$1(splitLineModel.get('length'), r);\n        var tickLen = parsePercent$1(tickModel.get('length'), r);\n        var angle = startAngle;\n        var step = (endAngle - startAngle) / splitNumber;\n        var subStep = step / subSplitNumber;\n        var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n        var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n        var splitLineDistance = splitLineModel.get('distance');\n        var unitX;\n        var unitY;\n\n        for (var i = 0; i <= splitNumber; i++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n\n          if (splitLineModel.get('show')) {\n            var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n            var splitLine = new Line({\n              shape: {\n                x1: unitX * (r - distance) + cx,\n                y1: unitY * (r - distance) + cy,\n                x2: unitX * (r - splitLineLen - distance) + cx,\n                y2: unitY * (r - splitLineLen - distance) + cy\n              },\n              style: splitLineStyle,\n              silent: true\n            });\n\n            if (splitLineStyle.stroke === 'auto') {\n              splitLine.setStyle({\n                stroke: getColor(i / splitNumber)\n              });\n            }\n\n            group.add(splitLine);\n          }\n\n          if (labelModel.get('show')) {\n            var distance = labelModel.get('distance') + splitLineDistance;\n            var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n            var autoColor = getColor(i / splitNumber);\n            group.add(new ZRText({\n              style: createTextStyle(labelModel, {\n                text: label,\n                x: unitX * (r - splitLineLen - distance) + cx,\n                y: unitY * (r - splitLineLen - distance) + cy,\n                verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n                align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n              }, {\n                inheritColor: autoColor\n              }),\n              silent: true\n            }));\n          }\n\n          if (tickModel.get('show') && i !== splitNumber) {\n            var distance = tickModel.get('distance');\n            distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n            for (var j = 0; j <= subSplitNumber; j++) {\n              unitX = Math.cos(angle);\n              unitY = Math.sin(angle);\n              var tickLine = new Line({\n                shape: {\n                  x1: unitX * (r - distance) + cx,\n                  y1: unitY * (r - distance) + cy,\n                  x2: unitX * (r - tickLen - distance) + cx,\n                  y2: unitY * (r - tickLen - distance) + cy\n                },\n                silent: true,\n                style: tickLineStyle\n              });\n\n              if (tickLineStyle.stroke === 'auto') {\n                tickLine.setStyle({\n                  stroke: getColor((i + j / subSplitNumber) / splitNumber)\n                });\n              }\n\n              group.add(tickLine);\n              angle += subStep;\n            }\n\n            angle -= subStep;\n          } else {\n            angle += step;\n          }\n        }\n      };\n\n      GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n        var group = this.group;\n        var oldData = this._data;\n        var oldProgressData = this._progressEls;\n        var progressList = [];\n        var showPointer = seriesModel.get(['pointer', 'show']);\n        var progressModel = seriesModel.getModel('progress');\n        var showProgress = progressModel.get('show');\n        var data = seriesModel.getData();\n        var valueDim = data.mapDimension('value');\n        var minVal = +seriesModel.get('min');\n        var maxVal = +seriesModel.get('max');\n        var valueExtent = [minVal, maxVal];\n        var angleExtent = [startAngle, endAngle];\n\n        function createPointer(idx, angle) {\n          var itemModel = data.getItemModel(idx);\n          var pointerModel = itemModel.getModel('pointer');\n          var pointerWidth = parsePercent$1(pointerModel.get('width'), posInfo.r);\n          var pointerLength = parsePercent$1(pointerModel.get('length'), posInfo.r);\n          var pointerStr = seriesModel.get(['pointer', 'icon']);\n          var pointerOffset = pointerModel.get('offsetCenter');\n          var pointerOffsetX = parsePercent$1(pointerOffset[0], posInfo.r);\n          var pointerOffsetY = parsePercent$1(pointerOffset[1], posInfo.r);\n          var pointerKeepAspect = pointerModel.get('keepAspect');\n          var pointer;\n\n          if (pointerStr) {\n            pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n          } else {\n            pointer = new PointerPath({\n              shape: {\n                angle: -Math.PI / 2,\n                width: pointerWidth,\n                r: pointerLength,\n                x: pointerOffsetX,\n                y: pointerOffsetY\n              }\n            });\n          }\n\n          pointer.rotation = -(angle + Math.PI / 2);\n          pointer.x = posInfo.cx;\n          pointer.y = posInfo.cy;\n          return pointer;\n        }\n\n        function createProgress(idx, endAngle) {\n          var roundCap = progressModel.get('roundCap');\n          var ProgressPath = roundCap ? SausagePath : Sector;\n          var isOverlap = progressModel.get('overlap');\n          var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n          var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n          var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n          var progress = new ProgressPath({\n            shape: {\n              startAngle: startAngle,\n              endAngle: endAngle,\n              cx: posInfo.cx,\n              cy: posInfo.cy,\n              clockwise: clockwise,\n              r0: r0,\n              r: r\n            }\n          });\n          isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n          return progress;\n        }\n\n        if (showProgress || showPointer) {\n          data.diff(oldData).add(function (idx) {\n            if (showPointer) {\n              var pointer = createPointer(idx, startAngle);\n              initProps(pointer, {\n                rotation: -(linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)\n              }, seriesModel);\n              group.add(pointer);\n              data.setItemGraphicEl(idx, pointer);\n            }\n\n            if (showProgress) {\n              var progress = createProgress(idx, startAngle);\n              var isClip = progressModel.get('clip');\n              initProps(progress, {\n                shape: {\n                  endAngle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, isClip)\n                }\n              }, seriesModel);\n              group.add(progress);\n              progressList[idx] = progress;\n            }\n          }).update(function (newIdx, oldIdx) {\n            if (showPointer) {\n              var previousPointer = oldData.getItemGraphicEl(oldIdx);\n              var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n              var pointer = createPointer(newIdx, previousRotate);\n              pointer.rotation = previousRotate;\n              updateProps(pointer, {\n                rotation: -(linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)\n              }, seriesModel);\n              group.add(pointer);\n              data.setItemGraphicEl(newIdx, pointer);\n            }\n\n            if (showProgress) {\n              var previousProgress = oldProgressData[oldIdx];\n              var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n              var progress = createProgress(newIdx, previousEndAngle);\n              var isClip = progressModel.get('clip');\n              updateProps(progress, {\n                shape: {\n                  endAngle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)\n                }\n              }, seriesModel);\n              group.add(progress);\n              progressList[newIdx] = progress;\n            }\n          }).execute();\n          data.each(function (idx) {\n            var itemModel = data.getItemModel(idx);\n            var emphasisModel = itemModel.getModel('emphasis');\n\n            if (showPointer) {\n              var pointer = data.getItemGraphicEl(idx);\n              pointer.useStyle(data.getItemVisual(idx, 'style'));\n              pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n              if (pointer.style.fill === 'auto') {\n                pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n              }\n\n              pointer.z2EmphasisLift = 0;\n              setStatesStylesFromModel(pointer, itemModel);\n              enableHoverEmphasis(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n            }\n\n            if (showProgress) {\n              var progress = progressList[idx];\n              progress.useStyle(data.getItemVisual(idx, 'style'));\n              progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n              progress.z2EmphasisLift = 0;\n              setStatesStylesFromModel(progress, itemModel);\n              enableHoverEmphasis(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n            }\n          });\n          this._progressEls = progressList;\n        }\n      };\n\n      GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n        var anchorModel = seriesModel.getModel('anchor');\n        var showAnchor = anchorModel.get('show');\n\n        if (showAnchor) {\n          var anchorSize = anchorModel.get('size');\n          var anchorType = anchorModel.get('icon');\n          var offsetCenter = anchorModel.get('offsetCenter');\n          var anchorKeepAspect = anchorModel.get('keepAspect');\n          var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent$1(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent$1(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n          anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n          anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n          this.group.add(anchor);\n        }\n      };\n\n      GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n        var _this = this;\n\n        var data = seriesModel.getData();\n        var valueDim = data.mapDimension('value');\n        var minVal = +seriesModel.get('min');\n        var maxVal = +seriesModel.get('max');\n        var contentGroup = new Group();\n        var newTitleEls = [];\n        var newDetailEls = [];\n        var hasAnimation = seriesModel.isAnimationEnabled();\n        data.diff(this._data).add(function (idx) {\n          newTitleEls[idx] = new ZRText({\n            silent: true\n          });\n          newDetailEls[idx] = new ZRText({\n            silent: true\n          });\n        }).update(function (idx, oldIdx) {\n          newTitleEls[idx] = _this._titleEls[oldIdx];\n          newDetailEls[idx] = _this._detailEls[oldIdx];\n        }).execute();\n        data.each(function (idx) {\n          var itemModel = data.getItemModel(idx);\n          var value = data.get(valueDim, idx);\n          var itemGroup = new Group();\n          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n          var itemTitleModel = itemModel.getModel('title');\n\n          if (itemTitleModel.get('show')) {\n            var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n            var titleX = posInfo.cx + parsePercent$1(titleOffsetCenter[0], posInfo.r);\n            var titleY = posInfo.cy + parsePercent$1(titleOffsetCenter[1], posInfo.r);\n            var labelEl = newTitleEls[idx];\n            labelEl.attr({\n              style: createTextStyle(itemTitleModel, {\n                x: titleX,\n                y: titleY,\n                text: data.getName(idx),\n                align: 'center',\n                verticalAlign: 'middle'\n              }, {\n                inheritColor: autoColor\n              })\n            });\n            itemGroup.add(labelEl);\n          }\n\n          var itemDetailModel = itemModel.getModel('detail');\n\n          if (itemDetailModel.get('show')) {\n            var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n            var detailX = posInfo.cx + parsePercent$1(detailOffsetCenter[0], posInfo.r);\n            var detailY = posInfo.cy + parsePercent$1(detailOffsetCenter[1], posInfo.r);\n            var width = parsePercent$1(itemDetailModel.get('width'), posInfo.r);\n            var height = parsePercent$1(itemDetailModel.get('height'), posInfo.r);\n            var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n            var labelEl = newDetailEls[idx];\n            var formatter_1 = itemDetailModel.get('formatter');\n            labelEl.attr({\n              style: createTextStyle(itemDetailModel, {\n                x: detailX,\n                y: detailY,\n                text: formatLabel(value, formatter_1),\n                width: isNaN(width) ? null : width,\n                height: isNaN(height) ? null : height,\n                align: 'center',\n                verticalAlign: 'middle'\n              }, {\n                inheritColor: detailColor\n              })\n            });\n            setLabelValueAnimation(labelEl, {\n              normal: itemDetailModel\n            }, value, function (value) {\n              return formatLabel(value, formatter_1);\n            });\n            hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n              getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n                return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n              }\n            });\n            itemGroup.add(labelEl);\n          }\n\n          contentGroup.add(itemGroup);\n        });\n        this.group.add(contentGroup);\n        this._titleEls = newTitleEls;\n        this._detailEls = newDetailEls;\n      };\n\n      GaugeView.type = 'gauge';\n      return GaugeView;\n    }(ChartView);\n\n    var GaugeSeriesModel = function (_super) {\n      __extends(GaugeSeriesModel, _super);\n\n      function GaugeSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GaugeSeriesModel.type;\n        _this.visualStyleAccessPath = 'itemStyle';\n        _this.useColorPaletteOnData = true;\n        return _this;\n      }\n\n      GaugeSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListSimply(this, ['value']);\n      };\n\n      GaugeSeriesModel.type = 'series.gauge';\n      GaugeSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        center: ['50%', '50%'],\n        legendHoverLink: true,\n        radius: '75%',\n        startAngle: 225,\n        endAngle: -45,\n        clockwise: true,\n        min: 0,\n        max: 100,\n        splitNumber: 10,\n        axisLine: {\n          show: true,\n          roundCap: false,\n          lineStyle: {\n            color: [[1, '#E6EBF8']],\n            width: 10\n          }\n        },\n        progress: {\n          show: false,\n          overlap: true,\n          width: 10,\n          roundCap: false,\n          clip: true\n        },\n        splitLine: {\n          show: true,\n          length: 10,\n          distance: 10,\n          lineStyle: {\n            color: '#63677A',\n            width: 3,\n            type: 'solid'\n          }\n        },\n        axisTick: {\n          show: true,\n          splitNumber: 5,\n          length: 6,\n          distance: 10,\n          lineStyle: {\n            color: '#63677A',\n            width: 1,\n            type: 'solid'\n          }\n        },\n        axisLabel: {\n          show: true,\n          distance: 15,\n          color: '#464646',\n          fontSize: 12\n        },\n        pointer: {\n          icon: null,\n          offsetCenter: [0, 0],\n          show: true,\n          length: '60%',\n          width: 6,\n          keepAspect: false\n        },\n        anchor: {\n          show: false,\n          showAbove: false,\n          size: 6,\n          icon: 'circle',\n          offsetCenter: [0, 0],\n          keepAspect: false,\n          itemStyle: {\n            color: '#fff',\n            borderWidth: 0,\n            borderColor: '#5470c6'\n          }\n        },\n        title: {\n          show: true,\n          offsetCenter: [0, '20%'],\n          color: '#464646',\n          fontSize: 16,\n          valueAnimation: false\n        },\n        detail: {\n          show: true,\n          backgroundColor: 'rgba(0,0,0,0)',\n          borderWidth: 0,\n          borderColor: '#ccc',\n          width: 100,\n          height: null,\n          padding: [5, 10],\n          offsetCenter: [0, '40%'],\n          color: '#464646',\n          fontSize: 30,\n          fontWeight: 'bold',\n          lineHeight: 30,\n          valueAnimation: false\n        }\n      };\n      return GaugeSeriesModel;\n    }(SeriesModel);\n\n    function install$d(registers) {\n      registers.registerChartView(GaugeView);\n      registers.registerSeriesModel(GaugeSeriesModel);\n    }\n\n    var opacityAccessPath = ['itemStyle', 'opacity'];\n\n    var FunnelPiece = function (_super) {\n      __extends(FunnelPiece, _super);\n\n      function FunnelPiece(data, idx) {\n        var _this = _super.call(this) || this;\n\n        var polygon = _this;\n        var labelLine = new Polyline();\n        var text = new ZRText();\n        polygon.setTextContent(text);\n\n        _this.setTextGuideLine(labelLine);\n\n        _this.updateData(data, idx, true);\n\n        return _this;\n      }\n\n      FunnelPiece.prototype.updateData = function (data, idx, firstCreate) {\n        var polygon = this;\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n        var opacity = itemModel.get(opacityAccessPath);\n        opacity = opacity == null ? 1 : opacity;\n        polygon.useStyle(data.getItemVisual(idx, 'style'));\n        polygon.style.lineJoin = 'round';\n\n        if (firstCreate) {\n          polygon.setShape({\n            points: layout.points\n          });\n          polygon.style.opacity = 0;\n          initProps(polygon, {\n            style: {\n              opacity: opacity\n            }\n          }, seriesModel, idx);\n        } else {\n          updateProps(polygon, {\n            style: {\n              opacity: opacity\n            },\n            shape: {\n              points: layout.points\n            }\n          }, seriesModel, idx);\n        }\n\n        setStatesStylesFromModel(polygon, itemModel);\n\n        this._updateLabel(data, idx);\n\n        enableHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n      };\n\n      FunnelPiece.prototype._updateLabel = function (data, idx) {\n        var polygon = this;\n        var labelLine = this.getTextGuideLine();\n        var labelText = polygon.getTextContent();\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var style = data.getItemVisual(idx, 'style');\n        var visualColor = style.fill;\n        setLabelStyle(labelText, getLabelStatesModels(itemModel), {\n          labelFetcher: data.hostModel,\n          labelDataIndex: idx,\n          defaultOpacity: style.opacity,\n          defaultText: data.getName(idx)\n        }, {\n          normal: {\n            align: labelLayout.textAlign,\n            verticalAlign: labelLayout.verticalAlign\n          }\n        });\n        polygon.setTextConfig({\n          local: true,\n          inside: !!labelLayout.inside,\n          insideStroke: visualColor,\n          outsideFill: visualColor\n        });\n        var linePoints = labelLayout.linePoints;\n        labelLine.setShape({\n          points: linePoints\n        });\n        polygon.textGuideLineConfig = {\n          anchor: linePoints ? new Point(linePoints[0][0], linePoints[0][1]) : null\n        };\n        updateProps(labelText, {\n          style: {\n            x: labelLayout.x,\n            y: labelLayout.y\n          }\n        }, seriesModel, idx);\n        labelText.attr({\n          rotation: labelLayout.rotation,\n          originX: labelLayout.x,\n          originY: labelLayout.y,\n          z2: 10\n        });\n        setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {\n          stroke: visualColor\n        });\n      };\n\n      return FunnelPiece;\n    }(Polygon);\n\n    var FunnelView = function (_super) {\n      __extends(FunnelView, _super);\n\n      function FunnelView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = FunnelView.type;\n        _this.ignoreLabelLineUpdate = true;\n        return _this;\n      }\n\n      FunnelView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var group = this.group;\n        data.diff(oldData).add(function (idx) {\n          var funnelPiece = new FunnelPiece(data, idx);\n          data.setItemGraphicEl(idx, funnelPiece);\n          group.add(funnelPiece);\n        }).update(function (newIdx, oldIdx) {\n          var piece = oldData.getItemGraphicEl(oldIdx);\n          piece.updateData(data, newIdx);\n          group.add(piece);\n          data.setItemGraphicEl(newIdx, piece);\n        }).remove(function (idx) {\n          var piece = oldData.getItemGraphicEl(idx);\n          removeElementWithFadeOut(piece, seriesModel, idx);\n        }).execute();\n        this._data = data;\n      };\n\n      FunnelView.prototype.remove = function () {\n        this.group.removeAll();\n        this._data = null;\n      };\n\n      FunnelView.prototype.dispose = function () {};\n\n      FunnelView.type = 'funnel';\n      return FunnelView;\n    }(ChartView);\n\n    var FunnelSeriesModel = function (_super) {\n      __extends(FunnelSeriesModel, _super);\n\n      function FunnelSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = FunnelSeriesModel.type;\n        _this.useColorPaletteOnData = true;\n        return _this;\n      }\n\n      FunnelSeriesModel.prototype.init = function (option) {\n        _super.prototype.init.apply(this, arguments);\n\n        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this));\n\n        this._defaultLabelLine(option);\n      };\n\n      FunnelSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListSimply(this, {\n          coordDimensions: ['value'],\n          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)\n        });\n      };\n\n      FunnelSeriesModel.prototype._defaultLabelLine = function (option) {\n        defaultEmphasis(option, 'labelLine', ['show']);\n        var labelLineNormalOpt = option.labelLine;\n        var labelLineEmphasisOpt = option.emphasis.labelLine;\n        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;\n        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;\n      };\n\n      FunnelSeriesModel.prototype.getDataParams = function (dataIndex) {\n        var data = this.getData();\n\n        var params = _super.prototype.getDataParams.call(this, dataIndex);\n\n        var valueDim = data.mapDimension('value');\n        var sum = data.getSum(valueDim);\n        params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);\n        params.$vars.push('percent');\n        return params;\n      };\n\n      FunnelSeriesModel.type = 'series.funnel';\n      FunnelSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        left: 80,\n        top: 60,\n        right: 80,\n        bottom: 60,\n        minSize: '0%',\n        maxSize: '100%',\n        sort: 'descending',\n        orient: 'vertical',\n        gap: 0,\n        funnelAlign: 'center',\n        label: {\n          show: true,\n          position: 'outer'\n        },\n        labelLine: {\n          show: true,\n          length: 20,\n          lineStyle: {\n            width: 1\n          }\n        },\n        itemStyle: {\n          borderColor: '#fff',\n          borderWidth: 1\n        },\n        emphasis: {\n          label: {\n            show: true\n          }\n        },\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        }\n      };\n      return FunnelSeriesModel;\n    }(SeriesModel);\n\n    function getViewRect$3(seriesModel, api) {\n      return getLayoutRect(seriesModel.getBoxLayoutParams(), {\n        width: api.getWidth(),\n        height: api.getHeight()\n      });\n    }\n\n    function getSortedIndices(data, sort) {\n      var valueDim = data.mapDimension('value');\n      var valueArr = data.mapArray(valueDim, function (val) {\n        return val;\n      });\n      var indices = [];\n      var isAscending = sort === 'ascending';\n\n      for (var i = 0, len = data.count(); i < len; i++) {\n        indices[i] = i;\n      }\n\n      if (typeof sort === 'function') {\n        indices.sort(sort);\n      } else if (sort !== 'none') {\n        indices.sort(function (a, b) {\n          return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];\n        });\n      }\n\n      return indices;\n    }\n\n    function labelLayout(data) {\n      var seriesModel = data.hostModel;\n      var orient = seriesModel.get('orient');\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var labelModel = itemModel.getModel('label');\n        var labelPosition = labelModel.get('position');\n        var labelLineModel = itemModel.getModel('labelLine');\n        var layout = data.getItemLayout(idx);\n        var points = layout.points;\n        var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight';\n        var textAlign;\n        var textX;\n        var textY;\n        var linePoints;\n\n        if (isLabelInside) {\n          if (labelPosition === 'insideLeft') {\n            textX = (points[0][0] + points[3][0]) / 2 + 5;\n            textY = (points[0][1] + points[3][1]) / 2;\n            textAlign = 'left';\n          } else if (labelPosition === 'insideRight') {\n            textX = (points[1][0] + points[2][0]) / 2 - 5;\n            textY = (points[1][1] + points[2][1]) / 2;\n            textAlign = 'right';\n          } else {\n            textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;\n            textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;\n            textAlign = 'center';\n          }\n\n          linePoints = [[textX, textY], [textX, textY]];\n        } else {\n          var x1 = void 0;\n          var y1 = void 0;\n          var x2 = void 0;\n          var y2 = void 0;\n          var labelLineLen = labelLineModel.get('length');\n\n          if (\"development\" !== 'production') {\n            if (orient === 'vertical' && ['top', 'bottom'].indexOf(labelPosition) > -1) {\n              labelPosition = 'left';\n              console.warn('Position error: Funnel chart on vertical orient dose not support top and bottom.');\n            }\n\n            if (orient === 'horizontal' && ['left', 'right'].indexOf(labelPosition) > -1) {\n              labelPosition = 'bottom';\n              console.warn('Position error: Funnel chart on horizontal orient dose not support left and right.');\n            }\n          }\n\n          if (labelPosition === 'left') {\n            x1 = (points[3][0] + points[0][0]) / 2;\n            y1 = (points[3][1] + points[0][1]) / 2;\n            x2 = x1 - labelLineLen;\n            textX = x2 - 5;\n            textAlign = 'right';\n          } else if (labelPosition === 'right') {\n            x1 = (points[1][0] + points[2][0]) / 2;\n            y1 = (points[1][1] + points[2][1]) / 2;\n            x2 = x1 + labelLineLen;\n            textX = x2 + 5;\n            textAlign = 'left';\n          } else if (labelPosition === 'top') {\n            x1 = (points[3][0] + points[0][0]) / 2;\n            y1 = (points[3][1] + points[0][1]) / 2;\n            y2 = y1 - labelLineLen;\n            textY = y2 - 5;\n            textAlign = 'center';\n          } else if (labelPosition === 'bottom') {\n            x1 = (points[1][0] + points[2][0]) / 2;\n            y1 = (points[1][1] + points[2][1]) / 2;\n            y2 = y1 + labelLineLen;\n            textY = y2 + 5;\n            textAlign = 'center';\n          } else if (labelPosition === 'rightTop') {\n            x1 = orient === 'horizontal' ? points[3][0] : points[1][0];\n            y1 = orient === 'horizontal' ? points[3][1] : points[1][1];\n\n            if (orient === 'horizontal') {\n              y2 = y1 - labelLineLen;\n              textY = y2 - 5;\n              textAlign = 'center';\n            } else {\n              x2 = x1 + labelLineLen;\n              textX = x2 + 5;\n              textAlign = 'top';\n            }\n          } else if (labelPosition === 'rightBottom') {\n            x1 = points[2][0];\n            y1 = points[2][1];\n\n            if (orient === 'horizontal') {\n              y2 = y1 + labelLineLen;\n              textY = y2 + 5;\n              textAlign = 'center';\n            } else {\n              x2 = x1 + labelLineLen;\n              textX = x2 + 5;\n              textAlign = 'bottom';\n            }\n          } else if (labelPosition === 'leftTop') {\n            x1 = points[0][0];\n            y1 = orient === 'horizontal' ? points[0][1] : points[1][1];\n\n            if (orient === 'horizontal') {\n              y2 = y1 - labelLineLen;\n              textY = y2 - 5;\n              textAlign = 'center';\n            } else {\n              x2 = x1 - labelLineLen;\n              textX = x2 - 5;\n              textAlign = 'right';\n            }\n          } else if (labelPosition === 'leftBottom') {\n            x1 = orient === 'horizontal' ? points[1][0] : points[3][0];\n            y1 = orient === 'horizontal' ? points[1][1] : points[2][1];\n\n            if (orient === 'horizontal') {\n              y2 = y1 + labelLineLen;\n              textY = y2 + 5;\n              textAlign = 'center';\n            } else {\n              x2 = x1 - labelLineLen;\n              textX = x2 - 5;\n              textAlign = 'right';\n            }\n          } else {\n            x1 = (points[1][0] + points[2][0]) / 2;\n            y1 = (points[1][1] + points[2][1]) / 2;\n\n            if (orient === 'horizontal') {\n              y2 = y1 + labelLineLen;\n              textY = y2 + 5;\n              textAlign = 'center';\n            } else {\n              x2 = x1 + labelLineLen;\n              textX = x2 + 5;\n              textAlign = 'left';\n            }\n          }\n\n          if (orient === 'horizontal') {\n            x2 = x1;\n            textX = x2;\n          } else {\n            y2 = y1;\n            textY = y2;\n          }\n\n          linePoints = [[x1, y1], [x2, y2]];\n        }\n\n        layout.label = {\n          linePoints: linePoints,\n          x: textX,\n          y: textY,\n          verticalAlign: 'middle',\n          textAlign: textAlign,\n          inside: isLabelInside\n        };\n      });\n    }\n\n    function funnelLayout(ecModel, api) {\n      ecModel.eachSeriesByType('funnel', function (seriesModel) {\n        var data = seriesModel.getData();\n        var valueDim = data.mapDimension('value');\n        var sort = seriesModel.get('sort');\n        var viewRect = getViewRect$3(seriesModel, api);\n        var orient = seriesModel.get('orient');\n        var viewWidth = viewRect.width;\n        var viewHeight = viewRect.height;\n        var indices = getSortedIndices(data, sort);\n        var x = viewRect.x;\n        var y = viewRect.y;\n        var sizeExtent = orient === 'horizontal' ? [parsePercent$1(seriesModel.get('minSize'), viewHeight), parsePercent$1(seriesModel.get('maxSize'), viewHeight)] : [parsePercent$1(seriesModel.get('minSize'), viewWidth), parsePercent$1(seriesModel.get('maxSize'), viewWidth)];\n        var dataExtent = data.getDataExtent(valueDim);\n        var min = seriesModel.get('min');\n        var max = seriesModel.get('max');\n\n        if (min == null) {\n          min = Math.min(dataExtent[0], 0);\n        }\n\n        if (max == null) {\n          max = dataExtent[1];\n        }\n\n        var funnelAlign = seriesModel.get('funnelAlign');\n        var gap = seriesModel.get('gap');\n        var viewSize = orient === 'horizontal' ? viewWidth : viewHeight;\n        var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();\n\n        var getLinePoints = function (idx, offset) {\n          if (orient === 'horizontal') {\n            var val_1 = data.get(valueDim, idx) || 0;\n            var itemHeight = linearMap(val_1, [min, max], sizeExtent, true);\n            var y0 = void 0;\n\n            switch (funnelAlign) {\n              case 'top':\n                y0 = y;\n                break;\n\n              case 'center':\n                y0 = y + (viewHeight - itemHeight) / 2;\n                break;\n\n              case 'bottom':\n                y0 = y + (viewHeight - itemHeight);\n                break;\n            }\n\n            return [[offset, y0], [offset, y0 + itemHeight]];\n          }\n\n          var val = data.get(valueDim, idx) || 0;\n          var itemWidth = linearMap(val, [min, max], sizeExtent, true);\n          var x0;\n\n          switch (funnelAlign) {\n            case 'left':\n              x0 = x;\n              break;\n\n            case 'center':\n              x0 = x + (viewWidth - itemWidth) / 2;\n              break;\n\n            case 'right':\n              x0 = x + viewWidth - itemWidth;\n              break;\n          }\n\n          return [[x0, offset], [x0 + itemWidth, offset]];\n        };\n\n        if (sort === 'ascending') {\n          itemSize = -itemSize;\n          gap = -gap;\n\n          if (orient === 'horizontal') {\n            x += viewWidth;\n          } else {\n            y += viewHeight;\n          }\n\n          indices = indices.reverse();\n        }\n\n        for (var i = 0; i < indices.length; i++) {\n          var idx = indices[i];\n          var nextIdx = indices[i + 1];\n          var itemModel = data.getItemModel(idx);\n\n          if (orient === 'horizontal') {\n            var width = itemModel.get(['itemStyle', 'width']);\n\n            if (width == null) {\n              width = itemSize;\n            } else {\n              width = parsePercent$1(width, viewWidth);\n\n              if (sort === 'ascending') {\n                width = -width;\n              }\n            }\n\n            var start = getLinePoints(idx, x);\n            var end = getLinePoints(nextIdx, x + width);\n            x += width + gap;\n            data.setItemLayout(idx, {\n              points: start.concat(end.slice().reverse())\n            });\n          } else {\n            var height = itemModel.get(['itemStyle', 'height']);\n\n            if (height == null) {\n              height = itemSize;\n            } else {\n              height = parsePercent$1(height, viewHeight);\n\n              if (sort === 'ascending') {\n                height = -height;\n              }\n            }\n\n            var start = getLinePoints(idx, y);\n            var end = getLinePoints(nextIdx, y + height);\n            y += height + gap;\n            data.setItemLayout(idx, {\n              points: start.concat(end.slice().reverse())\n            });\n          }\n        }\n\n        labelLayout(data);\n      });\n    }\n\n    function install$e(registers) {\n      registers.registerChartView(FunnelView);\n      registers.registerSeriesModel(FunnelSeriesModel);\n      registers.registerLayout(funnelLayout);\n      registers.registerProcessor(dataFilter('funnel'));\n    }\n\n    var DEFAULT_SMOOTH = 0.3;\n\n    var ParallelView = function (_super) {\n      __extends(ParallelView, _super);\n\n      function ParallelView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelView.type;\n        _this._dataGroup = new Group();\n        _this._initialized = false;\n        return _this;\n      }\n\n      ParallelView.prototype.init = function () {\n        this.group.add(this._dataGroup);\n      };\n\n      ParallelView.prototype.render = function (seriesModel, ecModel, api, payload) {\n        var dataGroup = this._dataGroup;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var coordSys = seriesModel.coordinateSystem;\n        var dimensions = coordSys.dimensions;\n        var seriesScope = makeSeriesScope$2(seriesModel);\n        data.diff(oldData).add(add).update(update).remove(remove).execute();\n\n        function add(newDataIndex) {\n          var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);\n          updateElCommon(line, data, newDataIndex, seriesScope);\n        }\n\n        function update(newDataIndex, oldDataIndex) {\n          var line = oldData.getItemGraphicEl(oldDataIndex);\n          var points = createLinePoints(data, newDataIndex, dimensions, coordSys);\n          data.setItemGraphicEl(newDataIndex, line);\n          updateProps(line, {\n            shape: {\n              points: points\n            }\n          }, seriesModel, newDataIndex);\n          updateElCommon(line, data, newDataIndex, seriesScope);\n        }\n\n        function remove(oldDataIndex) {\n          var line = oldData.getItemGraphicEl(oldDataIndex);\n          dataGroup.remove(line);\n        }\n\n        if (!this._initialized) {\n          this._initialized = true;\n          var clipPath = createGridClipShape(coordSys, seriesModel, function () {\n            setTimeout(function () {\n              dataGroup.removeClipPath();\n            });\n          });\n          dataGroup.setClipPath(clipPath);\n        }\n\n        this._data = data;\n      };\n\n      ParallelView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n        this._initialized = true;\n        this._data = null;\n\n        this._dataGroup.removeAll();\n      };\n\n      ParallelView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n        var data = seriesModel.getData();\n        var coordSys = seriesModel.coordinateSystem;\n        var dimensions = coordSys.dimensions;\n        var seriesScope = makeSeriesScope$2(seriesModel);\n\n        for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {\n          var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);\n          line.incremental = true;\n          updateElCommon(line, data, dataIndex, seriesScope);\n        }\n      };\n\n      ParallelView.prototype.remove = function () {\n        this._dataGroup && this._dataGroup.removeAll();\n        this._data = null;\n      };\n\n      ParallelView.type = 'parallel';\n      return ParallelView;\n    }(ChartView);\n\n    function createGridClipShape(coordSys, seriesModel, cb) {\n      var parallelModel = coordSys.model;\n      var rect = coordSys.getRect();\n      var rectEl = new Rect({\n        shape: {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        }\n      });\n      var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';\n      rectEl.setShape(dim, 0);\n      initProps(rectEl, {\n        shape: {\n          width: rect.width,\n          height: rect.height\n        }\n      }, seriesModel, cb);\n      return rectEl;\n    }\n\n    function createLinePoints(data, dataIndex, dimensions, coordSys) {\n      var points = [];\n\n      for (var i = 0; i < dimensions.length; i++) {\n        var dimName = dimensions[i];\n        var value = data.get(data.mapDimension(dimName), dataIndex);\n\n        if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {\n          points.push(coordSys.dataToPoint(value, dimName));\n        }\n      }\n\n      return points;\n    }\n\n    function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {\n      var points = createLinePoints(data, dataIndex, dimensions, coordSys);\n      var line = new Polyline({\n        shape: {\n          points: points\n        },\n        z2: 10\n      });\n      dataGroup.add(line);\n      data.setItemGraphicEl(dataIndex, line);\n      return line;\n    }\n\n    function makeSeriesScope$2(seriesModel) {\n      var smooth = seriesModel.get('smooth', true);\n      smooth === true && (smooth = DEFAULT_SMOOTH);\n      smooth = numericToNumber(smooth);\n      eqNaN(smooth) && (smooth = 0);\n      return {\n        smooth: smooth\n      };\n    }\n\n    function updateElCommon(el, data, dataIndex, seriesScope) {\n      el.useStyle(data.getItemVisual(dataIndex, 'style'));\n      el.style.fill = null;\n      el.setShape('smooth', seriesScope.smooth);\n      var itemModel = data.getItemModel(dataIndex);\n      var emphasisModel = itemModel.getModel('emphasis');\n      setStatesStylesFromModel(el, itemModel, 'lineStyle');\n      enableHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n    }\n\n    function isEmptyValue(val, axisType) {\n      return axisType === 'category' ? val == null : val == null || isNaN(val);\n    }\n\n    var ParallelSeriesModel = function (_super) {\n      __extends(ParallelSeriesModel, _super);\n\n      function ParallelSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelSeriesModel.type;\n        _this.visualStyleAccessPath = 'lineStyle';\n        _this.visualDrawType = 'stroke';\n        return _this;\n      }\n\n      ParallelSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: bind(makeDefaultEncode, null, this)\n        });\n      };\n\n      ParallelSeriesModel.prototype.getRawIndicesByActiveState = function (activeState) {\n        var coordSys = this.coordinateSystem;\n        var data = this.getData();\n        var indices = [];\n        coordSys.eachActiveState(data, function (theActiveState, dataIndex) {\n          if (activeState === theActiveState) {\n            indices.push(data.getRawIndex(dataIndex));\n          }\n        });\n        return indices;\n      };\n\n      ParallelSeriesModel.type = 'series.parallel';\n      ParallelSeriesModel.dependencies = ['parallel'];\n      ParallelSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'parallel',\n        parallelIndex: 0,\n        label: {\n          show: false\n        },\n        inactiveOpacity: 0.05,\n        activeOpacity: 1,\n        lineStyle: {\n          width: 1,\n          opacity: 0.45,\n          type: 'solid'\n        },\n        emphasis: {\n          label: {\n            show: false\n          }\n        },\n        progressive: 500,\n        smooth: false,\n        animationEasing: 'linear'\n      };\n      return ParallelSeriesModel;\n    }(SeriesModel);\n\n    function makeDefaultEncode(seriesModel) {\n      var parallelModel = seriesModel.ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n\n      if (!parallelModel) {\n        return;\n      }\n\n      var encodeDefine = {};\n      each(parallelModel.dimensions, function (axisDim) {\n        var dataDimIndex = convertDimNameToNumber(axisDim);\n        encodeDefine[axisDim] = dataDimIndex;\n      });\n      return encodeDefine;\n    }\n\n    function convertDimNameToNumber(dimName) {\n      return +dimName.replace('dim', '');\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var opacityAccessPath$1 = ['lineStyle', 'opacity'];\n    var parallelVisual = {\n      seriesType: 'parallel',\n      reset: function (seriesModel, ecModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var opacityMap = {\n          normal: seriesModel.get(['lineStyle', 'opacity']),\n          active: seriesModel.get('activeOpacity'),\n          inactive: seriesModel.get('inactiveOpacity')\n        };\n        return {\n          progress: function (params, data) {\n            coordSys.eachActiveState(data, function (activeState, dataIndex) {\n              var opacity = opacityMap[activeState];\n\n              if (activeState === 'normal' && data.hasItemOption) {\n                var itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath$1, true);\n                itemOpacity != null && (opacity = itemOpacity);\n              }\n\n              var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');\n              existsStyle.opacity = opacity;\n            }, params.start, params.end);\n          }\n        };\n      }\n    };\n\n    function parallelPreprocessor(option) {\n      createParallelIfNeeded(option);\n      mergeAxisOptionFromParallel(option);\n    }\n\n    function createParallelIfNeeded(option) {\n      if (option.parallel) {\n        return;\n      }\n\n      var hasParallelSeries = false;\n      each(option.series, function (seriesOpt) {\n        if (seriesOpt && seriesOpt.type === 'parallel') {\n          hasParallelSeries = true;\n        }\n      });\n\n      if (hasParallelSeries) {\n        option.parallel = [{}];\n      }\n    }\n\n    function mergeAxisOptionFromParallel(option) {\n      var axes = normalizeToArray(option.parallelAxis);\n      each(axes, function (axisOption) {\n        if (!isObject(axisOption)) {\n          return;\n        }\n\n        var parallelIndex = axisOption.parallelIndex || 0;\n        var parallelOption = normalizeToArray(option.parallel)[parallelIndex];\n\n        if (parallelOption && parallelOption.parallelAxisDefault) {\n          merge(axisOption, parallelOption.parallelAxisDefault, false);\n        }\n      });\n    }\n\n    var CLICK_THRESHOLD = 5;\n\n    var ParallelView$1 = function (_super) {\n      __extends(ParallelView, _super);\n\n      function ParallelView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelView.type;\n        return _this;\n      }\n\n      ParallelView.prototype.render = function (parallelModel, ecModel, api) {\n        this._model = parallelModel;\n        this._api = api;\n\n        if (!this._handlers) {\n          this._handlers = {};\n          each(handlers, function (handler, eventName) {\n            api.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));\n          }, this);\n        }\n\n        createOrUpdate(this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate');\n      };\n\n      ParallelView.prototype.dispose = function (ecModel, api) {\n        each(this._handlers, function (handler, eventName) {\n          api.getZr().off(eventName, handler);\n        });\n        this._handlers = null;\n      };\n\n      ParallelView.prototype._throttledDispatchExpand = function (opt) {\n        this._dispatchExpand(opt);\n      };\n\n      ParallelView.prototype._dispatchExpand = function (opt) {\n        opt && this._api.dispatchAction(extend({\n          type: 'parallelAxisExpand'\n        }, opt));\n      };\n\n      ParallelView.type = 'parallel';\n      return ParallelView;\n    }(ComponentView);\n\n    var handlers = {\n      mousedown: function (e) {\n        if (checkTrigger(this, 'click')) {\n          this._mouseDownPoint = [e.offsetX, e.offsetY];\n        }\n      },\n      mouseup: function (e) {\n        var mouseDownPoint = this._mouseDownPoint;\n\n        if (checkTrigger(this, 'click') && mouseDownPoint) {\n          var point = [e.offsetX, e.offsetY];\n          var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);\n\n          if (dist > CLICK_THRESHOLD) {\n            return;\n          }\n\n          var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);\n\n          result.behavior !== 'none' && this._dispatchExpand({\n            axisExpandWindow: result.axisExpandWindow\n          });\n        }\n\n        this._mouseDownPoint = null;\n      },\n      mousemove: function (e) {\n        if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {\n          return;\n        }\n\n        var model = this._model;\n        var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);\n        var behavior = result.behavior;\n        behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'));\n\n        this._throttledDispatchExpand(behavior === 'none' ? null : {\n          axisExpandWindow: result.axisExpandWindow,\n          animation: behavior === 'jump' ? null : {\n            duration: 0\n          }\n        });\n      }\n    };\n\n    function checkTrigger(view, triggerOn) {\n      var model = view._model;\n      return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn;\n    }\n\n    var ParallelModel = function (_super) {\n      __extends(ParallelModel, _super);\n\n      function ParallelModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelModel.type;\n        return _this;\n      }\n\n      ParallelModel.prototype.init = function () {\n        _super.prototype.init.apply(this, arguments);\n\n        this.mergeOption({});\n      };\n\n      ParallelModel.prototype.mergeOption = function (newOption) {\n        var thisOption = this.option;\n        newOption && merge(thisOption, newOption, true);\n\n        this._initDimensions();\n      };\n\n      ParallelModel.prototype.contains = function (model, ecModel) {\n        var parallelIndex = model.get('parallelIndex');\n        return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;\n      };\n\n      ParallelModel.prototype.setAxisExpand = function (opt) {\n        each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) {\n          if (opt.hasOwnProperty(name)) {\n            this.option[name] = opt[name];\n          }\n        }, this);\n      };\n\n      ParallelModel.prototype._initDimensions = function () {\n        var dimensions = this.dimensions = [];\n        var parallelAxisIndex = this.parallelAxisIndex = [];\n        var axisModels = filter(this.ecModel.queryComponents({\n          mainType: 'parallelAxis'\n        }), function (axisModel) {\n          return (axisModel.get('parallelIndex') || 0) === this.componentIndex;\n        }, this);\n        each(axisModels, function (axisModel) {\n          dimensions.push('dim' + axisModel.get('dim'));\n          parallelAxisIndex.push(axisModel.componentIndex);\n        });\n      };\n\n      ParallelModel.type = 'parallel';\n      ParallelModel.dependencies = ['parallelAxis'];\n      ParallelModel.layoutMode = 'box';\n      ParallelModel.defaultOption = {\n        zlevel: 0,\n        z: 0,\n        left: 80,\n        top: 60,\n        right: 80,\n        bottom: 60,\n        layout: 'horizontal',\n        axisExpandable: false,\n        axisExpandCenter: null,\n        axisExpandCount: 0,\n        axisExpandWidth: 50,\n        axisExpandRate: 17,\n        axisExpandDebounce: 50,\n        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],\n        axisExpandTriggerOn: 'click',\n        parallelAxisDefault: null\n      };\n      return ParallelModel;\n    }(ComponentModel);\n\n    var ParallelAxis = function (_super) {\n      __extends(ParallelAxis, _super);\n\n      function ParallelAxis(dim, scale, coordExtent, axisType, axisIndex) {\n        var _this = _super.call(this, dim, scale, coordExtent) || this;\n\n        _this.type = axisType || 'value';\n        _this.axisIndex = axisIndex;\n        return _this;\n      }\n\n      ParallelAxis.prototype.isHorizontal = function () {\n        return this.coordinateSystem.getModel().get('layout') !== 'horizontal';\n      };\n\n      return ParallelAxis;\n    }(Axis);\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {\n      delta = delta || 0;\n      var extentSpan = extent[1] - extent[0];\n\n      if (minSpan != null) {\n        minSpan = restrict(minSpan, [0, extentSpan]);\n      }\n\n      if (maxSpan != null) {\n        maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);\n      }\n\n      if (handleIndex === 'all') {\n        var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);\n        handleSpan = restrict(handleSpan, [0, extentSpan]);\n        minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);\n        handleIndex = 0;\n      }\n\n      handleEnds[0] = restrict(handleEnds[0], extent);\n      handleEnds[1] = restrict(handleEnds[1], extent);\n      var originalDistSign = getSpanSign(handleEnds, handleIndex);\n      handleEnds[handleIndex] += delta;\n      var extentMinSpan = minSpan || 0;\n      var realExtent = extent.slice();\n      originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;\n      handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);\n      var currDistSign;\n      currDistSign = getSpanSign(handleEnds, handleIndex);\n\n      if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {\n        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;\n      }\n\n      currDistSign = getSpanSign(handleEnds, handleIndex);\n\n      if (maxSpan != null && currDistSign.span > maxSpan) {\n        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;\n      }\n\n      return handleEnds;\n    }\n\n    function getSpanSign(handleEnds, handleIndex) {\n      var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];\n      return {\n        span: Math.abs(dist),\n        sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1\n      };\n    }\n\n    function restrict(value, extend) {\n      return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));\n    }\n\n    var each$6 = each;\n    var mathMin$8 = Math.min;\n    var mathMax$8 = Math.max;\n    var mathFloor$2 = Math.floor;\n    var mathCeil$1 = Math.ceil;\n    var round$2 = round;\n    var PI$7 = Math.PI;\n\n    var Parallel = function () {\n      function Parallel(parallelModel, ecModel, api) {\n        this.type = 'parallel';\n        this._axesMap = createHashMap();\n        this._axesLayout = {};\n        this.dimensions = parallelModel.dimensions;\n        this._model = parallelModel;\n\n        this._init(parallelModel, ecModel, api);\n      }\n\n      Parallel.prototype._init = function (parallelModel, ecModel, api) {\n        var dimensions = parallelModel.dimensions;\n        var parallelAxisIndex = parallelModel.parallelAxisIndex;\n        each$6(dimensions, function (dim, idx) {\n          var axisIndex = parallelAxisIndex[idx];\n          var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n\n          var axis = this._axesMap.set(dim, new ParallelAxis(dim, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex));\n\n          var isCategory = axis.type === 'category';\n          axis.onBand = isCategory && axisModel.get('boundaryGap');\n          axis.inverse = axisModel.get('inverse');\n          axisModel.axis = axis;\n          axis.model = axisModel;\n          axis.coordinateSystem = axisModel.coordinateSystem = this;\n        }, this);\n      };\n\n      Parallel.prototype.update = function (ecModel, api) {\n        this._updateAxesFromSeries(this._model, ecModel);\n      };\n\n      Parallel.prototype.containPoint = function (point) {\n        var layoutInfo = this._makeLayoutInfo();\n\n        var axisBase = layoutInfo.axisBase;\n        var layoutBase = layoutInfo.layoutBase;\n        var pixelDimIndex = layoutInfo.pixelDimIndex;\n        var pAxis = point[1 - pixelDimIndex];\n        var pLayout = point[pixelDimIndex];\n        return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;\n      };\n\n      Parallel.prototype.getModel = function () {\n        return this._model;\n      };\n\n      Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {\n        ecModel.eachSeries(function (seriesModel) {\n          if (!parallelModel.contains(seriesModel, ecModel)) {\n            return;\n          }\n\n          var data = seriesModel.getData();\n          each$6(this.dimensions, function (dim) {\n            var axis = this._axesMap.get(dim);\n\n            axis.scale.unionExtentFromData(data, data.mapDimension(dim));\n            niceScaleExtent(axis.scale, axis.model);\n          }, this);\n        }, this);\n      };\n\n      Parallel.prototype.resize = function (parallelModel, api) {\n        this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n\n        this._layoutAxes();\n      };\n\n      Parallel.prototype.getRect = function () {\n        return this._rect;\n      };\n\n      Parallel.prototype._makeLayoutInfo = function () {\n        var parallelModel = this._model;\n        var rect = this._rect;\n        var xy = ['x', 'y'];\n        var wh = ['width', 'height'];\n        var layout = parallelModel.get('layout');\n        var pixelDimIndex = layout === 'horizontal' ? 0 : 1;\n        var layoutLength = rect[wh[pixelDimIndex]];\n        var layoutExtent = [0, layoutLength];\n        var axisCount = this.dimensions.length;\n        var axisExpandWidth = restrict$1(parallelModel.get('axisExpandWidth'), layoutExtent);\n        var axisExpandCount = restrict$1(parallelModel.get('axisExpandCount') || 0, [0, axisCount]);\n        var axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;\n        var axisExpandWindow = parallelModel.get('axisExpandWindow');\n        var winSize;\n\n        if (!axisExpandWindow) {\n          winSize = restrict$1(axisExpandWidth * (axisExpandCount - 1), layoutExtent);\n          var axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor$2(axisCount / 2);\n          axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];\n          axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n        } else {\n          winSize = restrict$1(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);\n          axisExpandWindow[1] = axisExpandWindow[0] + winSize;\n        }\n\n        var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);\n        axisCollapseWidth < 3 && (axisCollapseWidth = 0);\n        var winInnerIndices = [mathFloor$2(round$2(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil$1(round$2(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];\n        var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];\n        return {\n          layout: layout,\n          pixelDimIndex: pixelDimIndex,\n          layoutBase: rect[xy[pixelDimIndex]],\n          layoutLength: layoutLength,\n          axisBase: rect[xy[1 - pixelDimIndex]],\n          axisLength: rect[wh[1 - pixelDimIndex]],\n          axisExpandable: axisExpandable,\n          axisExpandWidth: axisExpandWidth,\n          axisCollapseWidth: axisCollapseWidth,\n          axisExpandWindow: axisExpandWindow,\n          axisCount: axisCount,\n          winInnerIndices: winInnerIndices,\n          axisExpandWindow0Pos: axisExpandWindow0Pos\n        };\n      };\n\n      Parallel.prototype._layoutAxes = function () {\n        var rect = this._rect;\n        var axes = this._axesMap;\n        var dimensions = this.dimensions;\n\n        var layoutInfo = this._makeLayoutInfo();\n\n        var layout = layoutInfo.layout;\n        axes.each(function (axis) {\n          var axisExtent = [0, layoutInfo.axisLength];\n          var idx = axis.inverse ? 1 : 0;\n          axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);\n        });\n        each$6(dimensions, function (dim, idx) {\n          var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);\n          var positionTable = {\n            horizontal: {\n              x: posInfo.position,\n              y: layoutInfo.axisLength\n            },\n            vertical: {\n              x: 0,\n              y: posInfo.position\n            }\n          };\n          var rotationTable = {\n            horizontal: PI$7 / 2,\n            vertical: 0\n          };\n          var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];\n          var rotation = rotationTable[layout];\n          var transform = create$1();\n          rotate(transform, transform, rotation);\n          translate(transform, transform, position);\n          this._axesLayout[dim] = {\n            position: position,\n            rotation: rotation,\n            transform: transform,\n            axisNameAvailableWidth: posInfo.axisNameAvailableWidth,\n            axisLabelShow: posInfo.axisLabelShow,\n            nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,\n            tickDirection: 1,\n            labelDirection: 1\n          };\n        }, this);\n      };\n\n      Parallel.prototype.getAxis = function (dim) {\n        return this._axesMap.get(dim);\n      };\n\n      Parallel.prototype.dataToPoint = function (value, dim) {\n        return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);\n      };\n\n      Parallel.prototype.eachActiveState = function (data, callback, start, end) {\n        start == null && (start = 0);\n        end == null && (end = data.count());\n        var axesMap = this._axesMap;\n        var dimensions = this.dimensions;\n        var dataDimensions = [];\n        var axisModels = [];\n        each(dimensions, function (axisDim) {\n          dataDimensions.push(data.mapDimension(axisDim));\n          axisModels.push(axesMap.get(axisDim).model);\n        });\n        var hasActiveSet = this.hasAxisBrushed();\n\n        for (var dataIndex = start; dataIndex < end; dataIndex++) {\n          var activeState = void 0;\n\n          if (!hasActiveSet) {\n            activeState = 'normal';\n          } else {\n            activeState = 'active';\n            var values = data.getValues(dataDimensions, dataIndex);\n\n            for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n              var state = axisModels[j].getActiveState(values[j]);\n\n              if (state === 'inactive') {\n                activeState = 'inactive';\n                break;\n              }\n            }\n          }\n\n          callback(activeState, dataIndex);\n        }\n      };\n\n      Parallel.prototype.hasAxisBrushed = function () {\n        var dimensions = this.dimensions;\n        var axesMap = this._axesMap;\n        var hasActiveSet = false;\n\n        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {\n          if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {\n            hasActiveSet = true;\n          }\n        }\n\n        return hasActiveSet;\n      };\n\n      Parallel.prototype.axisCoordToPoint = function (coord, dim) {\n        var axisLayout = this._axesLayout[dim];\n        return applyTransform$1([coord, 0], axisLayout.transform);\n      };\n\n      Parallel.prototype.getAxisLayout = function (dim) {\n        return clone(this._axesLayout[dim]);\n      };\n\n      Parallel.prototype.getSlidedAxisExpandWindow = function (point) {\n        var layoutInfo = this._makeLayoutInfo();\n\n        var pixelDimIndex = layoutInfo.pixelDimIndex;\n        var axisExpandWindow = layoutInfo.axisExpandWindow.slice();\n        var winSize = axisExpandWindow[1] - axisExpandWindow[0];\n        var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];\n\n        if (!this.containPoint(point)) {\n          return {\n            behavior: 'none',\n            axisExpandWindow: axisExpandWindow\n          };\n        }\n\n        var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;\n        var delta;\n        var behavior = 'slide';\n        var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n\n        var triggerArea = this._model.get('axisExpandSlideTriggerArea');\n\n        var useJump = triggerArea[0] != null;\n\n        if (axisCollapseWidth) {\n          if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {\n            behavior = 'jump';\n            delta = pointCoord - winSize * triggerArea[2];\n          } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {\n            behavior = 'jump';\n            delta = pointCoord - winSize * (1 - triggerArea[2]);\n          } else {\n            (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);\n          }\n\n          delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;\n          delta ? sliderMove(delta, axisExpandWindow, extent, 'all') : behavior = 'none';\n        } else {\n          var winSize2 = axisExpandWindow[1] - axisExpandWindow[0];\n          var pos = extent[1] * pointCoord / winSize2;\n          axisExpandWindow = [mathMax$8(0, pos - winSize2 / 2)];\n          axisExpandWindow[1] = mathMin$8(extent[1], axisExpandWindow[0] + winSize2);\n          axisExpandWindow[0] = axisExpandWindow[1] - winSize2;\n        }\n\n        return {\n          axisExpandWindow: axisExpandWindow,\n          behavior: behavior\n        };\n      };\n\n      return Parallel;\n    }();\n\n    function restrict$1(len, extent) {\n      return mathMin$8(mathMax$8(len, extent[0]), extent[1]);\n    }\n\n    function layoutAxisWithoutExpand(axisIndex, layoutInfo) {\n      var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);\n      return {\n        position: step * axisIndex,\n        axisNameAvailableWidth: step,\n        axisLabelShow: true\n      };\n    }\n\n    function layoutAxisWithExpand(axisIndex, layoutInfo) {\n      var layoutLength = layoutInfo.layoutLength;\n      var axisExpandWidth = layoutInfo.axisExpandWidth;\n      var axisCount = layoutInfo.axisCount;\n      var axisCollapseWidth = layoutInfo.axisCollapseWidth;\n      var winInnerIndices = layoutInfo.winInnerIndices;\n      var position;\n      var axisNameAvailableWidth = axisCollapseWidth;\n      var axisLabelShow = false;\n      var nameTruncateMaxWidth;\n\n      if (axisIndex < winInnerIndices[0]) {\n        position = axisIndex * axisCollapseWidth;\n        nameTruncateMaxWidth = axisCollapseWidth;\n      } else if (axisIndex <= winInnerIndices[1]) {\n        position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];\n        axisNameAvailableWidth = axisExpandWidth;\n        axisLabelShow = true;\n      } else {\n        position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;\n        nameTruncateMaxWidth = axisCollapseWidth;\n      }\n\n      return {\n        position: position,\n        axisNameAvailableWidth: axisNameAvailableWidth,\n        axisLabelShow: axisLabelShow,\n        nameTruncateMaxWidth: nameTruncateMaxWidth\n      };\n    }\n\n    function createParallelCoordSys(ecModel, api) {\n      var coordSysList = [];\n      ecModel.eachComponent('parallel', function (parallelModel, idx) {\n        var coordSys = new Parallel(parallelModel, ecModel, api);\n        coordSys.name = 'parallel_' + idx;\n        coordSys.resize(parallelModel, api);\n        parallelModel.coordinateSystem = coordSys;\n        coordSys.model = parallelModel;\n        coordSysList.push(coordSys);\n      });\n      ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.get('coordinateSystem') === 'parallel') {\n          var parallelModel = seriesModel.getReferringComponents('parallel', SINGLE_REFERRING).models[0];\n          seriesModel.coordinateSystem = parallelModel.coordinateSystem;\n        }\n      });\n      return coordSysList;\n    }\n\n    var parallelCoordSysCreator = {\n      create: createParallelCoordSys\n    };\n\n    var ParallelAxisModel = function (_super) {\n      __extends(ParallelAxisModel, _super);\n\n      function ParallelAxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelAxisModel.type;\n        _this.activeIntervals = [];\n        return _this;\n      }\n\n      ParallelAxisModel.prototype.getAreaSelectStyle = function () {\n        return makeStyleMapper([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity']])(this.getModel('areaSelectStyle'));\n      };\n\n      ParallelAxisModel.prototype.setActiveIntervals = function (intervals) {\n        var activeIntervals = this.activeIntervals = clone(intervals);\n\n        if (activeIntervals) {\n          for (var i = activeIntervals.length - 1; i >= 0; i--) {\n            asc(activeIntervals[i]);\n          }\n        }\n      };\n\n      ParallelAxisModel.prototype.getActiveState = function (value) {\n        var activeIntervals = this.activeIntervals;\n\n        if (!activeIntervals.length) {\n          return 'normal';\n        }\n\n        if (value == null || isNaN(+value)) {\n          return 'inactive';\n        }\n\n        if (activeIntervals.length === 1) {\n          var interval = activeIntervals[0];\n\n          if (interval[0] <= value && value <= interval[1]) {\n            return 'active';\n          }\n        } else {\n          for (var i = 0, len = activeIntervals.length; i < len; i++) {\n            if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {\n              return 'active';\n            }\n          }\n        }\n\n        return 'inactive';\n      };\n\n      return ParallelAxisModel;\n    }(ComponentModel);\n\n    mixin(ParallelAxisModel, AxisModelCommonMixin);\n\n    var BRUSH_PANEL_GLOBAL = true;\n    var mathMin$9 = Math.min;\n    var mathMax$9 = Math.max;\n    var mathPow$2 = Math.pow;\n    var COVER_Z = 10000;\n    var UNSELECT_THRESHOLD = 6;\n    var MIN_RESIZE_LINE_WIDTH = 6;\n    var MUTEX_RESOURCE_KEY = 'globalPan';\n    var DIRECTION_MAP = {\n      w: [0, 0],\n      e: [0, 1],\n      n: [1, 0],\n      s: [1, 1]\n    };\n    var CURSOR_MAP = {\n      w: 'ew',\n      e: 'ew',\n      n: 'ns',\n      s: 'ns',\n      ne: 'nesw',\n      sw: 'nesw',\n      nw: 'nwse',\n      se: 'nwse'\n    };\n    var DEFAULT_BRUSH_OPT = {\n      brushStyle: {\n        lineWidth: 2,\n        stroke: 'rgba(210,219,238,0.3)',\n        fill: '#D2DBEE'\n      },\n      transformable: true,\n      brushMode: 'single',\n      removeOnClick: false\n    };\n    var baseUID = 0;\n\n    var BrushController = function (_super) {\n      __extends(BrushController, _super);\n\n      function BrushController(zr) {\n        var _this = _super.call(this) || this;\n\n        _this._track = [];\n        _this._covers = [];\n        _this._handlers = {};\n\n        if (\"development\" !== 'production') {\n          assert(zr);\n        }\n\n        _this._zr = zr;\n        _this.group = new Group();\n        _this._uid = 'brushController_' + baseUID++;\n        each(pointerHandlers, function (handler, eventName) {\n          this._handlers[eventName] = bind(handler, this);\n        }, _this);\n        return _this;\n      }\n\n      BrushController.prototype.enableBrush = function (brushOption) {\n        if (\"development\" !== 'production') {\n          assert(this._mounted);\n        }\n\n        this._brushType && this._doDisableBrush();\n        brushOption.brushType && this._doEnableBrush(brushOption);\n        return this;\n      };\n\n      BrushController.prototype._doEnableBrush = function (brushOption) {\n        var zr = this._zr;\n\n        if (!this._enableGlobalPan) {\n          take(zr, MUTEX_RESOURCE_KEY, this._uid);\n        }\n\n        each(this._handlers, function (handler, eventName) {\n          zr.on(eventName, handler);\n        });\n        this._brushType = brushOption.brushType;\n        this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);\n      };\n\n      BrushController.prototype._doDisableBrush = function () {\n        var zr = this._zr;\n        release(zr, MUTEX_RESOURCE_KEY, this._uid);\n        each(this._handlers, function (handler, eventName) {\n          zr.off(eventName, handler);\n        });\n        this._brushType = this._brushOption = null;\n      };\n\n      BrushController.prototype.setPanels = function (panelOpts) {\n        if (panelOpts && panelOpts.length) {\n          var panels_1 = this._panels = {};\n          each(panelOpts, function (panelOpts) {\n            panels_1[panelOpts.panelId] = clone(panelOpts);\n          });\n        } else {\n          this._panels = null;\n        }\n\n        return this;\n      };\n\n      BrushController.prototype.mount = function (opt) {\n        opt = opt || {};\n\n        if (\"development\" !== 'production') {\n          this._mounted = true;\n        }\n\n        this._enableGlobalPan = opt.enableGlobalPan;\n        var thisGroup = this.group;\n\n        this._zr.add(thisGroup);\n\n        thisGroup.attr({\n          x: opt.x || 0,\n          y: opt.y || 0,\n          rotation: opt.rotation || 0,\n          scaleX: opt.scaleX || 1,\n          scaleY: opt.scaleY || 1\n        });\n        this._transform = thisGroup.getLocalTransform();\n        return this;\n      };\n\n      BrushController.prototype.updateCovers = function (coverConfigList) {\n        if (\"development\" !== 'production') {\n          assert(this._mounted);\n        }\n\n        coverConfigList = map(coverConfigList, function (coverConfig) {\n          return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);\n        });\n        var tmpIdPrefix = '\\0-brush-index-';\n        var oldCovers = this._covers;\n        var newCovers = this._covers = [];\n        var controller = this;\n        var creatingCover = this._creatingCover;\n        new DataDiffer(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n        return this;\n\n        function getKey(brushOption, index) {\n          return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n        }\n\n        function oldGetKey(cover, index) {\n          return getKey(cover.__brushOption, index);\n        }\n\n        function addOrUpdate(newIndex, oldIndex) {\n          var newBrushInternal = coverConfigList[newIndex];\n\n          if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n            newCovers[newIndex] = oldCovers[oldIndex];\n          } else {\n            var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));\n            updateCoverAfterCreation(controller, cover);\n          }\n        }\n\n        function remove(oldIndex) {\n          if (oldCovers[oldIndex] !== creatingCover) {\n            controller.group.remove(oldCovers[oldIndex]);\n          }\n        }\n      };\n\n      BrushController.prototype.unmount = function () {\n        if (\"development\" !== 'production') {\n          if (!this._mounted) {\n            return;\n          }\n        }\n\n        this.enableBrush(false);\n        clearCovers(this);\n\n        this._zr.remove(this.group);\n\n        if (\"development\" !== 'production') {\n          this._mounted = false;\n        }\n\n        return this;\n      };\n\n      BrushController.prototype.dispose = function () {\n        this.unmount();\n        this.off();\n      };\n\n      return BrushController;\n    }(Eventful);\n\n    function createCover(controller, brushOption) {\n      var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n      cover.__brushOption = brushOption;\n      updateZ(cover, brushOption);\n      controller.group.add(cover);\n      return cover;\n    }\n\n    function endCreating(controller, creatingCover) {\n      var coverRenderer = getCoverRenderer(creatingCover);\n\n      if (coverRenderer.endCreating) {\n        coverRenderer.endCreating(controller, creatingCover);\n        updateZ(creatingCover, creatingCover.__brushOption);\n      }\n\n      return creatingCover;\n    }\n\n    function updateCoverShape(controller, cover) {\n      var brushOption = cover.__brushOption;\n      getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n    }\n\n    function updateZ(cover, brushOption) {\n      var z = brushOption.z;\n      z == null && (z = COVER_Z);\n      cover.traverse(function (el) {\n        el.z = z;\n        el.z2 = z;\n      });\n    }\n\n    function updateCoverAfterCreation(controller, cover) {\n      getCoverRenderer(cover).updateCommon(controller, cover);\n      updateCoverShape(controller, cover);\n    }\n\n    function getCoverRenderer(cover) {\n      return coverRenderers[cover.__brushOption.brushType];\n    }\n\n    function getPanelByPoint(controller, e, localCursorPoint) {\n      var panels = controller._panels;\n\n      if (!panels) {\n        return BRUSH_PANEL_GLOBAL;\n      }\n\n      var panel;\n      var transform = controller._transform;\n      each(panels, function (pn) {\n        pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n      });\n      return panel;\n    }\n\n    function getPanelByCover(controller, cover) {\n      var panels = controller._panels;\n\n      if (!panels) {\n        return BRUSH_PANEL_GLOBAL;\n      }\n\n      var panelId = cover.__brushOption.panelId;\n      return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;\n    }\n\n    function clearCovers(controller) {\n      var covers = controller._covers;\n      var originalLength = covers.length;\n      each(covers, function (cover) {\n        controller.group.remove(cover);\n      }, controller);\n      covers.length = 0;\n      return !!originalLength;\n    }\n\n    function trigger$1(controller, opt) {\n      var areas = map(controller._covers, function (cover) {\n        var brushOption = cover.__brushOption;\n        var range = clone(brushOption.range);\n        return {\n          brushType: brushOption.brushType,\n          panelId: brushOption.panelId,\n          range: range\n        };\n      });\n      controller.trigger('brush', {\n        areas: areas,\n        isEnd: !!opt.isEnd,\n        removeOnClick: !!opt.removeOnClick\n      });\n    }\n\n    function shouldShowCover(controller) {\n      var track = controller._track;\n\n      if (!track.length) {\n        return false;\n      }\n\n      var p2 = track[track.length - 1];\n      var p1 = track[0];\n      var dx = p2[0] - p1[0];\n      var dy = p2[1] - p1[1];\n      var dist = mathPow$2(dx * dx + dy * dy, 0.5);\n      return dist > UNSELECT_THRESHOLD;\n    }\n\n    function getTrackEnds(track) {\n      var tail = track.length - 1;\n      tail < 0 && (tail = 0);\n      return [track[0], track[tail]];\n    }\n\n    function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {\n      var cover = new Group();\n      cover.add(new Rect({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true,\n        draggable: true,\n        cursor: 'move',\n        drift: curry(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),\n        ondragend: curry(trigger$1, controller, {\n          isEnd: true\n        })\n      }));\n      each(edgeNameSequences, function (nameSequence) {\n        cover.add(new Rect({\n          name: nameSequence.join(''),\n          style: {\n            opacity: 0\n          },\n          draggable: true,\n          silent: true,\n          invisible: true,\n          drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),\n          ondragend: curry(trigger$1, controller, {\n            isEnd: true\n          })\n        }));\n      });\n      return cover;\n    }\n\n    function updateBaseRect(controller, cover, localRange, brushOption) {\n      var lineWidth = brushOption.brushStyle.lineWidth || 0;\n      var handleSize = mathMax$9(lineWidth, MIN_RESIZE_LINE_WIDTH);\n      var x = localRange[0][0];\n      var y = localRange[1][0];\n      var xa = x - lineWidth / 2;\n      var ya = y - lineWidth / 2;\n      var x2 = localRange[0][1];\n      var y2 = localRange[1][1];\n      var x2a = x2 - handleSize + lineWidth / 2;\n      var y2a = y2 - handleSize + lineWidth / 2;\n      var width = x2 - x;\n      var height = y2 - y;\n      var widtha = width + lineWidth;\n      var heighta = height + lineWidth;\n      updateRectShape(controller, cover, 'main', x, y, width, height);\n\n      if (brushOption.transformable) {\n        updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n        updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n        updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n        updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n        updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n        updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n        updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n        updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n      }\n    }\n\n    function updateCommon(controller, cover) {\n      var brushOption = cover.__brushOption;\n      var transformable = brushOption.transformable;\n      var mainEl = cover.childAt(0);\n      mainEl.useStyle(makeStyle(brushOption));\n      mainEl.attr({\n        silent: !transformable,\n        cursor: transformable ? 'move' : 'default'\n      });\n      each([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {\n        var el = cover.childOfName(nameSequence.join(''));\n        var globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);\n        el && el.attr({\n          silent: !transformable,\n          invisible: !transformable,\n          cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n        });\n      });\n    }\n\n    function updateRectShape(controller, cover, name, x, y, w, h) {\n      var el = cover.childOfName(name);\n      el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n    }\n\n    function makeStyle(brushOption) {\n      return defaults({\n        strokeNoScale: true\n      }, brushOption.brushStyle);\n    }\n\n    function formatRectRange(x, y, x2, y2) {\n      var min = [mathMin$9(x, x2), mathMin$9(y, y2)];\n      var max = [mathMax$9(x, x2), mathMax$9(y, y2)];\n      return [[min[0], max[0]], [min[1], max[1]]];\n    }\n\n    function getTransform$1(controller) {\n      return getTransform(controller.group);\n    }\n\n    function getGlobalDirection1(controller, localDirName) {\n      var map = {\n        w: 'left',\n        e: 'right',\n        n: 'top',\n        s: 'bottom'\n      };\n      var inverseMap = {\n        left: 'w',\n        right: 'e',\n        top: 'n',\n        bottom: 's'\n      };\n      var dir = transformDirection(map[localDirName], getTransform$1(controller));\n      return inverseMap[dir];\n    }\n\n    function getGlobalDirection2(controller, localDirNameSeq) {\n      var globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];\n      (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n      return globalDir.join('');\n    }\n\n    function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {\n      var brushOption = cover.__brushOption;\n      var rectRange = rectRangeConverter.toRectRange(brushOption.range);\n      var localDelta = toLocalDelta(controller, dx, dy);\n      each(dirNameSequence, function (dirName) {\n        var ind = DIRECTION_MAP[dirName];\n        rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n      });\n      brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n      updateCoverAfterCreation(controller, cover);\n      trigger$1(controller, {\n        isEnd: false\n      });\n    }\n\n    function driftPolygon(controller, cover, dx, dy) {\n      var range = cover.__brushOption.range;\n      var localDelta = toLocalDelta(controller, dx, dy);\n      each(range, function (point) {\n        point[0] += localDelta[0];\n        point[1] += localDelta[1];\n      });\n      updateCoverAfterCreation(controller, cover);\n      trigger$1(controller, {\n        isEnd: false\n      });\n    }\n\n    function toLocalDelta(controller, dx, dy) {\n      var thisGroup = controller.group;\n      var localD = thisGroup.transformCoordToLocal(dx, dy);\n      var localZero = thisGroup.transformCoordToLocal(0, 0);\n      return [localD[0] - localZero[0], localD[1] - localZero[1]];\n    }\n\n    function clipByPanel(controller, cover, data) {\n      var panel = getPanelByCover(controller, cover);\n      return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);\n    }\n\n    function pointsToRect(points) {\n      var xmin = mathMin$9(points[0][0], points[1][0]);\n      var ymin = mathMin$9(points[0][1], points[1][1]);\n      var xmax = mathMax$9(points[0][0], points[1][0]);\n      var ymax = mathMax$9(points[0][1], points[1][1]);\n      return {\n        x: xmin,\n        y: ymin,\n        width: xmax - xmin,\n        height: ymax - ymin\n      };\n    }\n\n    function resetCursor(controller, e, localCursorPoint) {\n      if (!controller._brushType || isOutsideZrArea(controller, e.offsetX, e.offsetY)) {\n        return;\n      }\n\n      var zr = controller._zr;\n      var covers = controller._covers;\n      var currPanel = getPanelByPoint(controller, e, localCursorPoint);\n\n      if (!controller._dragging) {\n        for (var i = 0; i < covers.length; i++) {\n          var brushOption = covers[i].__brushOption;\n\n          if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n            return;\n          }\n        }\n      }\n\n      currPanel && zr.setCursorStyle('crosshair');\n    }\n\n    function preventDefault(e) {\n      var rawE = e.event;\n      rawE.preventDefault && rawE.preventDefault();\n    }\n\n    function mainShapeContain(cover, x, y) {\n      return cover.childOfName('main').contain(x, y);\n    }\n\n    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n      var creatingCover = controller._creatingCover;\n      var panel = controller._creatingPanel;\n      var thisBrushOption = controller._brushOption;\n      var eventParams;\n\n      controller._track.push(localCursorPoint.slice());\n\n      if (shouldShowCover(controller) || creatingCover) {\n        if (panel && !creatingCover) {\n          thisBrushOption.brushMode === 'single' && clearCovers(controller);\n          var brushOption = clone(thisBrushOption);\n          brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n          brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;\n          creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n          controller._covers.push(creatingCover);\n        }\n\n        if (creatingCover) {\n          var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n          var coverBrushOption = creatingCover.__brushOption;\n          coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n          if (isEnd) {\n            endCreating(controller, creatingCover);\n            coverRenderer.updateCommon(controller, creatingCover);\n          }\n\n          updateCoverShape(controller, creatingCover);\n          eventParams = {\n            isEnd: isEnd\n          };\n        }\n      } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n        if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n          eventParams = {\n            isEnd: isEnd,\n            removeOnClick: true\n          };\n        }\n      }\n\n      return eventParams;\n    }\n\n    function determineBrushType(brushType, panel) {\n      if (brushType === 'auto') {\n        if (\"development\" !== 'production') {\n          assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is \"atuo\"');\n        }\n\n        return panel.defaultBrushType;\n      }\n\n      return brushType;\n    }\n\n    var pointerHandlers = {\n      mousedown: function (e) {\n        if (this._dragging) {\n          handleDragEnd(this, e);\n        } else if (!e.target || !e.target.draggable) {\n          preventDefault(e);\n          var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n          this._creatingCover = null;\n          var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n          if (panel) {\n            this._dragging = true;\n            this._track = [localCursorPoint.slice()];\n          }\n        }\n      },\n      mousemove: function (e) {\n        var x = e.offsetX;\n        var y = e.offsetY;\n        var localCursorPoint = this.group.transformCoordToLocal(x, y);\n        resetCursor(this, e, localCursorPoint);\n\n        if (this._dragging) {\n          preventDefault(e);\n          var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n          eventParams && trigger$1(this, eventParams);\n        }\n      },\n      mouseup: function (e) {\n        handleDragEnd(this, e);\n      }\n    };\n\n    function handleDragEnd(controller, e) {\n      if (controller._dragging) {\n        preventDefault(e);\n        var x = e.offsetX;\n        var y = e.offsetY;\n        var localCursorPoint = controller.group.transformCoordToLocal(x, y);\n        var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n        controller._dragging = false;\n        controller._track = [];\n        controller._creatingCover = null;\n        eventParams && trigger$1(controller, eventParams);\n      }\n    }\n\n    function isOutsideZrArea(controller, x, y) {\n      var zr = controller._zr;\n      return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();\n    }\n\n    var coverRenderers = {\n      lineX: getLineRenderer(0),\n      lineY: getLineRenderer(1),\n      rect: {\n        createCover: function (controller, brushOption) {\n          function returnInput(range) {\n            return range;\n          }\n\n          return createBaseRectCover({\n            toRectRange: returnInput,\n            fromRectRange: returnInput\n          }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']]);\n        },\n        getCreatingRange: function (localTrack) {\n          var ends = getTrackEnds(localTrack);\n          return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n          updateBaseRect(controller, cover, localRange, brushOption);\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n      },\n      polygon: {\n        createCover: function (controller, brushOption) {\n          var cover = new Group();\n          cover.add(new Polyline({\n            name: 'main',\n            style: makeStyle(brushOption),\n            silent: true\n          }));\n          return cover;\n        },\n        getCreatingRange: function (localTrack) {\n          return localTrack;\n        },\n        endCreating: function (controller, cover) {\n          cover.remove(cover.childAt(0));\n          cover.add(new Polygon({\n            name: 'main',\n            draggable: true,\n            drift: curry(driftPolygon, controller, cover),\n            ondragend: curry(trigger$1, controller, {\n              isEnd: true\n            })\n          }));\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n          cover.childAt(0).setShape({\n            points: clipByPanel(controller, cover, localRange)\n          });\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n      }\n    };\n\n    function getLineRenderer(xyIndex) {\n      return {\n        createCover: function (controller, brushOption) {\n          return createBaseRectCover({\n            toRectRange: function (range) {\n              var rectRange = [range, [0, 100]];\n              xyIndex && rectRange.reverse();\n              return rectRange;\n            },\n            fromRectRange: function (rectRange) {\n              return rectRange[xyIndex];\n            }\n          }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex]);\n        },\n        getCreatingRange: function (localTrack) {\n          var ends = getTrackEnds(localTrack);\n          var min = mathMin$9(ends[0][xyIndex], ends[1][xyIndex]);\n          var max = mathMax$9(ends[0][xyIndex], ends[1][xyIndex]);\n          return [min, max];\n        },\n        updateCoverShape: function (controller, cover, localRange, brushOption) {\n          var otherExtent;\n          var panel = getPanelByCover(controller, cover);\n\n          if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {\n            otherExtent = panel.getLinearBrushOtherExtent(xyIndex);\n          } else {\n            var zr = controller._zr;\n            otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n          }\n\n          var rectRange = [localRange, otherExtent];\n          xyIndex && rectRange.reverse();\n          updateBaseRect(controller, cover, rectRange, brushOption);\n        },\n        updateCommon: updateCommon,\n        contain: mainShapeContain\n      };\n    }\n\n    function makeRectPanelClipPath(rect) {\n      rect = normalizeRect(rect);\n      return function (localPoints) {\n        return clipPointsByRect(localPoints, rect);\n      };\n    }\n    function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {\n      rect = normalizeRect(rect);\n      return function (xyIndex) {\n        var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;\n        var brushWidth = idx ? rect.width : rect.height;\n        var base = idx ? rect.x : rect.y;\n        return [base, base + (brushWidth || 0)];\n      };\n    }\n    function makeRectIsTargetByCursor(rect, api, targetModel) {\n      var boundingRect = normalizeRect(rect);\n      return function (e, localCursorPoint) {\n        return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);\n      };\n    }\n\n    function normalizeRect(rect) {\n      return BoundingRect.create(rect);\n    }\n\n    var elementList = ['axisLine', 'axisTickLabel', 'axisName'];\n\n    var ParallelAxisView = function (_super) {\n      __extends(ParallelAxisView, _super);\n\n      function ParallelAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ParallelAxisView.type;\n        return _this;\n      }\n\n      ParallelAxisView.prototype.init = function (ecModel, api) {\n        _super.prototype.init.apply(this, arguments);\n\n        (this._brushController = new BrushController(api.getZr())).on('brush', bind(this._onBrush, this));\n      };\n\n      ParallelAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n        if (fromAxisAreaSelect(axisModel, ecModel, payload)) {\n          return;\n        }\n\n        this.axisModel = axisModel;\n        this.api = api;\n        this.group.removeAll();\n        var oldAxisGroup = this._axisGroup;\n        this._axisGroup = new Group();\n        this.group.add(this._axisGroup);\n\n        if (!axisModel.get('show')) {\n          return;\n        }\n\n        var coordSysModel = getCoordSysModel(axisModel, ecModel);\n        var coordSys = coordSysModel.coordinateSystem;\n        var areaSelectStyle = axisModel.getAreaSelectStyle();\n        var areaWidth = areaSelectStyle.width;\n        var dim = axisModel.axis.dim;\n        var axisLayout = coordSys.getAxisLayout(dim);\n        var builderOpt = extend({\n          strokeContainThreshold: areaWidth\n        }, axisLayout);\n        var axisBuilder = new AxisBuilder(axisModel, builderOpt);\n        each(elementList, axisBuilder.add, axisBuilder);\n\n        this._axisGroup.add(axisBuilder.getGroup());\n\n        this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);\n\n        groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n      };\n\n      ParallelAxisView.prototype._refreshBrushController = function (builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {\n        var extent = axisModel.axis.getExtent();\n        var extentLen = extent[1] - extent[0];\n        var extra = Math.min(30, Math.abs(extentLen) * 0.1);\n        var rect = BoundingRect.create({\n          x: extent[0],\n          y: -areaWidth / 2,\n          width: extentLen,\n          height: areaWidth\n        });\n        rect.x -= extra;\n        rect.width += 2 * extra;\n\n        this._brushController.mount({\n          enableGlobalPan: true,\n          rotation: builderOpt.rotation,\n          x: builderOpt.position[0],\n          y: builderOpt.position[1]\n        }).setPanels([{\n          panelId: 'pl',\n          clipPath: makeRectPanelClipPath(rect),\n          isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),\n          getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)\n        }]).enableBrush({\n          brushType: 'lineX',\n          brushStyle: areaSelectStyle,\n          removeOnClick: true\n        }).updateCovers(getCoverInfoList(axisModel));\n      };\n\n      ParallelAxisView.prototype._onBrush = function (eventParam) {\n        var coverInfoList = eventParam.areas;\n        var axisModel = this.axisModel;\n        var axis = axisModel.axis;\n        var intervals = map(coverInfoList, function (coverInfo) {\n          return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];\n        });\n\n        if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {\n          this.api.dispatchAction({\n            type: 'axisAreaSelect',\n            parallelAxisId: axisModel.id,\n            intervals: intervals\n          });\n        }\n      };\n\n      ParallelAxisView.prototype.dispose = function () {\n        this._brushController.dispose();\n      };\n\n      ParallelAxisView.type = 'parallelAxis';\n      return ParallelAxisView;\n    }(ComponentView);\n\n    function fromAxisAreaSelect(axisModel, ecModel, payload) {\n      return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({\n        mainType: 'parallelAxis',\n        query: payload\n      })[0] === axisModel;\n    }\n\n    function getCoverInfoList(axisModel) {\n      var axis = axisModel.axis;\n      return map(axisModel.activeIntervals, function (interval) {\n        return {\n          brushType: 'lineX',\n          panelId: 'pl',\n          range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]\n        };\n      });\n    }\n\n    function getCoordSysModel(axisModel, ecModel) {\n      return ecModel.getComponent('parallel', axisModel.get('parallelIndex'));\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var actionInfo$1 = {\n      type: 'axisAreaSelect',\n      event: 'axisAreaSelected'\n    };\n    function installParallelActions(registers) {\n      registers.registerAction(actionInfo$1, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'parallelAxis',\n          query: payload\n        }, function (parallelAxisModel) {\n          parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);\n        });\n      });\n      registers.registerAction('parallelAxisExpand', function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'parallel',\n          query: payload\n        }, function (parallelModel) {\n          parallelModel.setAxisExpand(payload);\n        });\n      });\n    }\n\n    var defaultAxisOption = {\n      type: 'value',\n      areaSelectStyle: {\n        width: 20,\n        borderWidth: 1,\n        borderColor: 'rgba(160,197,232)',\n        color: 'rgba(160,197,232)',\n        opacity: 0.3\n      },\n      realtime: true,\n      z: 10\n    };\n    function install$f(registers) {\n      registers.registerComponentView(ParallelView$1);\n      registers.registerComponentModel(ParallelModel);\n      registers.registerCoordinateSystem('parallel', parallelCoordSysCreator);\n      registers.registerPreprocessor(parallelPreprocessor);\n      registers.registerComponentModel(ParallelAxisModel);\n      registers.registerComponentView(ParallelAxisView);\n      axisModelCreator(registers, 'parallel', ParallelAxisModel, defaultAxisOption);\n      installParallelActions(registers);\n    }\n\n    function install$g(registers) {\n      use(install$f);\n      registers.registerChartView(ParallelView);\n      registers.registerSeriesModel(ParallelSeriesModel);\n      registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual);\n    }\n\n    var SankeyPathShape = function () {\n      function SankeyPathShape() {\n        this.x1 = 0;\n        this.y1 = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this.cpx1 = 0;\n        this.cpy1 = 0;\n        this.cpx2 = 0;\n        this.cpy2 = 0;\n        this.extent = 0;\n      }\n\n      return SankeyPathShape;\n    }();\n\n    var SankeyPath = function (_super) {\n      __extends(SankeyPath, _super);\n\n      function SankeyPath(opts) {\n        return _super.call(this, opts) || this;\n      }\n\n      SankeyPath.prototype.getDefaultShape = function () {\n        return new SankeyPathShape();\n      };\n\n      SankeyPath.prototype.buildPath = function (ctx, shape) {\n        var extent = shape.extent;\n        ctx.moveTo(shape.x1, shape.y1);\n        ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);\n\n        if (shape.orient === 'vertical') {\n          ctx.lineTo(shape.x2 + extent, shape.y2);\n          ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);\n        } else {\n          ctx.lineTo(shape.x2, shape.y2 + extent);\n          ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);\n        }\n\n        ctx.closePath();\n      };\n\n      SankeyPath.prototype.highlight = function () {\n        enterEmphasis(this);\n      };\n\n      SankeyPath.prototype.downplay = function () {\n        leaveEmphasis(this);\n      };\n\n      return SankeyPath;\n    }(Path);\n\n    var SankeyView = function (_super) {\n      __extends(SankeyView, _super);\n\n      function SankeyView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SankeyView.type;\n        _this._focusAdjacencyDisabled = false;\n        return _this;\n      }\n\n      SankeyView.prototype.render = function (seriesModel, ecModel, api) {\n        var sankeyView = this;\n        var graph = seriesModel.getGraph();\n        var group = this.group;\n        var layoutInfo = seriesModel.layoutInfo;\n        var width = layoutInfo.width;\n        var height = layoutInfo.height;\n        var nodeData = seriesModel.getData();\n        var edgeData = seriesModel.getData('edge');\n        var orient = seriesModel.get('orient');\n        this._model = seriesModel;\n        group.removeAll();\n        group.x = layoutInfo.x;\n        group.y = layoutInfo.y;\n        graph.eachEdge(function (edge) {\n          var curve = new SankeyPath();\n          var ecData = getECData(curve);\n          ecData.dataIndex = edge.dataIndex;\n          ecData.seriesIndex = seriesModel.seriesIndex;\n          ecData.dataType = 'edge';\n          var edgeModel = edge.getModel();\n          var lineStyleModel = edgeModel.getModel('lineStyle');\n          var curvature = lineStyleModel.get('curveness');\n          var n1Layout = edge.node1.getLayout();\n          var node1Model = edge.node1.getModel();\n          var dragX1 = node1Model.get('localX');\n          var dragY1 = node1Model.get('localY');\n          var n2Layout = edge.node2.getLayout();\n          var node2Model = edge.node2.getModel();\n          var dragX2 = node2Model.get('localX');\n          var dragY2 = node2Model.get('localY');\n          var edgeLayout = edge.getLayout();\n          var x1;\n          var y1;\n          var x2;\n          var y2;\n          var cpx1;\n          var cpy1;\n          var cpx2;\n          var cpy2;\n          curve.shape.extent = Math.max(1, edgeLayout.dy);\n          curve.shape.orient = orient;\n\n          if (orient === 'vertical') {\n            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;\n            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;\n            x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;\n            y2 = dragY2 != null ? dragY2 * height : n2Layout.y;\n            cpx1 = x1;\n            cpy1 = y1 * (1 - curvature) + y2 * curvature;\n            cpx2 = x2;\n            cpy2 = y1 * curvature + y2 * (1 - curvature);\n          } else {\n            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;\n            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;\n            x2 = dragX2 != null ? dragX2 * width : n2Layout.x;\n            y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;\n            cpx1 = x1 * (1 - curvature) + x2 * curvature;\n            cpy1 = y1;\n            cpx2 = x1 * curvature + x2 * (1 - curvature);\n            cpy2 = y2;\n          }\n\n          curve.setShape({\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2,\n            cpx1: cpx1,\n            cpy1: cpy1,\n            cpx2: cpx2,\n            cpy2: cpy2\n          });\n          curve.useStyle(lineStyleModel.getItemStyle());\n\n          switch (curve.style.fill) {\n            case 'source':\n              curve.style.fill = edge.node1.getVisual('color');\n              curve.style.decal = edge.node1.getVisual('style').decal;\n              break;\n\n            case 'target':\n              curve.style.fill = edge.node2.getVisual('color');\n              curve.style.decal = edge.node2.getVisual('style').decal;\n              break;\n\n            case 'gradient':\n              var sourceColor = edge.node1.getVisual('color');\n              var targetColor = edge.node2.getVisual('color');\n\n              if (typeof sourceColor === 'string' && typeof targetColor === 'string') {\n                curve.style.fill = new LinearGradient(0, 0, 1, 0, [{\n                  color: sourceColor,\n                  offset: 0\n                }, {\n                  color: targetColor,\n                  offset: 1\n                }]);\n              }\n\n          }\n\n          var emphasisModel = edgeModel.getModel('emphasis');\n          setStatesStylesFromModel(curve, edgeModel, 'lineStyle', function (model) {\n            return model.getItemStyle();\n          });\n          group.add(curve);\n          edgeData.setItemGraphicEl(edge.dataIndex, curve);\n          var focus = emphasisModel.get('focus');\n          enableHoverEmphasis(curve, focus === 'adjacency' ? edge.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'));\n          getECData(curve).dataType = 'edge';\n        });\n        graph.eachNode(function (node) {\n          var layout = node.getLayout();\n          var itemModel = node.getModel();\n          var dragX = itemModel.get('localX');\n          var dragY = itemModel.get('localY');\n          var emphasisModel = itemModel.getModel('emphasis');\n          var rect = new Rect({\n            shape: {\n              x: dragX != null ? dragX * width : layout.x,\n              y: dragY != null ? dragY * height : layout.y,\n              width: layout.dx,\n              height: layout.dy\n            },\n            style: itemModel.getModel('itemStyle').getItemStyle()\n          });\n          setLabelStyle(rect, getLabelStatesModels(itemModel), {\n            labelFetcher: seriesModel,\n            labelDataIndex: node.dataIndex,\n            defaultText: node.id\n          });\n          rect.disableLabelAnimation = true;\n          rect.setStyle('fill', node.getVisual('color'));\n          rect.setStyle('decal', node.getVisual('style').decal);\n          setStatesStylesFromModel(rect, itemModel);\n          group.add(rect);\n          nodeData.setItemGraphicEl(node.dataIndex, rect);\n          getECData(rect).dataType = 'node';\n          var focus = emphasisModel.get('focus');\n          enableHoverEmphasis(rect, focus === 'adjacency' ? node.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'));\n        });\n        nodeData.eachItemGraphicEl(function (el, dataIndex) {\n          var itemModel = nodeData.getItemModel(dataIndex);\n\n          if (itemModel.get('draggable')) {\n            el.drift = function (dx, dy) {\n              sankeyView._focusAdjacencyDisabled = true;\n              this.shape.x += dx;\n              this.shape.y += dy;\n              this.dirty();\n              api.dispatchAction({\n                type: 'dragNode',\n                seriesId: seriesModel.id,\n                dataIndex: nodeData.getRawIndex(dataIndex),\n                localX: this.shape.x / width,\n                localY: this.shape.y / height\n              });\n            };\n\n            el.ondragend = function () {\n              sankeyView._focusAdjacencyDisabled = false;\n            };\n\n            el.draggable = true;\n            el.cursor = 'move';\n          }\n        });\n\n        if (!this._data && seriesModel.isAnimationEnabled()) {\n          group.setClipPath(createGridClipShape$1(group.getBoundingRect(), seriesModel, function () {\n            group.removeClipPath();\n          }));\n        }\n\n        this._data = seriesModel.getData();\n      };\n\n      SankeyView.prototype.dispose = function () {};\n\n      SankeyView.type = 'sankey';\n      return SankeyView;\n    }(ChartView);\n\n    function createGridClipShape$1(rect, seriesModel, cb) {\n      var rectEl = new Rect({\n        shape: {\n          x: rect.x - 10,\n          y: rect.y - 10,\n          width: 0,\n          height: rect.height + 20\n        }\n      });\n      initProps(rectEl, {\n        shape: {\n          width: rect.width + 20\n        }\n      }, seriesModel, cb);\n      return rectEl;\n    }\n\n    var SankeySeriesModel = function (_super) {\n      __extends(SankeySeriesModel, _super);\n\n      function SankeySeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SankeySeriesModel.type;\n        return _this;\n      }\n\n      SankeySeriesModel.prototype.getInitialData = function (option, ecModel) {\n        var links = option.edges || option.links;\n        var nodes = option.data || option.nodes;\n        var levels = option.levels;\n        this.levelModels = [];\n        var levelModels = this.levelModels;\n\n        for (var i = 0; i < levels.length; i++) {\n          if (levels[i].depth != null && levels[i].depth >= 0) {\n            levelModels[levels[i].depth] = new Model(levels[i], this, ecModel);\n          } else {\n            if (\"development\" !== 'production') {\n              throw new Error('levels[i].depth is mandatory and should be natural number');\n            }\n          }\n        }\n\n        if (nodes && links) {\n          var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);\n          return graph.data;\n        }\n\n        function beforeLink(nodeData, edgeData) {\n          nodeData.wrapMethod('getItemModel', function (model, idx) {\n            var seriesModel = model.parentModel;\n            var layout = seriesModel.getData().getItemLayout(idx);\n\n            if (layout) {\n              var nodeDepth = layout.depth;\n              var levelModel = seriesModel.levelModels[nodeDepth];\n\n              if (levelModel) {\n                model.parentModel = levelModel;\n              }\n            }\n\n            return model;\n          });\n          edgeData.wrapMethod('getItemModel', function (model, idx) {\n            var seriesModel = model.parentModel;\n            var edge = seriesModel.getGraph().getEdgeByIndex(idx);\n            var layout = edge.node1.getLayout();\n\n            if (layout) {\n              var depth = layout.depth;\n              var levelModel = seriesModel.levelModels[depth];\n\n              if (levelModel) {\n                model.parentModel = levelModel;\n              }\n            }\n\n            return model;\n          });\n        }\n      };\n\n      SankeySeriesModel.prototype.setNodePosition = function (dataIndex, localPosition) {\n        var dataItem = this.option.data[dataIndex];\n        dataItem.localX = localPosition[0];\n        dataItem.localY = localPosition[1];\n      };\n\n      SankeySeriesModel.prototype.getGraph = function () {\n        return this.getData().graph;\n      };\n\n      SankeySeriesModel.prototype.getEdgeData = function () {\n        return this.getGraph().edgeData;\n      };\n\n      SankeySeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        function noValue(val) {\n          return isNaN(val) || val == null;\n        }\n\n        if (dataType === 'edge') {\n          var params = this.getDataParams(dataIndex, dataType);\n          var rawDataOpt = params.data;\n          var edgeValue = params.value;\n          var edgeName = rawDataOpt.source + ' -- ' + rawDataOpt.target;\n          return createTooltipMarkup('nameValue', {\n            name: edgeName,\n            value: edgeValue,\n            noValue: noValue(edgeValue)\n          });\n        } else {\n          var node = this.getGraph().getNodeByIndex(dataIndex);\n          var value = node.getLayout().value;\n          var name_1 = this.getDataParams(dataIndex, dataType).data.name;\n          return createTooltipMarkup('nameValue', {\n            name: name_1 != null ? name_1 + '' : null,\n            value: value,\n            noValue: noValue(value)\n          });\n        }\n      };\n\n      SankeySeriesModel.prototype.optionUpdated = function () {\n        var option = this.option;\n\n        if (option.focusNodeAdjacency === true) {\n          option.focusNodeAdjacency = 'allEdges';\n        }\n      };\n\n      SankeySeriesModel.prototype.getDataParams = function (dataIndex, dataType) {\n        var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n\n        if (params.value == null && dataType === 'node') {\n          var node = this.getGraph().getNodeByIndex(dataIndex);\n          var nodeValue = node.getLayout().value;\n          params.value = nodeValue;\n        }\n\n        return params;\n      };\n\n      SankeySeriesModel.type = 'series.sankey';\n      SankeySeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'view',\n        left: '5%',\n        top: '5%',\n        right: '20%',\n        bottom: '5%',\n        orient: 'horizontal',\n        nodeWidth: 20,\n        nodeGap: 8,\n        draggable: true,\n        focusNodeAdjacency: false,\n        layoutIterations: 32,\n        label: {\n          show: true,\n          position: 'right',\n          fontSize: 12\n        },\n        levels: [],\n        nodeAlign: 'justify',\n        lineStyle: {\n          color: '#314656',\n          opacity: 0.2,\n          curveness: 0.5\n        },\n        emphasis: {\n          label: {\n            show: true\n          },\n          lineStyle: {\n            opacity: 0.5\n          }\n        },\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        },\n        animationEasing: 'linear',\n        animationDuration: 1000\n      };\n      return SankeySeriesModel;\n    }(SeriesModel);\n\n    function sankeyLayout(ecModel, api) {\n      ecModel.eachSeriesByType('sankey', function (seriesModel) {\n        var nodeWidth = seriesModel.get('nodeWidth');\n        var nodeGap = seriesModel.get('nodeGap');\n        var layoutInfo = getViewRect$4(seriesModel, api);\n        seriesModel.layoutInfo = layoutInfo;\n        var width = layoutInfo.width;\n        var height = layoutInfo.height;\n        var graph = seriesModel.getGraph();\n        var nodes = graph.nodes;\n        var edges = graph.edges;\n        computeNodeValues(nodes);\n        var filteredNodes = filter(nodes, function (node) {\n          return node.getLayout().value === 0;\n        });\n        var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n        var orient = seriesModel.get('orient');\n        var nodeAlign = seriesModel.get('nodeAlign');\n        layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n      });\n    }\n\n    function getViewRect$4(seriesModel, api) {\n      return getLayoutRect(seriesModel.getBoxLayoutParams(), {\n        width: api.getWidth(),\n        height: api.getHeight()\n      });\n    }\n\n    function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n      computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n      computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n      computeEdgeDepths(nodes, orient);\n    }\n\n    function computeNodeValues(nodes) {\n      each(nodes, function (node) {\n        var value1 = sum(node.outEdges, getEdgeValue);\n        var value2 = sum(node.inEdges, getEdgeValue);\n        var nodeRawValue = node.getValue() || 0;\n        var value = Math.max(value1, value2, nodeRawValue);\n        node.setLayout({\n          value: value\n        }, true);\n      });\n    }\n\n    function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n      var remainEdges = [];\n      var indegreeArr = [];\n      var zeroIndegrees = [];\n      var nextTargetNode = [];\n      var x = 0;\n\n      for (var i = 0; i < edges.length; i++) {\n        remainEdges[i] = 1;\n      }\n\n      for (var i = 0; i < nodes.length; i++) {\n        indegreeArr[i] = nodes[i].inEdges.length;\n\n        if (indegreeArr[i] === 0) {\n          zeroIndegrees.push(nodes[i]);\n        }\n      }\n\n      var maxNodeDepth = -1;\n\n      while (zeroIndegrees.length) {\n        for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n          var node = zeroIndegrees[idx];\n          var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n          var isItemDepth = item.depth != null && item.depth >= 0;\n\n          if (isItemDepth && item.depth > maxNodeDepth) {\n            maxNodeDepth = item.depth;\n          }\n\n          node.setLayout({\n            depth: isItemDepth ? item.depth : x\n          }, true);\n          orient === 'vertical' ? node.setLayout({\n            dy: nodeWidth\n          }, true) : node.setLayout({\n            dx: nodeWidth\n          }, true);\n\n          for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n            var edge = node.outEdges[edgeIdx];\n            var indexEdge = edges.indexOf(edge);\n            remainEdges[indexEdge] = 0;\n            var targetNode = edge.node2;\n            var nodeIndex = nodes.indexOf(targetNode);\n\n            if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n              nextTargetNode.push(targetNode);\n            }\n          }\n        }\n\n        ++x;\n        zeroIndegrees = nextTargetNode;\n        nextTargetNode = [];\n      }\n\n      for (var i = 0; i < remainEdges.length; i++) {\n        if (remainEdges[i] === 1) {\n          throw new Error('Sankey is a DAG, the original data has cycle!');\n        }\n      }\n\n      var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n\n      if (nodeAlign && nodeAlign !== 'left') {\n        adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n      }\n\n      var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n      scaleNodeBreadths(nodes, kx, orient);\n    }\n\n    function isNodeDepth(node) {\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      return item.depth != null && item.depth >= 0;\n    }\n\n    function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n      if (nodeAlign === 'right') {\n        var nextSourceNode = [];\n        var remainNodes = nodes;\n        var nodeHeight = 0;\n\n        while (remainNodes.length) {\n          for (var i = 0; i < remainNodes.length; i++) {\n            var node = remainNodes[i];\n            node.setLayout({\n              skNodeHeight: nodeHeight\n            }, true);\n\n            for (var j = 0; j < node.inEdges.length; j++) {\n              var edge = node.inEdges[j];\n\n              if (nextSourceNode.indexOf(edge.node1) < 0) {\n                nextSourceNode.push(edge.node1);\n              }\n            }\n          }\n\n          remainNodes = nextSourceNode;\n          nextSourceNode = [];\n          ++nodeHeight;\n        }\n\n        each(nodes, function (node) {\n          if (!isNodeDepth(node)) {\n            node.setLayout({\n              depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n            }, true);\n          }\n        });\n      } else if (nodeAlign === 'justify') {\n        moveSinksRight(nodes, maxDepth);\n      }\n    }\n\n    function moveSinksRight(nodes, maxDepth) {\n      each(nodes, function (node) {\n        if (!isNodeDepth(node) && !node.outEdges.length) {\n          node.setLayout({\n            depth: maxDepth\n          }, true);\n        }\n      });\n    }\n\n    function scaleNodeBreadths(nodes, kx, orient) {\n      each(nodes, function (node) {\n        var nodeDepth = node.getLayout().depth * kx;\n        orient === 'vertical' ? node.setLayout({\n          y: nodeDepth\n        }, true) : node.setLayout({\n          x: nodeDepth\n        }, true);\n      });\n    }\n\n    function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n      var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n      initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n\n      for (var alpha = 1; iterations > 0; iterations--) {\n        alpha *= 0.99;\n        relaxRightToLeft(nodesByBreadth, alpha, orient);\n        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n        relaxLeftToRight(nodesByBreadth, alpha, orient);\n        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n      }\n    }\n\n    function prepareNodesByBreadth(nodes, orient) {\n      var nodesByBreadth = [];\n      var keyAttr = orient === 'vertical' ? 'y' : 'x';\n      var groupResult = groupData(nodes, function (node) {\n        return node.getLayout()[keyAttr];\n      });\n      groupResult.keys.sort(function (a, b) {\n        return a - b;\n      });\n      each(groupResult.keys, function (key) {\n        nodesByBreadth.push(groupResult.buckets.get(key));\n      });\n      return nodesByBreadth;\n    }\n\n    function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n      var minKy = Infinity;\n      each(nodesByBreadth, function (nodes) {\n        var n = nodes.length;\n        var sum = 0;\n        each(nodes, function (node) {\n          sum += node.getLayout().value;\n        });\n        var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n\n        if (ky < minKy) {\n          minKy = ky;\n        }\n      });\n      each(nodesByBreadth, function (nodes) {\n        each(nodes, function (node, i) {\n          var nodeDy = node.getLayout().value * minKy;\n\n          if (orient === 'vertical') {\n            node.setLayout({\n              x: i\n            }, true);\n            node.setLayout({\n              dx: nodeDy\n            }, true);\n          } else {\n            node.setLayout({\n              y: i\n            }, true);\n            node.setLayout({\n              dy: nodeDy\n            }, true);\n          }\n        });\n      });\n      each(edges, function (edge) {\n        var edgeDy = +edge.getValue() * minKy;\n        edge.setLayout({\n          dy: edgeDy\n        }, true);\n      });\n    }\n\n    function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n      var keyAttr = orient === 'vertical' ? 'x' : 'y';\n      each(nodesByBreadth, function (nodes) {\n        nodes.sort(function (a, b) {\n          return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n        });\n        var nodeX;\n        var node;\n        var dy;\n        var y0 = 0;\n        var n = nodes.length;\n        var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n\n        for (var i = 0; i < n; i++) {\n          node = nodes[i];\n          dy = y0 - node.getLayout()[keyAttr];\n\n          if (dy > 0) {\n            nodeX = node.getLayout()[keyAttr] + dy;\n            orient === 'vertical' ? node.setLayout({\n              x: nodeX\n            }, true) : node.setLayout({\n              y: nodeX\n            }, true);\n          }\n\n          y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n        }\n\n        var viewWidth = orient === 'vertical' ? width : height;\n        dy = y0 - nodeGap - viewWidth;\n\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n          y0 = nodeX;\n\n          for (var i = n - 2; i >= 0; --i) {\n            node = nodes[i];\n            dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n\n            if (dy > 0) {\n              nodeX = node.getLayout()[keyAttr] - dy;\n              orient === 'vertical' ? node.setLayout({\n                x: nodeX\n              }, true) : node.setLayout({\n                y: nodeX\n              }, true);\n            }\n\n            y0 = node.getLayout()[keyAttr];\n          }\n        }\n      });\n    }\n\n    function relaxRightToLeft(nodesByBreadth, alpha, orient) {\n      each(nodesByBreadth.slice().reverse(), function (nodes) {\n        each(nodes, function (node) {\n          if (node.outEdges.length) {\n            var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);\n\n            if (isNaN(y)) {\n              var len = node.outEdges.length;\n              y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;\n            }\n\n            if (orient === 'vertical') {\n              var nodeX = node.getLayout().x + (y - center$1(node, orient)) * alpha;\n              node.setLayout({\n                x: nodeX\n              }, true);\n            } else {\n              var nodeY = node.getLayout().y + (y - center$1(node, orient)) * alpha;\n              node.setLayout({\n                y: nodeY\n              }, true);\n            }\n          }\n        });\n      });\n    }\n\n    function weightedTarget(edge, orient) {\n      return center$1(edge.node2, orient) * edge.getValue();\n    }\n\n    function centerTarget(edge, orient) {\n      return center$1(edge.node2, orient);\n    }\n\n    function weightedSource(edge, orient) {\n      return center$1(edge.node1, orient) * edge.getValue();\n    }\n\n    function centerSource(edge, orient) {\n      return center$1(edge.node1, orient);\n    }\n\n    function center$1(node, orient) {\n      return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n    }\n\n    function getEdgeValue(edge) {\n      return edge.getValue();\n    }\n\n    function sum(array, cb, orient) {\n      var sum = 0;\n      var len = array.length;\n      var i = -1;\n\n      while (++i < len) {\n        var value = +cb(array[i], orient);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n\n      return sum;\n    }\n\n    function relaxLeftToRight(nodesByBreadth, alpha, orient) {\n      each(nodesByBreadth, function (nodes) {\n        each(nodes, function (node) {\n          if (node.inEdges.length) {\n            var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);\n\n            if (isNaN(y)) {\n              var len = node.inEdges.length;\n              y = len ? sum(node.inEdges, centerSource, orient) / len : 0;\n            }\n\n            if (orient === 'vertical') {\n              var nodeX = node.getLayout().x + (y - center$1(node, orient)) * alpha;\n              node.setLayout({\n                x: nodeX\n              }, true);\n            } else {\n              var nodeY = node.getLayout().y + (y - center$1(node, orient)) * alpha;\n              node.setLayout({\n                y: nodeY\n              }, true);\n            }\n          }\n        });\n      });\n    }\n\n    function computeEdgeDepths(nodes, orient) {\n      var keyAttr = orient === 'vertical' ? 'x' : 'y';\n      each(nodes, function (node) {\n        node.outEdges.sort(function (a, b) {\n          return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n        });\n        node.inEdges.sort(function (a, b) {\n          return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n        });\n      });\n      each(nodes, function (node) {\n        var sy = 0;\n        var ty = 0;\n        each(node.outEdges, function (edge) {\n          edge.setLayout({\n            sy: sy\n          }, true);\n          sy += edge.getLayout().dy;\n        });\n        each(node.inEdges, function (edge) {\n          edge.setLayout({\n            ty: ty\n          }, true);\n          ty += edge.getLayout().dy;\n        });\n      });\n    }\n\n    function sankeyVisual(ecModel) {\n      ecModel.eachSeriesByType('sankey', function (seriesModel) {\n        var graph = seriesModel.getGraph();\n        var nodes = graph.nodes;\n\n        if (nodes.length) {\n          var minValue_1 = Infinity;\n          var maxValue_1 = -Infinity;\n          each(nodes, function (node) {\n            var nodeValue = node.getLayout().value;\n\n            if (nodeValue < minValue_1) {\n              minValue_1 = nodeValue;\n            }\n\n            if (nodeValue > maxValue_1) {\n              maxValue_1 = nodeValue;\n            }\n          });\n          each(nodes, function (node) {\n            var mapping = new VisualMapping({\n              type: 'color',\n              mappingMethod: 'linear',\n              dataExtent: [minValue_1, maxValue_1],\n              visual: seriesModel.get('color')\n            });\n            var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);\n            var customColor = node.getModel().get(['itemStyle', 'color']);\n\n            if (customColor != null) {\n              node.setVisual('color', customColor);\n              node.setVisual('style', {\n                fill: customColor\n              });\n            } else {\n              node.setVisual('color', mapValueToColor);\n              node.setVisual('style', {\n                fill: mapValueToColor\n              });\n            }\n          });\n        }\n      });\n    }\n\n    function install$h(registers) {\n      registers.registerChartView(SankeyView);\n      registers.registerSeriesModel(SankeySeriesModel);\n      registers.registerLayout(sankeyLayout);\n      registers.registerVisual(sankeyVisual);\n      registers.registerAction({\n        type: 'dragNode',\n        event: 'dragnode',\n        update: 'update'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'sankey',\n          query: payload\n        }, function (seriesModel) {\n          seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);\n        });\n      });\n    }\n\n    var WhiskerBoxCommonMixin = function () {\n      function WhiskerBoxCommonMixin() {}\n\n      WhiskerBoxCommonMixin.prototype.getInitialData = function (option, ecModel) {\n        var ordinalMeta;\n        var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));\n        var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));\n        var xAxisType = xAxisModel.get('type');\n        var yAxisType = yAxisModel.get('type');\n        var addOrdinal;\n\n        if (xAxisType === 'category') {\n          option.layout = 'horizontal';\n          ordinalMeta = xAxisModel.getOrdinalMeta();\n          addOrdinal = true;\n        } else if (yAxisType === 'category') {\n          option.layout = 'vertical';\n          ordinalMeta = yAxisModel.getOrdinalMeta();\n          addOrdinal = true;\n        } else {\n          option.layout = option.layout || 'horizontal';\n        }\n\n        var coordDims = ['x', 'y'];\n        var baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1;\n        var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];\n        var otherAxisDim = coordDims[1 - baseAxisDimIndex];\n        var axisModels = [xAxisModel, yAxisModel];\n        var baseAxisType = axisModels[baseAxisDimIndex].get('type');\n        var otherAxisType = axisModels[1 - baseAxisDimIndex].get('type');\n        var data = option.data;\n\n        if (data && addOrdinal) {\n          var newOptionData_1 = [];\n          each(data, function (item, index) {\n            var newItem;\n\n            if (isArray(item)) {\n              newItem = item.slice();\n              item.unshift(index);\n            } else if (isArray(item.value)) {\n              newItem = item.value.slice();\n              item.value.unshift(index);\n            } else {\n              newItem = item;\n            }\n\n            newOptionData_1.push(newItem);\n          });\n          option.data = newOptionData_1;\n        }\n\n        var defaultValueDimensions = this.defaultValueDimensions;\n        var coordDimensions = [{\n          name: baseAxisDim,\n          type: getDimensionTypeByAxis(baseAxisType),\n          ordinalMeta: ordinalMeta,\n          otherDims: {\n            tooltip: false,\n            itemName: 0\n          },\n          dimsDef: ['base']\n        }, {\n          name: otherAxisDim,\n          type: getDimensionTypeByAxis(otherAxisType),\n          dimsDef: defaultValueDimensions.slice()\n        }];\n        return createListSimply(this, {\n          coordDimensions: coordDimensions,\n          dimensionsCount: defaultValueDimensions.length + 1,\n          encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)\n        });\n      };\n\n      WhiskerBoxCommonMixin.prototype.getBaseAxis = function () {\n        var dim = this._baseAxisDim;\n        return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;\n      };\n\n      return WhiskerBoxCommonMixin;\n    }();\n\n    var BoxplotSeriesModel = function (_super) {\n      __extends(BoxplotSeriesModel, _super);\n\n      function BoxplotSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BoxplotSeriesModel.type;\n        _this.defaultValueDimensions = [{\n          name: 'min',\n          defaultTooltip: true\n        }, {\n          name: 'Q1',\n          defaultTooltip: true\n        }, {\n          name: 'median',\n          defaultTooltip: true\n        }, {\n          name: 'Q3',\n          defaultTooltip: true\n        }, {\n          name: 'max',\n          defaultTooltip: true\n        }];\n        _this.visualDrawType = 'stroke';\n        return _this;\n      }\n\n      BoxplotSeriesModel.type = 'series.boxplot';\n      BoxplotSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];\n      BoxplotSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        layout: null,\n        boxWidth: [7, 50],\n        itemStyle: {\n          color: '#fff',\n          borderWidth: 1\n        },\n        emphasis: {\n          scale: true,\n          itemStyle: {\n            borderWidth: 2,\n            shadowBlur: 5,\n            shadowOffsetX: 1,\n            shadowOffsetY: 1,\n            shadowColor: 'rgba(0,0,0,0.2)'\n          }\n        },\n        animationDuration: 800\n      };\n      return BoxplotSeriesModel;\n    }(SeriesModel);\n\n    mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);\n\n    var BoxplotView = function (_super) {\n      __extends(BoxplotView, _super);\n\n      function BoxplotView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BoxplotView.type;\n        return _this;\n      }\n\n      BoxplotView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var group = this.group;\n        var oldData = this._data;\n\n        if (!this._data) {\n          group.removeAll();\n        }\n\n        var constDim = seriesModel.get('layout') === 'horizontal' ? 1 : 0;\n        data.diff(oldData).add(function (newIdx) {\n          if (data.hasValue(newIdx)) {\n            var itemLayout = data.getItemLayout(newIdx);\n            var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);\n            data.setItemGraphicEl(newIdx, symbolEl);\n            group.add(symbolEl);\n          }\n        }).update(function (newIdx, oldIdx) {\n          var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\n          if (!data.hasValue(newIdx)) {\n            group.remove(symbolEl);\n            return;\n          }\n\n          var itemLayout = data.getItemLayout(newIdx);\n\n          if (!symbolEl) {\n            symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);\n          } else {\n            updateNormalBoxData(itemLayout, symbolEl, data, newIdx);\n          }\n\n          group.add(symbolEl);\n          data.setItemGraphicEl(newIdx, symbolEl);\n        }).remove(function (oldIdx) {\n          var el = oldData.getItemGraphicEl(oldIdx);\n          el && group.remove(el);\n        }).execute();\n        this._data = data;\n      };\n\n      BoxplotView.prototype.remove = function (ecModel) {\n        var group = this.group;\n        var data = this._data;\n        this._data = null;\n        data && data.eachItemGraphicEl(function (el) {\n          el && group.remove(el);\n        });\n      };\n\n      BoxplotView.type = 'boxplot';\n      return BoxplotView;\n    }(ChartView);\n\n    var BoxPathShape = function () {\n      function BoxPathShape() {}\n\n      return BoxPathShape;\n    }();\n\n    var BoxPath = function (_super) {\n      __extends(BoxPath, _super);\n\n      function BoxPath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'boxplotBoxPath';\n        return _this;\n      }\n\n      BoxPath.prototype.getDefaultShape = function () {\n        return new BoxPathShape();\n      };\n\n      BoxPath.prototype.buildPath = function (ctx, shape) {\n        var ends = shape.points;\n        var i = 0;\n        ctx.moveTo(ends[i][0], ends[i][1]);\n        i++;\n\n        for (; i < 4; i++) {\n          ctx.lineTo(ends[i][0], ends[i][1]);\n        }\n\n        ctx.closePath();\n\n        for (; i < ends.length; i++) {\n          ctx.moveTo(ends[i][0], ends[i][1]);\n          i++;\n          ctx.lineTo(ends[i][0], ends[i][1]);\n        }\n      };\n\n      return BoxPath;\n    }(Path);\n\n    function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {\n      var ends = itemLayout.ends;\n      var el = new BoxPath({\n        shape: {\n          points: isInit ? transInit(ends, constDim, itemLayout) : ends\n        }\n      });\n      updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);\n      return el;\n    }\n\n    function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {\n      var seriesModel = data.hostModel;\n      var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];\n      updateMethod(el, {\n        shape: {\n          points: itemLayout.ends\n        }\n      }, seriesModel, dataIndex);\n      el.useStyle(data.getItemVisual(dataIndex, 'style'));\n      el.style.strokeNoScale = true;\n      el.z2 = 100;\n      var itemModel = data.getItemModel(dataIndex);\n      setStatesStylesFromModel(el, itemModel);\n      enableHoverEmphasis(el, itemModel.get(['emphasis', 'focus']), itemModel.get(['emphasis', 'blurScope']));\n    }\n\n    function transInit(points, dim, itemLayout) {\n      return map(points, function (point) {\n        point = point.slice();\n        point[dim] = itemLayout.initBaseline;\n        return point;\n      });\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function boxplotVisual(ecModel, api) {\n      ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {\n        seriesModel.getData().setVisual('legendSymbol', 'roundRect');\n      });\n    }\n\n    var each$7 = each;\n    function boxplotLayout(ecModel) {\n      var groupResult = groupSeriesByAxis(ecModel);\n      each$7(groupResult, function (groupItem) {\n        var seriesModels = groupItem.seriesModels;\n\n        if (!seriesModels.length) {\n          return;\n        }\n\n        calculateBase(groupItem);\n        each$7(seriesModels, function (seriesModel, idx) {\n          layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);\n        });\n      });\n    }\n\n    function groupSeriesByAxis(ecModel) {\n      var result = [];\n      var axisList = [];\n      ecModel.eachSeriesByType('boxplot', function (seriesModel) {\n        var baseAxis = seriesModel.getBaseAxis();\n        var idx = indexOf(axisList, baseAxis);\n\n        if (idx < 0) {\n          idx = axisList.length;\n          axisList[idx] = baseAxis;\n          result[idx] = {\n            axis: baseAxis,\n            seriesModels: []\n          };\n        }\n\n        result[idx].seriesModels.push(seriesModel);\n      });\n      return result;\n    }\n\n    function calculateBase(groupItem) {\n      var extent;\n      var baseAxis = groupItem.axis;\n      var seriesModels = groupItem.seriesModels;\n      var seriesCount = seriesModels.length;\n      var boxWidthList = groupItem.boxWidthList = [];\n      var boxOffsetList = groupItem.boxOffsetList = [];\n      var boundList = [];\n      var bandWidth;\n\n      if (baseAxis.type === 'category') {\n        bandWidth = baseAxis.getBandWidth();\n      } else {\n        var maxDataCount_1 = 0;\n        each$7(seriesModels, function (seriesModel) {\n          maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count());\n        });\n        extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount_1;\n      }\n\n      each$7(seriesModels, function (seriesModel) {\n        var boxWidthBound = seriesModel.get('boxWidth');\n\n        if (!isArray(boxWidthBound)) {\n          boxWidthBound = [boxWidthBound, boxWidthBound];\n        }\n\n        boundList.push([parsePercent$1(boxWidthBound[0], bandWidth) || 0, parsePercent$1(boxWidthBound[1], bandWidth) || 0]);\n      });\n      var availableWidth = bandWidth * 0.8 - 2;\n      var boxGap = availableWidth / seriesCount * 0.3;\n      var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;\n      var base = boxWidth / 2 - availableWidth / 2;\n      each$7(seriesModels, function (seriesModel, idx) {\n        boxOffsetList.push(base);\n        base += boxGap + boxWidth;\n        boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));\n      });\n    }\n\n    function layoutSingleSeries(seriesModel, offset, boxWidth) {\n      var coordSys = seriesModel.coordinateSystem;\n      var data = seriesModel.getData();\n      var halfWidth = boxWidth / 2;\n      var cDimIdx = seriesModel.get('layout') === 'horizontal' ? 0 : 1;\n      var vDimIdx = 1 - cDimIdx;\n      var coordDims = ['x', 'y'];\n      var cDim = data.mapDimension(coordDims[cDimIdx]);\n      var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);\n\n      if (cDim == null || vDims.length < 5) {\n        return;\n      }\n\n      for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {\n        var axisDimVal = data.get(cDim, dataIndex);\n        var median = getPoint(axisDimVal, vDims[2], dataIndex);\n        var end1 = getPoint(axisDimVal, vDims[0], dataIndex);\n        var end2 = getPoint(axisDimVal, vDims[1], dataIndex);\n        var end4 = getPoint(axisDimVal, vDims[3], dataIndex);\n        var end5 = getPoint(axisDimVal, vDims[4], dataIndex);\n        var ends = [];\n        addBodyEnd(ends, end2, false);\n        addBodyEnd(ends, end4, true);\n        ends.push(end1, end2, end5, end4);\n        layEndLine(ends, end1);\n        layEndLine(ends, end5);\n        layEndLine(ends, median);\n        data.setItemLayout(dataIndex, {\n          initBaseline: median[vDimIdx],\n          ends: ends\n        });\n      }\n\n      function getPoint(axisDimVal, dim, dataIndex) {\n        var val = data.get(dim, dataIndex);\n        var p = [];\n        p[cDimIdx] = axisDimVal;\n        p[vDimIdx] = val;\n        var point;\n\n        if (isNaN(axisDimVal) || isNaN(val)) {\n          point = [NaN, NaN];\n        } else {\n          point = coordSys.dataToPoint(p);\n          point[cDimIdx] += offset;\n        }\n\n        return point;\n      }\n\n      function addBodyEnd(ends, point, start) {\n        var point1 = point.slice();\n        var point2 = point.slice();\n        point1[cDimIdx] += halfWidth;\n        point2[cDimIdx] -= halfWidth;\n        start ? ends.push(point1, point2) : ends.push(point2, point1);\n      }\n\n      function layEndLine(ends, endCenter) {\n        var from = endCenter.slice();\n        var to = endCenter.slice();\n        from[cDimIdx] -= halfWidth;\n        to[cDimIdx] += halfWidth;\n        ends.push(from, to);\n      }\n    }\n\n    function prepareBoxplotData(rawData, opt) {\n      opt = opt || {};\n      var boxData = [];\n      var outliers = [];\n      var boundIQR = opt.boundIQR;\n      var useExtreme = boundIQR === 'none' || boundIQR === 0;\n\n      for (var i = 0; i < rawData.length; i++) {\n        var ascList = asc(rawData[i].slice());\n        var Q1 = quantile(ascList, 0.25);\n        var Q2 = quantile(ascList, 0.5);\n        var Q3 = quantile(ascList, 0.75);\n        var min = ascList[0];\n        var max = ascList[ascList.length - 1];\n        var bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);\n        var low = useExtreme ? min : Math.max(min, Q1 - bound);\n        var high = useExtreme ? max : Math.min(max, Q3 + bound);\n        var itemNameFormatter = opt.itemNameFormatter;\n        var itemName = isFunction(itemNameFormatter) ? itemNameFormatter({\n          value: i\n        }) : isString(itemNameFormatter) ? itemNameFormatter.replace('{value}', i + '') : i + '';\n        boxData.push([itemName, low, Q1, Q2, Q3, high]);\n\n        for (var j = 0; j < ascList.length; j++) {\n          var dataItem = ascList[j];\n\n          if (dataItem < low || dataItem > high) {\n            var outlier = [itemName, dataItem];\n            outliers.push(outlier);\n          }\n        }\n      }\n\n      return {\n        boxData: boxData,\n        outliers: outliers\n      };\n    }\n\n    var boxplotTransform = {\n      type: 'echarts:boxplot',\n      transform: function transform(params) {\n        var upstream = params.upstream;\n\n        if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = makePrintable('source data is not applicable for this boxplot transform. Expect number[][].');\n          }\n\n          throwError(errMsg);\n        }\n\n        var result = prepareBoxplotData(upstream.getRawData(), params.config);\n        return [{\n          dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],\n          data: result.boxData\n        }, {\n          data: result.outliers\n        }];\n      }\n    };\n\n    function install$i(registers) {\n      registers.registerSeriesModel(BoxplotSeriesModel);\n      registers.registerChartView(BoxplotView);\n      registers.registerVisual(boxplotVisual);\n      registers.registerLayout(boxplotLayout);\n      registers.registerTransform(boxplotTransform);\n    }\n\n    var SKIP_PROPS = ['color', 'borderColor'];\n\n    var CandlestickView = function (_super) {\n      __extends(CandlestickView, _super);\n\n      function CandlestickView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CandlestickView.type;\n        return _this;\n      }\n\n      CandlestickView.prototype.render = function (seriesModel, ecModel, api) {\n        this.group.removeClipPath();\n\n        this._updateDrawMode(seriesModel);\n\n        this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);\n      };\n\n      CandlestickView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n        this._clear();\n\n        this._updateDrawMode(seriesModel);\n      };\n\n      CandlestickView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {\n        this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);\n      };\n\n      CandlestickView.prototype._updateDrawMode = function (seriesModel) {\n        var isLargeDraw = seriesModel.pipelineContext.large;\n\n        if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n          this._isLargeDraw = isLargeDraw;\n\n          this._clear();\n        }\n      };\n\n      CandlestickView.prototype._renderNormal = function (seriesModel) {\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var group = this.group;\n        var isSimpleBox = data.getLayout('isSimpleBox');\n        var needsClip = seriesModel.get('clip', true);\n        var coord = seriesModel.coordinateSystem;\n        var clipArea = coord.getArea && coord.getArea();\n\n        if (!this._data) {\n          group.removeAll();\n        }\n\n        data.diff(oldData).add(function (newIdx) {\n          if (data.hasValue(newIdx)) {\n            var itemLayout = data.getItemLayout(newIdx);\n\n            if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {\n              return;\n            }\n\n            var el = createNormalBox$1(itemLayout, newIdx, true);\n            initProps(el, {\n              shape: {\n                points: itemLayout.ends\n              }\n            }, seriesModel, newIdx);\n            setBoxCommon(el, data, newIdx, isSimpleBox);\n            group.add(el);\n            data.setItemGraphicEl(newIdx, el);\n          }\n        }).update(function (newIdx, oldIdx) {\n          var el = oldData.getItemGraphicEl(oldIdx);\n\n          if (!data.hasValue(newIdx)) {\n            group.remove(el);\n            return;\n          }\n\n          var itemLayout = data.getItemLayout(newIdx);\n\n          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {\n            group.remove(el);\n            return;\n          }\n\n          if (!el) {\n            el = createNormalBox$1(itemLayout);\n          } else {\n            updateProps(el, {\n              shape: {\n                points: itemLayout.ends\n              }\n            }, seriesModel, newIdx);\n          }\n\n          setBoxCommon(el, data, newIdx, isSimpleBox);\n          group.add(el);\n          data.setItemGraphicEl(newIdx, el);\n        }).remove(function (oldIdx) {\n          var el = oldData.getItemGraphicEl(oldIdx);\n          el && group.remove(el);\n        }).execute();\n        this._data = data;\n      };\n\n      CandlestickView.prototype._renderLarge = function (seriesModel) {\n        this._clear();\n\n        createLarge$1(seriesModel, this.group);\n        var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;\n\n        if (clipPath) {\n          this.group.setClipPath(clipPath);\n        } else {\n          this.group.removeClipPath();\n        }\n      };\n\n      CandlestickView.prototype._incrementalRenderNormal = function (params, seriesModel) {\n        var data = seriesModel.getData();\n        var isSimpleBox = data.getLayout('isSimpleBox');\n        var dataIndex;\n\n        while ((dataIndex = params.next()) != null) {\n          var itemLayout = data.getItemLayout(dataIndex);\n          var el = createNormalBox$1(itemLayout);\n          setBoxCommon(el, data, dataIndex, isSimpleBox);\n          el.incremental = true;\n          this.group.add(el);\n        }\n      };\n\n      CandlestickView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n        createLarge$1(seriesModel, this.group, true);\n      };\n\n      CandlestickView.prototype.remove = function (ecModel) {\n        this._clear();\n      };\n\n      CandlestickView.prototype._clear = function () {\n        this.group.removeAll();\n        this._data = null;\n      };\n\n      CandlestickView.type = 'candlestick';\n      return CandlestickView;\n    }(ChartView);\n\n    var NormalBoxPathShape = function () {\n      function NormalBoxPathShape() {}\n\n      return NormalBoxPathShape;\n    }();\n\n    var NormalBoxPath = function (_super) {\n      __extends(NormalBoxPath, _super);\n\n      function NormalBoxPath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'normalCandlestickBox';\n        return _this;\n      }\n\n      NormalBoxPath.prototype.getDefaultShape = function () {\n        return new NormalBoxPathShape();\n      };\n\n      NormalBoxPath.prototype.buildPath = function (ctx, shape) {\n        var ends = shape.points;\n\n        if (this.__simpleBox) {\n          ctx.moveTo(ends[4][0], ends[4][1]);\n          ctx.lineTo(ends[6][0], ends[6][1]);\n        } else {\n          ctx.moveTo(ends[0][0], ends[0][1]);\n          ctx.lineTo(ends[1][0], ends[1][1]);\n          ctx.lineTo(ends[2][0], ends[2][1]);\n          ctx.lineTo(ends[3][0], ends[3][1]);\n          ctx.closePath();\n          ctx.moveTo(ends[4][0], ends[4][1]);\n          ctx.lineTo(ends[5][0], ends[5][1]);\n          ctx.moveTo(ends[6][0], ends[6][1]);\n          ctx.lineTo(ends[7][0], ends[7][1]);\n        }\n      };\n\n      return NormalBoxPath;\n    }(Path);\n\n    function createNormalBox$1(itemLayout, dataIndex, isInit) {\n      var ends = itemLayout.ends;\n      return new NormalBoxPath({\n        shape: {\n          points: isInit ? transInit$1(ends, itemLayout) : ends\n        },\n        z2: 100\n      });\n    }\n\n    function isNormalBoxClipped(clipArea, itemLayout) {\n      var clipped = true;\n\n      for (var i = 0; i < itemLayout.ends.length; i++) {\n        if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {\n          clipped = false;\n          break;\n        }\n      }\n\n      return clipped;\n    }\n\n    function setBoxCommon(el, data, dataIndex, isSimpleBox) {\n      var itemModel = data.getItemModel(dataIndex);\n      el.useStyle(data.getItemVisual(dataIndex, 'style'));\n      el.style.strokeNoScale = true;\n      el.__simpleBox = isSimpleBox;\n      setStatesStylesFromModel(el, itemModel);\n    }\n\n    function transInit$1(points, itemLayout) {\n      return map(points, function (point) {\n        point = point.slice();\n        point[1] = itemLayout.initBaseline;\n        return point;\n      });\n    }\n\n    var LargeBoxPathShape = function () {\n      function LargeBoxPathShape() {}\n\n      return LargeBoxPathShape;\n    }();\n\n    var LargeBoxPath = function (_super) {\n      __extends(LargeBoxPath, _super);\n\n      function LargeBoxPath(opts) {\n        var _this = _super.call(this, opts) || this;\n\n        _this.type = 'largeCandlestickBox';\n        return _this;\n      }\n\n      LargeBoxPath.prototype.getDefaultShape = function () {\n        return new LargeBoxPathShape();\n      };\n\n      LargeBoxPath.prototype.buildPath = function (ctx, shape) {\n        var points = shape.points;\n\n        for (var i = 0; i < points.length;) {\n          if (this.__sign === points[i++]) {\n            var x = points[i++];\n            ctx.moveTo(x, points[i++]);\n            ctx.lineTo(x, points[i++]);\n          } else {\n            i += 3;\n          }\n        }\n      };\n\n      return LargeBoxPath;\n    }(Path);\n\n    function createLarge$1(seriesModel, group, incremental) {\n      var data = seriesModel.getData();\n      var largePoints = data.getLayout('largePoints');\n      var elP = new LargeBoxPath({\n        shape: {\n          points: largePoints\n        },\n        __sign: 1\n      });\n      group.add(elP);\n      var elN = new LargeBoxPath({\n        shape: {\n          points: largePoints\n        },\n        __sign: -1\n      });\n      group.add(elN);\n      setLargeStyle$1(1, elP, seriesModel);\n      setLargeStyle$1(-1, elN, seriesModel);\n\n      if (incremental) {\n        elP.incremental = true;\n        elN.incremental = true;\n      }\n    }\n\n    function setLargeStyle$1(sign, el, seriesModel, data) {\n      var borderColor = seriesModel.get(['itemStyle', sign > 0 ? 'borderColor' : 'borderColor0']) || seriesModel.get(['itemStyle', sign > 0 ? 'color' : 'color0']);\n      var itemStyle = seriesModel.getModel('itemStyle').getItemStyle(SKIP_PROPS);\n      el.useStyle(itemStyle);\n      el.style.fill = null;\n      el.style.stroke = borderColor;\n    }\n\n    var CandlestickSeriesModel = function (_super) {\n      __extends(CandlestickSeriesModel, _super);\n\n      function CandlestickSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CandlestickSeriesModel.type;\n        _this.defaultValueDimensions = [{\n          name: 'open',\n          defaultTooltip: true\n        }, {\n          name: 'close',\n          defaultTooltip: true\n        }, {\n          name: 'lowest',\n          defaultTooltip: true\n        }, {\n          name: 'highest',\n          defaultTooltip: true\n        }];\n        return _this;\n      }\n\n      CandlestickSeriesModel.prototype.getShadowDim = function () {\n        return 'open';\n      };\n\n      CandlestickSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n        var itemLayout = data.getItemLayout(dataIndex);\n        return itemLayout && selectors.rect(itemLayout.brushRect);\n      };\n\n      CandlestickSeriesModel.type = 'series.candlestick';\n      CandlestickSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid'];\n      CandlestickSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'cartesian2d',\n        legendHoverLink: true,\n        layout: null,\n        clip: true,\n        itemStyle: {\n          color: '#eb5454',\n          color0: '#47b262',\n          borderColor: '#eb5454',\n          borderColor0: '#47b262',\n          borderWidth: 1\n        },\n        emphasis: {\n          scale: true,\n          itemStyle: {\n            borderWidth: 2\n          }\n        },\n        barMaxWidth: null,\n        barMinWidth: null,\n        barWidth: null,\n        large: true,\n        largeThreshold: 600,\n        progressive: 3e3,\n        progressiveThreshold: 1e4,\n        progressiveChunkMode: 'mod',\n        animationEasing: 'linear',\n        animationDuration: 300\n      };\n      return CandlestickSeriesModel;\n    }(SeriesModel);\n\n    mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);\n\n    function candlestickPreprocessor(option) {\n      if (!option || !isArray(option.series)) {\n        return;\n      }\n\n      each(option.series, function (seriesItem) {\n        if (isObject(seriesItem) && seriesItem.type === 'k') {\n          seriesItem.type = 'candlestick';\n        }\n      });\n    }\n\n    var positiveBorderColorQuery = ['itemStyle', 'borderColor'];\n    var negativeBorderColorQuery = ['itemStyle', 'borderColor0'];\n    var positiveColorQuery = ['itemStyle', 'color'];\n    var negativeColorQuery = ['itemStyle', 'color0'];\n    var candlestickVisual = {\n      seriesType: 'candlestick',\n      plan: createRenderPlanner(),\n      performRawSeries: true,\n      reset: function (seriesModel, ecModel) {\n        function getColor(sign, model) {\n          return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);\n        }\n\n        function getBorderColor(sign, model) {\n          return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);\n        }\n\n        var data = seriesModel.getData();\n        data.setVisual('legendSymbol', 'roundRect');\n\n        if (ecModel.isSeriesFiltered(seriesModel)) {\n          return;\n        }\n\n        var isLargeRender = seriesModel.pipelineContext.large;\n        return !isLargeRender && {\n          progress: function (params, data) {\n            var dataIndex;\n\n            while ((dataIndex = params.next()) != null) {\n              var itemModel = data.getItemModel(dataIndex);\n              var sign = data.getItemLayout(dataIndex).sign;\n              var style = itemModel.getItemStyle();\n              style.fill = getColor(sign, itemModel);\n              style.stroke = getBorderColor(sign, itemModel) || style.fill;\n              var existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style');\n              extend(existsStyle, style);\n            }\n          }\n        };\n      }\n    };\n\n    var LargeArr$1 = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n    var candlestickLayout = {\n      seriesType: 'candlestick',\n      plan: createRenderPlanner(),\n      reset: function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var data = seriesModel.getData();\n        var candleWidth = calculateCandleWidth(seriesModel, data);\n        var cDimIdx = 0;\n        var vDimIdx = 1;\n        var coordDims = ['x', 'y'];\n        var cDim = data.mapDimension(coordDims[cDimIdx]);\n        var vDims = data.mapDimensionsAll(coordDims[vDimIdx]);\n        var openDim = vDims[0];\n        var closeDim = vDims[1];\n        var lowestDim = vDims[2];\n        var highestDim = vDims[3];\n        data.setLayout({\n          candleWidth: candleWidth,\n          isSimpleBox: candleWidth <= 1.3\n        });\n\n        if (cDim == null || vDims.length < 4) {\n          return;\n        }\n\n        return {\n          progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress\n        };\n\n        function normalProgress(params, data) {\n          var dataIndex;\n\n          while ((dataIndex = params.next()) != null) {\n            var axisDimVal = data.get(cDim, dataIndex);\n            var openVal = data.get(openDim, dataIndex);\n            var closeVal = data.get(closeDim, dataIndex);\n            var lowestVal = data.get(lowestDim, dataIndex);\n            var highestVal = data.get(highestDim, dataIndex);\n            var ocLow = Math.min(openVal, closeVal);\n            var ocHigh = Math.max(openVal, closeVal);\n            var ocLowPoint = getPoint(ocLow, axisDimVal);\n            var ocHighPoint = getPoint(ocHigh, axisDimVal);\n            var lowestPoint = getPoint(lowestVal, axisDimVal);\n            var highestPoint = getPoint(highestVal, axisDimVal);\n            var ends = [];\n            addBodyEnd(ends, ocHighPoint, 0);\n            addBodyEnd(ends, ocLowPoint, 1);\n            ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));\n            data.setItemLayout(dataIndex, {\n              sign: getSign(data, dataIndex, openVal, closeVal, closeDim),\n              initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],\n              ends: ends,\n              brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)\n            });\n          }\n\n          function getPoint(val, axisDimVal) {\n            var p = [];\n            p[cDimIdx] = axisDimVal;\n            p[vDimIdx] = val;\n            return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);\n          }\n\n          function addBodyEnd(ends, point, start) {\n            var point1 = point.slice();\n            var point2 = point.slice();\n            point1[cDimIdx] = subPixelOptimize$1(point1[cDimIdx] + candleWidth / 2, 1, false);\n            point2[cDimIdx] = subPixelOptimize$1(point2[cDimIdx] - candleWidth / 2, 1, true);\n            start ? ends.push(point1, point2) : ends.push(point2, point1);\n          }\n\n          function makeBrushRect(lowestVal, highestVal, axisDimVal) {\n            var pmin = getPoint(lowestVal, axisDimVal);\n            var pmax = getPoint(highestVal, axisDimVal);\n            pmin[cDimIdx] -= candleWidth / 2;\n            pmax[cDimIdx] -= candleWidth / 2;\n            return {\n              x: pmin[0],\n              y: pmin[1],\n              width:  candleWidth ,\n              height:  pmax[1] - pmin[1] \n            };\n          }\n\n          function subPixelOptimizePoint(point) {\n            point[cDimIdx] = subPixelOptimize$1(point[cDimIdx], 1);\n            return point;\n          }\n        }\n\n        function largeProgress(params, data) {\n          var points = new LargeArr$1(params.count * 4);\n          var offset = 0;\n          var point;\n          var tmpIn = [];\n          var tmpOut = [];\n          var dataIndex;\n\n          while ((dataIndex = params.next()) != null) {\n            var axisDimVal = data.get(cDim, dataIndex);\n            var openVal = data.get(openDim, dataIndex);\n            var closeVal = data.get(closeDim, dataIndex);\n            var lowestVal = data.get(lowestDim, dataIndex);\n            var highestVal = data.get(highestDim, dataIndex);\n\n            if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {\n              points[offset++] = NaN;\n              offset += 3;\n              continue;\n            }\n\n            points[offset++] = getSign(data, dataIndex, openVal, closeVal, closeDim);\n            tmpIn[cDimIdx] = axisDimVal;\n            tmpIn[vDimIdx] = lowestVal;\n            point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n            tmpIn[vDimIdx] = highestVal;\n            point = coordSys.dataToPoint(tmpIn, null, tmpOut);\n            points[offset++] = point ? point[1] : NaN;\n          }\n\n          data.setLayout('largePoints', points);\n        }\n      }\n    };\n\n    function getSign(data, dataIndex, openVal, closeVal, closeDim) {\n      var sign;\n\n      if (openVal > closeVal) {\n        sign = -1;\n      } else if (openVal < closeVal) {\n        sign = 1;\n      } else {\n        sign = dataIndex > 0 ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : 1;\n      }\n\n      return sign;\n    }\n\n    function calculateCandleWidth(seriesModel, data) {\n      var baseAxis = seriesModel.getBaseAxis();\n      var extent;\n      var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());\n      var barMaxWidth = parsePercent$1(retrieve2(seriesModel.get('barMaxWidth'), bandWidth), bandWidth);\n      var barMinWidth = parsePercent$1(retrieve2(seriesModel.get('barMinWidth'), 1), bandWidth);\n      var barWidth = seriesModel.get('barWidth');\n      return barWidth != null ? parsePercent$1(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);\n    }\n\n    function install$j(registers) {\n      registers.registerChartView(CandlestickView);\n      registers.registerSeriesModel(CandlestickSeriesModel);\n      registers.registerPreprocessor(candlestickPreprocessor);\n      registers.registerVisual(candlestickVisual);\n      registers.registerLayout(candlestickLayout);\n    }\n\n    var EFFECT_RIPPLE_NUMBER = 3;\n\n    function normalizeSymbolSize$1(symbolSize) {\n      if (!isArray(symbolSize)) {\n        symbolSize = [+symbolSize, +symbolSize];\n      }\n\n      return symbolSize;\n    }\n\n    function updateRipplePath(rippleGroup, effectCfg) {\n      var color = effectCfg.rippleEffectColor || effectCfg.color;\n      rippleGroup.eachChild(function (ripplePath) {\n        ripplePath.attr({\n          z: effectCfg.z,\n          zlevel: effectCfg.zlevel,\n          style: {\n            stroke: effectCfg.brushType === 'stroke' ? color : null,\n            fill: effectCfg.brushType === 'fill' ? color : null\n          }\n        });\n      });\n    }\n\n    var EffectSymbol = function (_super) {\n      __extends(EffectSymbol, _super);\n\n      function EffectSymbol(data, idx) {\n        var _this = _super.call(this) || this;\n\n        var symbol = new Symbol(data, idx);\n        var rippleGroup = new Group();\n\n        _this.add(symbol);\n\n        _this.add(rippleGroup);\n\n        _this.updateData(data, idx);\n\n        return _this;\n      }\n\n      EffectSymbol.prototype.stopEffectAnimation = function () {\n        this.childAt(1).removeAll();\n      };\n\n      EffectSymbol.prototype.startEffectAnimation = function (effectCfg) {\n        var symbolType = effectCfg.symbolType;\n        var color = effectCfg.color;\n        var rippleGroup = this.childAt(1);\n\n        for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {\n          var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);\n          ripplePath.attr({\n            style: {\n              strokeNoScale: true\n            },\n            z2: 99,\n            silent: true,\n            scaleX: 0.5,\n            scaleY: 0.5\n          });\n          var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;\n          ripplePath.animate('', true).when(effectCfg.period, {\n            scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]\n          }).delay(delay).start();\n          ripplePath.animateStyle(true).when(effectCfg.period, {\n            opacity: 0\n          }).delay(delay).start();\n          rippleGroup.add(ripplePath);\n        }\n\n        updateRipplePath(rippleGroup, effectCfg);\n      };\n\n      EffectSymbol.prototype.updateEffectAnimation = function (effectCfg) {\n        var oldEffectCfg = this._effectCfg;\n        var rippleGroup = this.childAt(1);\n        var DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale'];\n\n        for (var i = 0; i < DIFFICULT_PROPS.length; i++) {\n          var propName = DIFFICULT_PROPS[i];\n\n          if (oldEffectCfg[propName] !== effectCfg[propName]) {\n            this.stopEffectAnimation();\n            this.startEffectAnimation(effectCfg);\n            return;\n          }\n        }\n\n        updateRipplePath(rippleGroup, effectCfg);\n      };\n\n      EffectSymbol.prototype.highlight = function () {\n        enterEmphasis(this);\n      };\n\n      EffectSymbol.prototype.downplay = function () {\n        leaveEmphasis(this);\n      };\n\n      EffectSymbol.prototype.updateData = function (data, idx) {\n        var _this = this;\n\n        var seriesModel = data.hostModel;\n        this.childAt(0).updateData(data, idx);\n        var rippleGroup = this.childAt(1);\n        var itemModel = data.getItemModel(idx);\n        var symbolType = data.getItemVisual(idx, 'symbol');\n        var symbolSize = normalizeSymbolSize$1(data.getItemVisual(idx, 'symbolSize'));\n        var symbolStyle = data.getItemVisual(idx, 'style');\n        var color = symbolStyle && symbolStyle.fill;\n        rippleGroup.setScale(symbolSize);\n        rippleGroup.traverse(function (ripplePath) {\n          ripplePath.setStyle('fill', color);\n        });\n        var symbolOffset = itemModel.getShallow('symbolOffset');\n\n        if (symbolOffset) {\n          rippleGroup.x = parsePercent$1(symbolOffset[0], symbolSize[0]);\n          rippleGroup.y = parsePercent$1(symbolOffset[1], symbolSize[1]);\n        }\n\n        var symbolRotate = data.getItemVisual(idx, 'symbolRotate');\n        rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n        var effectCfg = {};\n        effectCfg.showEffectOn = seriesModel.get('showEffectOn');\n        effectCfg.rippleScale = itemModel.get(['rippleEffect', 'scale']);\n        effectCfg.brushType = itemModel.get(['rippleEffect', 'brushType']);\n        effectCfg.period = itemModel.get(['rippleEffect', 'period']) * 1000;\n        effectCfg.effectOffset = idx / data.count();\n        effectCfg.z = seriesModel.getShallow('z') || 0;\n        effectCfg.zlevel = seriesModel.getShallow('zlevel') || 0;\n        effectCfg.symbolType = symbolType;\n        effectCfg.color = color;\n        effectCfg.rippleEffectColor = itemModel.get(['rippleEffect', 'color']);\n        this.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\n        if (effectCfg.showEffectOn === 'render') {\n          this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);\n          this._effectCfg = effectCfg;\n        } else {\n          this._effectCfg = null;\n          this.stopEffectAnimation();\n\n          this.onHoverStateChange = function (toState) {\n            if (toState === 'emphasis') {\n              if (effectCfg.showEffectOn !== 'render') {\n                _this.startEffectAnimation(effectCfg);\n              }\n            } else if (toState === 'normal') {\n              if (effectCfg.showEffectOn !== 'render') {\n                _this.stopEffectAnimation();\n              }\n            }\n          };\n        }\n\n        this._effectCfg = effectCfg;\n        enableHoverEmphasis(this);\n      };\n\n      EffectSymbol.prototype.fadeOut = function (cb) {\n        this.off('mouseover').off('mouseout');\n        cb && cb();\n      };\n      return EffectSymbol;\n    }(Group);\n\n    inherits(EffectSymbol, Group);\n\n    var EffectScatterView = function (_super) {\n      __extends(EffectScatterView, _super);\n\n      function EffectScatterView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = EffectScatterView.type;\n        return _this;\n      }\n\n      EffectScatterView.prototype.init = function () {\n        this._symbolDraw = new SymbolDraw(EffectSymbol);\n      };\n\n      EffectScatterView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var effectSymbolDraw = this._symbolDraw;\n        effectSymbolDraw.updateData(data);\n        this.group.add(effectSymbolDraw.group);\n      };\n\n      EffectScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        this.group.dirty();\n        var res = pointsLayout('').reset(seriesModel, ecModel, api);\n\n        if (res.progress) {\n          res.progress({\n            start: 0,\n            end: data.count(),\n            count: data.count()\n          }, data);\n        }\n\n        this._symbolDraw.updateLayout();\n      };\n\n      EffectScatterView.prototype._updateGroupTransform = function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys && coordSys.getRoamTransform) {\n          this.group.transform = clone$2(coordSys.getRoamTransform());\n          this.group.decomposeTransform();\n        }\n      };\n\n      EffectScatterView.prototype.remove = function (ecModel, api) {\n        this._symbolDraw && this._symbolDraw.remove(true);\n      };\n\n      EffectScatterView.type = 'effectScatter';\n      return EffectScatterView;\n    }(ChartView);\n\n    var EffectScatterSeriesModel = function (_super) {\n      __extends(EffectScatterSeriesModel, _super);\n\n      function EffectScatterSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = EffectScatterSeriesModel.type;\n        _this.hasSymbolVisual = true;\n        return _this;\n      }\n\n      EffectScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this, {\n          useEncodeDefaulter: true\n        });\n      };\n\n      EffectScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {\n        return selectors.point(data.getItemLayout(dataIndex));\n      };\n\n      EffectScatterSeriesModel.type = 'series.effectScatter';\n      EffectScatterSeriesModel.dependencies = ['grid', 'polar'];\n      EffectScatterSeriesModel.defaultOption = {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        effectType: 'ripple',\n        progressive: 0,\n        showEffectOn: 'render',\n        rippleEffect: {\n          period: 4,\n          scale: 2.5,\n          brushType: 'fill'\n        },\n        symbolSize: 10\n      };\n      return EffectScatterSeriesModel;\n    }(SeriesModel);\n\n    function install$k(registers) {\n      registers.registerChartView(EffectScatterView);\n      registers.registerSeriesModel(EffectScatterSeriesModel);\n      registers.registerLayout(pointsLayout('effectScatter'));\n    }\n\n    var EffectLine = function (_super) {\n      __extends(EffectLine, _super);\n\n      function EffectLine(lineData, idx, seriesScope) {\n        var _this = _super.call(this) || this;\n\n        _this.add(_this.createLine(lineData, idx, seriesScope));\n\n        _this._updateEffectSymbol(lineData, idx);\n\n        return _this;\n      }\n\n      EffectLine.prototype.createLine = function (lineData, idx, seriesScope) {\n        return new Line$1(lineData, idx, seriesScope);\n      };\n\n      EffectLine.prototype._updateEffectSymbol = function (lineData, idx) {\n        var itemModel = lineData.getItemModel(idx);\n        var effectModel = itemModel.getModel('effect');\n        var size = effectModel.get('symbolSize');\n        var symbolType = effectModel.get('symbol');\n\n        if (!isArray(size)) {\n          size = [size, size];\n        }\n\n        var lineStyle = lineData.getItemVisual(idx, 'style');\n        var color = effectModel.get('color') || lineStyle && lineStyle.stroke;\n        var symbol = this.childAt(1);\n\n        if (this._symbolType !== symbolType) {\n          this.remove(symbol);\n          symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color);\n          symbol.z2 = 100;\n          symbol.culling = true;\n          this.add(symbol);\n        }\n\n        if (!symbol) {\n          return;\n        }\n\n        symbol.setStyle('shadowColor', color);\n        symbol.setStyle(effectModel.getItemStyle(['color']));\n        symbol.scaleX = size[0];\n        symbol.scaleY = size[1];\n        symbol.setColor(color);\n        this._symbolType = symbolType;\n        this._symbolScale = size;\n\n        this._updateEffectAnimation(lineData, effectModel, idx);\n      };\n\n      EffectLine.prototype._updateEffectAnimation = function (lineData, effectModel, idx) {\n        var symbol = this.childAt(1);\n\n        if (!symbol) {\n          return;\n        }\n\n        var self = this;\n        var points = lineData.getItemLayout(idx);\n        var period = effectModel.get('period') * 1000;\n        var loop = effectModel.get('loop');\n        var constantSpeed = effectModel.get('constantSpeed');\n        var delayExpr = retrieve(effectModel.get('delay'), function (idx) {\n          return idx / lineData.count() * period / 3;\n        });\n        symbol.ignore = true;\n\n        this._updateAnimationPoints(symbol, points);\n\n        if (constantSpeed > 0) {\n          period = this._getLineLength(symbol) / constantSpeed * 1000;\n        }\n\n        if (period !== this._period || loop !== this._loop) {\n          symbol.stopAnimation();\n\n          if (period > 0) {\n            var delayNum = void 0;\n\n            if (typeof delayExpr === 'function') {\n              delayNum = delayExpr(idx);\n            } else {\n              delayNum = delayExpr;\n            }\n\n            if (symbol.__t > 0) {\n              delayNum = -period * symbol.__t;\n            }\n\n            symbol.__t = 0;\n            var animator = symbol.animate('', loop).when(period, {\n              __t: 1\n            }).delay(delayNum).during(function () {\n              self._updateSymbolPosition(symbol);\n            });\n\n            if (!loop) {\n              animator.done(function () {\n                self.remove(symbol);\n              });\n            }\n\n            animator.start();\n          }\n        }\n\n        this._period = period;\n        this._loop = loop;\n      };\n\n      EffectLine.prototype._getLineLength = function (symbol) {\n        return dist(symbol.__p1, symbol.__cp1) + dist(symbol.__cp1, symbol.__p2);\n      };\n\n      EffectLine.prototype._updateAnimationPoints = function (symbol, points) {\n        symbol.__p1 = points[0];\n        symbol.__p2 = points[1];\n        symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];\n      };\n\n      EffectLine.prototype.updateData = function (lineData, idx, seriesScope) {\n        this.childAt(0).updateData(lineData, idx, seriesScope);\n\n        this._updateEffectSymbol(lineData, idx);\n      };\n\n      EffectLine.prototype._updateSymbolPosition = function (symbol) {\n        var p1 = symbol.__p1;\n        var p2 = symbol.__p2;\n        var cp1 = symbol.__cp1;\n        var t = symbol.__t;\n        var pos = [symbol.x, symbol.y];\n        var lastPos = pos.slice();\n        var quadraticAt$1 = quadraticAt;\n        var quadraticDerivativeAt$1 = quadraticDerivativeAt;\n        pos[0] = quadraticAt$1(p1[0], cp1[0], p2[0], t);\n        pos[1] = quadraticAt$1(p1[1], cp1[1], p2[1], t);\n        var tx = quadraticDerivativeAt$1(p1[0], cp1[0], p2[0], t);\n        var ty = quadraticDerivativeAt$1(p1[1], cp1[1], p2[1], t);\n        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n\n        if (this._symbolType === 'line' || this._symbolType === 'rect' || this._symbolType === 'roundRect') {\n          if (symbol.__lastT !== undefined && symbol.__lastT < symbol.__t) {\n            symbol.scaleY = dist(lastPos, pos) * 1.05;\n\n            if (t === 1) {\n              pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;\n              pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;\n            }\n          } else if (symbol.__lastT === 1) {\n            symbol.scaleY = 2 * dist(p1, pos);\n          } else {\n            symbol.scaleY = this._symbolScale[1];\n          }\n        }\n\n        symbol.__lastT = symbol.__t;\n        symbol.ignore = false;\n        symbol.x = pos[0];\n        symbol.y = pos[1];\n      };\n\n      EffectLine.prototype.updateLayout = function (lineData, idx) {\n        this.childAt(0).updateLayout(lineData, idx);\n        var effectModel = lineData.getItemModel(idx).getModel('effect');\n\n        this._updateEffectAnimation(lineData, effectModel, idx);\n      };\n\n      return EffectLine;\n    }(Group);\n\n    var Polyline$1 = function (_super) {\n      __extends(Polyline$1, _super);\n\n      function Polyline$1(lineData, idx, seriesScope) {\n        var _this = _super.call(this) || this;\n\n        _this._createPolyline(lineData, idx, seriesScope);\n\n        return _this;\n      }\n\n      Polyline$1.prototype._createPolyline = function (lineData, idx, seriesScope) {\n        var points = lineData.getItemLayout(idx);\n        var line = new Polyline({\n          shape: {\n            points: points\n          }\n        });\n        this.add(line);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n      };\n\n      Polyline$1.prototype.updateData = function (lineData, idx, seriesScope) {\n        var seriesModel = lineData.hostModel;\n        var line = this.childAt(0);\n        var target = {\n          shape: {\n            points: lineData.getItemLayout(idx)\n          }\n        };\n        updateProps(line, target, seriesModel, idx);\n\n        this._updateCommonStl(lineData, idx, seriesScope);\n      };\n\n      Polyline$1.prototype._updateCommonStl = function (lineData, idx, seriesScope) {\n        var line = this.childAt(0);\n        var itemModel = lineData.getItemModel(idx);\n        var hoverLineStyle = seriesScope && seriesScope.emphasisLineStyle;\n\n        if (!seriesScope || lineData.hasItemOption) {\n          hoverLineStyle = itemModel.getModel(['emphasis', 'lineStyle']).getLineStyle();\n        }\n\n        line.useStyle(lineData.getItemVisual(idx, 'style'));\n        line.style.fill = null;\n        line.style.strokeNoScale = true;\n        var lineEmphasisState = line.ensureState('emphasis');\n        lineEmphasisState.style = hoverLineStyle;\n        enableHoverEmphasis(this);\n      };\n\n      Polyline$1.prototype.updateLayout = function (lineData, idx) {\n        var polyline = this.childAt(0);\n        polyline.setShape('points', lineData.getItemLayout(idx));\n      };\n      return Polyline$1;\n    }(Group);\n\n    var EffectPolyline = function (_super) {\n      __extends(EffectPolyline, _super);\n\n      function EffectPolyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this._lastFrame = 0;\n        _this._lastFramePercent = 0;\n        return _this;\n      }\n\n      EffectPolyline.prototype.createLine = function (lineData, idx, seriesScope) {\n        return new Polyline$1(lineData, idx, seriesScope);\n      };\n\n      EffectPolyline.prototype._updateAnimationPoints = function (symbol, points) {\n        this._points = points;\n        var accLenArr = [0];\n        var len = 0;\n\n        for (var i = 1; i < points.length; i++) {\n          var p1 = points[i - 1];\n          var p2 = points[i];\n          len += dist(p1, p2);\n          accLenArr.push(len);\n        }\n\n        if (len === 0) {\n          this._length = 0;\n          return;\n        }\n\n        for (var i = 0; i < accLenArr.length; i++) {\n          accLenArr[i] /= len;\n        }\n\n        this._offsets = accLenArr;\n        this._length = len;\n      };\n\n      EffectPolyline.prototype._getLineLength = function () {\n        return this._length;\n      };\n\n      EffectPolyline.prototype._updateSymbolPosition = function (symbol) {\n        var t = symbol.__t;\n        var points = this._points;\n        var offsets = this._offsets;\n        var len = points.length;\n\n        if (!offsets) {\n          return;\n        }\n\n        var lastFrame = this._lastFrame;\n        var frame;\n\n        if (t < this._lastFramePercent) {\n          var start = Math.min(lastFrame + 1, len - 1);\n\n          for (frame = start; frame >= 0; frame--) {\n            if (offsets[frame] <= t) {\n              break;\n            }\n          }\n\n          frame = Math.min(frame, len - 2);\n        } else {\n          for (frame = lastFrame; frame < len; frame++) {\n            if (offsets[frame] > t) {\n              break;\n            }\n          }\n\n          frame = Math.min(frame - 1, len - 2);\n        }\n\n        var p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);\n        var p0 = points[frame];\n        var p1 = points[frame + 1];\n        symbol.x = p0[0] * (1 - p) + p * p1[0];\n        symbol.y = p0[1] * (1 - p) + p * p1[1];\n        var tx = p1[0] - p0[0];\n        var ty = p1[1] - p0[1];\n        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;\n        this._lastFrame = frame;\n        this._lastFramePercent = t;\n        symbol.ignore = false;\n      };\n      return EffectPolyline;\n    }(EffectLine);\n\n    var LargeLinesPathShape = function () {\n      function LargeLinesPathShape() {\n        this.polyline = false;\n        this.curveness = 0;\n        this.segs = [];\n      }\n\n      return LargeLinesPathShape;\n    }();\n\n    var LargeLinesPath = function (_super) {\n      __extends(LargeLinesPath, _super);\n\n      function LargeLinesPath(opts) {\n        return _super.call(this, opts) || this;\n      }\n\n      LargeLinesPath.prototype.getDefaultStyle = function () {\n        return {\n          stroke: '#000',\n          fill: null\n        };\n      };\n\n      LargeLinesPath.prototype.getDefaultShape = function () {\n        return new LargeLinesPathShape();\n      };\n\n      LargeLinesPath.prototype.buildPath = function (ctx, shape) {\n        var segs = shape.segs;\n        var curveness = shape.curveness;\n\n        if (shape.polyline) {\n          for (var i = 0; i < segs.length;) {\n            var count = segs[i++];\n\n            if (count > 0) {\n              ctx.moveTo(segs[i++], segs[i++]);\n\n              for (var k = 1; k < count; k++) {\n                ctx.lineTo(segs[i++], segs[i++]);\n              }\n            }\n          }\n        } else {\n          for (var i = 0; i < segs.length;) {\n            var x0 = segs[i++];\n            var y0 = segs[i++];\n            var x1 = segs[i++];\n            var y1 = segs[i++];\n            ctx.moveTo(x0, y0);\n\n            if (curveness > 0) {\n              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;\n              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;\n              ctx.quadraticCurveTo(x2, y2, x1, y1);\n            } else {\n              ctx.lineTo(x1, y1);\n            }\n          }\n        }\n      };\n\n      LargeLinesPath.prototype.findDataIndex = function (x, y) {\n        var shape = this.shape;\n        var segs = shape.segs;\n        var curveness = shape.curveness;\n        var lineWidth = this.style.lineWidth;\n\n        if (shape.polyline) {\n          var dataIndex = 0;\n\n          for (var i = 0; i < segs.length;) {\n            var count = segs[i++];\n\n            if (count > 0) {\n              var x0 = segs[i++];\n              var y0 = segs[i++];\n\n              for (var k = 1; k < count; k++) {\n                var x1 = segs[i++];\n                var y1 = segs[i++];\n\n                if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {\n                  return dataIndex;\n                }\n              }\n            }\n\n            dataIndex++;\n          }\n        } else {\n          var dataIndex = 0;\n\n          for (var i = 0; i < segs.length;) {\n            var x0 = segs[i++];\n            var y0 = segs[i++];\n            var x1 = segs[i++];\n            var y1 = segs[i++];\n\n            if (curveness > 0) {\n              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;\n              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;\n\n              if (containStroke$2(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {\n                return dataIndex;\n              }\n            } else {\n              if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {\n                return dataIndex;\n              }\n            }\n\n            dataIndex++;\n          }\n        }\n\n        return -1;\n      };\n\n      return LargeLinesPath;\n    }(Path);\n\n    var LargeLineDraw = function () {\n      function LargeLineDraw() {\n        this.group = new Group();\n      }\n\n      LargeLineDraw.prototype.isPersistent = function () {\n        return !this._incremental;\n      };\n\n      LargeLineDraw.prototype.updateData = function (data) {\n        this.group.removeAll();\n        var lineEl = new LargeLinesPath({\n          rectHover: true,\n          cursor: 'default'\n        });\n        lineEl.setShape({\n          segs: data.getLayout('linesPoints')\n        });\n\n        this._setCommon(lineEl, data);\n\n        this.group.add(lineEl);\n        this._incremental = null;\n      };\n\n      LargeLineDraw.prototype.incrementalPrepareUpdate = function (data) {\n        this.group.removeAll();\n\n        this._clearIncremental();\n\n        if (data.count() > 5e5) {\n          if (!this._incremental) {\n            this._incremental = new IncrementalDisplayable({\n              silent: true\n            });\n          }\n\n          this.group.add(this._incremental);\n        } else {\n          this._incremental = null;\n        }\n      };\n\n      LargeLineDraw.prototype.incrementalUpdate = function (taskParams, data) {\n        var lineEl = new LargeLinesPath();\n        lineEl.setShape({\n          segs: data.getLayout('linesPoints')\n        });\n\n        this._setCommon(lineEl, data, !!this._incremental);\n\n        if (!this._incremental) {\n          lineEl.rectHover = true;\n          lineEl.cursor = 'default';\n          lineEl.__startIndex = taskParams.start;\n          this.group.add(lineEl);\n        } else {\n          this._incremental.addDisplayable(lineEl, true);\n        }\n      };\n\n      LargeLineDraw.prototype.remove = function () {\n        this._clearIncremental();\n\n        this._incremental = null;\n        this.group.removeAll();\n      };\n\n      LargeLineDraw.prototype._setCommon = function (lineEl, data, isIncremental) {\n        var hostModel = data.hostModel;\n        lineEl.setShape({\n          polyline: hostModel.get('polyline'),\n          curveness: hostModel.get(['lineStyle', 'curveness'])\n        });\n        lineEl.useStyle(hostModel.getModel('lineStyle').getLineStyle());\n        lineEl.style.strokeNoScale = true;\n        var style = data.getVisual('style');\n\n        if (style && style.stroke) {\n          lineEl.setStyle('stroke', style.stroke);\n        }\n\n        lineEl.setStyle('fill', null);\n\n        if (!isIncremental) {\n          var ecData_1 = getECData(lineEl);\n          ecData_1.seriesIndex = hostModel.seriesIndex;\n          lineEl.on('mousemove', function (e) {\n            ecData_1.dataIndex = null;\n            var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);\n\n            if (dataIndex > 0) {\n              ecData_1.dataIndex = dataIndex + lineEl.__startIndex;\n            }\n          });\n        }\n      };\n\n      LargeLineDraw.prototype._clearIncremental = function () {\n        var incremental = this._incremental;\n\n        if (incremental) {\n          incremental.clearDisplaybles();\n        }\n      };\n      return LargeLineDraw;\n    }();\n\n    var linesLayout = {\n      seriesType: 'lines',\n      plan: createRenderPlanner(),\n      reset: function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var isPolyline = seriesModel.get('polyline');\n        var isLarge = seriesModel.pipelineContext.large;\n        return {\n          progress: function (params, lineData) {\n            var lineCoords = [];\n\n            if (isLarge) {\n              var points = void 0;\n              var segCount = params.end - params.start;\n\n              if (isPolyline) {\n                var totalCoordsCount = 0;\n\n                for (var i = params.start; i < params.end; i++) {\n                  totalCoordsCount += seriesModel.getLineCoordsCount(i);\n                }\n\n                points = new Float32Array(segCount + totalCoordsCount * 2);\n              } else {\n                points = new Float32Array(segCount * 4);\n              }\n\n              var offset = 0;\n              var pt = [];\n\n              for (var i = params.start; i < params.end; i++) {\n                var len = seriesModel.getLineCoords(i, lineCoords);\n\n                if (isPolyline) {\n                  points[offset++] = len;\n                }\n\n                for (var k = 0; k < len; k++) {\n                  pt = coordSys.dataToPoint(lineCoords[k], false, pt);\n                  points[offset++] = pt[0];\n                  points[offset++] = pt[1];\n                }\n              }\n\n              lineData.setLayout('linesPoints', points);\n            } else {\n              for (var i = params.start; i < params.end; i++) {\n                var itemModel = lineData.getItemModel(i);\n                var len = seriesModel.getLineCoords(i, lineCoords);\n                var pts = [];\n\n                if (isPolyline) {\n                  for (var j = 0; j < len; j++) {\n                    pts.push(coordSys.dataToPoint(lineCoords[j]));\n                  }\n                } else {\n                  pts[0] = coordSys.dataToPoint(lineCoords[0]);\n                  pts[1] = coordSys.dataToPoint(lineCoords[1]);\n                  var curveness = itemModel.get(['lineStyle', 'curveness']);\n\n                  if (+curveness) {\n                    pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];\n                  }\n                }\n\n                lineData.setItemLayout(i, pts);\n              }\n            }\n          }\n        };\n      }\n    };\n\n    var LinesView = function (_super) {\n      __extends(LinesView, _super);\n\n      function LinesView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = LinesView.type;\n        return _this;\n      }\n\n      LinesView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n\n        var lineDraw = this._updateLineDraw(data, seriesModel);\n\n        var zlevel = seriesModel.get('zlevel');\n        var trailLength = seriesModel.get(['effect', 'trailLength']);\n        var zr = api.getZr();\n        var isSvg = zr.painter.getType() === 'svg';\n\n        if (!isSvg) {\n          zr.painter.getLayer(zlevel).clear(true);\n        }\n\n        if (this._lastZlevel != null && !isSvg) {\n          zr.configLayer(this._lastZlevel, {\n            motionBlur: false\n          });\n        }\n\n        if (this._showEffect(seriesModel) && trailLength) {\n          if (\"development\" !== 'production') {\n            var notInIndividual_1 = false;\n            ecModel.eachSeries(function (otherSeriesModel) {\n              if (otherSeriesModel !== seriesModel && otherSeriesModel.get('zlevel') === zlevel) {\n                notInIndividual_1 = true;\n              }\n            });\n            notInIndividual_1 && console.warn('Lines with trail effect should have an individual zlevel');\n          }\n\n          if (!isSvg) {\n            zr.configLayer(zlevel, {\n              motionBlur: true,\n              lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)\n            });\n          }\n        }\n\n        lineDraw.updateData(data);\n        var clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);\n\n        if (clipPath) {\n          this.group.setClipPath(clipPath);\n        } else {\n          this.group.removeClipPath();\n        }\n\n        this._lastZlevel = zlevel;\n        this._finished = true;\n      };\n\n      LinesView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n\n        var lineDraw = this._updateLineDraw(data, seriesModel);\n\n        lineDraw.incrementalPrepareUpdate(data);\n\n        this._clearLayer(api);\n\n        this._finished = false;\n      };\n\n      LinesView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {\n        this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());\n\n        this._finished = taskParams.end === seriesModel.getData().count();\n      };\n\n      LinesView.prototype.updateTransform = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var pipelineContext = seriesModel.pipelineContext;\n\n        if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {\n          return {\n            update: true\n          };\n        } else {\n          var res = linesLayout.reset(seriesModel, ecModel, api);\n\n          if (res.progress) {\n            res.progress({\n              start: 0,\n              end: data.count(),\n              count: data.count()\n            }, data);\n          }\n\n          this._lineDraw.updateLayout();\n\n          this._clearLayer(api);\n        }\n      };\n\n      LinesView.prototype._updateLineDraw = function (data, seriesModel) {\n        var lineDraw = this._lineDraw;\n\n        var hasEffect = this._showEffect(seriesModel);\n\n        var isPolyline = !!seriesModel.get('polyline');\n        var pipelineContext = seriesModel.pipelineContext;\n        var isLargeDraw = pipelineContext.large;\n\n        if (\"development\" !== 'production') {\n          if (hasEffect && isLargeDraw) {\n            console.warn('Large lines not support effect');\n          }\n        }\n\n        if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {\n          if (lineDraw) {\n            lineDraw.remove();\n          }\n\n          lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline$1 : hasEffect ? EffectLine : Line$1);\n          this._hasEffet = hasEffect;\n          this._isPolyline = isPolyline;\n          this._isLargeDraw = isLargeDraw;\n          this.group.removeAll();\n        }\n\n        this.group.add(lineDraw.group);\n        return lineDraw;\n      };\n\n      LinesView.prototype._showEffect = function (seriesModel) {\n        return !!seriesModel.get(['effect', 'show']);\n      };\n\n      LinesView.prototype._clearLayer = function (api) {\n        var zr = api.getZr();\n        var isSvg = zr.painter.getType() === 'svg';\n\n        if (!isSvg && this._lastZlevel != null) {\n          zr.painter.getLayer(this._lastZlevel).clear(true);\n        }\n      };\n\n      LinesView.prototype.remove = function (ecModel, api) {\n        this._lineDraw && this._lineDraw.remove();\n        this._lineDraw = null;\n\n        this._clearLayer(api);\n      };\n\n      LinesView.type = 'lines';\n      return LinesView;\n    }(ChartView);\n\n    var Uint32Arr = typeof Uint32Array === 'undefined' ? Array : Uint32Array;\n    var Float64Arr = typeof Float64Array === 'undefined' ? Array : Float64Array;\n\n    function compatEc2(seriesOpt) {\n      var data = seriesOpt.data;\n\n      if (data && data[0] && data[0][0] && data[0][0].coord) {\n        if (\"development\" !== 'production') {\n          console.warn('Lines data configuration has been changed to' + ' { coords:[[1,2],[2,3]] }');\n        }\n\n        seriesOpt.data = map(data, function (itemOpt) {\n          var coords = [itemOpt[0].coord, itemOpt[1].coord];\n          var target = {\n            coords: coords\n          };\n\n          if (itemOpt[0].name) {\n            target.fromName = itemOpt[0].name;\n          }\n\n          if (itemOpt[1].name) {\n            target.toName = itemOpt[1].name;\n          }\n\n          return mergeAll([target, itemOpt[0], itemOpt[1]]);\n        });\n      }\n    }\n\n    var LinesSeriesModel = function (_super) {\n      __extends(LinesSeriesModel, _super);\n\n      function LinesSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = LinesSeriesModel.type;\n        _this.visualStyleAccessPath = 'lineStyle';\n        _this.visualDrawType = 'stroke';\n        return _this;\n      }\n\n      LinesSeriesModel.prototype.init = function (option) {\n        option.data = option.data || [];\n        compatEc2(option);\n\n        var result = this._processFlatCoordsArray(option.data);\n\n        this._flatCoords = result.flatCoords;\n        this._flatCoordsOffset = result.flatCoordsOffset;\n\n        if (result.flatCoords) {\n          option.data = new Float32Array(result.count);\n        }\n\n        _super.prototype.init.apply(this, arguments);\n      };\n\n      LinesSeriesModel.prototype.mergeOption = function (option) {\n        compatEc2(option);\n\n        if (option.data) {\n          var result = this._processFlatCoordsArray(option.data);\n\n          this._flatCoords = result.flatCoords;\n          this._flatCoordsOffset = result.flatCoordsOffset;\n\n          if (result.flatCoords) {\n            option.data = new Float32Array(result.count);\n          }\n        }\n\n        _super.prototype.mergeOption.apply(this, arguments);\n      };\n\n      LinesSeriesModel.prototype.appendData = function (params) {\n        var result = this._processFlatCoordsArray(params.data);\n\n        if (result.flatCoords) {\n          if (!this._flatCoords) {\n            this._flatCoords = result.flatCoords;\n            this._flatCoordsOffset = result.flatCoordsOffset;\n          } else {\n            this._flatCoords = concatArray(this._flatCoords, result.flatCoords);\n            this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);\n          }\n\n          params.data = new Float32Array(result.count);\n        }\n\n        this.getRawData().appendData(params.data);\n      };\n\n      LinesSeriesModel.prototype._getCoordsFromItemModel = function (idx) {\n        var itemModel = this.getData().getItemModel(idx);\n        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords');\n\n        if (\"development\" !== 'production') {\n          if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {\n            throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.');\n          }\n        }\n\n        return coords;\n      };\n\n      LinesSeriesModel.prototype.getLineCoordsCount = function (idx) {\n        if (this._flatCoordsOffset) {\n          return this._flatCoordsOffset[idx * 2 + 1];\n        } else {\n          return this._getCoordsFromItemModel(idx).length;\n        }\n      };\n\n      LinesSeriesModel.prototype.getLineCoords = function (idx, out) {\n        if (this._flatCoordsOffset) {\n          var offset = this._flatCoordsOffset[idx * 2];\n          var len = this._flatCoordsOffset[idx * 2 + 1];\n\n          for (var i = 0; i < len; i++) {\n            out[i] = out[i] || [];\n            out[i][0] = this._flatCoords[offset + i * 2];\n            out[i][1] = this._flatCoords[offset + i * 2 + 1];\n          }\n\n          return len;\n        } else {\n          var coords = this._getCoordsFromItemModel(idx);\n\n          for (var i = 0; i < coords.length; i++) {\n            out[i] = out[i] || [];\n            out[i][0] = coords[i][0];\n            out[i][1] = coords[i][1];\n          }\n\n          return coords.length;\n        }\n      };\n\n      LinesSeriesModel.prototype._processFlatCoordsArray = function (data) {\n        var startOffset = 0;\n\n        if (this._flatCoords) {\n          startOffset = this._flatCoords.length;\n        }\n\n        if (typeof data[0] === 'number') {\n          var len = data.length;\n          var coordsOffsetAndLenStorage = new Uint32Arr(len);\n          var coordsStorage = new Float64Arr(len);\n          var coordsCursor = 0;\n          var offsetCursor = 0;\n          var dataCount = 0;\n\n          for (var i = 0; i < len;) {\n            dataCount++;\n            var count = data[i++];\n            coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;\n            coordsOffsetAndLenStorage[offsetCursor++] = count;\n\n            for (var k = 0; k < count; k++) {\n              var x = data[i++];\n              var y = data[i++];\n              coordsStorage[coordsCursor++] = x;\n              coordsStorage[coordsCursor++] = y;\n\n              if (i > len) {\n                if (\"development\" !== 'production') {\n                  throw new Error('Invalid data format.');\n                }\n              }\n            }\n          }\n\n          return {\n            flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),\n            flatCoords: coordsStorage,\n            count: dataCount\n          };\n        }\n\n        return {\n          flatCoordsOffset: null,\n          flatCoords: null,\n          count: data.length\n        };\n      };\n\n      LinesSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        if (\"development\" !== 'production') {\n          var CoordSys = CoordinateSystemManager.get(option.coordinateSystem);\n\n          if (!CoordSys) {\n            throw new Error('Unkown coordinate system ' + option.coordinateSystem);\n          }\n        }\n\n        var lineData = new List(['value'], this);\n        lineData.hasItemOption = false;\n        lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {\n          if (dataItem instanceof Array) {\n            return NaN;\n          } else {\n            lineData.hasItemOption = true;\n            var value = dataItem.value;\n\n            if (value != null) {\n              return value instanceof Array ? value[dimIndex] : value;\n            }\n          }\n        });\n        return lineData;\n      };\n\n      LinesSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var itemModel = data.getItemModel(dataIndex);\n        var name = itemModel.get('name');\n\n        if (name) {\n          return name;\n        }\n\n        var fromName = itemModel.get('fromName');\n        var toName = itemModel.get('toName');\n        var nameArr = [];\n        fromName != null && nameArr.push(fromName);\n        toName != null && nameArr.push(toName);\n        return createTooltipMarkup('nameValue', {\n          name: nameArr.join(' > ')\n        });\n      };\n\n      LinesSeriesModel.prototype.preventIncremental = function () {\n        return !!this.get(['effect', 'show']);\n      };\n\n      LinesSeriesModel.prototype.getProgressive = function () {\n        var progressive = this.option.progressive;\n\n        if (progressive == null) {\n          return this.option.large ? 1e4 : this.get('progressive');\n        }\n\n        return progressive;\n      };\n\n      LinesSeriesModel.prototype.getProgressiveThreshold = function () {\n        var progressiveThreshold = this.option.progressiveThreshold;\n\n        if (progressiveThreshold == null) {\n          return this.option.large ? 2e4 : this.get('progressiveThreshold');\n        }\n\n        return progressiveThreshold;\n      };\n\n      LinesSeriesModel.type = 'series.lines';\n      LinesSeriesModel.dependencies = ['grid', 'polar', 'geo', 'calendar'];\n      LinesSeriesModel.defaultOption = {\n        coordinateSystem: 'geo',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        xAxisIndex: 0,\n        yAxisIndex: 0,\n        symbol: ['none', 'none'],\n        symbolSize: [10, 10],\n        geoIndex: 0,\n        effect: {\n          show: false,\n          period: 4,\n          constantSpeed: 0,\n          symbol: 'circle',\n          symbolSize: 3,\n          loop: true,\n          trailLength: 0.2\n        },\n        large: false,\n        largeThreshold: 2000,\n        polyline: false,\n        clip: true,\n        label: {\n          show: false,\n          position: 'end'\n        },\n        lineStyle: {\n          opacity: 0.5\n        }\n      };\n      return LinesSeriesModel;\n    }(SeriesModel);\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function normalize$3(a) {\n      if (!(a instanceof Array)) {\n        a = [a, a];\n      }\n\n      return a;\n    }\n\n    var linesVisual = {\n      seriesType: 'lines',\n      reset: function (seriesModel) {\n        var symbolType = normalize$3(seriesModel.get('symbol'));\n        var symbolSize = normalize$3(seriesModel.get('symbolSize'));\n        var data = seriesModel.getData();\n        data.setVisual('fromSymbol', symbolType && symbolType[0]);\n        data.setVisual('toSymbol', symbolType && symbolType[1]);\n        data.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);\n        data.setVisual('toSymbolSize', symbolSize && symbolSize[1]);\n\n        function dataEach(data, idx) {\n          var itemModel = data.getItemModel(idx);\n          var symbolType = normalize$3(itemModel.getShallow('symbol', true));\n          var symbolSize = normalize$3(itemModel.getShallow('symbolSize', true));\n          symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0]);\n          symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1]);\n          symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0]);\n          symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1]);\n        }\n\n        return {\n          dataEach: data.hasItemOption ? dataEach : null\n        };\n      }\n    };\n\n    function install$l(registers) {\n      registers.registerChartView(LinesView);\n      registers.registerSeriesModel(LinesSeriesModel);\n      registers.registerLayout(linesLayout);\n      registers.registerVisual(linesVisual);\n    }\n\n    var GRADIENT_LEVELS = 256;\n\n    var HeatmapLayer = function () {\n      function HeatmapLayer() {\n        this.blurSize = 30;\n        this.pointSize = 20;\n        this.maxOpacity = 1;\n        this.minOpacity = 0;\n        this._gradientPixels = {\n          inRange: null,\n          outOfRange: null\n        };\n        var canvas = createCanvas();\n        this.canvas = canvas;\n      }\n\n      HeatmapLayer.prototype.update = function (data, width, height, normalize, colorFunc, isInRange) {\n        var brush = this._getBrush();\n\n        var gradientInRange = this._getGradient(colorFunc, 'inRange');\n\n        var gradientOutOfRange = this._getGradient(colorFunc, 'outOfRange');\n\n        var r = this.pointSize + this.blurSize;\n        var canvas = this.canvas;\n        var ctx = canvas.getContext('2d');\n        var len = data.length;\n        canvas.width = width;\n        canvas.height = height;\n\n        for (var i = 0; i < len; ++i) {\n          var p = data[i];\n          var x = p[0];\n          var y = p[1];\n          var value = p[2];\n          var alpha = normalize(value);\n          ctx.globalAlpha = alpha;\n          ctx.drawImage(brush, x - r, y - r);\n        }\n\n        if (!canvas.width || !canvas.height) {\n          return canvas;\n        }\n\n        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        var pixels = imageData.data;\n        var offset = 0;\n        var pixelLen = pixels.length;\n        var minOpacity = this.minOpacity;\n        var maxOpacity = this.maxOpacity;\n        var diffOpacity = maxOpacity - minOpacity;\n\n        while (offset < pixelLen) {\n          var alpha = pixels[offset + 3] / 256;\n          var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;\n\n          if (alpha > 0) {\n            var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;\n            alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);\n            pixels[offset++] = gradient[gradientOffset];\n            pixels[offset++] = gradient[gradientOffset + 1];\n            pixels[offset++] = gradient[gradientOffset + 2];\n            pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;\n          } else {\n            offset += 4;\n          }\n        }\n\n        ctx.putImageData(imageData, 0, 0);\n        return canvas;\n      };\n\n      HeatmapLayer.prototype._getBrush = function () {\n        var brushCanvas = this._brushCanvas || (this._brushCanvas = createCanvas());\n        var r = this.pointSize + this.blurSize;\n        var d = r * 2;\n        brushCanvas.width = d;\n        brushCanvas.height = d;\n        var ctx = brushCanvas.getContext('2d');\n        ctx.clearRect(0, 0, d, d);\n        ctx.shadowOffsetX = d;\n        ctx.shadowBlur = this.blurSize;\n        ctx.shadowColor = '#000';\n        ctx.beginPath();\n        ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fill();\n        return brushCanvas;\n      };\n\n      HeatmapLayer.prototype._getGradient = function (colorFunc, state) {\n        var gradientPixels = this._gradientPixels;\n        var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));\n        var color = [0, 0, 0, 0];\n        var off = 0;\n\n        for (var i = 0; i < 256; i++) {\n          colorFunc[state](i / 255, true, color);\n          pixelsSingleState[off++] = color[0];\n          pixelsSingleState[off++] = color[1];\n          pixelsSingleState[off++] = color[2];\n          pixelsSingleState[off++] = color[3];\n        }\n\n        return pixelsSingleState;\n      };\n\n      return HeatmapLayer;\n    }();\n\n    function getIsInPiecewiseRange(dataExtent, pieceList, selected) {\n      var dataSpan = dataExtent[1] - dataExtent[0];\n      pieceList = map(pieceList, function (piece) {\n        return {\n          interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]\n        };\n      });\n      var len = pieceList.length;\n      var lastIndex = 0;\n      return function (val) {\n        var i;\n\n        for (i = lastIndex; i < len; i++) {\n          var interval = pieceList[i].interval;\n\n          if (interval[0] <= val && val <= interval[1]) {\n            lastIndex = i;\n            break;\n          }\n        }\n\n        if (i === len) {\n          for (i = lastIndex - 1; i >= 0; i--) {\n            var interval = pieceList[i].interval;\n\n            if (interval[0] <= val && val <= interval[1]) {\n              lastIndex = i;\n              break;\n            }\n          }\n        }\n\n        return i >= 0 && i < len && selected[i];\n      };\n    }\n\n    function getIsInContinuousRange(dataExtent, range) {\n      var dataSpan = dataExtent[1] - dataExtent[0];\n      range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];\n      return function (val) {\n        return val >= range[0] && val <= range[1];\n      };\n    }\n\n    function isGeoCoordSys(coordSys) {\n      var dimensions = coordSys.dimensions;\n      return dimensions[0] === 'lng' && dimensions[1] === 'lat';\n    }\n\n    var HeatmapView = function (_super) {\n      __extends(HeatmapView, _super);\n\n      function HeatmapView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = HeatmapView.type;\n        return _this;\n      }\n\n      HeatmapView.prototype.render = function (seriesModel, ecModel, api) {\n        var visualMapOfThisSeries;\n        ecModel.eachComponent('visualMap', function (visualMap) {\n          visualMap.eachTargetSeries(function (targetSeries) {\n            if (targetSeries === seriesModel) {\n              visualMapOfThisSeries = visualMap;\n            }\n          });\n        });\n\n        if (\"development\" !== 'production') {\n          if (!visualMapOfThisSeries) {\n            throw new Error('Heatmap must use with visualMap');\n          }\n        }\n\n        this.group.removeAll();\n        this._incrementalDisplayable = null;\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {\n          this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());\n        } else if (isGeoCoordSys(coordSys)) {\n          this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);\n        }\n      };\n\n      HeatmapView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {\n        this.group.removeAll();\n      };\n\n      HeatmapView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys) {\n          if (isGeoCoordSys(coordSys)) {\n            this.render(seriesModel, ecModel, api);\n          } else {\n            this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);\n          }\n        }\n      };\n\n      HeatmapView.prototype._renderOnCartesianAndCalendar = function (seriesModel, api, start, end, incremental) {\n        var coordSys = seriesModel.coordinateSystem;\n        var width;\n        var height;\n        var xAxisExtent;\n        var yAxisExtent;\n\n        if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n          var xAxis = coordSys.getAxis('x');\n          var yAxis = coordSys.getAxis('y');\n\n          if (\"development\" !== 'production') {\n            if (!(xAxis.type === 'category' && yAxis.type === 'category')) {\n              throw new Error('Heatmap on cartesian must have two category axes');\n            }\n\n            if (!(xAxis.onBand && yAxis.onBand)) {\n              throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');\n            }\n          }\n\n          width = xAxis.getBandWidth();\n          height = yAxis.getBandWidth();\n          xAxisExtent = xAxis.scale.getExtent();\n          yAxisExtent = yAxis.scale.getExtent();\n        }\n\n        var group = this.group;\n        var data = seriesModel.getData();\n        var emphasisStyle = seriesModel.getModel(['emphasis', 'itemStyle']).getItemStyle();\n        var blurStyle = seriesModel.getModel(['blur', 'itemStyle']).getItemStyle();\n        var selectStyle = seriesModel.getModel(['select', 'itemStyle']).getItemStyle();\n        var labelStatesModels = getLabelStatesModels(seriesModel);\n        var focus = seriesModel.get(['emphasis', 'focus']);\n        var blurScope = seriesModel.get(['emphasis', 'blurScope']);\n        var dataDims = isCoordinateSystemType(coordSys, 'cartesian2d') ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')];\n\n        for (var idx = start; idx < end; idx++) {\n          var rect = void 0;\n          var style = data.getItemVisual(idx, 'style');\n\n          if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n            var dataDimX = data.get(dataDims[0], idx);\n            var dataDimY = data.get(dataDims[1], idx);\n\n            if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {\n              continue;\n            }\n\n            var point = coordSys.dataToPoint([dataDimX, dataDimY]);\n            rect = new Rect({\n              shape: {\n                x: Math.floor(Math.round(point[0]) - width / 2),\n                y: Math.floor(Math.round(point[1]) - height / 2),\n                width: Math.ceil(width),\n                height: Math.ceil(height)\n              },\n              style: style\n            });\n          } else {\n            if (isNaN(data.get(dataDims[1], idx))) {\n              continue;\n            }\n\n            rect = new Rect({\n              z2: 1,\n              shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,\n              style: style\n            });\n          }\n\n          var itemModel = data.getItemModel(idx);\n\n          if (data.hasItemOption) {\n            var emphasisModel = itemModel.getModel('emphasis');\n            emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n            blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n            selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n            focus = emphasisModel.get('focus');\n            blurScope = emphasisModel.get('blurScope');\n            labelStatesModels = getLabelStatesModels(itemModel);\n          }\n\n          var rawValue = seriesModel.getRawValue(idx);\n          var defaultText = '-';\n\n          if (rawValue && rawValue[2] != null) {\n            defaultText = rawValue[2] + '';\n          }\n\n          setLabelStyle(rect, labelStatesModels, {\n            labelFetcher: seriesModel,\n            labelDataIndex: idx,\n            defaultOpacity: style.opacity,\n            defaultText: defaultText\n          });\n          rect.ensureState('emphasis').style = emphasisStyle;\n          rect.ensureState('blur').style = blurStyle;\n          rect.ensureState('select').style = selectStyle;\n          enableHoverEmphasis(rect, focus, blurScope);\n          rect.incremental = incremental;\n\n          if (incremental) {\n            rect.states.emphasis.hoverLayer = true;\n          }\n\n          group.add(rect);\n          data.setItemGraphicEl(idx, rect);\n        }\n      };\n\n      HeatmapView.prototype._renderOnGeo = function (geo, seriesModel, visualMapModel, api) {\n        var inRangeVisuals = visualMapModel.targetVisuals.inRange;\n        var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;\n        var data = seriesModel.getData();\n        var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer();\n        hmLayer.blurSize = seriesModel.get('blurSize');\n        hmLayer.pointSize = seriesModel.get('pointSize');\n        hmLayer.minOpacity = seriesModel.get('minOpacity');\n        hmLayer.maxOpacity = seriesModel.get('maxOpacity');\n        var rect = geo.getViewRect().clone();\n        var roamTransform = geo.getRoamTransform();\n        rect.applyTransform(roamTransform);\n        var x = Math.max(rect.x, 0);\n        var y = Math.max(rect.y, 0);\n        var x2 = Math.min(rect.width + rect.x, api.getWidth());\n        var y2 = Math.min(rect.height + rect.y, api.getHeight());\n        var width = x2 - x;\n        var height = y2 - y;\n        var dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')];\n        var points = data.mapArray(dims, function (lng, lat, value) {\n          var pt = geo.dataToPoint([lng, lat]);\n          pt[0] -= x;\n          pt[1] -= y;\n          pt.push(value);\n          return pt;\n        });\n        var dataExtent = visualMapModel.getExtent();\n        var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);\n        hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {\n          inRange: inRangeVisuals.color.getColorMapper(),\n          outOfRange: outOfRangeVisuals.color.getColorMapper()\n        }, isInRange);\n        var img = new ZRImage({\n          style: {\n            width: width,\n            height: height,\n            x: x,\n            y: y,\n            image: hmLayer.canvas\n          },\n          silent: true\n        });\n        this.group.add(img);\n      };\n\n      HeatmapView.type = 'heatmap';\n      return HeatmapView;\n    }(ChartView);\n\n    var HeatmapSeriesModel = function (_super) {\n      __extends(HeatmapSeriesModel, _super);\n\n      function HeatmapSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = HeatmapSeriesModel.type;\n        return _this;\n      }\n\n      HeatmapSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this, {\n          generateCoord: 'value'\n        });\n      };\n\n      HeatmapSeriesModel.prototype.preventIncremental = function () {\n        var coordSysCreator = CoordinateSystemManager.get(this.get('coordinateSystem'));\n\n        if (coordSysCreator && coordSysCreator.dimensions) {\n          return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat';\n        }\n      };\n\n      HeatmapSeriesModel.type = 'series.heatmap';\n      HeatmapSeriesModel.dependencies = ['grid', 'geo', 'calendar'];\n      HeatmapSeriesModel.defaultOption = {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        geoIndex: 0,\n        blurSize: 30,\n        pointSize: 20,\n        maxOpacity: 1,\n        minOpacity: 0,\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        }\n      };\n      return HeatmapSeriesModel;\n    }(SeriesModel);\n\n    function install$m(registers) {\n      registers.registerChartView(HeatmapView);\n      registers.registerSeriesModel(HeatmapSeriesModel);\n    }\n\n    var BAR_BORDER_WIDTH_QUERY$1 = ['itemStyle', 'borderWidth'];\n    var LAYOUT_ATTRS = [{\n      xy: 'x',\n      wh: 'width',\n      index: 0,\n      posDesc: ['left', 'right']\n    }, {\n      xy: 'y',\n      wh: 'height',\n      index: 1,\n      posDesc: ['top', 'bottom']\n    }];\n    var pathForLineWidth = new Circle();\n\n    var PictorialBarView = function (_super) {\n      __extends(PictorialBarView, _super);\n\n      function PictorialBarView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PictorialBarView.type;\n        return _this;\n      }\n\n      PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {\n        var group = this.group;\n        var data = seriesModel.getData();\n        var oldData = this._data;\n        var cartesian = seriesModel.coordinateSystem;\n        var baseAxis = cartesian.getBaseAxis();\n        var isHorizontal = baseAxis.isHorizontal();\n        var coordSysRect = cartesian.master.getRect();\n        var opt = {\n          ecSize: {\n            width: api.getWidth(),\n            height: api.getHeight()\n          },\n          seriesModel: seriesModel,\n          coordSys: cartesian,\n          coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],\n          isHorizontal: isHorizontal,\n          valueDim: LAYOUT_ATTRS[+isHorizontal],\n          categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]\n        };\n        data.diff(oldData).add(function (dataIndex) {\n          if (!data.hasValue(dataIndex)) {\n            return;\n          }\n\n          var itemModel = getItemModel(data, dataIndex);\n          var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);\n          var bar = createBar(data, opt, symbolMeta);\n          data.setItemGraphicEl(dataIndex, bar);\n          group.add(bar);\n          updateCommon$1(bar, opt, symbolMeta);\n        }).update(function (newIndex, oldIndex) {\n          var bar = oldData.getItemGraphicEl(oldIndex);\n\n          if (!data.hasValue(newIndex)) {\n            group.remove(bar);\n            return;\n          }\n\n          var itemModel = getItemModel(data, newIndex);\n          var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);\n          var pictorialShapeStr = getShapeStr(data, symbolMeta);\n\n          if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {\n            group.remove(bar);\n            data.setItemGraphicEl(newIndex, null);\n            bar = null;\n          }\n\n          if (bar) {\n            updateBar(bar, opt, symbolMeta);\n          } else {\n            bar = createBar(data, opt, symbolMeta, true);\n          }\n\n          data.setItemGraphicEl(newIndex, bar);\n          bar.__pictorialSymbolMeta = symbolMeta;\n          group.add(bar);\n          updateCommon$1(bar, opt, symbolMeta);\n        }).remove(function (dataIndex) {\n          var bar = oldData.getItemGraphicEl(dataIndex);\n          bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);\n        }).execute();\n        this._data = data;\n        return this.group;\n      };\n\n      PictorialBarView.prototype.remove = function (ecModel, api) {\n        var group = this.group;\n        var data = this._data;\n\n        if (ecModel.get('animation')) {\n          if (data) {\n            data.eachItemGraphicEl(function (bar) {\n              removeBar(data, getECData(bar).dataIndex, ecModel, bar);\n            });\n          }\n        } else {\n          group.removeAll();\n        }\n      };\n\n      PictorialBarView.type = 'pictorialBar';\n      return PictorialBarView;\n    }(ChartView);\n\n    function getSymbolMeta(data, dataIndex, itemModel, opt) {\n      var layout = data.getItemLayout(dataIndex);\n      var symbolRepeat = itemModel.get('symbolRepeat');\n      var symbolClip = itemModel.get('symbolClip');\n      var symbolPosition = itemModel.get('symbolPosition') || 'start';\n      var symbolRotate = itemModel.get('symbolRotate');\n      var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n      var symbolPatternSize = itemModel.get('symbolPatternSize') || 2;\n      var isAnimationEnabled = itemModel.isAnimationEnabled();\n      var symbolMeta = {\n        dataIndex: dataIndex,\n        layout: layout,\n        itemModel: itemModel,\n        symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',\n        style: data.getItemVisual(dataIndex, 'style'),\n        symbolClip: symbolClip,\n        symbolRepeat: symbolRepeat,\n        symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),\n        symbolPatternSize: symbolPatternSize,\n        rotation: rotation,\n        animationModel: isAnimationEnabled ? itemModel : null,\n        hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),\n        z2: itemModel.getShallow('z', true) || 0\n      };\n      prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);\n      prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);\n      prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);\n      var symbolSize = symbolMeta.symbolSize;\n      var symbolOffset = itemModel.get('symbolOffset');\n\n      if (isArray(symbolOffset)) {\n        symbolOffset = [parsePercent$1(symbolOffset[0], symbolSize[0]), parsePercent$1(symbolOffset[1], symbolSize[1])];\n      }\n\n      prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);\n      return symbolMeta;\n    }\n\n    function prepareBarLength(itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {\n      var valueDim = opt.valueDim;\n      var symbolBoundingData = itemModel.get('symbolBoundingData');\n      var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());\n      var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));\n      var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);\n      var boundingLength;\n\n      if (isArray(symbolBoundingData)) {\n        var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];\n        symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();\n        boundingLength = symbolBoundingExtent[pxSignIdx];\n      } else if (symbolBoundingData != null) {\n        boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;\n      } else if (symbolRepeat) {\n        boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;\n      } else {\n        boundingLength = layout[valueDim.wh];\n      }\n\n      outputSymbolMeta.boundingLength = boundingLength;\n\n      if (symbolRepeat) {\n        outputSymbolMeta.repeatCutLength = layout[valueDim.wh];\n      }\n\n      outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;\n    }\n\n    function convertToCoordOnAxis(axis, value) {\n      return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));\n    }\n\n    function prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {\n      var valueDim = opt.valueDim;\n      var categoryDim = opt.categoryDim;\n      var categorySize = Math.abs(layout[categoryDim.wh]);\n      var symbolSize = data.getItemVisual(dataIndex, 'symbolSize');\n      var parsedSymbolSize;\n\n      if (isArray(symbolSize)) {\n        parsedSymbolSize = symbolSize.slice();\n      } else {\n        if (symbolSize == null) {\n          parsedSymbolSize = ['100%', '100%'];\n        } else {\n          parsedSymbolSize = [symbolSize, symbolSize];\n        }\n      }\n\n      parsedSymbolSize[categoryDim.index] = parsePercent$1(parsedSymbolSize[categoryDim.index], categorySize);\n      parsedSymbolSize[valueDim.index] = parsePercent$1(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));\n      outputSymbolMeta.symbolSize = parsedSymbolSize;\n      var symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize];\n      symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;\n    }\n\n    function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {\n      var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY$1) || 0;\n\n      if (valueLineWidth) {\n        pathForLineWidth.attr({\n          scaleX: symbolScale[0],\n          scaleY: symbolScale[1],\n          rotation: rotation\n        });\n        pathForLineWidth.updateTransform();\n        valueLineWidth /= pathForLineWidth.getLineScale();\n        valueLineWidth *= symbolScale[opt.valueDim.index];\n      }\n\n      outputSymbolMeta.valueLineWidth = valueLineWidth;\n    }\n\n    function prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {\n      var categoryDim = opt.categoryDim;\n      var valueDim = opt.valueDim;\n      var pxSign = outputSymbolMeta.pxSign;\n      var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);\n      var pathLen = unitLength;\n\n      if (symbolRepeat) {\n        var absBoundingLength = Math.abs(boundingLength);\n        var symbolMargin = retrieve(itemModel.get('symbolMargin'), '15%') + '';\n        var hasEndGap = false;\n\n        if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {\n          hasEndGap = true;\n          symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);\n        }\n\n        var symbolMarginNumeric = parsePercent$1(symbolMargin, symbolSize[valueDim.index]);\n        var uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);\n        var endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;\n        var repeatSpecified = isNumeric(symbolRepeat);\n        var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);\n        var mDiff = absBoundingLength - repeatTimes * unitLength;\n        symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);\n        uLenWithMargin = unitLength + symbolMarginNumeric * 2;\n        endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;\n\n        if (!repeatSpecified && symbolRepeat !== 'fixed') {\n          repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;\n        }\n\n        pathLen = repeatTimes * uLenWithMargin - endFix;\n        outputSymbolMeta.repeatTimes = repeatTimes;\n        outputSymbolMeta.symbolMargin = symbolMarginNumeric;\n      }\n\n      var sizeFix = pxSign * (pathLen / 2);\n      var pathPosition = outputSymbolMeta.pathPosition = [];\n      pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;\n      pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2;\n\n      if (symbolOffset) {\n        pathPosition[0] += symbolOffset[0];\n        pathPosition[1] += symbolOffset[1];\n      }\n\n      var bundlePosition = outputSymbolMeta.bundlePosition = [];\n      bundlePosition[categoryDim.index] = layout[categoryDim.xy];\n      bundlePosition[valueDim.index] = layout[valueDim.xy];\n      var barRectShape = outputSymbolMeta.barRectShape = extend({}, layout);\n      barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));\n      barRectShape[categoryDim.wh] = layout[categoryDim.wh];\n      var clipShape = outputSymbolMeta.clipShape = {};\n      clipShape[categoryDim.xy] = -layout[categoryDim.xy];\n      clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];\n      clipShape[valueDim.xy] = 0;\n      clipShape[valueDim.wh] = layout[valueDim.wh];\n    }\n\n    function createPath(symbolMeta) {\n      var symbolPatternSize = symbolMeta.symbolPatternSize;\n      var path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);\n      path.attr({\n        culling: true\n      });\n      path.type !== 'image' && path.setStyle({\n        strokeNoScale: true\n      });\n      return path;\n    }\n\n    function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {\n      var bundle = bar.__pictorialBundle;\n      var symbolSize = symbolMeta.symbolSize;\n      var valueLineWidth = symbolMeta.valueLineWidth;\n      var pathPosition = symbolMeta.pathPosition;\n      var valueDim = opt.valueDim;\n      var repeatTimes = symbolMeta.repeatTimes || 0;\n      var index = 0;\n      var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;\n      eachPath(bar, function (path) {\n        path.__pictorialAnimationIndex = index;\n        path.__pictorialRepeatTimes = repeatTimes;\n\n        if (index < repeatTimes) {\n          updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);\n        } else {\n          updateAttr(path, null, {\n            scaleX: 0,\n            scaleY: 0\n          }, symbolMeta, isUpdate, function () {\n            bundle.remove(path);\n          });\n        }\n\n        index++;\n      });\n\n      for (; index < repeatTimes; index++) {\n        var path = createPath(symbolMeta);\n        path.__pictorialAnimationIndex = index;\n        path.__pictorialRepeatTimes = repeatTimes;\n        bundle.add(path);\n        var target = makeTarget(index);\n        updateAttr(path, {\n          x: target.x,\n          y: target.y,\n          scaleX: 0,\n          scaleY: 0\n        }, {\n          scaleX: target.scaleX,\n          scaleY: target.scaleY,\n          rotation: target.rotation\n        }, symbolMeta, isUpdate);\n      }\n\n      function makeTarget(index) {\n        var position = pathPosition.slice();\n        var pxSign = symbolMeta.pxSign;\n        var i = index;\n\n        if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {\n          i = repeatTimes - 1 - index;\n        }\n\n        position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];\n        return {\n          x: position[0],\n          y: position[1],\n          scaleX: symbolMeta.symbolScale[0],\n          scaleY: symbolMeta.symbolScale[1],\n          rotation: symbolMeta.rotation\n        };\n      }\n    }\n\n    function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {\n      var bundle = bar.__pictorialBundle;\n      var mainPath = bar.__pictorialMainPath;\n\n      if (!mainPath) {\n        mainPath = bar.__pictorialMainPath = createPath(symbolMeta);\n        bundle.add(mainPath);\n        updateAttr(mainPath, {\n          x: symbolMeta.pathPosition[0],\n          y: symbolMeta.pathPosition[1],\n          scaleX: 0,\n          scaleY: 0,\n          rotation: symbolMeta.rotation\n        }, {\n          scaleX: symbolMeta.symbolScale[0],\n          scaleY: symbolMeta.symbolScale[1]\n        }, symbolMeta, isUpdate);\n      } else {\n        updateAttr(mainPath, null, {\n          x: symbolMeta.pathPosition[0],\n          y: symbolMeta.pathPosition[1],\n          scaleX: symbolMeta.symbolScale[0],\n          scaleY: symbolMeta.symbolScale[1],\n          rotation: symbolMeta.rotation\n        }, symbolMeta, isUpdate);\n      }\n    }\n\n    function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {\n      var rectShape = extend({}, symbolMeta.barRectShape);\n      var barRect = bar.__pictorialBarRect;\n\n      if (!barRect) {\n        barRect = bar.__pictorialBarRect = new Rect({\n          z2: 2,\n          shape: rectShape,\n          silent: true,\n          style: {\n            stroke: 'transparent',\n            fill: 'transparent',\n            lineWidth: 0\n          }\n        });\n        bar.add(barRect);\n      } else {\n        updateAttr(barRect, null, {\n          shape: rectShape\n        }, symbolMeta, isUpdate);\n      }\n    }\n\n    function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {\n      if (symbolMeta.symbolClip) {\n        var clipPath = bar.__pictorialClipPath;\n        var clipShape = extend({}, symbolMeta.clipShape);\n        var valueDim = opt.valueDim;\n        var animationModel = symbolMeta.animationModel;\n        var dataIndex = symbolMeta.dataIndex;\n\n        if (clipPath) {\n          updateProps(clipPath, {\n            shape: clipShape\n          }, animationModel, dataIndex);\n        } else {\n          clipShape[valueDim.wh] = 0;\n          clipPath = new Rect({\n            shape: clipShape\n          });\n\n          bar.__pictorialBundle.setClipPath(clipPath);\n\n          bar.__pictorialClipPath = clipPath;\n          var target = {};\n          target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];\n          graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {\n            shape: target\n          }, animationModel, dataIndex);\n        }\n      }\n    }\n\n    function getItemModel(data, dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      itemModel.getAnimationDelayParams = getAnimationDelayParams;\n      itemModel.isAnimationEnabled = isAnimationEnabled;\n      return itemModel;\n    }\n\n    function getAnimationDelayParams(path) {\n      return {\n        index: path.__pictorialAnimationIndex,\n        count: path.__pictorialRepeatTimes\n      };\n    }\n\n    function isAnimationEnabled() {\n      return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation');\n    }\n\n    function createBar(data, opt, symbolMeta, isUpdate) {\n      var bar = new Group();\n      var bundle = new Group();\n      bar.add(bundle);\n      bar.__pictorialBundle = bundle;\n      bundle.x = symbolMeta.bundlePosition[0];\n      bundle.y = symbolMeta.bundlePosition[1];\n\n      if (symbolMeta.symbolRepeat) {\n        createOrUpdateRepeatSymbols(bar, opt, symbolMeta);\n      } else {\n        createOrUpdateSingleSymbol(bar, opt, symbolMeta);\n      }\n\n      createOrUpdateBarRect(bar, symbolMeta, isUpdate);\n      createOrUpdateClip(bar, opt, symbolMeta, isUpdate);\n      bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);\n      bar.__pictorialSymbolMeta = symbolMeta;\n      return bar;\n    }\n\n    function updateBar(bar, opt, symbolMeta) {\n      var animationModel = symbolMeta.animationModel;\n      var dataIndex = symbolMeta.dataIndex;\n      var bundle = bar.__pictorialBundle;\n      updateProps(bundle, {\n        x: symbolMeta.bundlePosition[0],\n        y: symbolMeta.bundlePosition[1]\n      }, animationModel, dataIndex);\n\n      if (symbolMeta.symbolRepeat) {\n        createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);\n      } else {\n        createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);\n      }\n\n      createOrUpdateBarRect(bar, symbolMeta, true);\n      createOrUpdateClip(bar, opt, symbolMeta, true);\n    }\n\n    function removeBar(data, dataIndex, animationModel, bar) {\n      var labelRect = bar.__pictorialBarRect;\n      labelRect && labelRect.removeTextContent();\n      var pathes = [];\n      eachPath(bar, function (path) {\n        pathes.push(path);\n      });\n      bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);\n      bar.__pictorialClipPath && (animationModel = null);\n      each(pathes, function (path) {\n        removeElement(path, {\n          scaleX: 0,\n          scaleY: 0\n        }, animationModel, dataIndex, function () {\n          bar.parent && bar.parent.remove(bar);\n        });\n      });\n      data.setItemGraphicEl(dataIndex, null);\n    }\n\n    function getShapeStr(data, symbolMeta) {\n      return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':');\n    }\n\n    function eachPath(bar, cb, context) {\n      each(bar.__pictorialBundle.children(), function (el) {\n        el !== bar.__pictorialBarRect && cb.call(context, el);\n      });\n    }\n\n    function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {\n      immediateAttrs && el.attr(immediateAttrs);\n\n      if (symbolMeta.symbolClip && !isUpdate) {\n        animationAttrs && el.attr(animationAttrs);\n      } else {\n        animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);\n      }\n    }\n\n    function updateCommon$1(bar, opt, symbolMeta) {\n      var dataIndex = symbolMeta.dataIndex;\n      var itemModel = symbolMeta.itemModel;\n      var emphasisModel = itemModel.getModel('emphasis');\n      var emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle();\n      var blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();\n      var selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();\n      var cursorStyle = itemModel.getShallow('cursor');\n      var focus = emphasisModel.get('focus');\n      var blurScope = emphasisModel.get('blurScope');\n      var hoverScale = emphasisModel.get('scale');\n      eachPath(bar, function (path) {\n        if (path instanceof ZRImage) {\n          var pathStyle = path.style;\n          path.useStyle(extend({\n            image: pathStyle.image,\n            x: pathStyle.x,\n            y: pathStyle.y,\n            width: pathStyle.width,\n            height: pathStyle.height\n          }, symbolMeta.style));\n        } else {\n          path.useStyle(symbolMeta.style);\n        }\n\n        var emphasisState = path.ensureState('emphasis');\n        emphasisState.style = emphasisStyle;\n\n        if (hoverScale) {\n          emphasisState.scaleX = path.scaleX * 1.1;\n          emphasisState.scaleY = path.scaleY * 1.1;\n        }\n\n        path.ensureState('blur').style = blurStyle;\n        path.ensureState('select').style = selectStyle;\n        cursorStyle && (path.cursor = cursorStyle);\n        path.z2 = symbolMeta.z2;\n      });\n      var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];\n      var barRect = bar.__pictorialBarRect;\n      setLabelStyle(barRect, getLabelStatesModels(itemModel), {\n        labelFetcher: opt.seriesModel,\n        labelDataIndex: dataIndex,\n        defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),\n        inheritColor: symbolMeta.style.fill,\n        defaultOpacity: symbolMeta.style.opacity,\n        defaultOutsidePosition: barPositionOutside\n      });\n      enableHoverEmphasis(bar, focus, blurScope);\n    }\n\n    function toIntTimes(times) {\n      var roundedTimes = Math.round(times);\n      return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);\n    }\n\n    var PictorialBarSeriesModel = function (_super) {\n      __extends(PictorialBarSeriesModel, _super);\n\n      function PictorialBarSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PictorialBarSeriesModel.type;\n        _this.hasSymbolVisual = true;\n        _this.defaultSymbol = 'roundRect';\n        return _this;\n      }\n\n      PictorialBarSeriesModel.prototype.getInitialData = function (option) {\n        option.stack = null;\n        return _super.prototype.getInitialData.apply(this, arguments);\n      };\n\n      PictorialBarSeriesModel.type = 'series.pictorialBar';\n      PictorialBarSeriesModel.dependencies = ['grid'];\n      PictorialBarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {\n        symbol: 'circle',\n        symbolSize: null,\n        symbolRotate: null,\n        symbolPosition: null,\n        symbolOffset: null,\n        symbolMargin: null,\n        symbolRepeat: false,\n        symbolRepeatDirection: 'end',\n        symbolClip: false,\n        symbolBoundingData: null,\n        symbolPatternSize: 400,\n        barGap: '-100%',\n        progressive: 0,\n        emphasis: {\n          scale: false\n        },\n        select: {\n          itemStyle: {\n            borderColor: '#212121'\n          }\n        }\n      });\n      return PictorialBarSeriesModel;\n    }(BaseBarSeriesModel);\n\n    function install$n(registers) {\n      registers.registerChartView(PictorialBarView);\n      registers.registerSeriesModel(PictorialBarSeriesModel);\n      registers.registerLayout(curry(layout, 'pictorialBar'));\n    }\n\n    var ThemeRiverView = function (_super) {\n      __extends(ThemeRiverView, _super);\n\n      function ThemeRiverView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ThemeRiverView.type;\n        _this._layers = [];\n        return _this;\n      }\n\n      ThemeRiverView.prototype.render = function (seriesModel, ecModel, api) {\n        var data = seriesModel.getData();\n        var self = this;\n        var group = this.group;\n        var layersSeries = seriesModel.getLayerSeries();\n        var layoutInfo = data.getLayout('layoutInfo');\n        var rect = layoutInfo.rect;\n        var boundaryGap = layoutInfo.boundaryGap;\n        group.x = 0;\n        group.y = rect.y + boundaryGap[0];\n\n        function keyGetter(item) {\n          return item.name;\n        }\n\n        var dataDiffer = new DataDiffer(this._layersSeries || [], layersSeries, keyGetter, keyGetter);\n        var newLayersGroups = [];\n        dataDiffer.add(bind(process, this, 'add')).update(bind(process, this, 'update')).remove(bind(process, this, 'remove')).execute();\n\n        function process(status, idx, oldIdx) {\n          var oldLayersGroups = self._layers;\n\n          if (status === 'remove') {\n            group.remove(oldLayersGroups[idx]);\n            return;\n          }\n\n          var points0 = [];\n          var points1 = [];\n          var style;\n          var indices = layersSeries[idx].indices;\n          var j = 0;\n\n          for (; j < indices.length; j++) {\n            var layout = data.getItemLayout(indices[j]);\n            var x = layout.x;\n            var y0 = layout.y0;\n            var y = layout.y;\n            points0.push(x, y0);\n            points1.push(x, y0 + y);\n            style = data.getItemVisual(indices[j], 'style');\n          }\n\n          var polygon;\n          var textLayout = data.getItemLayout(indices[0]);\n          var labelModel = seriesModel.getModel('label');\n          var margin = labelModel.get('margin');\n          var emphasisModel = seriesModel.getModel('emphasis');\n\n          if (status === 'add') {\n            var layerGroup = newLayersGroups[idx] = new Group();\n            polygon = new ECPolygon({\n              shape: {\n                points: points0,\n                stackedOnPoints: points1,\n                smooth: 0.4,\n                stackedOnSmooth: 0.4,\n                smoothConstraint: false\n              },\n              z2: 0\n            });\n            layerGroup.add(polygon);\n            group.add(layerGroup);\n\n            if (seriesModel.isAnimationEnabled()) {\n              polygon.setClipPath(createGridClipShape$2(polygon.getBoundingRect(), seriesModel, function () {\n                polygon.removeClipPath();\n              }));\n            }\n          } else {\n            var layerGroup = oldLayersGroups[oldIdx];\n            polygon = layerGroup.childAt(0);\n            group.add(layerGroup);\n            newLayersGroups[idx] = layerGroup;\n            updateProps(polygon, {\n              shape: {\n                points: points0,\n                stackedOnPoints: points1\n              }\n            }, seriesModel);\n          }\n\n          setLabelStyle(polygon, getLabelStatesModels(seriesModel), {\n            labelDataIndex: indices[j - 1],\n            defaultText: data.getName(indices[j - 1]),\n            inheritColor: style.fill\n          }, {\n            normal: {\n              verticalAlign: 'middle'\n            }\n          });\n          polygon.setTextConfig({\n            position: null,\n            local: true\n          });\n          var labelEl = polygon.getTextContent();\n\n          if (labelEl) {\n            labelEl.x = textLayout.x - margin;\n            labelEl.y = textLayout.y0 + textLayout.y / 2;\n          }\n\n          polygon.useStyle(style);\n          data.setItemGraphicEl(idx, polygon);\n          setStatesStylesFromModel(polygon, seriesModel);\n          enableHoverEmphasis(polygon, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n\n        this._layersSeries = layersSeries;\n        this._layers = newLayersGroups;\n      };\n\n      ThemeRiverView.type = 'themeRiver';\n      return ThemeRiverView;\n    }(ChartView);\n\n    function createGridClipShape$2(rect, seriesModel, cb) {\n      var rectEl = new Rect({\n        shape: {\n          x: rect.x - 10,\n          y: rect.y - 10,\n          width: 0,\n          height: rect.height + 20\n        }\n      });\n      initProps(rectEl, {\n        shape: {\n          x: rect.x - 50,\n          width: rect.width + 100,\n          height: rect.height + 20\n        }\n      }, seriesModel, cb);\n      return rectEl;\n    }\n\n    var DATA_NAME_INDEX = 2;\n\n    var ThemeRiverSeriesModel = function (_super) {\n      __extends(ThemeRiverSeriesModel, _super);\n\n      function ThemeRiverSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ThemeRiverSeriesModel.type;\n        _this.useColorPaletteOnData = true;\n        return _this;\n      }\n\n      ThemeRiverSeriesModel.prototype.init = function (option) {\n        _super.prototype.init.apply(this, arguments);\n\n        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this));\n      };\n\n      ThemeRiverSeriesModel.prototype.fixData = function (data) {\n        var rawDataLength = data.length;\n        var timeValueKeys = {};\n        var groupResult = groupData(data, function (item) {\n          if (!timeValueKeys.hasOwnProperty(item[0] + '')) {\n            timeValueKeys[item[0] + ''] = -1;\n          }\n\n          return item[2];\n        });\n        var layerData = [];\n        groupResult.buckets.each(function (items, key) {\n          layerData.push({\n            name: key,\n            dataList: items\n          });\n        });\n        var layerNum = layerData.length;\n\n        for (var k = 0; k < layerNum; ++k) {\n          var name_1 = layerData[k].name;\n\n          for (var j = 0; j < layerData[k].dataList.length; ++j) {\n            var timeValue = layerData[k].dataList[j][0] + '';\n            timeValueKeys[timeValue] = k;\n          }\n\n          for (var timeValue in timeValueKeys) {\n            if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {\n              timeValueKeys[timeValue] = k;\n              data[rawDataLength] = [timeValue, 0, name_1];\n              rawDataLength++;\n            }\n          }\n        }\n\n        return data;\n      };\n\n      ThemeRiverSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        var singleAxisModel = this.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];\n        var axisType = singleAxisModel.get('type');\n        var filterData = filter(option.data, function (dataItem) {\n          return dataItem[2] !== undefined;\n        });\n        var data = this.fixData(filterData || []);\n        var nameList = [];\n        var nameMap = this.nameMap = createHashMap();\n        var count = 0;\n\n        for (var i = 0; i < data.length; ++i) {\n          nameList.push(data[i][DATA_NAME_INDEX]);\n\n          if (!nameMap.get(data[i][DATA_NAME_INDEX])) {\n            nameMap.set(data[i][DATA_NAME_INDEX], count);\n            count++;\n          }\n        }\n\n        var dimensionsInfo = createDimensions(data, {\n          coordDimensions: ['single'],\n          dimensionsDefine: [{\n            name: 'time',\n            type: getDimensionTypeByAxis(axisType)\n          }, {\n            name: 'value',\n            type: 'float'\n          }, {\n            name: 'name',\n            type: 'ordinal'\n          }],\n          encodeDefine: {\n            single: 0,\n            value: 1,\n            itemName: 2\n          }\n        });\n        var list = new List(dimensionsInfo, this);\n        list.initData(data);\n        return list;\n      };\n\n      ThemeRiverSeriesModel.prototype.getLayerSeries = function () {\n        var data = this.getData();\n        var lenCount = data.count();\n        var indexArr = [];\n\n        for (var i = 0; i < lenCount; ++i) {\n          indexArr[i] = i;\n        }\n\n        var timeDim = data.mapDimension('single');\n        var groupResult = groupData(indexArr, function (index) {\n          return data.get('name', index);\n        });\n        var layerSeries = [];\n        groupResult.buckets.each(function (items, key) {\n          items.sort(function (index1, index2) {\n            return data.get(timeDim, index1) - data.get(timeDim, index2);\n          });\n          layerSeries.push({\n            name: key,\n            indices: items\n          });\n        });\n        return layerSeries;\n      };\n\n      ThemeRiverSeriesModel.prototype.getAxisTooltipData = function (dim, value, baseAxis) {\n        if (!isArray(dim)) {\n          dim = dim ? [dim] : [];\n        }\n\n        var data = this.getData();\n        var layerSeries = this.getLayerSeries();\n        var indices = [];\n        var layerNum = layerSeries.length;\n        var nestestValue;\n\n        for (var i = 0; i < layerNum; ++i) {\n          var minDist = Number.MAX_VALUE;\n          var nearestIdx = -1;\n          var pointNum = layerSeries[i].indices.length;\n\n          for (var j = 0; j < pointNum; ++j) {\n            var theValue = data.get(dim[0], layerSeries[i].indices[j]);\n            var dist = Math.abs(theValue - value);\n\n            if (dist <= minDist) {\n              nestestValue = theValue;\n              minDist = dist;\n              nearestIdx = layerSeries[i].indices[j];\n            }\n          }\n\n          indices.push(nearestIdx);\n        }\n\n        return {\n          dataIndices: indices,\n          nestestValue: nestestValue\n        };\n      };\n\n      ThemeRiverSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var name = data.getName(dataIndex);\n        var value = data.get(data.mapDimension('value'), dataIndex);\n        return createTooltipMarkup('nameValue', {\n          name: name,\n          value: value\n        });\n      };\n\n      ThemeRiverSeriesModel.type = 'series.themeRiver';\n      ThemeRiverSeriesModel.dependencies = ['singleAxis'];\n      ThemeRiverSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        coordinateSystem: 'singleAxis',\n        boundaryGap: ['10%', '10%'],\n        singleAxisIndex: 0,\n        animationEasing: 'linear',\n        label: {\n          margin: 4,\n          show: true,\n          position: 'left',\n          fontSize: 11\n        },\n        emphasis: {\n          label: {\n            show: true\n          }\n        }\n      };\n      return ThemeRiverSeriesModel;\n    }(SeriesModel);\n\n    function themeRiverLayout(ecModel, api) {\n      ecModel.eachSeriesByType('themeRiver', function (seriesModel) {\n        var data = seriesModel.getData();\n        var single = seriesModel.coordinateSystem;\n        var layoutInfo = {};\n        var rect = single.getRect();\n        layoutInfo.rect = rect;\n        var boundaryGap = seriesModel.get('boundaryGap');\n        var axis = single.getAxis();\n        layoutInfo.boundaryGap = boundaryGap;\n\n        if (axis.orient === 'horizontal') {\n          boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.height);\n          boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.height);\n          var height = rect.height - boundaryGap[0] - boundaryGap[1];\n          doThemeRiverLayout(data, seriesModel, height);\n        } else {\n          boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.width);\n          boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.width);\n          var width = rect.width - boundaryGap[0] - boundaryGap[1];\n          doThemeRiverLayout(data, seriesModel, width);\n        }\n\n        data.setLayout('layoutInfo', layoutInfo);\n      });\n    }\n\n    function doThemeRiverLayout(data, seriesModel, height) {\n      if (!data.count()) {\n        return;\n      }\n\n      var coordSys = seriesModel.coordinateSystem;\n      var layerSeries = seriesModel.getLayerSeries();\n      var timeDim = data.mapDimension('single');\n      var valueDim = data.mapDimension('value');\n      var layerPoints = map(layerSeries, function (singleLayer) {\n        return map(singleLayer.indices, function (idx) {\n          var pt = coordSys.dataToPoint(data.get(timeDim, idx));\n          pt[1] = data.get(valueDim, idx);\n          return pt;\n        });\n      });\n      var base = computeBaseline(layerPoints);\n      var baseLine = base.y0;\n      var ky = height / base.max;\n      var n = layerSeries.length;\n      var m = layerSeries[0].indices.length;\n      var baseY0;\n\n      for (var j = 0; j < m; ++j) {\n        baseY0 = baseLine[j] * ky;\n        data.setItemLayout(layerSeries[0].indices[j], {\n          layerIndex: 0,\n          x: layerPoints[0][j][0],\n          y0: baseY0,\n          y: layerPoints[0][j][1] * ky\n        });\n\n        for (var i = 1; i < n; ++i) {\n          baseY0 += layerPoints[i - 1][j][1] * ky;\n          data.setItemLayout(layerSeries[i].indices[j], {\n            layerIndex: i,\n            x: layerPoints[i][j][0],\n            y0: baseY0,\n            y: layerPoints[i][j][1] * ky\n          });\n        }\n      }\n    }\n\n    function computeBaseline(data) {\n      var layerNum = data.length;\n      var pointNum = data[0].length;\n      var sums = [];\n      var y0 = [];\n      var max = 0;\n\n      for (var i = 0; i < pointNum; ++i) {\n        var temp = 0;\n\n        for (var j = 0; j < layerNum; ++j) {\n          temp += data[j][i][1];\n        }\n\n        if (temp > max) {\n          max = temp;\n        }\n\n        sums.push(temp);\n      }\n\n      for (var k = 0; k < pointNum; ++k) {\n        y0[k] = (max - sums[k]) / 2;\n      }\n\n      max = 0;\n\n      for (var l = 0; l < pointNum; ++l) {\n        var sum = sums[l] + y0[l];\n\n        if (sum > max) {\n          max = sum;\n        }\n      }\n\n      return {\n        y0: y0,\n        max: max\n      };\n    }\n\n    function install$o(registers) {\n      registers.registerChartView(ThemeRiverView);\n      registers.registerSeriesModel(ThemeRiverSeriesModel);\n      registers.registerLayout(themeRiverLayout);\n      registers.registerProcessor(dataFilter('themeRiver'));\n    }\n\n    var DEFAULT_SECTOR_Z = 2;\n    var DEFAULT_TEXT_Z = 4;\n\n    var SunburstPiece = function (_super) {\n      __extends(SunburstPiece, _super);\n\n      function SunburstPiece(node, seriesModel, ecModel, api) {\n        var _this = _super.call(this) || this;\n\n        _this.z2 = DEFAULT_SECTOR_Z;\n        _this.textConfig = {\n          inside: true\n        };\n        getECData(_this).seriesIndex = seriesModel.seriesIndex;\n        var text = new ZRText({\n          z2: DEFAULT_TEXT_Z,\n          silent: node.getModel().get(['label', 'silent'])\n        });\n\n        _this.setTextContent(text);\n\n        _this.updateData(true, node, seriesModel, ecModel, api);\n\n        return _this;\n      }\n\n      SunburstPiece.prototype.updateData = function (firstCreate, node, seriesModel, ecModel, api) {\n        this.node = node;\n        node.piece = this;\n        seriesModel = seriesModel || this._seriesModel;\n        ecModel = ecModel || this._ecModel;\n        var sector = this;\n        getECData(sector).dataIndex = node.dataIndex;\n        var itemModel = node.getModel();\n        var emphasisModel = itemModel.getModel('emphasis');\n        var layout = node.getLayout();\n        var sectorShape = extend({}, layout);\n        sectorShape.label = null;\n        var normalStyle = node.getVisual('style');\n        normalStyle.lineJoin = 'bevel';\n        var decal = node.getVisual('decal');\n\n        if (decal) {\n          normalStyle.decal = createOrUpdatePatternFromDecal(decal, api);\n        }\n\n        var cornerRadius = getSectorCornerRadius(itemModel.getModel('itemStyle'), sectorShape);\n        extend(sectorShape, cornerRadius);\n        each(SPECIAL_STATES, function (stateName) {\n          var state = sector.ensureState(stateName);\n          var itemStyleModel = itemModel.getModel([stateName, 'itemStyle']);\n          state.style = itemStyleModel.getItemStyle();\n          var cornerRadius = getSectorCornerRadius(itemStyleModel, sectorShape);\n\n          if (cornerRadius) {\n            state.shape = cornerRadius;\n          }\n        });\n\n        if (firstCreate) {\n          sector.setShape(sectorShape);\n          sector.shape.r = layout.r0;\n          updateProps(sector, {\n            shape: {\n              r: layout.r\n            }\n          }, seriesModel, node.dataIndex);\n        } else {\n          updateProps(sector, {\n            shape: sectorShape\n          }, seriesModel);\n        }\n\n        sector.useStyle(normalStyle);\n\n        this._updateLabel(seriesModel);\n\n        var cursorStyle = itemModel.getShallow('cursor');\n        cursorStyle && sector.attr('cursor', cursorStyle);\n        this._seriesModel = seriesModel || this._seriesModel;\n        this._ecModel = ecModel || this._ecModel;\n        var focus = emphasisModel.get('focus');\n        var focusDataIndices = focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null;\n        enableHoverEmphasis(this, focusDataIndices || focus, emphasisModel.get('blurScope'));\n      };\n\n      SunburstPiece.prototype._updateLabel = function (seriesModel) {\n        var _this = this;\n\n        var itemModel = this.node.getModel();\n        var normalLabelModel = itemModel.getModel('label');\n        var layout = this.node.getLayout();\n        var angle = layout.endAngle - layout.startAngle;\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n        var sector = this;\n        var label = sector.getTextContent();\n        var dataIndex = this.node.dataIndex;\n        var labelMinAngle = normalLabelModel.get('minAngle') / 180 * Math.PI;\n        var isNormalShown = normalLabelModel.get('show') && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);\n        label.ignore = !isNormalShown;\n        each(DISPLAY_STATES, function (stateName) {\n          var labelStateModel = stateName === 'normal' ? itemModel.getModel('label') : itemModel.getModel([stateName, 'label']);\n          var isNormal = stateName === 'normal';\n          var state = isNormal ? label : label.ensureState(stateName);\n          var text = seriesModel.getFormattedLabel(dataIndex, stateName);\n\n          if (isNormal) {\n            text = text || _this.node.name;\n          }\n\n          state.style = createTextStyle(labelStateModel, {}, null, stateName !== 'normal', true);\n\n          if (text) {\n            state.style.text = text;\n          }\n\n          var isShown = labelStateModel.get('show');\n\n          if (isShown != null && !isNormal) {\n            state.ignore = !isShown;\n          }\n\n          var labelPosition = getLabelAttr(labelStateModel, 'position');\n          var sectorState = isNormal ? sector : sector.states[stateName];\n          var labelColor = sectorState.style.fill;\n          sectorState.textConfig = {\n            outsideFill: labelStateModel.get('color') === 'inherit' ? labelColor : null,\n            inside: labelPosition !== 'outside'\n          };\n          var r;\n          var labelPadding = getLabelAttr(labelStateModel, 'distance') || 0;\n          var textAlign = getLabelAttr(labelStateModel, 'align');\n\n          if (labelPosition === 'outside') {\n            r = layout.r + labelPadding;\n            textAlign = midAngle > Math.PI / 2 ? 'right' : 'left';\n          } else {\n            if (!textAlign || textAlign === 'center') {\n              r = (layout.r + layout.r0) / 2;\n              textAlign = 'center';\n            } else if (textAlign === 'left') {\n              r = layout.r0 + labelPadding;\n\n              if (midAngle > Math.PI / 2) {\n                textAlign = 'right';\n              }\n            } else if (textAlign === 'right') {\n              r = layout.r - labelPadding;\n\n              if (midAngle > Math.PI / 2) {\n                textAlign = 'left';\n              }\n            }\n          }\n\n          state.style.align = textAlign;\n          state.style.verticalAlign = getLabelAttr(labelStateModel, 'verticalAlign') || 'middle';\n          state.x = r * dx + layout.cx;\n          state.y = r * dy + layout.cy;\n          var rotateType = getLabelAttr(labelStateModel, 'rotate');\n          var rotate = 0;\n\n          if (rotateType === 'radial') {\n            rotate = -midAngle;\n\n            if (rotate < -Math.PI / 2) {\n              rotate += Math.PI;\n            }\n          } else if (rotateType === 'tangential') {\n            rotate = Math.PI / 2 - midAngle;\n\n            if (rotate > Math.PI / 2) {\n              rotate -= Math.PI;\n            } else if (rotate < -Math.PI / 2) {\n              rotate += Math.PI;\n            }\n          } else if (typeof rotateType === 'number') {\n            rotate = rotateType * Math.PI / 180;\n          }\n\n          state.rotation = rotate;\n        });\n\n        function getLabelAttr(model, name) {\n          var stateAttr = model.get(name);\n\n          if (stateAttr == null) {\n            return normalLabelModel.get(name);\n          }\n\n          return stateAttr;\n        }\n\n        label.dirtyStyle();\n      };\n\n      return SunburstPiece;\n    }(Sector);\n\n    var ROOT_TO_NODE_ACTION = 'sunburstRootToNode';\n    var HIGHLIGHT_ACTION = 'sunburstHighlight';\n    var UNHIGHLIGHT_ACTION = 'sunburstUnhighlight';\n    function installSunburstAction(registers) {\n      registers.registerAction({\n        type: ROOT_TO_NODE_ACTION,\n        update: 'updateView'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'sunburst',\n          query: payload\n        }, handleRootToNode);\n\n        function handleRootToNode(model, index) {\n          var targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);\n\n          if (targetInfo) {\n            var originViewRoot = model.getViewRoot();\n\n            if (originViewRoot) {\n              payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown';\n            }\n\n            model.resetViewRoot(targetInfo.node);\n          }\n        }\n      });\n      registers.registerAction({\n        type: HIGHLIGHT_ACTION,\n        update: 'none'\n      }, function (payload, ecModel, api) {\n        payload = extend({}, payload);\n        ecModel.eachComponent({\n          mainType: 'series',\n          subType: 'sunburst',\n          query: payload\n        }, handleHighlight);\n\n        function handleHighlight(model) {\n          var targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);\n\n          if (targetInfo) {\n            payload.dataIndex = targetInfo.node.dataIndex;\n          }\n        }\n\n        if (\"development\" !== 'production') {\n          deprecateReplaceLog('highlight', 'sunburstHighlight');\n        }\n\n        api.dispatchAction(extend(payload, {\n          type: 'highlight'\n        }));\n      });\n      registers.registerAction({\n        type: UNHIGHLIGHT_ACTION,\n        update: 'updateView'\n      }, function (payload, ecModel, api) {\n        payload = extend({}, payload);\n\n        if (\"development\" !== 'production') {\n          deprecateReplaceLog('downplay', 'sunburstUnhighlight');\n        }\n\n        api.dispatchAction(extend(payload, {\n          type: 'downplay'\n        }));\n      });\n    }\n\n    var SunburstView = function (_super) {\n      __extends(SunburstView, _super);\n\n      function SunburstView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SunburstView.type;\n        return _this;\n      }\n\n      SunburstView.prototype.render = function (seriesModel, ecModel, api, payload) {\n        var self = this;\n        this.seriesModel = seriesModel;\n        this.api = api;\n        this.ecModel = ecModel;\n        var data = seriesModel.getData();\n        var virtualRoot = data.tree.root;\n        var newRoot = seriesModel.getViewRoot();\n        var group = this.group;\n        var renderLabelForZeroData = seriesModel.get('renderLabelForZeroData');\n        var newChildren = [];\n        newRoot.eachNode(function (node) {\n          newChildren.push(node);\n        });\n        var oldChildren = this._oldChildren || [];\n        dualTravel(newChildren, oldChildren);\n        renderRollUp(virtualRoot, newRoot);\n\n        this._initEvents();\n\n        this._oldChildren = newChildren;\n\n        function dualTravel(newChildren, oldChildren) {\n          if (newChildren.length === 0 && oldChildren.length === 0) {\n            return;\n          }\n\n          new DataDiffer(oldChildren, newChildren, getKey, getKey).add(processNode).update(processNode).remove(curry(processNode, null)).execute();\n\n          function getKey(node) {\n            return node.getId();\n          }\n\n          function processNode(newIdx, oldIdx) {\n            var newNode = newIdx == null ? null : newChildren[newIdx];\n            var oldNode = oldIdx == null ? null : oldChildren[oldIdx];\n            doRenderNode(newNode, oldNode);\n          }\n        }\n\n        function doRenderNode(newNode, oldNode) {\n          if (!renderLabelForZeroData && newNode && !newNode.getValue()) {\n            newNode = null;\n          }\n\n          if (newNode !== virtualRoot && oldNode !== virtualRoot) {\n            if (oldNode && oldNode.piece) {\n              if (newNode) {\n                oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api);\n                data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);\n              } else {\n                removeNode(oldNode);\n              }\n            } else if (newNode) {\n              var piece = new SunburstPiece(newNode, seriesModel, ecModel, api);\n              group.add(piece);\n              data.setItemGraphicEl(newNode.dataIndex, piece);\n            }\n          }\n        }\n\n        function removeNode(node) {\n          if (!node) {\n            return;\n          }\n\n          if (node.piece) {\n            group.remove(node.piece);\n            node.piece = null;\n          }\n        }\n\n        function renderRollUp(virtualRoot, viewRoot) {\n          if (viewRoot.depth > 0) {\n            if (self.virtualPiece) {\n              self.virtualPiece.updateData(false, virtualRoot, seriesModel, ecModel, api);\n            } else {\n              self.virtualPiece = new SunburstPiece(virtualRoot, seriesModel, ecModel, api);\n              group.add(self.virtualPiece);\n            }\n\n            viewRoot.piece.off('click');\n            self.virtualPiece.on('click', function (e) {\n              self._rootToNode(viewRoot.parentNode);\n            });\n          } else if (self.virtualPiece) {\n            group.remove(self.virtualPiece);\n            self.virtualPiece = null;\n          }\n        }\n      };\n\n      SunburstView.prototype._initEvents = function () {\n        var _this = this;\n\n        this.group.off('click');\n        this.group.on('click', function (e) {\n          var targetFound = false;\n\n          var viewRoot = _this.seriesModel.getViewRoot();\n\n          viewRoot.eachNode(function (node) {\n            if (!targetFound && node.piece && node.piece === e.target) {\n              var nodeClick = node.getModel().get('nodeClick');\n\n              if (nodeClick === 'rootToNode') {\n                _this._rootToNode(node);\n              } else if (nodeClick === 'link') {\n                var itemModel = node.getModel();\n                var link = itemModel.get('link');\n\n                if (link) {\n                  var linkTarget = itemModel.get('target', true) || '_blank';\n                  windowOpen(link, linkTarget);\n                }\n              }\n\n              targetFound = true;\n            }\n          });\n        });\n      };\n\n      SunburstView.prototype._rootToNode = function (node) {\n        if (node !== this.seriesModel.getViewRoot()) {\n          this.api.dispatchAction({\n            type: ROOT_TO_NODE_ACTION,\n            from: this.uid,\n            seriesId: this.seriesModel.id,\n            targetNode: node\n          });\n        }\n      };\n\n      SunburstView.prototype.containPoint = function (point, seriesModel) {\n        var treeRoot = seriesModel.getData();\n        var itemLayout = treeRoot.getItemLayout(0);\n\n        if (itemLayout) {\n          var dx = point[0] - itemLayout.cx;\n          var dy = point[1] - itemLayout.cy;\n          var radius = Math.sqrt(dx * dx + dy * dy);\n          return radius <= itemLayout.r && radius >= itemLayout.r0;\n        }\n      };\n\n      SunburstView.type = 'sunburst';\n      return SunburstView;\n    }(ChartView);\n\n    var SunburstSeriesModel = function (_super) {\n      __extends(SunburstSeriesModel, _super);\n\n      function SunburstSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SunburstSeriesModel.type;\n        _this.ignoreStyleOnData = true;\n        return _this;\n      }\n\n      SunburstSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        var root = {\n          name: option.name,\n          children: option.data\n        };\n        completeTreeValue$1(root);\n        var levelModels = map(option.levels || [], function (levelDefine) {\n          return new Model(levelDefine, this, ecModel);\n        }, this);\n        var tree = Tree.createTree(root, this, beforeLink);\n\n        function beforeLink(nodeData) {\n          nodeData.wrapMethod('getItemModel', function (model, idx) {\n            var node = tree.getNodeByDataIndex(idx);\n            var levelModel = levelModels[node.depth];\n            levelModel && (model.parentModel = levelModel);\n            return model;\n          });\n        }\n\n        return tree.data;\n      };\n\n      SunburstSeriesModel.prototype.optionUpdated = function () {\n        this.resetViewRoot();\n      };\n\n      SunburstSeriesModel.prototype.getDataParams = function (dataIndex) {\n        var params = _super.prototype.getDataParams.apply(this, arguments);\n\n        var node = this.getData().tree.getNodeByDataIndex(dataIndex);\n        params.treePathInfo = wrapTreePathInfo(node, this);\n        return params;\n      };\n\n      SunburstSeriesModel.prototype.getViewRoot = function () {\n        return this._viewRoot;\n      };\n\n      SunburstSeriesModel.prototype.resetViewRoot = function (viewRoot) {\n        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;\n        var root = this.getRawData().tree.root;\n\n        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {\n          this._viewRoot = root;\n        }\n      };\n\n      SunburstSeriesModel.prototype.enableAriaDecal = function () {\n        enableAriaDecalForTree(this);\n      };\n\n      SunburstSeriesModel.type = 'series.sunburst';\n      SunburstSeriesModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        center: ['50%', '50%'],\n        radius: [0, '75%'],\n        clockwise: true,\n        startAngle: 90,\n        minAngle: 0,\n        stillShowZeroSum: true,\n        nodeClick: 'rootToNode',\n        renderLabelForZeroData: false,\n        label: {\n          rotate: 'radial',\n          show: true,\n          opacity: 1,\n          align: 'center',\n          position: 'inside',\n          distance: 5,\n          silent: true\n        },\n        itemStyle: {\n          borderWidth: 1,\n          borderColor: 'white',\n          borderType: 'solid',\n          shadowBlur: 0,\n          shadowColor: 'rgba(0, 0, 0, 0.2)',\n          shadowOffsetX: 0,\n          shadowOffsetY: 0,\n          opacity: 1\n        },\n        emphasis: {\n          focus: 'descendant'\n        },\n        blur: {\n          itemStyle: {\n            opacity: 0.2\n          },\n          label: {\n            opacity: 0.1\n          }\n        },\n        animationType: 'expansion',\n        animationDuration: 1000,\n        animationDurationUpdate: 500,\n        data: [],\n        levels: [],\n        sort: 'desc'\n      };\n      return SunburstSeriesModel;\n    }(SeriesModel);\n\n    function completeTreeValue$1(dataNode) {\n      var sum = 0;\n      each(dataNode.children, function (child) {\n        completeTreeValue$1(child);\n        var childValue = child.value;\n        isArray(childValue) && (childValue = childValue[0]);\n        sum += childValue;\n      });\n      var thisValue = dataNode.value;\n\n      if (isArray(thisValue)) {\n        thisValue = thisValue[0];\n      }\n\n      if (thisValue == null || isNaN(thisValue)) {\n        thisValue = sum;\n      }\n\n      if (thisValue < 0) {\n        thisValue = 0;\n      }\n\n      isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;\n    }\n\n    var RADIAN$2 = Math.PI / 180;\n    function sunburstLayout(seriesType, ecModel, api) {\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        var center = seriesModel.get('center');\n        var radius = seriesModel.get('radius');\n\n        if (!isArray(radius)) {\n          radius = [0, radius];\n        }\n\n        if (!isArray(center)) {\n          center = [center, center];\n        }\n\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        var cx = parsePercent$1(center[0], width);\n        var cy = parsePercent$1(center[1], height);\n        var r0 = parsePercent$1(radius[0], size / 2);\n        var r = parsePercent$1(radius[1], size / 2);\n        var startAngle = -seriesModel.get('startAngle') * RADIAN$2;\n        var minAngle = seriesModel.get('minAngle') * RADIAN$2;\n        var virtualRoot = seriesModel.getData().tree.root;\n        var treeRoot = seriesModel.getViewRoot();\n        var rootDepth = treeRoot.depth;\n        var sort = seriesModel.get('sort');\n\n        if (sort != null) {\n          initChildren$1(treeRoot, sort);\n        }\n\n        var validDataCount = 0;\n        each(treeRoot.children, function (child) {\n          !isNaN(child.getValue()) && validDataCount++;\n        });\n        var sum = treeRoot.getValue();\n        var unitRadian = Math.PI / (sum || validDataCount) * 2;\n        var renderRollupNode = treeRoot.depth > 0;\n        var levels = treeRoot.height - (renderRollupNode ? -1 : 1);\n        var rPerLevel = (r - r0) / (levels || 1);\n        var clockwise = seriesModel.get('clockwise');\n        var stillShowZeroSum = seriesModel.get('stillShowZeroSum');\n        var dir = clockwise ? 1 : -1;\n\n        var renderNode = function (node, startAngle) {\n          if (!node) {\n            return;\n          }\n\n          var endAngle = startAngle;\n\n          if (node !== virtualRoot) {\n            var value = node.getValue();\n            var angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;\n\n            if (angle < minAngle) {\n              angle = minAngle;\n            }\n\n            endAngle = startAngle + dir * angle;\n            var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);\n            var rStart = r0 + rPerLevel * depth;\n            var rEnd = r0 + rPerLevel * (depth + 1);\n            var itemModel = node.getModel();\n\n            if (itemModel.get('r0') != null) {\n              rStart = parsePercent$1(itemModel.get('r0'), size / 2);\n            }\n\n            if (itemModel.get('r') != null) {\n              rEnd = parsePercent$1(itemModel.get('r'), size / 2);\n            }\n\n            node.setLayout({\n              angle: angle,\n              startAngle: startAngle,\n              endAngle: endAngle,\n              clockwise: clockwise,\n              cx: cx,\n              cy: cy,\n              r0: rStart,\n              r: rEnd\n            });\n          }\n\n          if (node.children && node.children.length) {\n            var siblingAngle_1 = 0;\n            each(node.children, function (node) {\n              siblingAngle_1 += renderNode(node, startAngle + siblingAngle_1);\n            });\n          }\n\n          return endAngle - startAngle;\n        };\n\n        if (renderRollupNode) {\n          var rStart = r0;\n          var rEnd = r0 + rPerLevel;\n          var angle = Math.PI * 2;\n          virtualRoot.setLayout({\n            angle: angle,\n            startAngle: startAngle,\n            endAngle: startAngle + angle,\n            clockwise: clockwise,\n            cx: cx,\n            cy: cy,\n            r0: rStart,\n            r: rEnd\n          });\n        }\n\n        renderNode(treeRoot, startAngle);\n      });\n    }\n\n    function initChildren$1(node, sortOrder) {\n      var children = node.children || [];\n      node.children = sort$2(children, sortOrder);\n\n      if (children.length) {\n        each(node.children, function (child) {\n          initChildren$1(child, sortOrder);\n        });\n      }\n    }\n\n    function sort$2(children, sortOrder) {\n      if (typeof sortOrder === 'function') {\n        var sortTargets = map(children, function (child, idx) {\n          var value = child.getValue();\n          return {\n            params: {\n              depth: child.depth,\n              height: child.height,\n              dataIndex: child.dataIndex,\n              getValue: function () {\n                return value;\n              }\n            },\n            index: idx\n          };\n        });\n        sortTargets.sort(function (a, b) {\n          return sortOrder(a.params, b.params);\n        });\n        return map(sortTargets, function (target) {\n          return children[target.index];\n        });\n      } else {\n        var isAsc_1 = sortOrder === 'asc';\n        return children.sort(function (a, b) {\n          var diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1);\n          return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff;\n        });\n      }\n    }\n\n    function sunburstVisual(ecModel) {\n      var paletteScope = {};\n\n      function pickColor(node, seriesModel, treeHeight) {\n        var current = node;\n\n        while (current && current.depth > 1) {\n          current = current.parentNode;\n        }\n\n        var color = seriesModel.getColorFromPalette(current.name || current.dataIndex + '', paletteScope);\n\n        if (node.depth > 1 && typeof color === 'string') {\n          color = lift(color, (node.depth - 1) / (treeHeight - 1) * 0.5);\n        }\n\n        return color;\n      }\n\n      ecModel.eachSeriesByType('sunburst', function (seriesModel) {\n        var data = seriesModel.getData();\n        var tree = data.tree;\n        tree.eachNode(function (node) {\n          var model = node.getModel();\n          var style = model.getModel('itemStyle').getItemStyle();\n\n          if (!style.fill) {\n            style.fill = pickColor(node, seriesModel, tree.root.height);\n          }\n\n          var existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style');\n          extend(existsStyle, style);\n        });\n      });\n    }\n\n    function install$p(registers) {\n      registers.registerChartView(SunburstView);\n      registers.registerSeriesModel(SunburstSeriesModel);\n      registers.registerLayout(curry(sunburstLayout, 'sunburst'));\n      registers.registerProcessor(curry(dataFilter, 'sunburst'));\n      registers.registerVisual(sunburstVisual);\n      installSunburstAction(registers);\n    }\n\n    function dataToCoordSize(dataSize, dataItem) {\n      dataItem = dataItem || [0, 0];\n      return map(['x', 'y'], function (dim, dimIdx) {\n        var axis = this.getAxis(dim);\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n      }, this);\n    }\n\n    function cartesianPrepareCustom(coordSys) {\n      var rect = coordSys.master.getRect();\n      return {\n        coordSys: {\n          type: 'cartesian2d',\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        },\n        api: {\n          coord: function (data) {\n            return coordSys.dataToPoint(data);\n          },\n          size: bind(dataToCoordSize, coordSys)\n        }\n      };\n    }\n\n    function dataToCoordSize$1(dataSize, dataItem) {\n      dataItem = dataItem || [0, 0];\n      return map([0, 1], function (dimIdx) {\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        var p1 = [];\n        var p2 = [];\n        p1[dimIdx] = val - halfSize;\n        p2[dimIdx] = val + halfSize;\n        p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];\n        return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);\n      }, this);\n    }\n\n    function geoPrepareCustom(coordSys) {\n      var rect = coordSys.getBoundingRect();\n      return {\n        coordSys: {\n          type: 'geo',\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height,\n          zoom: coordSys.getZoom()\n        },\n        api: {\n          coord: function (data) {\n            return coordSys.dataToPoint(data);\n          },\n          size: bind(dataToCoordSize$1, coordSys)\n        }\n      };\n    }\n\n    function dataToCoordSize$2(dataSize, dataItem) {\n      var axis = this.getAxis();\n      var val = dataItem instanceof Array ? dataItem[0] : dataItem;\n      var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;\n      return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n    }\n\n    function singlePrepareCustom(coordSys) {\n      var rect = coordSys.getRect();\n      return {\n        coordSys: {\n          type: 'singleAxis',\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        },\n        api: {\n          coord: function (val) {\n            return coordSys.dataToPoint(val);\n          },\n          size: bind(dataToCoordSize$2, coordSys)\n        }\n      };\n    }\n\n    function dataToCoordSize$3(dataSize, dataItem) {\n      dataItem = dataItem || [0, 0];\n      return map(['Radius', 'Angle'], function (dim, dimIdx) {\n        var getterName = 'get' + dim + 'Axis';\n        var axis = this[getterName]();\n        var val = dataItem[dimIdx];\n        var halfSize = dataSize[dimIdx] / 2;\n        var result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));\n\n        if (dim === 'Angle') {\n          result = result * Math.PI / 180;\n        }\n\n        return result;\n      }, this);\n    }\n\n    function polarPrepareCustom(coordSys) {\n      var radiusAxis = coordSys.getRadiusAxis();\n      var angleAxis = coordSys.getAngleAxis();\n      var radius = radiusAxis.getExtent();\n      radius[0] > radius[1] && radius.reverse();\n      return {\n        coordSys: {\n          type: 'polar',\n          cx: coordSys.cx,\n          cy: coordSys.cy,\n          r: radius[1],\n          r0: radius[0]\n        },\n        api: {\n          coord: function (data) {\n            var radius = radiusAxis.dataToRadius(data[0]);\n            var angle = angleAxis.dataToAngle(data[1]);\n            var coord = coordSys.coordToPoint([radius, angle]);\n            coord.push(radius, angle * Math.PI / 180);\n            return coord;\n          },\n          size: bind(dataToCoordSize$3, coordSys)\n        }\n      };\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function calendarPrepareCustom(coordSys) {\n      var rect = coordSys.getRect();\n      var rangeInfo = coordSys.getRangeInfo();\n      return {\n        coordSys: {\n          type: 'calendar',\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height,\n          cellWidth: coordSys.getCellWidth(),\n          cellHeight: coordSys.getCellHeight(),\n          rangeInfo: {\n            start: rangeInfo.start,\n            end: rangeInfo.end,\n            weeks: rangeInfo.weeks,\n            dayCount: rangeInfo.allDay\n          }\n        },\n        api: {\n          coord: function (data, clamp) {\n            return coordSys.dataToPoint(data, clamp);\n          }\n        }\n      };\n    }\n\n    var deprecatedLogs = {};\n    function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {\n      return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== 'tspan' && (elType === 'text' || hasOwn(style, 'text')));\n    }\n    function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {\n      var srcStyle = hostStyle;\n      var textConfig;\n      var textContent;\n      var textContentStyle;\n\n      if (elType === 'text') {\n        textContentStyle = srcStyle;\n      } else {\n        textContentStyle = {};\n        hasOwn(srcStyle, 'text') && (textContentStyle.text = srcStyle.text);\n        hasOwn(srcStyle, 'rich') && (textContentStyle.rich = srcStyle.rich);\n        hasOwn(srcStyle, 'textFill') && (textContentStyle.fill = srcStyle.textFill);\n        hasOwn(srcStyle, 'textStroke') && (textContentStyle.stroke = srcStyle.textStroke);\n        textContent = {\n          type: 'text',\n          style: textContentStyle,\n          silent: true\n        };\n        textConfig = {};\n        var hasOwnPos = hasOwn(srcStyle, 'textPosition');\n\n        if (isNormal) {\n          textConfig.position = hasOwnPos ? srcStyle.textPosition : 'inside';\n        } else {\n          hasOwnPos && (textConfig.position = srcStyle.textPosition);\n        }\n\n        hasOwn(srcStyle, 'textPosition') && (textConfig.position = srcStyle.textPosition);\n        hasOwn(srcStyle, 'textOffset') && (textConfig.offset = srcStyle.textOffset);\n        hasOwn(srcStyle, 'textRotation') && (textConfig.rotation = srcStyle.textRotation);\n        hasOwn(srcStyle, 'textDistance') && (textConfig.distance = srcStyle.textDistance);\n      }\n\n      convertEC4CompatibleRichItem(textContentStyle, hostStyle);\n      each(textContentStyle.rich, function (richItem) {\n        convertEC4CompatibleRichItem(richItem, richItem);\n      });\n      return {\n        textConfig: textConfig,\n        textContent: textContent\n      };\n    }\n\n    function convertEC4CompatibleRichItem(out, richItem) {\n      if (!richItem) {\n        return;\n      }\n\n      richItem.font = richItem.textFont || richItem.font;\n      hasOwn(richItem, 'textStrokeWidth') && (out.lineWidth = richItem.textStrokeWidth);\n      hasOwn(richItem, 'textAlign') && (out.align = richItem.textAlign);\n      hasOwn(richItem, 'textVerticalAlign') && (out.verticalAlign = richItem.textVerticalAlign);\n      hasOwn(richItem, 'textLineHeight') && (out.lineHeight = richItem.textLineHeight);\n      hasOwn(richItem, 'textWidth') && (out.width = richItem.textWidth);\n      hasOwn(richItem, 'textHeight') && (out.height = richItem.textHeight);\n      hasOwn(richItem, 'textBackgroundColor') && (out.backgroundColor = richItem.textBackgroundColor);\n      hasOwn(richItem, 'textPadding') && (out.padding = richItem.textPadding);\n      hasOwn(richItem, 'textBorderColor') && (out.borderColor = richItem.textBorderColor);\n      hasOwn(richItem, 'textBorderWidth') && (out.borderWidth = richItem.textBorderWidth);\n      hasOwn(richItem, 'textBorderRadius') && (out.borderRadius = richItem.textBorderRadius);\n      hasOwn(richItem, 'textBoxShadowColor') && (out.shadowColor = richItem.textBoxShadowColor);\n      hasOwn(richItem, 'textBoxShadowBlur') && (out.shadowBlur = richItem.textBoxShadowBlur);\n      hasOwn(richItem, 'textBoxShadowOffsetX') && (out.shadowOffsetX = richItem.textBoxShadowOffsetX);\n      hasOwn(richItem, 'textBoxShadowOffsetY') && (out.shadowOffsetY = richItem.textBoxShadowOffsetY);\n    }\n\n    function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {\n      var out = itemStl;\n      out.textPosition = out.textPosition || txCfg.position || 'inside';\n      txCfg.offset != null && (out.textOffset = txCfg.offset);\n      txCfg.rotation != null && (out.textRotation = txCfg.rotation);\n      txCfg.distance != null && (out.textDistance = txCfg.distance);\n      var isInside = out.textPosition.indexOf('inside') >= 0;\n      var hostFill = itemStl.fill || '#000';\n      convertToEC4RichItem(out, txStl);\n      var textFillNotSet = out.textFill == null;\n\n      if (isInside) {\n        if (textFillNotSet) {\n          out.textFill = txCfg.insideFill || '#fff';\n          !out.textStroke && txCfg.insideStroke && (out.textStroke = txCfg.insideStroke);\n          !out.textStroke && (out.textStroke = hostFill);\n          out.textStrokeWidth == null && (out.textStrokeWidth = 2);\n        }\n      } else {\n        if (textFillNotSet) {\n          out.textFill = txCfg.outsideFill || hostFill;\n        }\n\n        !out.textStroke && txCfg.outsideStroke && (out.textStroke = txCfg.outsideStroke);\n      }\n\n      out.text = txStl.text;\n      out.rich = txStl.rich;\n      each(txStl.rich, function (richItem) {\n        convertToEC4RichItem(richItem, richItem);\n      });\n      return out;\n    }\n\n    function convertToEC4RichItem(out, richItem) {\n      if (!richItem) {\n        return;\n      }\n\n      hasOwn(richItem, 'fill') && (out.textFill = richItem.fill);\n      hasOwn(richItem, 'stroke') && (out.textStroke = richItem.fill);\n      hasOwn(richItem, 'lineWidth') && (out.textStrokeWidth = richItem.lineWidth);\n      hasOwn(richItem, 'font') && (out.font = richItem.font);\n      hasOwn(richItem, 'fontStyle') && (out.fontStyle = richItem.fontStyle);\n      hasOwn(richItem, 'fontWeight') && (out.fontWeight = richItem.fontWeight);\n      hasOwn(richItem, 'fontSize') && (out.fontSize = richItem.fontSize);\n      hasOwn(richItem, 'fontFamily') && (out.fontFamily = richItem.fontFamily);\n      hasOwn(richItem, 'align') && (out.textAlign = richItem.align);\n      hasOwn(richItem, 'verticalAlign') && (out.textVerticalAlign = richItem.verticalAlign);\n      hasOwn(richItem, 'lineHeight') && (out.textLineHeight = richItem.lineHeight);\n      hasOwn(richItem, 'width') && (out.textWidth = richItem.width);\n      hasOwn(richItem, 'height') && (out.textHeight = richItem.height);\n      hasOwn(richItem, 'backgroundColor') && (out.textBackgroundColor = richItem.backgroundColor);\n      hasOwn(richItem, 'padding') && (out.textPadding = richItem.padding);\n      hasOwn(richItem, 'borderColor') && (out.textBorderColor = richItem.borderColor);\n      hasOwn(richItem, 'borderWidth') && (out.textBorderWidth = richItem.borderWidth);\n      hasOwn(richItem, 'borderRadius') && (out.textBorderRadius = richItem.borderRadius);\n      hasOwn(richItem, 'shadowColor') && (out.textBoxShadowColor = richItem.shadowColor);\n      hasOwn(richItem, 'shadowBlur') && (out.textBoxShadowBlur = richItem.shadowBlur);\n      hasOwn(richItem, 'shadowOffsetX') && (out.textBoxShadowOffsetX = richItem.shadowOffsetX);\n      hasOwn(richItem, 'shadowOffsetY') && (out.textBoxShadowOffsetY = richItem.shadowOffsetY);\n      hasOwn(richItem, 'textShadowColor') && (out.textShadowColor = richItem.textShadowColor);\n      hasOwn(richItem, 'textShadowBlur') && (out.textShadowBlur = richItem.textShadowBlur);\n      hasOwn(richItem, 'textShadowOffsetX') && (out.textShadowOffsetX = richItem.textShadowOffsetX);\n      hasOwn(richItem, 'textShadowOffsetY') && (out.textShadowOffsetY = richItem.textShadowOffsetY);\n    }\n\n    function warnDeprecated(deprecated, insteadApproach) {\n      if (\"development\" !== 'production') {\n        var key = deprecated + '^_^' + insteadApproach;\n\n        if (!deprecatedLogs[key]) {\n          console.warn(\"[ECharts] DEPRECATED: \\\"\" + deprecated + \"\\\" has been deprecated. \" + insteadApproach);\n          deprecatedLogs[key] = true;\n        }\n      }\n    }\n\n    var CMD$4 = PathProxy.CMD;\n    var PI2$a = Math.PI * 2;\n    var PROP_XY = ['x', 'y'];\n    var PROP_WH = ['width', 'height'];\n    var tmpArr$1 = [];\n    function aroundEqual(a, b) {\n        return Math.abs(a - b) < 1e-5;\n    }\n    function pathToBezierCurves(path) {\n        var data = path.data;\n        var len = path.len();\n        var bezierArray = [];\n        var currentSubpath;\n        var xi = 0;\n        var yi = 0;\n        var x0 = 0;\n        var y0 = 0;\n        function createNewSubpath(x, y) {\n            if (currentSubpath && currentSubpath.length > 2) {\n                bezierArray.push(currentSubpath);\n            }\n            currentSubpath = [x, y];\n        }\n        function addLine(x0, y0, x1, y1) {\n            if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n                currentSubpath.push(x0, y0, x1, y1, x1, y1);\n            }\n        }\n        function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n            var delta = Math.abs(endAngle - startAngle);\n            var len = Math.tan(delta / 4) * 4 / 3;\n            var dir = endAngle < startAngle ? -1 : 1;\n            var c1 = Math.cos(startAngle);\n            var s1 = Math.sin(startAngle);\n            var c2 = Math.cos(endAngle);\n            var s2 = Math.sin(endAngle);\n            var x1 = c1 * rx + cx;\n            var y1 = s1 * ry + cy;\n            var x4 = c2 * rx + cx;\n            var y4 = s2 * ry + cy;\n            var hx = rx * len * dir;\n            var hy = ry * len * dir;\n            currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n        }\n        var x1;\n        var y1;\n        var x2;\n        var y2;\n        for (var i = 0; i < len;) {\n            var cmd = data[i++];\n            var isFirst = i === 1;\n            if (isFirst) {\n                xi = data[i];\n                yi = data[i + 1];\n                x0 = xi;\n                y0 = yi;\n                if (cmd === CMD$4.L || cmd === CMD$4.C || cmd === CMD$4.Q) {\n                    currentSubpath = [x0, y0];\n                }\n            }\n            switch (cmd) {\n                case CMD$4.M:\n                    xi = x0 = data[i++];\n                    yi = y0 = data[i++];\n                    createNewSubpath(x0, y0);\n                    break;\n                case CMD$4.L:\n                    x1 = data[i++];\n                    y1 = data[i++];\n                    addLine(xi, yi, x1, y1);\n                    xi = x1;\n                    yi = y1;\n                    break;\n                case CMD$4.C:\n                    currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                    break;\n                case CMD$4.Q:\n                    x1 = data[i++];\n                    y1 = data[i++];\n                    x2 = data[i++];\n                    y2 = data[i++];\n                    currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                    xi = x2;\n                    yi = y2;\n                    break;\n                case CMD$4.A:\n                    var cx = data[i++];\n                    var cy = data[i++];\n                    var rx = data[i++];\n                    var ry = data[i++];\n                    var startAngle = data[i++];\n                    var endAngle = data[i++] + startAngle;\n                    i += 1;\n                    var anticlockwise = !data[i++];\n                    x1 = Math.cos(startAngle) * rx + cx;\n                    y1 = Math.sin(startAngle) * ry + cy;\n                    if (isFirst) {\n                        x0 = x1;\n                        y0 = y1;\n                        createNewSubpath(x0, y0);\n                    }\n                    else {\n                        addLine(xi, yi, x1, y1);\n                    }\n                    xi = Math.cos(endAngle) * rx + cx;\n                    yi = Math.sin(endAngle) * ry + cy;\n                    var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                    for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                        var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                            : Math.min(angle + step, endAngle);\n                        addArc(angle, nextAngle, cx, cy, rx, ry);\n                    }\n                    break;\n                case CMD$4.R:\n                    x0 = xi = data[i++];\n                    y0 = yi = data[i++];\n                    x1 = x0 + data[i++];\n                    y1 = y0 + data[i++];\n                    createNewSubpath(x1, y0);\n                    addLine(x1, y0, x1, y1);\n                    addLine(x1, y1, x0, y1);\n                    addLine(x0, y1, x0, y0);\n                    addLine(x0, y0, x1, y0);\n                    break;\n                case CMD$4.Z:\n                    currentSubpath && addLine(xi, yi, x0, y0);\n                    xi = x0;\n                    yi = y0;\n                    break;\n            }\n        }\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArray.push(currentSubpath);\n        }\n        return bezierArray;\n    }\n    function alignSubpath(subpath1, subpath2) {\n        var len1 = subpath1.length;\n        var len2 = subpath2.length;\n        if (len1 === len2) {\n            return [subpath1, subpath2];\n        }\n        var shorterPath = len1 < len2 ? subpath1 : subpath2;\n        var shorterLen = Math.min(len1, len2);\n        var diff = Math.abs(len2 - len1) / 6;\n        var shorterBezierCount = (shorterLen - 2) / 6;\n        var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n        var newSubpath = [shorterPath[0], shorterPath[1]];\n        var remained = diff;\n        var tmpSegX = [];\n        var tmpSegY = [];\n        for (var i = 2; i < shorterLen;) {\n            var x0 = shorterPath[i - 2];\n            var y0 = shorterPath[i - 1];\n            var x1 = shorterPath[i++];\n            var y1 = shorterPath[i++];\n            var x2 = shorterPath[i++];\n            var y2 = shorterPath[i++];\n            var x3 = shorterPath[i++];\n            var y3 = shorterPath[i++];\n            if (remained <= 0) {\n                newSubpath.push(x1, y1, x2, y2, x3, y3);\n                continue;\n            }\n            var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n            for (var k = 1; k <= actualSubDivCount; k++) {\n                var p = k / actualSubDivCount;\n                cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n                cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n                x0 = tmpSegX[3];\n                y0 = tmpSegY[3];\n                newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n                x1 = tmpSegX[5];\n                y1 = tmpSegY[5];\n                x2 = tmpSegX[6];\n                y2 = tmpSegY[6];\n            }\n            remained -= actualSubDivCount - 1;\n        }\n        return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n    }\n    function createSubpath(lastSubpathSubpath, otherSubpath) {\n        var len = lastSubpathSubpath.length;\n        var lastX = lastSubpathSubpath[len - 2];\n        var lastY = lastSubpathSubpath[len - 1];\n        var newSubpath = [];\n        for (var i = 0; i < otherSubpath.length;) {\n            newSubpath[i++] = lastX;\n            newSubpath[i++] = lastY;\n        }\n        return newSubpath;\n    }\n    function alignBezierCurves(array1, array2) {\n        var _a;\n        var lastSubpath1;\n        var lastSubpath2;\n        var newArray1 = [];\n        var newArray2 = [];\n        for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n            var subpath1 = array1[i];\n            var subpath2 = array2[i];\n            var newSubpath1 = void 0;\n            var newSubpath2 = void 0;\n            if (!subpath1) {\n                newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n                newSubpath2 = subpath2;\n            }\n            else if (!subpath2) {\n                newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n                newSubpath1 = subpath1;\n            }\n            else {\n                _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n                lastSubpath1 = newSubpath1;\n                lastSubpath2 = newSubpath2;\n            }\n            newArray1.push(newSubpath1);\n            newArray2.push(newSubpath2);\n        }\n        return [newArray1, newArray2];\n    }\n    function centroid(array) {\n        var signedArea = 0;\n        var cx = 0;\n        var cy = 0;\n        var len = array.length;\n        for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n            var x0 = array[j];\n            var y0 = array[j + 1];\n            var x1 = array[i];\n            var y1 = array[i + 1];\n            var a = x0 * y1 - x1 * y0;\n            signedArea += a;\n            cx += (x0 + x1) * a;\n            cy += (y0 + y1) * a;\n        }\n        if (signedArea === 0) {\n            return [array[0] || 0, array[1] || 0];\n        }\n        return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n    }\n    function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n        var bezierCount = (fromSubBeziers.length - 2) / 6;\n        var bestScore = Infinity;\n        var bestOffset = 0;\n        var len = fromSubBeziers.length;\n        var len2 = len - 2;\n        for (var offset = 0; offset < bezierCount; offset++) {\n            var cursorOffset = offset * 6;\n            var score = 0;\n            for (var k = 0; k < len; k += 2) {\n                var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n                var x0 = fromSubBeziers[idx] - fromCp[0];\n                var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n                var x1 = toSubBeziers[k] - toCp[0];\n                var y1 = toSubBeziers[k + 1] - toCp[1];\n                var dx = x1 - x0;\n                var dy = y1 - y0;\n                score += dx * dx + dy * dy;\n            }\n            if (score < bestScore) {\n                bestScore = score;\n                bestOffset = offset;\n            }\n        }\n        return bestOffset;\n    }\n    function reverse(array) {\n        var newArr = [];\n        var len = array.length;\n        for (var i = 0; i < len; i += 2) {\n            newArr[i] = array[len - i - 2];\n            newArr[i + 1] = array[len - i - 1];\n        }\n        return newArr;\n    }\n    function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n        var result = [];\n        var fromNeedsReverse;\n        for (var i = 0; i < fromArr.length; i++) {\n            var fromSubpathBezier = fromArr[i];\n            var toSubpathBezier = toArr[i];\n            var fromCp = centroid(fromSubpathBezier);\n            var toCp = centroid(toSubpathBezier);\n            if (fromNeedsReverse == null) {\n                fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n            }\n            var newFromSubpathBezier = [];\n            var newToSubpathBezier = [];\n            var bestAngle = 0;\n            var bestScore = Infinity;\n            var tmpArr_1 = [];\n            var len = fromSubpathBezier.length;\n            if (fromNeedsReverse) {\n                fromSubpathBezier = reverse(fromSubpathBezier);\n            }\n            var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n            var len2 = len - 2;\n            for (var k = 0; k < len2; k += 2) {\n                var idx = (offset + k) % len2 + 2;\n                newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n                newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n            }\n            newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n            newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n            if (searchAngleIteration > 0) {\n                var step = searchAngleRange / searchAngleIteration;\n                for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                    var sa = Math.sin(angle);\n                    var ca = Math.cos(angle);\n                    var score = 0;\n                    for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                        var x0 = newFromSubpathBezier[k];\n                        var y0 = newFromSubpathBezier[k + 1];\n                        var x1 = toSubpathBezier[k] - toCp[0];\n                        var y1 = toSubpathBezier[k + 1] - toCp[1];\n                        var newX1 = x1 * ca - y1 * sa;\n                        var newY1 = x1 * sa + y1 * ca;\n                        tmpArr_1[k] = newX1;\n                        tmpArr_1[k + 1] = newY1;\n                        var dx = newX1 - x0;\n                        var dy = newY1 - y0;\n                        score += dx * dx + dy * dy;\n                    }\n                    if (score < bestScore) {\n                        bestScore = score;\n                        bestAngle = angle;\n                        for (var m = 0; m < tmpArr_1.length; m++) {\n                            newToSubpathBezier[m] = tmpArr_1[m];\n                        }\n                    }\n                }\n            }\n            else {\n                for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                    newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                    newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n                }\n            }\n            result.push({\n                from: newFromSubpathBezier,\n                to: newToSubpathBezier,\n                fromCp: fromCp,\n                toCp: toCp,\n                rotation: -bestAngle\n            });\n        }\n        return result;\n    }\n    function morphPath(fromPath, toPath, animationOpts) {\n        var fromPathProxy;\n        var toPathProxy;\n        if (!fromPath || !toPath) {\n            return toPath;\n        }\n        !fromPath.path && fromPath.createPathProxy();\n        fromPathProxy = fromPath.path;\n        fromPathProxy.beginPath();\n        fromPath.buildPath(fromPathProxy, fromPath.shape);\n        !toPath.path && toPath.createPathProxy();\n        toPathProxy = toPath.path;\n        toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n        toPathProxy.beginPath();\n        if (isIndividualMorphingPath(toPath)) {\n            toPath.__oldBuildPath(toPathProxy, toPath.shape);\n        }\n        else {\n            toPath.buildPath(toPathProxy, toPath.shape);\n        }\n        var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n        var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n        becomeIndividualMorphingPath(toPath, morphingData, 0);\n        var oldDone = animationOpts && animationOpts.done;\n        var oldAborted = animationOpts && animationOpts.aborted;\n        var oldDuring = animationOpts && animationOpts.during;\n        toPath.animateTo({\n            __morphT: 1\n        }, defaults({\n            during: function (p) {\n                toPath.dirtyShape();\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                restoreIndividualMorphingPath(toPath);\n                toPath.createPathProxy();\n                toPath.dirtyShape();\n                oldDone && oldDone();\n            },\n            aborted: function () {\n                oldAborted && oldAborted();\n            }\n        }, animationOpts));\n        return toPath;\n    }\n    function morphingPathBuildPath(path) {\n        var morphingData = this.__morphingData;\n        var t = this.__morphT;\n        var onet = 1 - t;\n        var newCp = [];\n        for (var i = 0; i < morphingData.length; i++) {\n            var item = morphingData[i];\n            var from = item.from;\n            var to = item.to;\n            var angle = item.rotation * t;\n            var fromCp = item.fromCp;\n            var toCp = item.toCp;\n            var sa = Math.sin(angle);\n            var ca = Math.cos(angle);\n            lerp(newCp, fromCp, toCp, t);\n            for (var m = 0; m < from.length; m += 2) {\n                var x0 = from[m];\n                var y0 = from[m + 1];\n                var x1 = to[m];\n                var y1 = to[m + 1];\n                var x = x0 * onet + x1 * t;\n                var y = y0 * onet + y1 * t;\n                tmpArr$1[m] = (x * ca - y * sa) + newCp[0];\n                tmpArr$1[m + 1] = (x * sa + y * ca) + newCp[1];\n            }\n            for (var m = 0; m < from.length;) {\n                if (m === 0) {\n                    path.moveTo(tmpArr$1[m++], tmpArr$1[m++]);\n                }\n                path.bezierCurveTo(tmpArr$1[m++], tmpArr$1[m++], tmpArr$1[m++], tmpArr$1[m++], tmpArr$1[m++], tmpArr$1[m++]);\n            }\n        }\n    }\n    function becomeIndividualMorphingPath(path, morphingData, morphT) {\n        if (isIndividualMorphingPath(path)) {\n            updateIndividualMorphingPath(path, morphingData, morphT);\n            return;\n        }\n        var morphingPath = path;\n        morphingPath.__oldBuildPath = morphingPath.buildPath;\n        morphingPath.buildPath = morphingPathBuildPath;\n        updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n    }\n    function updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n        morphingPath.__morphingData = morphingData;\n        morphingPath.__morphT = morphT;\n    }\n    function restoreIndividualMorphingPath(path) {\n        if (isIndividualMorphingPath(path)) {\n            path.buildPath = path.__oldBuildPath;\n            path.__oldBuildPath = path.__morphingData = null;\n        }\n    }\n    function isIndividualMorphingPath(path) {\n        return path.__oldBuildPath != null;\n    }\n    function isCombiningPath(path) {\n        return !!path.__combiningSubList;\n    }\n    function isInAnyMorphing(path) {\n        return isIndividualMorphingPath(path) || isCombiningPath(path);\n    }\n    function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n        var fromIndividuals = [];\n        var separateCount = 0;\n        for (var i = 0; i < fromPathList.length; i++) {\n            var fromPath = fromPathList[i];\n            if (isCombiningPath(fromPath)) {\n                var fromCombiningSubList = fromPath.__combiningSubList;\n                for (var j = 0; j < fromCombiningSubList.length; j++) {\n                    fromIndividuals.push(fromCombiningSubList[j]);\n                }\n                separateCount += fromCombiningSubList.length;\n            }\n            else {\n                fromIndividuals.push(fromPath);\n                separateCount++;\n            }\n        }\n        if (!separateCount) {\n            return;\n        }\n        var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n        var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n        assert(toPathSplittedList.length === separateCount);\n        var oldDone = animationOpts && animationOpts.done;\n        var oldAborted = animationOpts && animationOpts.aborted;\n        var oldDuring = animationOpts && animationOpts.during;\n        var doneCount = 0;\n        var abortedCalled = false;\n        var morphAnimationOpts = defaults({\n            during: function (p) {\n                oldDuring && oldDuring(p);\n            },\n            done: function () {\n                doneCount++;\n                if (doneCount === toPathSplittedList.length) {\n                    restoreCombiningPath(toPath);\n                    oldDone && oldDone();\n                }\n            },\n            aborted: function () {\n                if (!abortedCalled) {\n                    abortedCalled = true;\n                    oldAborted && oldAborted();\n                }\n            }\n        }, animationOpts);\n        for (var i = 0; i < separateCount; i++) {\n            var from = fromIndividuals[i];\n            var to = toPathSplittedList[i];\n            copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n            morphPath(from, to, morphAnimationOpts);\n        }\n        becomeCombiningPath(toPath, toPathSplittedList);\n        return {\n            fromIndividuals: fromIndividuals,\n            toIndividuals: toPathSplittedList,\n            count: separateCount\n        };\n    }\n    function becomeCombiningPath(path, combiningSubList) {\n        if (isCombiningPath(path)) {\n            updateCombiningPathSubList(path, combiningSubList);\n            return;\n        }\n        var combiningPath = path;\n        updateCombiningPathSubList(combiningPath, combiningSubList);\n        combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n        combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n        combiningPath.addSelfToZr = combiningAddSelfToZr;\n        combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n        combiningPath.__oldBuildPath = combiningPath.buildPath;\n        combiningPath.buildPath = noop;\n        combiningPath.childrenRef = combiningChildrenRef;\n    }\n    function restoreCombiningPath(path) {\n        if (!isCombiningPath(path)) {\n            return;\n        }\n        var combiningPath = path;\n        updateCombiningPathSubList(combiningPath, null);\n        combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n        combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n        combiningPath.buildPath = combiningPath.__oldBuildPath;\n        combiningPath.childrenRef =\n            combiningPath.__combiningSubList =\n                combiningPath.__oldAddSelfToZr =\n                    combiningPath.__oldRemoveSelfFromZr =\n                        combiningPath.__oldBuildPath = null;\n    }\n    function updateCombiningPathSubList(combiningPath, combiningSubList) {\n        if (combiningPath.__combiningSubList !== combiningSubList) {\n            combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n            combiningPath.__combiningSubList = combiningSubList;\n            if (combiningSubList) {\n                for (var i = 0; i < combiningSubList.length; i++) {\n                    combiningSubList[i].parent = combiningPath;\n                }\n            }\n            combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n        }\n    }\n    function combiningAddSelfToZr(zr) {\n        this.__oldAddSelfToZr(zr);\n        combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n    }\n    function combiningPathSubListAddRemoveWithZr(path, method) {\n        var combiningSubList = path.__combiningSubList;\n        var zr = path.__zr;\n        if (combiningSubList && zr) {\n            for (var i = 0; i < combiningSubList.length; i++) {\n                var child = combiningSubList[i];\n                child[method](zr);\n            }\n        }\n    }\n    function combiningRemoveSelfFromZr(zr) {\n        this.__oldRemoveSelfFromZr(zr);\n        var combiningSubList = this.__combiningSubList;\n        for (var i = 0; i < combiningSubList.length; i++) {\n            var child = combiningSubList[i];\n            child.removeSelfFromZr(zr);\n        }\n    }\n    function combiningChildrenRef() {\n        return this.__combiningSubList;\n    }\n    function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n        var toPathListLen = toPathList.length;\n        var fromPathList;\n        var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n        var copyProps = false;\n        if (isCombiningPath(fromPath)) {\n            var fromCombiningSubList = fromPath.__combiningSubList;\n            if (fromCombiningSubList.length === toPathListLen) {\n                fromPathList = fromCombiningSubList;\n            }\n            else {\n                fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n                copyProps = true;\n            }\n        }\n        else {\n            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n            copyProps = true;\n        }\n        assert(fromPathList.length === toPathListLen);\n        for (var i = 0; i < toPathListLen; i++) {\n            if (copyProps && copyPropsIfDivided) {\n                copyPropsIfDivided(fromPath, fromPathList[i], false);\n            }\n            morphPath(fromPathList[i], toPathList[i], animationOpts);\n        }\n        return {\n            fromIndividuals: fromPathList,\n            toIndividuals: toPathList,\n            count: toPathListLen\n        };\n    }\n    function divideShape(path, separateCount, dividingMethod) {\n        return dividingMethod === 'duplicate'\n            ? duplicateShape(path, separateCount)\n            : splitShape(path, separateCount);\n    }\n    function splitShape(path, separateCount) {\n        var resultPaths = [];\n        if (separateCount <= 0) {\n            return resultPaths;\n        }\n        if (separateCount === 1) {\n            return duplicateShape(path, separateCount);\n        }\n        if (path instanceof Rect) {\n            var toPathShape = path.shape;\n            var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n            var propWH = PROP_WH[splitPropIdx];\n            var propXY = PROP_XY[splitPropIdx];\n            var subWH = toPathShape[propWH] / separateCount;\n            var xyCurr = toPathShape[propXY];\n            for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n                var subShape = {\n                    x: toPathShape.x,\n                    y: toPathShape.y,\n                    width: toPathShape.width,\n                    height: toPathShape.height\n                };\n                subShape[propXY] = xyCurr;\n                subShape[propWH] = i < separateCount - 1\n                    ? subWH\n                    : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n                var splitted = new Rect({ shape: subShape });\n                resultPaths.push(splitted);\n            }\n        }\n        else if (path instanceof Sector) {\n            var toPathShape = path.shape;\n            var clockwise = toPathShape.clockwise;\n            var startAngle = toPathShape.startAngle;\n            var endAngle = toPathShape.endAngle;\n            var endAngleNormalized = normalizeRadian$1(startAngle, toPathShape.endAngle, clockwise);\n            var step = (endAngleNormalized - startAngle) / separateCount;\n            var angleCurr = startAngle;\n            for (var i = 0; i < separateCount; i++, angleCurr += step) {\n                var splitted = new Sector({\n                    shape: {\n                        cx: toPathShape.cx,\n                        cy: toPathShape.cy,\n                        r: toPathShape.r,\n                        r0: toPathShape.r0,\n                        clockwise: clockwise,\n                        startAngle: angleCurr,\n                        endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n                    }\n                });\n                resultPaths.push(splitted);\n            }\n        }\n        else {\n            return duplicateShape(path, separateCount);\n        }\n        return resultPaths;\n    }\n    function duplicateShape(path, separateCount) {\n        var resultPaths = [];\n        if (separateCount <= 0) {\n            return resultPaths;\n        }\n        var ctor = path.constructor;\n        for (var i = 0; i < separateCount; i++) {\n            var sub = new ctor({\n                shape: clone(path.shape)\n            });\n            resultPaths.push(sub);\n        }\n        return resultPaths;\n    }\n    function normalizeRadian$1(start, end, clockwise) {\n        return end + PI2$a * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2$a));\n    }\n\n    var inner$b = makeInner();\n    var TRANSFORM_PROPS = {\n      x: 1,\n      y: 1,\n      scaleX: 1,\n      scaleY: 1,\n      originX: 1,\n      originY: 1,\n      rotation: 1\n    };\n    var transformPropNamesStr = keys(TRANSFORM_PROPS).join(', ');\n    var STYLE_VISUAL_TYPE = {\n      color: 'fill',\n      borderColor: 'stroke'\n    };\n    var NON_STYLE_VISUAL_PROPS = {\n      symbol: 1,\n      symbolSize: 1,\n      symbolKeepAspect: 1,\n      legendSymbol: 1,\n      visualMeta: 1,\n      liftZ: 1,\n      decal: 1\n    };\n    var EMPHASIS = 'emphasis';\n    var NORMAL = 'normal';\n    var BLUR = 'blur';\n    var SELECT = 'select';\n    var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];\n    var PATH_ITEM_STYLE = {\n      normal: ['itemStyle'],\n      emphasis: [EMPHASIS, 'itemStyle'],\n      blur: [BLUR, 'itemStyle'],\n      select: [SELECT, 'itemStyle']\n    };\n    var PATH_LABEL = {\n      normal: ['label'],\n      emphasis: [EMPHASIS, 'label'],\n      blur: [BLUR, 'label'],\n      select: [SELECT, 'label']\n    };\n    var GROUP_DIFF_PREFIX = 'e\\0\\0';\n    var attachedTxInfoTmp = {\n      normal: {},\n      emphasis: {},\n      blur: {},\n      select: {}\n    };\n    var LEGACY_TRANSFORM_PROPS = {\n      position: ['x', 'y'],\n      scale: ['scaleX', 'scaleY'],\n      origin: ['originX', 'originY']\n    };\n    var tmpTransformable = new Transformable();\n    var prepareCustoms = {\n      cartesian2d: cartesianPrepareCustom,\n      geo: geoPrepareCustom,\n      singleAxis: singlePrepareCustom,\n      polar: polarPrepareCustom,\n      calendar: calendarPrepareCustom\n    };\n\n    var CustomSeriesModel = function (_super) {\n      __extends(CustomSeriesModel, _super);\n\n      function CustomSeriesModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CustomSeriesModel.type;\n        return _this;\n      }\n\n      CustomSeriesModel.prototype.optionUpdated = function () {\n        this.currentZLevel = this.get('zlevel', true);\n        this.currentZ = this.get('z', true);\n      };\n\n      CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {\n        return createListFromArray(this.getSource(), this);\n      };\n\n      CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {\n        var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n\n        el && (params.info = inner$b(el).info);\n        return params;\n      };\n\n      CustomSeriesModel.type = 'series.custom';\n      CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n      CustomSeriesModel.defaultOption = {\n        coordinateSystem: 'cartesian2d',\n        zlevel: 0,\n        z: 2,\n        legendHoverLink: true,\n        clip: false\n      };\n      return CustomSeriesModel;\n    }(SeriesModel);\n\n    var CustomSeriesView = function (_super) {\n      __extends(CustomSeriesView, _super);\n\n      function CustomSeriesView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CustomSeriesView.type;\n        return _this;\n      }\n\n      CustomSeriesView.prototype.render = function (customSeries, ecModel, api, payload) {\n        var oldData = this._data;\n        var data = customSeries.getData();\n        var group = this.group;\n        var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n        var transOpt = customSeries.__transientTransitionOpt;\n\n        if (transOpt && (transOpt.from == null || transOpt.to == null)) {\n          oldData && oldData.each(function (oldIdx) {\n            doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n          });\n          data.each(function (newIdx) {\n            createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n          });\n        } else {\n          var morphPreparation_1 = new MorphPreparation(customSeries, transOpt);\n          var diffMode = transOpt ? 'multiple' : 'oneToOne';\n          new DataDiffer(oldData ? oldData.getIndices() : [], data.getIndices(), createGetKey(oldData, diffMode, transOpt && transOpt.from), createGetKey(data, diffMode, transOpt && transOpt.to), null, diffMode).add(function (newIdx) {\n            createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n          }).remove(function (oldIdx) {\n            doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n          }).update(function (newIdx, oldIdx) {\n            morphPreparation_1.reset('oneToOne');\n            var oldEl = oldData.getItemGraphicEl(oldIdx);\n            morphPreparation_1.findAndAddFrom(oldEl);\n\n            if (morphPreparation_1.hasFrom()) {\n              removeElementDirectly(oldEl, group);\n              oldEl = null;\n            }\n\n            createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n            morphPreparation_1.applyMorphing();\n          }).updateManyToOne(function (newIdx, oldIndices) {\n            morphPreparation_1.reset('manyToOne');\n\n            for (var i = 0; i < oldIndices.length; i++) {\n              var oldEl = oldData.getItemGraphicEl(oldIndices[i]);\n              morphPreparation_1.findAndAddFrom(oldEl);\n              removeElementDirectly(oldEl, group);\n            }\n\n            createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n            morphPreparation_1.applyMorphing();\n          }).updateOneToMany(function (newIndices, oldIdx) {\n            morphPreparation_1.reset('oneToMany');\n            var newLen = newIndices.length;\n            var oldEl = oldData.getItemGraphicEl(oldIdx);\n            morphPreparation_1.findAndAddFrom(oldEl);\n            removeElementDirectly(oldEl, group);\n\n            for (var i = 0; i < newLen; i++) {\n              createOrUpdateItem(api, null, newIndices[i], renderItem(newIndices[i], payload), customSeries, group, data, morphPreparation_1);\n            }\n\n            morphPreparation_1.applyMorphing();\n          }).execute();\n        }\n\n        var clipPath = customSeries.get('clip', true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;\n\n        if (clipPath) {\n          group.setClipPath(clipPath);\n        } else {\n          group.removeClipPath();\n        }\n\n        this._data = data;\n      };\n\n      CustomSeriesView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {\n        this.group.removeAll();\n        this._data = null;\n      };\n\n      CustomSeriesView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {\n        var data = customSeries.getData();\n        var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n\n        function setIncrementalAndHoverLayer(el) {\n          if (!el.isGroup) {\n            el.incremental = true;\n            el.ensureState('emphasis').hoverLayer = true;\n          }\n        }\n\n        for (var idx = params.start; idx < params.end; idx++) {\n          var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data, null);\n          el.traverse(setIncrementalAndHoverLayer);\n        }\n      };\n\n      CustomSeriesView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {\n        var elementName = query.element;\n\n        if (elementName == null || targetEl.name === elementName) {\n          return true;\n        }\n\n        while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {\n          if (targetEl.name === elementName) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      CustomSeriesView.type = 'custom';\n      return CustomSeriesView;\n    }(ChartView);\n\n    function createGetKey(data, diffMode, dimension) {\n      if (!data) {\n        return;\n      }\n\n      if (diffMode === 'oneToOne') {\n        return function (rawIdx, dataIndex) {\n          return data.getId(dataIndex);\n        };\n      }\n\n      var diffByDimName = data.getDimension(dimension);\n      var dimInfo = data.getDimensionInfo(diffByDimName);\n\n      if (!dimInfo) {\n        var errMsg = '';\n\n        if (\"development\" !== 'production') {\n          errMsg = dimension + \" is not a valid dimension.\";\n        }\n\n        throwError(errMsg);\n      }\n\n      var ordinalMeta = dimInfo.ordinalMeta;\n      return function (rawIdx, dataIndex) {\n        var key = data.get(diffByDimName, dataIndex);\n\n        if (ordinalMeta) {\n          key = ordinalMeta.categories[key];\n        }\n\n        return key == null || eqNaN(key) ? rawIdx + '' : '_ec_' + key;\n      };\n    }\n\n    function createEl(elOption) {\n      var graphicType = elOption.type;\n      var el;\n\n      if (graphicType === 'path') {\n        var shape = elOption.shape;\n        var pathRect = shape.width != null && shape.height != null ? {\n          x: shape.x || 0,\n          y: shape.y || 0,\n          width: shape.width,\n          height: shape.height\n        } : null;\n        var pathData = getPathData(shape);\n        el = makePath(pathData, null, pathRect, shape.layout || 'center');\n        inner$b(el).customPathData = pathData;\n      } else if (graphicType === 'image') {\n        el = new ZRImage({});\n        inner$b(el).customImagePath = elOption.style.image;\n      } else if (graphicType === 'text') {\n        el = new ZRText({});\n      } else if (graphicType === 'group') {\n        el = new Group();\n      } else if (graphicType === 'compoundPath') {\n        throw new Error('\"compoundPath\" is not supported yet.');\n      } else {\n        var Clz = getShapeClass(graphicType);\n\n        if (!Clz) {\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = 'graphic type \"' + graphicType + '\" can not be found.';\n          }\n\n          throwError(errMsg);\n        }\n\n        el = new Clz();\n      }\n\n      inner$b(el).customGraphicType = graphicType;\n      el.name = elOption.name;\n      el.z2EmphasisLift = 1;\n      el.z2SelectLift = 1;\n      return el;\n    }\n\n    function updateElNormal(api, el, isMorphTo, dataIndex, elOption, styleOpt, attachedTxInfo, seriesModel, isInit, isTextContent) {\n      var transFromProps = {};\n      var allPropsFinal = {};\n      var elDisplayable = el.isGroup ? null : el;\n      !isMorphTo && prepareShapeOrExtraTransitionFrom('shape', el, null, elOption, transFromProps, isInit);\n      prepareShapeOrExtraAllPropsFinal('shape', elOption, allPropsFinal);\n      !isMorphTo && prepareShapeOrExtraTransitionFrom('extra', el, null, elOption, transFromProps, isInit);\n      prepareShapeOrExtraAllPropsFinal('extra', elOption, allPropsFinal);\n      !isMorphTo && prepareTransformTransitionFrom(el, null, elOption, transFromProps, isInit);\n      prepareTransformAllPropsFinal(elOption, allPropsFinal);\n      var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;\n\n      if (txCfgOpt) {\n        el.setTextConfig(txCfgOpt);\n      }\n\n      if (el.type === 'text' && styleOpt) {\n        var textOptionStyle = styleOpt;\n        hasOwn(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill);\n        hasOwn(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke);\n      }\n\n      if (styleOpt) {\n        var decalPattern = void 0;\n        var decalObj = isPath$1(el) ? styleOpt.decal : null;\n\n        if (api && decalObj) {\n          decalObj.dirty = true;\n          decalPattern = createOrUpdatePatternFromDecal(decalObj, api);\n        }\n\n        styleOpt.__decalPattern = decalPattern;\n      }\n\n      !isMorphTo && prepareStyleTransitionFrom(el, null, elOption, styleOpt, transFromProps, isInit);\n\n      if (elDisplayable) {\n        hasOwn(elOption, 'invisible') && (elDisplayable.invisible = elOption.invisible);\n      }\n\n      if (!isMorphTo) {\n        applyPropsFinal(el, allPropsFinal, styleOpt);\n        applyTransitionFrom(el, dataIndex, elOption, seriesModel, transFromProps, isInit);\n      }\n\n      hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n      hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n\n      if (!isTextContent) {\n        hasOwn(elOption, 'info') && (inner$b(el).info = elOption.info);\n      }\n\n      styleOpt ? el.dirty() : el.markRedraw();\n      return isMorphTo ? allPropsFinal : null;\n    }\n\n    function applyPropsFinal(el, allPropsFinal, styleOpt) {\n      var elDisplayable = el.isGroup ? null : el;\n\n      if (elDisplayable && styleOpt) {\n        var decalPattern = styleOpt.__decalPattern;\n        var originalDecalObj = void 0;\n\n        if (decalPattern) {\n          originalDecalObj = styleOpt.decal;\n          styleOpt.decal = decalPattern;\n        }\n\n        elDisplayable.useStyle(styleOpt);\n\n        if (decalPattern) {\n          styleOpt.decal = originalDecalObj;\n        }\n\n        var animators = elDisplayable.animators;\n\n        for (var i = 0; i < animators.length; i++) {\n          var animator = animators[i];\n\n          if (animator.targetName === 'style') {\n            animator.changeTarget(elDisplayable.style);\n          }\n        }\n      }\n\n      allPropsFinal && el.attr(allPropsFinal);\n    }\n\n    function applyTransitionFrom(el, dataIndex, elOption, seriesModel, transFromProps, isInit) {\n      if (transFromProps) {\n        var userDuring = elOption.during;\n        inner$b(el).userDuring = userDuring;\n        var cfgDuringCall = userDuring ? bind(duringCall, {\n          el: el,\n          userDuring: userDuring\n        }) : null;\n        var cfg = {\n          dataIndex: dataIndex,\n          isFrom: true,\n          during: cfgDuringCall\n        };\n        isInit ? initProps(el, transFromProps, seriesModel, cfg) : updateProps(el, transFromProps, seriesModel, cfg);\n      }\n    }\n\n    function prepareShapeOrExtraTransitionFrom(mainAttr, el, morphFromEl, elOption, transFromProps, isInit) {\n      var attrOpt = elOption[mainAttr];\n\n      if (!attrOpt) {\n        return;\n      }\n\n      var elPropsInAttr = el[mainAttr];\n      var transFromPropsInAttr;\n      var enterFrom = attrOpt.enterFrom;\n\n      if (isInit && enterFrom) {\n        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n        var enterFromKeys = keys(enterFrom);\n\n        for (var i = 0; i < enterFromKeys.length; i++) {\n          var key = enterFromKeys[i];\n          transFromPropsInAttr[key] = enterFrom[key];\n        }\n      }\n\n      if (!isInit && elPropsInAttr && !(morphFromEl != null && mainAttr === 'shape')) {\n        if (attrOpt.transition) {\n          !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n          var transitionKeys = normalizeToArray(attrOpt.transition);\n\n          for (var i = 0; i < transitionKeys.length; i++) {\n            var key = transitionKeys[i];\n            var elVal = elPropsInAttr[key];\n\n            if (\"development\" !== 'production') {\n              checkNonStyleTansitionRefer(key, attrOpt[key], elVal);\n            }\n\n            transFromPropsInAttr[key] = elVal;\n          }\n        } else if (indexOf(elOption.transition, mainAttr) >= 0) {\n          !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n          var elPropsInAttrKeys = keys(elPropsInAttr);\n\n          for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n            var key = elPropsInAttrKeys[i];\n            var elVal = elPropsInAttr[key];\n\n            if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n              transFromPropsInAttr[key] = elVal;\n            }\n          }\n        }\n      }\n\n      var leaveTo = attrOpt.leaveTo;\n\n      if (leaveTo) {\n        var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n        var leaveToPropsInAttr = leaveToProps[mainAttr] || (leaveToProps[mainAttr] = {});\n        var leaveToKeys = keys(leaveTo);\n\n        for (var i = 0; i < leaveToKeys.length; i++) {\n          var key = leaveToKeys[i];\n          leaveToPropsInAttr[key] = leaveTo[key];\n        }\n      }\n    }\n\n    function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n      var attrOpt = elOption[mainAttr];\n\n      if (!attrOpt) {\n        return;\n      }\n\n      var allPropsInAttr = allProps[mainAttr] = {};\n      var keysInAttr = keys(attrOpt);\n\n      for (var i = 0; i < keysInAttr.length; i++) {\n        var key = keysInAttr[i];\n        allPropsInAttr[key] = cloneValue(attrOpt[key]);\n      }\n    }\n\n    function prepareTransformTransitionFrom(el, morphFromEl, elOption, transFromProps, isInit) {\n      var enterFrom = elOption.enterFrom;\n\n      if (isInit && enterFrom) {\n        var enterFromKeys = keys(enterFrom);\n\n        for (var i = 0; i < enterFromKeys.length; i++) {\n          var key = enterFromKeys[i];\n\n          if (\"development\" !== 'production') {\n            checkTransformPropRefer(key, 'el.enterFrom');\n          }\n\n          transFromProps[key] = enterFrom[key];\n        }\n      }\n\n      if (!isInit) {\n        if (morphFromEl) {\n          var fromTransformable = calcOldElLocalTransformBasedOnNewElParent(morphFromEl, el);\n          setTransformPropToTransitionFrom(transFromProps, 'x', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'y', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'scaleX', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'scaleY', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'originX', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'originY', fromTransformable);\n          setTransformPropToTransitionFrom(transFromProps, 'rotation', fromTransformable);\n        } else if (elOption.transition) {\n          var transitionKeys = normalizeToArray(elOption.transition);\n\n          for (var i = 0; i < transitionKeys.length; i++) {\n            var key = transitionKeys[i];\n\n            if (key === 'style' || key === 'shape' || key === 'extra') {\n              continue;\n            }\n\n            var elVal = el[key];\n\n            if (\"development\" !== 'production') {\n              checkTransformPropRefer(key, 'el.transition');\n              checkNonStyleTansitionRefer(key, elOption[key], elVal);\n            }\n\n            transFromProps[key] = elVal;\n          }\n        } else {\n          setTransformPropToTransitionFrom(transFromProps, 'x', el);\n          setTransformPropToTransitionFrom(transFromProps, 'y', el);\n        }\n      }\n\n      var leaveTo = elOption.leaveTo;\n\n      if (leaveTo) {\n        var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n        var leaveToKeys = keys(leaveTo);\n\n        for (var i = 0; i < leaveToKeys.length; i++) {\n          var key = leaveToKeys[i];\n\n          if (\"development\" !== 'production') {\n            checkTransformPropRefer(key, 'el.leaveTo');\n          }\n\n          leaveToProps[key] = leaveTo[key];\n        }\n      }\n    }\n\n    function prepareTransformAllPropsFinal(elOption, allProps) {\n      setLagecyTransformProp(elOption, allProps, 'position');\n      setLagecyTransformProp(elOption, allProps, 'scale');\n      setLagecyTransformProp(elOption, allProps, 'origin');\n      setTransformProp(elOption, allProps, 'x');\n      setTransformProp(elOption, allProps, 'y');\n      setTransformProp(elOption, allProps, 'scaleX');\n      setTransformProp(elOption, allProps, 'scaleY');\n      setTransformProp(elOption, allProps, 'originX');\n      setTransformProp(elOption, allProps, 'originY');\n      setTransformProp(elOption, allProps, 'rotation');\n    }\n\n    function prepareStyleTransitionFrom(el, morphFromEl, elOption, styleOpt, transFromProps, isInit) {\n      if (!styleOpt) {\n        return;\n      }\n\n      var fromEl = morphFromEl || el;\n      var fromElStyle = fromEl.style;\n      var transFromStyleProps;\n      var enterFrom = styleOpt.enterFrom;\n\n      if (isInit && enterFrom) {\n        var enterFromKeys = keys(enterFrom);\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n\n        for (var i = 0; i < enterFromKeys.length; i++) {\n          var key = enterFromKeys[i];\n          transFromStyleProps[key] = enterFrom[key];\n        }\n      }\n\n      if (!isInit && fromElStyle) {\n        if (styleOpt.transition) {\n          var transitionKeys = normalizeToArray(styleOpt.transition);\n          !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n\n          for (var i = 0; i < transitionKeys.length; i++) {\n            var key = transitionKeys[i];\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        } else if (el.getAnimationStyleProps && indexOf(elOption.transition, 'style') >= 0) {\n          var animationProps = el.getAnimationStyleProps();\n          var animationStyleProps = animationProps ? animationProps.style : null;\n\n          if (animationStyleProps) {\n            !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n            var styleKeys = keys(styleOpt);\n\n            for (var i = 0; i < styleKeys.length; i++) {\n              var key = styleKeys[i];\n\n              if (animationStyleProps[key]) {\n                var elVal = fromElStyle[key];\n                transFromStyleProps[key] = elVal;\n              }\n            }\n          }\n        }\n      }\n\n      var leaveTo = styleOpt.leaveTo;\n\n      if (leaveTo) {\n        var leaveToKeys = keys(leaveTo);\n        var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n        var leaveToStyleProps = leaveToProps.style || (leaveToProps.style = {});\n\n        for (var i = 0; i < leaveToKeys.length; i++) {\n          var key = leaveToKeys[i];\n          leaveToStyleProps[key] = leaveTo[key];\n        }\n      }\n    }\n\n    function calcOldElLocalTransformBasedOnNewElParent(oldEl, newEl) {\n      if (!oldEl || oldEl === newEl || oldEl.parent === newEl.parent) {\n        return oldEl;\n      }\n\n      var tmpM = tmpTransformable.transform || (tmpTransformable.transform = identity([]));\n      var oldGlobalTransform = oldEl.getComputedTransform();\n      oldGlobalTransform ? copy$1(tmpM, oldGlobalTransform) : identity(tmpM);\n      var newParent = newEl.parent;\n\n      if (newParent) {\n        newParent.getComputedTransform();\n      }\n\n      tmpTransformable.originX = oldEl.originX;\n      tmpTransformable.originY = oldEl.originY;\n      tmpTransformable.parent = newParent;\n      tmpTransformable.decomposeTransform();\n      return tmpTransformable;\n    }\n\n    var checkNonStyleTansitionRefer;\n\n    if (\"development\" !== 'production') {\n      checkNonStyleTansitionRefer = function (propName, optVal, elVal) {\n        if (!isArrayLike(optVal)) {\n          assert(optVal != null && isFinite(optVal), 'Prop `' + propName + '` must refer to a finite number or ArrayLike for transition.');\n        } else {\n          assert(optVal !== elVal, 'Prop `' + propName + '` must use different Array object each time for transition.');\n        }\n      };\n    }\n\n    function isNonStyleTransitionEnabled(optVal, elVal) {\n      return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n    }\n\n    var checkTransformPropRefer;\n\n    if (\"development\" !== 'production') {\n      checkTransformPropRefer = function (key, usedIn) {\n        assert(hasOwn(TRANSFORM_PROPS, key), 'Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS).join('`, `') + '` are permitted.');\n      };\n    }\n\n    function getOrCreateLeaveToPropsFromEl(el) {\n      var innerEl = inner$b(el);\n      return innerEl.leaveToProps || (innerEl.leaveToProps = {});\n    }\n\n    var tmpDuringScope = {};\n    var customDuringAPI = {\n      setTransform: function (key, val) {\n        if (\"development\" !== 'production') {\n          assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n        }\n\n        tmpDuringScope.el[key] = val;\n        return this;\n      },\n      getTransform: function (key) {\n        if (\"development\" !== 'production') {\n          assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n        }\n\n        return tmpDuringScope.el[key];\n      },\n      setShape: function (key, val) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var shape = tmpDuringScope.el.shape || (tmpDuringScope.el.shape = {});\n        shape[key] = val;\n        tmpDuringScope.isShapeDirty = true;\n        return this;\n      },\n      getShape: function (key) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var shape = tmpDuringScope.el.shape;\n\n        if (shape) {\n          return shape[key];\n        }\n      },\n      setStyle: function (key, val) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var style = tmpDuringScope.el.style;\n\n        if (style) {\n          if (\"development\" !== 'production') {\n            if (eqNaN(val)) {\n              warn('style.' + key + ' must not be assigned with NaN.');\n            }\n          }\n\n          style[key] = val;\n          tmpDuringScope.isStyleDirty = true;\n        }\n\n        return this;\n      },\n      getStyle: function (key) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var style = tmpDuringScope.el.style;\n\n        if (style) {\n          return style[key];\n        }\n      },\n      setExtra: function (key, val) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n        extra[key] = val;\n        return this;\n      },\n      getExtra: function (key) {\n        if (\"development\" !== 'production') {\n          assertNotReserved(key);\n        }\n\n        var extra = tmpDuringScope.el.extra;\n\n        if (extra) {\n          return extra[key];\n        }\n      }\n    };\n\n    function assertNotReserved(key) {\n      if (\"development\" !== 'production') {\n        if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n          throw new Error('key must not be \"' + key + '\"');\n        }\n      }\n    }\n\n    function duringCall() {\n      var scope = this;\n      var el = scope.el;\n\n      if (!el) {\n        return;\n      }\n\n      var newstUserDuring = inner$b(el).userDuring;\n      var scopeUserDuring = scope.userDuring;\n\n      if (newstUserDuring !== scopeUserDuring) {\n        scope.el = scope.userDuring = null;\n        return;\n      }\n\n      tmpDuringScope.el = el;\n      tmpDuringScope.isShapeDirty = false;\n      tmpDuringScope.isStyleDirty = false;\n      scopeUserDuring(customDuringAPI);\n\n      if (tmpDuringScope.isShapeDirty && el.dirtyShape) {\n        el.dirtyShape();\n      }\n\n      if (tmpDuringScope.isStyleDirty && el.dirtyStyle) {\n        el.dirtyStyle();\n      }\n    }\n\n    function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo, isRoot, isTextContent) {\n      var elDisplayable = el.isGroup ? null : el;\n      var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;\n\n      if (elDisplayable) {\n        var stateObj = elDisplayable.ensureState(state);\n\n        if (styleOpt === false) {\n          var existingEmphasisState = elDisplayable.getState(state);\n\n          if (existingEmphasisState) {\n            existingEmphasisState.style = null;\n          }\n        } else {\n          stateObj.style = styleOpt || null;\n        }\n\n        if (txCfgOpt) {\n          stateObj.textConfig = txCfgOpt;\n        }\n\n        setDefaultStateProxy(elDisplayable);\n      }\n    }\n\n    function updateZ$1(el, elOption, seriesModel, attachedTxInfo) {\n      if (el.isGroup) {\n        return;\n      }\n\n      var elDisplayable = el;\n      var currentZ = seriesModel.currentZ;\n      var currentZLevel = seriesModel.currentZLevel;\n      elDisplayable.z = currentZ;\n      elDisplayable.zlevel = currentZLevel;\n      var optZ2 = elOption.z2;\n      optZ2 != null && (elDisplayable.z2 = optZ2 || 0);\n\n      for (var i = 0; i < STATES.length; i++) {\n        updateZForEachState(elDisplayable, elOption, STATES[i]);\n      }\n    }\n\n    function updateZForEachState(elDisplayable, elOption, state) {\n      var isNormal = state === NORMAL;\n      var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);\n      var optZ2 = elStateOpt ? elStateOpt.z2 : null;\n      var stateObj;\n\n      if (optZ2 != null) {\n        stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);\n        stateObj.z2 = optZ2 || 0;\n      }\n    }\n\n    function setLagecyTransformProp(elOption, targetProps, legacyName, fromTransformable) {\n      var legacyArr = elOption[legacyName];\n      var xyName = LEGACY_TRANSFORM_PROPS[legacyName];\n\n      if (legacyArr) {\n        if (fromTransformable) {\n          targetProps[xyName[0]] = fromTransformable[xyName[0]];\n          targetProps[xyName[1]] = fromTransformable[xyName[1]];\n        } else {\n          targetProps[xyName[0]] = legacyArr[0];\n          targetProps[xyName[1]] = legacyArr[1];\n        }\n      }\n    }\n\n    function setTransformProp(elOption, allProps, name, fromTransformable) {\n      if (elOption[name] != null) {\n        allProps[name] = fromTransformable ? fromTransformable[name] : elOption[name];\n      }\n    }\n\n    function setTransformPropToTransitionFrom(transitionFrom, name, fromTransformable) {\n      if (fromTransformable) {\n        transitionFrom[name] = fromTransformable[name];\n      }\n    }\n\n    function makeRenderItem(customSeries, data, ecModel, api) {\n      var renderItem = customSeries.get('renderItem');\n      var coordSys = customSeries.coordinateSystem;\n      var prepareResult = {};\n\n      if (coordSys) {\n        if (\"development\" !== 'production') {\n          assert(renderItem, 'series.render is required.');\n          assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.');\n        }\n\n        prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);\n      }\n\n      var userAPI = defaults({\n        getWidth: api.getWidth,\n        getHeight: api.getHeight,\n        getZr: api.getZr,\n        getDevicePixelRatio: api.getDevicePixelRatio,\n        value: value,\n        style: style,\n        ordinalRawValue: ordinalRawValue,\n        styleEmphasis: styleEmphasis,\n        visual: visual,\n        barLayout: barLayout,\n        currentSeriesIndices: currentSeriesIndices,\n        font: font\n      }, prepareResult.api || {});\n      var userParams = {\n        context: {},\n        seriesId: customSeries.id,\n        seriesName: customSeries.name,\n        seriesIndex: customSeries.seriesIndex,\n        coordSys: prepareResult.coordSys,\n        dataInsideLength: data.count(),\n        encode: wrapEncodeDef(customSeries.getData())\n      };\n      var currDataIndexInside;\n      var currItemModel;\n      var currItemStyleModels = {};\n      var currLabelModels = {};\n      var seriesItemStyleModels = {};\n      var seriesLabelModels = {};\n\n      for (var i = 0; i < STATES.length; i++) {\n        var stateName = STATES[i];\n        seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);\n        seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);\n      }\n\n      function getItemModel(dataIndexInside) {\n        return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);\n      }\n\n      function getItemStyleModel(dataIndexInside, state) {\n        return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);\n      }\n\n      function getLabelModel(dataIndexInside, state) {\n        return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);\n      }\n\n      return function (dataIndexInside, payload) {\n        currDataIndexInside = dataIndexInside;\n        currItemModel = null;\n        currItemStyleModels = {};\n        currLabelModels = {};\n        return renderItem && renderItem(defaults({\n          dataIndexInside: dataIndexInside,\n          dataIndex: data.getRawIndex(dataIndexInside),\n          actionType: payload ? payload.type : null\n        }, userParams), userAPI);\n      };\n\n      function value(dim, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        return data.get(data.getDimension(dim || 0), dataIndexInside);\n      }\n\n      function ordinalRawValue(dim, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        var dimInfo = data.getDimensionInfo(dim || 0);\n\n        if (!dimInfo) {\n          return;\n        }\n\n        var val = data.get(dimInfo.name, dataIndexInside);\n        var ordinalMeta = dimInfo && dimInfo.ordinalMeta;\n        return ordinalMeta ? ordinalMeta.categories[val] : val;\n      }\n\n      function style(userProps, dataIndexInside) {\n        if (\"development\" !== 'production') {\n          warnDeprecated('api.style', 'Please write literal style directly instead.');\n        }\n\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        var style = data.getItemVisual(dataIndexInside, 'style');\n        var visualColor = style && style.fill;\n        var opacity = style && style.opacity;\n        var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();\n        visualColor != null && (itemStyle.fill = visualColor);\n        opacity != null && (itemStyle.opacity = opacity);\n        var opt = {\n          inheritColor: isString(visualColor) ? visualColor : '#000'\n        };\n        var labelModel = getLabelModel(dataIndexInside, NORMAL);\n        var textStyle = createTextStyle(labelModel, null, opt, false, true);\n        textStyle.text = labelModel.getShallow('show') ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n        var textConfig = createTextConfig(labelModel, opt, false);\n        preFetchFromExtra(userProps, itemStyle);\n        itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n        userProps && applyUserPropsAfter(itemStyle, userProps);\n        itemStyle.legacy = true;\n        return itemStyle;\n      }\n\n      function styleEmphasis(userProps, dataIndexInside) {\n        if (\"development\" !== 'production') {\n          warnDeprecated('api.styleEmphasis', 'Please write literal style directly instead.');\n        }\n\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n        var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();\n        var labelModel = getLabelModel(dataIndexInside, EMPHASIS);\n        var textStyle = createTextStyle(labelModel, null, null, true, true);\n        textStyle.text = labelModel.getShallow('show') ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n        var textConfig = createTextConfig(labelModel, null, true);\n        preFetchFromExtra(userProps, itemStyle);\n        itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n        userProps && applyUserPropsAfter(itemStyle, userProps);\n        itemStyle.legacy = true;\n        return itemStyle;\n      }\n\n      function applyUserPropsAfter(itemStyle, extra) {\n        for (var key in extra) {\n          if (hasOwn(extra, key)) {\n            itemStyle[key] = extra[key];\n          }\n        }\n      }\n\n      function preFetchFromExtra(extra, itemStyle) {\n        if (extra) {\n          extra.textFill && (itemStyle.textFill = extra.textFill);\n          extra.textPosition && (itemStyle.textPosition = extra.textPosition);\n        }\n      }\n\n      function visual(visualType, dataIndexInside) {\n        dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n\n        if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {\n          var style_1 = data.getItemVisual(dataIndexInside, 'style');\n          return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;\n        }\n\n        if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {\n          return data.getItemVisual(dataIndexInside, visualType);\n        }\n      }\n\n      function barLayout(opt) {\n        if (coordSys.type === 'cartesian2d') {\n          var baseAxis = coordSys.getBaseAxis();\n          return getLayoutOnAxis(defaults({\n            axis: baseAxis\n          }, opt));\n        }\n      }\n\n      function currentSeriesIndices() {\n        return ecModel.getCurrentSeriesIndices();\n      }\n\n      function font(opt) {\n        return getFont(opt, ecModel);\n      }\n    }\n\n    function wrapEncodeDef(data) {\n      var encodeDef = {};\n      each(data.dimensions, function (dimName, dataDimIndex) {\n        var dimInfo = data.getDimensionInfo(dimName);\n\n        if (!dimInfo.isExtraCoord) {\n          var coordDim = dimInfo.coordDim;\n          var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];\n          dataDims[dimInfo.coordDimIndex] = dataDimIndex;\n        }\n      });\n      return encodeDef;\n    }\n\n    function createOrUpdateItem(api, el, dataIndex, elOption, seriesModel, group, data, morphPreparation) {\n      if (!elOption) {\n        removeElementDirectly(el, group);\n        return;\n      }\n\n      el = doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, true, morphPreparation);\n      el && data.setItemGraphicEl(dataIndex, el);\n      enableHoverEmphasis(el, elOption.focus, elOption.blurScope);\n      return el;\n    }\n\n    function doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, isRoot, morphPreparation) {\n      if (\"development\" !== 'production') {\n        assert(elOption, 'should not have an null/undefined element setting');\n      }\n\n      var toBeReplacedIdx = -1;\n\n      if (el && doesElNeedRecreate(el, elOption)) {\n        toBeReplacedIdx = group.childrenRef().indexOf(el);\n        el = null;\n      }\n\n      var elIsNewCreated = !el;\n\n      if (!el) {\n        el = createEl(elOption);\n      } else {\n        el.clearStates();\n      }\n\n      var canMorph = inner$b(el).canMorph = elOption.morph && isPath$1(el);\n      var thisElIsMorphTo = canMorph && morphPreparation && morphPreparation.hasFrom();\n      var isInit = elIsNewCreated && !thisElIsMorphTo;\n      attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;\n      attachedTxInfoTmp.isLegacy = false;\n      doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);\n      doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);\n      var pendingAllPropsFinal = updateElNormal(api, el, thisElIsMorphTo, dataIndex, elOption, elOption.style, attachedTxInfoTmp, seriesModel, isInit, false);\n\n      if (thisElIsMorphTo) {\n        morphPreparation.addTo(el, elOption, dataIndex, pendingAllPropsFinal);\n      }\n\n      for (var i = 0; i < STATES.length; i++) {\n        var stateName = STATES[i];\n\n        if (stateName !== NORMAL) {\n          var otherStateOpt = retrieveStateOption(elOption, stateName);\n          var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);\n          updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);\n        }\n      }\n\n      updateZ$1(el, elOption, seriesModel);\n\n      if (elOption.type === 'group') {\n        mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation);\n      }\n\n      if (toBeReplacedIdx >= 0) {\n        group.replaceAt(el, toBeReplacedIdx);\n      } else {\n        group.add(el);\n      }\n\n      return el;\n    }\n\n    function doesElNeedRecreate(el, elOption) {\n      var elInner = inner$b(el);\n      var elOptionType = elOption.type;\n      var elOptionShape = elOption.shape;\n      var elOptionStyle = elOption.style;\n      return elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && hasOwn(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath;\n    }\n\n    function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {\n      var clipPathOpt = elOption.clipPath;\n\n      if (clipPathOpt === false) {\n        if (el && el.getClipPath()) {\n          el.removeClipPath();\n        }\n      } else if (clipPathOpt) {\n        var clipPath = el.getClipPath();\n\n        if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt)) {\n          clipPath = null;\n        }\n\n        if (!clipPath) {\n          clipPath = createEl(clipPathOpt);\n\n          if (\"development\" !== 'production') {\n            assert(clipPath instanceof Path, 'Only any type of `path` can be used in `clipPath`, rather than ' + clipPath.type + '.');\n          }\n\n          el.setClipPath(clipPath);\n        }\n\n        updateElNormal(null, clipPath, null, dataIndex, clipPathOpt, null, null, seriesModel, isInit, false);\n      }\n    }\n\n    function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {\n      if (el.isGroup) {\n        return;\n      }\n\n      processTxInfo(elOption, null, attachedTxInfo);\n      processTxInfo(elOption, EMPHASIS, attachedTxInfo);\n      var txConOptNormal = attachedTxInfo.normal.conOpt;\n      var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;\n      var txConOptBlur = attachedTxInfo.blur.conOpt;\n      var txConOptSelect = attachedTxInfo.select.conOpt;\n\n      if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {\n        var textContent = el.getTextContent();\n\n        if (txConOptNormal === false) {\n          textContent && el.removeTextContent();\n        } else {\n          txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {\n            type: 'text'\n          };\n\n          if (!textContent) {\n            textContent = createEl(txConOptNormal);\n            el.setTextContent(textContent);\n          } else {\n            textContent.clearStates();\n          }\n\n          var txConStlOptNormal = txConOptNormal && txConOptNormal.style;\n          updateElNormal(null, textContent, null, dataIndex, txConOptNormal, txConStlOptNormal, null, seriesModel, isInit, true);\n\n          for (var i = 0; i < STATES.length; i++) {\n            var stateName = STATES[i];\n\n            if (stateName !== NORMAL) {\n              var txConOptOtherState = attachedTxInfo[stateName].conOpt;\n              updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);\n            }\n          }\n\n          txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();\n        }\n      }\n    }\n\n    function processTxInfo(elOption, state, attachedTxInfo) {\n      var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);\n      var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);\n      var elType = elOption.type;\n      var txCfg = stateOpt ? stateOpt.textConfig : null;\n      var txConOptNormal = elOption.textContent;\n      var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);\n\n      if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {\n        attachedTxInfo.isLegacy = true;\n        var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);\n\n        if (!txCfg && convertResult.textConfig) {\n          txCfg = convertResult.textConfig;\n        }\n\n        if (!txConOpt && convertResult.textContent) {\n          txConOpt = convertResult.textContent;\n        }\n      }\n\n      if (!state && txConOpt) {\n        var txConOptNormal_1 = txConOpt;\n        !txConOptNormal_1.type && (txConOptNormal_1.type = 'text');\n\n        if (\"development\" !== 'production') {\n          txConOptNormal_1.type !== 'text' && assert(txConOptNormal_1.type === 'text', 'textContent.type must be \"text\"');\n        }\n      }\n\n      var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];\n      info.cfg = txCfg;\n      info.conOpt = txConOpt;\n    }\n\n    function retrieveStateOption(elOption, state) {\n      return !state ? elOption : elOption ? elOption[state] : null;\n    }\n\n    function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {\n      var style = stateOption && stateOption.style;\n\n      if (style == null && state === EMPHASIS && stateOptionNormal) {\n        style = stateOptionNormal.styleEmphasis;\n      }\n\n      return style;\n    }\n\n    function mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation) {\n      var newChildren = elOption.children;\n      var newLen = newChildren ? newChildren.length : 0;\n      var mergeChildren = elOption.$mergeChildren;\n      var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;\n      var notMerge = mergeChildren === false;\n\n      if (!newLen && !byName && !notMerge) {\n        return;\n      }\n\n      if (byName) {\n        diffGroupChildren({\n          api: api,\n          oldChildren: el.children() || [],\n          newChildren: newChildren || [],\n          dataIndex: dataIndex,\n          seriesModel: seriesModel,\n          group: el,\n          morphPreparation: morphPreparation\n        });\n        return;\n      }\n\n      notMerge && el.removeAll();\n      var index = 0;\n\n      for (; index < newLen; index++) {\n        newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el, false, morphPreparation);\n      }\n\n      for (var i = el.childCount() - 1; i >= index; i--) {\n        doRemoveEl(el.childAt(i), seriesModel, el);\n      }\n    }\n\n    function diffGroupChildren(context) {\n      new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();\n    }\n\n    function getKey(item, idx) {\n      var name = item && item.name;\n      return name != null ? name : GROUP_DIFF_PREFIX + idx;\n    }\n\n    function processAddUpdate(newIndex, oldIndex) {\n      var context = this.context;\n      var childOption = newIndex != null ? context.newChildren[newIndex] : null;\n      var child = oldIndex != null ? context.oldChildren[oldIndex] : null;\n      doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group, false, context.morphPreparation);\n    }\n\n    function processRemove(oldIndex) {\n      var context = this.context;\n      var child = context.oldChildren[oldIndex];\n      doRemoveEl(child, context.seriesModel, context.group);\n    }\n\n    function doRemoveEl(el, seriesModel, group) {\n      if (el) {\n        var leaveToProps = inner$b(el).leaveToProps;\n        leaveToProps ? updateProps(el, leaveToProps, seriesModel, {\n          cb: function () {\n            group.remove(el);\n          }\n        }) : group.remove(el);\n      }\n    }\n\n    function getPathData(shape) {\n      return shape && (shape.pathData || shape.d);\n    }\n\n    function hasOwnPathData(shape) {\n      return shape && (hasOwn(shape, 'pathData') || hasOwn(shape, 'd'));\n    }\n\n    function isPath$1(el) {\n      return el && el instanceof Path;\n    }\n\n    function removeElementDirectly(el, group) {\n      el && group.remove(el);\n    }\n\n    var MorphPreparation = function () {\n      function MorphPreparation(seriesModel, transOpt) {\n        this._fromList = [];\n        this._toList = [];\n        this._toElOptionList = [];\n        this._allPropsFinalList = [];\n        this._toDataIndices = [];\n        this._morphConfigList = [];\n        this._seriesModel = seriesModel;\n        this._transOpt = transOpt;\n      }\n\n      MorphPreparation.prototype.hasFrom = function () {\n        return !!this._fromList.length;\n      };\n\n      MorphPreparation.prototype.findAndAddFrom = function (el) {\n        if (!el) {\n          return;\n        }\n\n        if (inner$b(el).canMorph) {\n          this._fromList.push(el);\n        }\n\n        if (el.isGroup) {\n          var children = el.childrenRef();\n\n          for (var i = 0; i < children.length; i++) {\n            this.findAndAddFrom(children[i]);\n          }\n        }\n      };\n\n      MorphPreparation.prototype.addTo = function (path, elOption, dataIndex, allPropsFinal) {\n        if (path) {\n          this._toList.push(path);\n\n          this._toElOptionList.push(elOption);\n\n          this._toDataIndices.push(dataIndex);\n\n          this._allPropsFinalList.push(allPropsFinal);\n        }\n      };\n\n      MorphPreparation.prototype.applyMorphing = function () {\n        var type = this._type;\n        var fromList = this._fromList;\n        var toList = this._toList;\n        var toListLen = toList.length;\n        var fromListLen = fromList.length;\n\n        if (!fromListLen || !toListLen) {\n          return;\n        }\n\n        if (type === 'oneToOne') {\n          for (var toIdx = 0; toIdx < toListLen; toIdx++) {\n            this._oneToOneForSingleTo(toIdx, toIdx);\n          }\n        } else if (type === 'manyToOne') {\n          var fromSingleSegLen = Math.max(1, Math.floor(fromListLen / toListLen));\n\n          for (var toIdx = 0, fromIdxStart = 0; toIdx < toListLen; toIdx++, fromIdxStart += fromSingleSegLen) {\n            var fromCount = toIdx + 1 >= toListLen ? fromListLen - fromIdxStart : fromSingleSegLen;\n\n            this._manyToOneForSingleTo(toIdx, fromIdxStart >= fromListLen ? null : fromIdxStart, fromCount);\n          }\n        } else if (type === 'oneToMany') {\n          var toSingleSegLen = Math.max(1, Math.floor(toListLen / fromListLen));\n\n          for (var toIdxStart = 0, fromIdx = 0; toIdxStart < toListLen; toIdxStart += toSingleSegLen, fromIdx++) {\n            var toCount = toIdxStart + toSingleSegLen >= toListLen ? toListLen - toIdxStart : toSingleSegLen;\n\n            this._oneToManyForSingleFrom(toIdxStart, toCount, fromIdx >= fromListLen ? null : fromIdx);\n          }\n        }\n      };\n\n      MorphPreparation.prototype._oneToOneForSingleTo = function (toIdx, fromIdx) {\n        var to = this._toList[toIdx];\n        var toElOption = this._toElOptionList[toIdx];\n        var toDataIndex = this._toDataIndices[toIdx];\n        var allPropsFinal = this._allPropsFinalList[toIdx];\n        var from = this._fromList[fromIdx];\n\n        var elAnimationConfig = this._getOrCreateMorphConfig(toDataIndex);\n\n        var morphDuration = elAnimationConfig.duration;\n\n        if (from && isCombiningPath(from)) {\n          applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n          if (morphDuration) {\n            var combineResult = combine([from], to, elAnimationConfig, copyPropsWhenDivided);\n\n            this._processResultIndividuals(combineResult, toIdx, null);\n          }\n        } else {\n          var morphFrom = morphDuration && from && (from !== to || isInAnyMorphing(from)) ? from : null;\n          var transFromProps = {};\n          prepareShapeOrExtraTransitionFrom('shape', to, morphFrom, toElOption, transFromProps, false);\n          prepareShapeOrExtraTransitionFrom('extra', to, morphFrom, toElOption, transFromProps, false);\n          prepareTransformTransitionFrom(to, morphFrom, toElOption, transFromProps, false);\n          prepareStyleTransitionFrom(to, morphFrom, toElOption, toElOption.style, transFromProps, false);\n          applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n          if (morphFrom) {\n            morphPath(morphFrom, to, elAnimationConfig);\n          }\n\n          applyTransitionFrom(to, toDataIndex, toElOption, this._seriesModel, transFromProps, false);\n        }\n      };\n\n      MorphPreparation.prototype._manyToOneForSingleTo = function (toIdx, fromIdxStart, fromCount) {\n        var to = this._toList[toIdx];\n        var toElOption = this._toElOptionList[toIdx];\n        var allPropsFinal = this._allPropsFinalList[toIdx];\n        applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n        var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdx]);\n\n        if (elAnimationConfig.duration && fromIdxStart != null) {\n          var combineFromList = [];\n\n          for (var fromIdx = fromIdxStart; fromIdx < fromCount; fromIdx++) {\n            combineFromList.push(this._fromList[fromIdx]);\n          }\n\n          var combineResult = combine(combineFromList, to, elAnimationConfig, copyPropsWhenDivided);\n\n          this._processResultIndividuals(combineResult, toIdx, null);\n        }\n      };\n\n      MorphPreparation.prototype._oneToManyForSingleFrom = function (toIdxStart, toCount, fromIdx) {\n        var from = fromIdx == null ? null : this._fromList[fromIdx];\n        var toList = this._toList;\n        var separateToList = [];\n\n        for (var toIdx = toIdxStart; toIdx < toCount; toIdx++) {\n          var to = toList[toIdx];\n          applyPropsFinal(to, this._allPropsFinalList[toIdx], this._toElOptionList[toIdx].style);\n          separateToList.push(to);\n        }\n\n        var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdxStart]);\n\n        if (elAnimationConfig.duration && from) {\n          var separateResult = separate(from, separateToList, elAnimationConfig, copyPropsWhenDivided);\n\n          this._processResultIndividuals(separateResult, toIdxStart, toCount);\n        }\n      };\n\n      MorphPreparation.prototype._processResultIndividuals = function (combineSeparateResult, toIdxStart, toCount) {\n        var isSeparate = toCount != null;\n\n        for (var i = 0; i < combineSeparateResult.count; i++) {\n          var fromIndividual = combineSeparateResult.fromIndividuals[i];\n          var toIndividual = combineSeparateResult.toIndividuals[i];\n          var toIdx = toIdxStart + (isSeparate ? i : 0);\n          var toElOption = this._toElOptionList[toIdx];\n          var dataIndex = this._toDataIndices[toIdx];\n          var transFromProps = {};\n          prepareTransformTransitionFrom(toIndividual, fromIndividual, toElOption, transFromProps, false);\n          prepareStyleTransitionFrom(toIndividual, fromIndividual, toElOption, toElOption.style, transFromProps, false);\n          applyTransitionFrom(toIndividual, dataIndex, toElOption, this._seriesModel, transFromProps, false);\n        }\n      };\n\n      MorphPreparation.prototype._getOrCreateMorphConfig = function (dataIndex) {\n        var morphConfigList = this._morphConfigList;\n        var config = morphConfigList[dataIndex];\n\n        if (config) {\n          return config;\n        }\n\n        var duration;\n        var easing;\n        var delay;\n        var seriesModel = this._seriesModel;\n        var transOpt = this._transOpt;\n\n        if (seriesModel.isAnimationEnabled()) {\n          var animationPayload = void 0;\n\n          if (seriesModel && seriesModel.ecModel) {\n            var updatePayload = seriesModel.ecModel.getUpdatePayload();\n            animationPayload = updatePayload && updatePayload.animation;\n          }\n\n          if (animationPayload) {\n            duration = animationPayload.duration || 0;\n            easing = animationPayload.easing || 'cubicOut';\n            delay = animationPayload.delay || 0;\n          } else {\n            easing = seriesModel.get('animationEasingUpdate');\n            var delayOption = seriesModel.get('animationDelayUpdate');\n            delay = isFunction(delayOption) ? delayOption(dataIndex) : delayOption;\n            var durationOption = seriesModel.get('animationDurationUpdate');\n            duration = isFunction(durationOption) ? durationOption(dataIndex) : durationOption;\n          }\n        }\n\n        config = {\n          duration: duration || 0,\n          delay: delay,\n          easing: easing,\n          dividingMethod: transOpt ? transOpt.dividingMethod : null\n        };\n        morphConfigList[dataIndex] = config;\n        return config;\n      };\n\n      MorphPreparation.prototype.reset = function (type) {\n        this._type = type;\n        this._fromList.length = this._toList.length = this._toElOptionList.length = this._allPropsFinalList.length = this._toDataIndices.length = 0;\n      };\n\n      return MorphPreparation;\n    }();\n\n    function copyPropsWhenDivided(srcPath, tarPath, willClone) {\n      tarPath.style = willClone ? clone(srcPath.style) : srcPath.style;\n      tarPath.zlevel = srcPath.zlevel;\n      tarPath.z = srcPath.z;\n      tarPath.z2 = srcPath.z2;\n    }\n\n    function install$q(registers) {\n      registers.registerChartView(CustomSeriesView);\n      registers.registerSeriesModel(CustomSeriesModel);\n    }\n\n    var inner$c = makeInner();\n    var clone$3 = clone;\n    var bind$1 = bind;\n\n    var BaseAxisPointer = function () {\n      function BaseAxisPointer() {\n        this._dragging = false;\n        this.animationThreshold = 15;\n      }\n\n      BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {\n        var value = axisPointerModel.get('value');\n        var status = axisPointerModel.get('status');\n        this._axisModel = axisModel;\n        this._axisPointerModel = axisPointerModel;\n        this._api = api;\n\n        if (!forceRender && this._lastValue === value && this._lastStatus === status) {\n          return;\n        }\n\n        this._lastValue = value;\n        this._lastStatus = status;\n        var group = this._group;\n        var handle = this._handle;\n\n        if (!status || status === 'hide') {\n          group && group.hide();\n          handle && handle.hide();\n          return;\n        }\n\n        group && group.show();\n        handle && handle.show();\n        var elOption = {};\n        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);\n        var graphicKey = elOption.graphicKey;\n\n        if (graphicKey !== this._lastGraphicKey) {\n          this.clear(api);\n        }\n\n        this._lastGraphicKey = graphicKey;\n        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);\n\n        if (!group) {\n          group = this._group = new Group();\n          this.createPointerEl(group, elOption, axisModel, axisPointerModel);\n          this.createLabelEl(group, elOption, axisModel, axisPointerModel);\n          api.getZr().add(group);\n        } else {\n          var doUpdateProps = curry(updateProps$1, axisPointerModel, moveAnimation);\n          this.updatePointerEl(group, elOption, doUpdateProps);\n          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);\n        }\n\n        updateMandatoryProps(group, axisPointerModel, true);\n\n        this._renderHandle(value);\n      };\n\n      BaseAxisPointer.prototype.remove = function (api) {\n        this.clear(api);\n      };\n\n      BaseAxisPointer.prototype.dispose = function (api) {\n        this.clear(api);\n      };\n\n      BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {\n        var animation = axisPointerModel.get('animation');\n        var axis = axisModel.axis;\n        var isCategoryAxis = axis.type === 'category';\n        var useSnap = axisPointerModel.get('snap');\n\n        if (!useSnap && !isCategoryAxis) {\n          return false;\n        }\n\n        if (animation === 'auto' || animation == null) {\n          var animationThreshold = this.animationThreshold;\n\n          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {\n            return true;\n          }\n\n          if (useSnap) {\n            var seriesDataCount = getAxisInfo(axisModel).seriesDataCount;\n            var axisExtent = axis.getExtent();\n            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;\n          }\n\n          return false;\n        }\n\n        return animation === true;\n      };\n\n      BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {};\n\n      BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {\n        var pointerOption = elOption.pointer;\n\n        if (pointerOption) {\n          var pointerEl = inner$c(group).pointerEl = new graphic[pointerOption.type](clone$3(elOption.pointer));\n          group.add(pointerEl);\n        }\n      };\n\n      BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {\n        if (elOption.label) {\n          var labelEl = inner$c(group).labelEl = new ZRText(clone$3(elOption.label));\n          group.add(labelEl);\n          updateLabelShowHide(labelEl, axisPointerModel);\n        }\n      };\n\n      BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {\n        var pointerEl = inner$c(group).pointerEl;\n\n        if (pointerEl && elOption.pointer) {\n          pointerEl.setStyle(elOption.pointer.style);\n          updateProps(pointerEl, {\n            shape: elOption.pointer.shape\n          });\n        }\n      };\n\n      BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {\n        var labelEl = inner$c(group).labelEl;\n\n        if (labelEl) {\n          labelEl.setStyle(elOption.label.style);\n          updateProps(labelEl, {\n            x: elOption.label.x,\n            y: elOption.label.y\n          });\n          updateLabelShowHide(labelEl, axisPointerModel);\n        }\n      };\n\n      BaseAxisPointer.prototype._renderHandle = function (value) {\n        if (this._dragging || !this.updateHandleTransform) {\n          return;\n        }\n\n        var axisPointerModel = this._axisPointerModel;\n\n        var zr = this._api.getZr();\n\n        var handle = this._handle;\n        var handleModel = axisPointerModel.getModel('handle');\n        var status = axisPointerModel.get('status');\n\n        if (!handleModel.get('show') || !status || status === 'hide') {\n          handle && zr.remove(handle);\n          this._handle = null;\n          return;\n        }\n\n        var isInit;\n\n        if (!this._handle) {\n          isInit = true;\n          handle = this._handle = createIcon(handleModel.get('icon'), {\n            cursor: 'move',\n            draggable: true,\n            onmousemove: function (e) {\n              stop(e.event);\n            },\n            onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),\n            drift: bind$1(this._onHandleDragMove, this),\n            ondragend: bind$1(this._onHandleDragEnd, this)\n          });\n          zr.add(handle);\n        }\n\n        updateMandatoryProps(handle, axisPointerModel, false);\n        handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']));\n        var handleSize = handleModel.get('size');\n\n        if (!isArray(handleSize)) {\n          handleSize = [handleSize, handleSize];\n        }\n\n        handle.scaleX = handleSize[0] / 2;\n        handle.scaleY = handleSize[1] / 2;\n        createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');\n\n        this._moveHandleToValue(value, isInit);\n      };\n\n      BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {\n        updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));\n      };\n\n      BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {\n        var handle = this._handle;\n\n        if (!handle) {\n          return;\n        }\n\n        this._dragging = true;\n        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);\n        this._payloadInfo = trans;\n        handle.stopAnimation();\n        handle.attr(getHandleTransProps(trans));\n        inner$c(handle).lastProp = null;\n\n        this._doDispatchAxisPointer();\n      };\n\n      BaseAxisPointer.prototype._doDispatchAxisPointer = function () {\n        var handle = this._handle;\n\n        if (!handle) {\n          return;\n        }\n\n        var payloadInfo = this._payloadInfo;\n        var axisModel = this._axisModel;\n\n        this._api.dispatchAction({\n          type: 'updateAxisPointer',\n          x: payloadInfo.cursorPoint[0],\n          y: payloadInfo.cursorPoint[1],\n          tooltipOption: payloadInfo.tooltipOption,\n          axesInfo: [{\n            axisDim: axisModel.axis.dim,\n            axisIndex: axisModel.componentIndex\n          }]\n        });\n      };\n\n      BaseAxisPointer.prototype._onHandleDragEnd = function () {\n        this._dragging = false;\n        var handle = this._handle;\n\n        if (!handle) {\n          return;\n        }\n\n        var value = this._axisPointerModel.get('value');\n\n        this._moveHandleToValue(value);\n\n        this._api.dispatchAction({\n          type: 'hideTip'\n        });\n      };\n\n      BaseAxisPointer.prototype.clear = function (api) {\n        this._lastValue = null;\n        this._lastStatus = null;\n        var zr = api.getZr();\n        var group = this._group;\n        var handle = this._handle;\n\n        if (zr && group) {\n          this._lastGraphicKey = null;\n          group && zr.remove(group);\n          handle && zr.remove(handle);\n          this._group = null;\n          this._handle = null;\n          this._payloadInfo = null;\n        }\n      };\n\n      BaseAxisPointer.prototype.doClear = function () {};\n\n      BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {\n        xDimIndex = xDimIndex || 0;\n        return {\n          x: xy[xDimIndex],\n          y: xy[1 - xDimIndex],\n          width: wh[xDimIndex],\n          height: wh[1 - xDimIndex]\n        };\n      };\n\n      return BaseAxisPointer;\n    }();\n\n    function updateProps$1(animationModel, moveAnimation, el, props) {\n      if (!propsEqual(inner$c(el).lastProp, props)) {\n        inner$c(el).lastProp = props;\n        moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));\n      }\n    }\n\n    function propsEqual(lastProps, newProps) {\n      if (isObject(lastProps) && isObject(newProps)) {\n        var equals_1 = true;\n        each(newProps, function (item, key) {\n          equals_1 = equals_1 && propsEqual(lastProps[key], item);\n        });\n        return !!equals_1;\n      } else {\n        return lastProps === newProps;\n      }\n    }\n\n    function updateLabelShowHide(labelEl, axisPointerModel) {\n      labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']();\n    }\n\n    function getHandleTransProps(trans) {\n      return {\n        x: trans.x || 0,\n        y: trans.y || 0,\n        rotation: trans.rotation || 0\n      };\n    }\n\n    function updateMandatoryProps(group, axisPointerModel, silent) {\n      var z = axisPointerModel.get('z');\n      var zlevel = axisPointerModel.get('zlevel');\n      group && group.traverse(function (el) {\n        if (el.type !== 'group') {\n          z != null && (el.z = z);\n          zlevel != null && (el.zlevel = zlevel);\n          el.silent = silent;\n        }\n      });\n    }\n\n    function buildElStyle(axisPointerModel) {\n      var axisPointerType = axisPointerModel.get('type');\n      var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');\n      var style;\n\n      if (axisPointerType === 'line') {\n        style = styleModel.getLineStyle();\n        style.fill = null;\n      } else if (axisPointerType === 'shadow') {\n        style = styleModel.getAreaStyle();\n        style.stroke = null;\n      }\n\n      return style;\n    }\n    function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {\n      var value = axisPointerModel.get('value');\n      var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {\n        precision: axisPointerModel.get(['label', 'precision']),\n        formatter: axisPointerModel.get(['label', 'formatter'])\n      });\n      var labelModel = axisPointerModel.getModel('label');\n      var paddings = normalizeCssArray$1(labelModel.get('padding') || 0);\n      var font = labelModel.getFont();\n      var textRect = getBoundingRect(text, font);\n      var position = labelPos.position;\n      var width = textRect.width + paddings[1] + paddings[3];\n      var height = textRect.height + paddings[0] + paddings[2];\n      var align = labelPos.align;\n      align === 'right' && (position[0] -= width);\n      align === 'center' && (position[0] -= width / 2);\n      var verticalAlign = labelPos.verticalAlign;\n      verticalAlign === 'bottom' && (position[1] -= height);\n      verticalAlign === 'middle' && (position[1] -= height / 2);\n      confineInContainer(position, width, height, api);\n      var bgColor = labelModel.get('backgroundColor');\n\n      if (!bgColor || bgColor === 'auto') {\n        bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);\n      }\n\n      elOption.label = {\n        x: position[0],\n        y: position[1],\n        style: createTextStyle(labelModel, {\n          text: text,\n          font: font,\n          fill: labelModel.getTextColor(),\n          padding: paddings,\n          backgroundColor: bgColor\n        }),\n        z2: 10\n      };\n    }\n\n    function confineInContainer(position, width, height, api) {\n      var viewWidth = api.getWidth();\n      var viewHeight = api.getHeight();\n      position[0] = Math.min(position[0] + width, viewWidth) - width;\n      position[1] = Math.min(position[1] + height, viewHeight) - height;\n      position[0] = Math.max(position[0], 0);\n      position[1] = Math.max(position[1], 0);\n    }\n\n    function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {\n      value = axis.scale.parse(value);\n      var text = axis.scale.getLabel({\n        value: value\n      }, {\n        precision: opt.precision\n      });\n      var formatter = opt.formatter;\n\n      if (formatter) {\n        var params_1 = {\n          value: getAxisRawValue(axis, {\n            value: value\n          }),\n          axisDimension: axis.dim,\n          axisIndex: axis.index,\n          seriesData: []\n        };\n        each(seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var dataParams = series && series.getDataParams(dataIndex);\n          dataParams && params_1.seriesData.push(dataParams);\n        });\n\n        if (isString(formatter)) {\n          text = formatter.replace('{value}', text);\n        } else if (isFunction(formatter)) {\n          text = formatter(params_1);\n        }\n      }\n\n      return text;\n    }\n    function getTransformedPosition(axis, value, layoutInfo) {\n      var transform = create$1();\n      rotate(transform, transform, layoutInfo.rotation);\n      translate(transform, transform, layoutInfo.position);\n      return applyTransform$1([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);\n    }\n    function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {\n      var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);\n      layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);\n      buildLabelElOption(elOption, axisModel, axisPointerModel, api, {\n        position: getTransformedPosition(axisModel.axis, value, layoutInfo),\n        align: textLayout.textAlign,\n        verticalAlign: textLayout.textVerticalAlign\n      });\n    }\n    function makeLineShape(p1, p2, xDimIndex) {\n      xDimIndex = xDimIndex || 0;\n      return {\n        x1: p1[xDimIndex],\n        y1: p1[1 - xDimIndex],\n        x2: p2[xDimIndex],\n        y2: p2[1 - xDimIndex]\n      };\n    }\n    function makeRectShape(xy, wh, xDimIndex) {\n      xDimIndex = xDimIndex || 0;\n      return {\n        x: xy[xDimIndex],\n        y: xy[1 - xDimIndex],\n        width: wh[xDimIndex],\n        height: wh[1 - xDimIndex]\n      };\n    }\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n      return {\n        cx: cx,\n        cy: cy,\n        r0: r0,\n        r: r,\n        startAngle: startAngle,\n        endAngle: endAngle,\n        clockwise: true\n      };\n    }\n\n    var CartesianAxisPointer = function (_super) {\n      __extends(CartesianAxisPointer, _super);\n\n      function CartesianAxisPointer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n        var grid = axis.grid;\n        var axisPointerType = axisPointerModel.get('type');\n        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));\n\n        if (axisPointerType && axisPointerType !== 'none') {\n          var elStyle = buildElStyle(axisPointerModel);\n          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);\n          pointerOption.style = elStyle;\n          elOption.graphicKey = pointerOption.type;\n          elOption.pointer = pointerOption;\n        }\n\n        var layoutInfo = layout$1(grid.model, axisModel);\n        buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n      };\n\n      CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {\n        var layoutInfo = layout$1(axisModel.axis.grid.model, axisModel, {\n          labelInside: false\n        });\n        layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);\n        var pos = getTransformedPosition(axisModel.axis, value, layoutInfo);\n        return {\n          x: pos[0],\n          y: pos[1],\n          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n        };\n      };\n\n      CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {\n        var axis = axisModel.axis;\n        var grid = axis.grid;\n        var axisExtent = axis.getGlobalExtent(true);\n        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();\n        var dimIndex = axis.dim === 'x' ? 0 : 1;\n        var currPosition = [transform.x, transform.y];\n        currPosition[dimIndex] += delta[dimIndex];\n        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n        var cursorPoint = [cursorOtherValue, cursorOtherValue];\n        cursorPoint[dimIndex] = currPosition[dimIndex];\n        var tooltipOptions = [{\n          verticalAlign: 'middle'\n        }, {\n          align: 'center'\n        }];\n        return {\n          x: currPosition[0],\n          y: currPosition[1],\n          rotation: transform.rotation,\n          cursorPoint: cursorPoint,\n          tooltipOption: tooltipOptions[dimIndex]\n        };\n      };\n\n      return CartesianAxisPointer;\n    }(BaseAxisPointer);\n\n    function getCartesian(grid, axis) {\n      var opt = {};\n      opt[axis.dim + 'AxisIndex'] = axis.index;\n      return grid.getCartesian(opt);\n    }\n\n    var pointerShapeBuilder = {\n      line: function (axis, pixelValue, otherExtent) {\n        var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));\n        return {\n          type: 'Line',\n          subPixelOptimize: true,\n          shape: targetShape\n        };\n      },\n      shadow: function (axis, pixelValue, otherExtent) {\n        var bandWidth = Math.max(1, axis.getBandWidth());\n        var span = otherExtent[1] - otherExtent[0];\n        return {\n          type: 'Rect',\n          shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))\n        };\n      }\n    };\n\n    function getAxisDimIndex(axis) {\n      return axis.dim === 'x' ? 0 : 1;\n    }\n\n    var AxisPointerModel = function (_super) {\n      __extends(AxisPointerModel, _super);\n\n      function AxisPointerModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = AxisPointerModel.type;\n        return _this;\n      }\n\n      AxisPointerModel.type = 'axisPointer';\n      AxisPointerModel.defaultOption = {\n        show: 'auto',\n        zlevel: 0,\n        z: 50,\n        type: 'line',\n        snap: false,\n        triggerTooltip: true,\n        value: null,\n        status: null,\n        link: [],\n        animation: null,\n        animationDurationUpdate: 200,\n        lineStyle: {\n          color: '#B9BEC9',\n          width: 1,\n          type: 'dashed'\n        },\n        shadowStyle: {\n          color: 'rgba(210,219,238,0.2)'\n        },\n        label: {\n          show: true,\n          formatter: null,\n          precision: 'auto',\n          margin: 3,\n          color: '#fff',\n          padding: [5, 7, 5, 7],\n          backgroundColor: 'auto',\n          borderColor: null,\n          borderWidth: 0,\n          borderRadius: 3\n        },\n        handle: {\n          show: false,\n          icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',\n          size: 45,\n          margin: 50,\n          color: '#333',\n          shadowBlur: 3,\n          shadowColor: '#aaa',\n          shadowOffsetX: 0,\n          shadowOffsetY: 2,\n          throttle: 40\n        }\n      };\n      return AxisPointerModel;\n    }(ComponentModel);\n\n    var inner$d = makeInner();\n    var each$8 = each;\n    function register(key, api, handler) {\n      if (env.node) {\n        return;\n      }\n\n      var zr = api.getZr();\n      inner$d(zr).records || (inner$d(zr).records = {});\n      initGlobalListeners(zr, api);\n      var record = inner$d(zr).records[key] || (inner$d(zr).records[key] = {});\n      record.handler = handler;\n    }\n\n    function initGlobalListeners(zr, api) {\n      if (inner$d(zr).initialized) {\n        return;\n      }\n\n      inner$d(zr).initialized = true;\n      useHandler('click', curry(doEnter, 'click'));\n      useHandler('mousemove', curry(doEnter, 'mousemove'));\n      useHandler('globalout', onLeave);\n\n      function useHandler(eventType, cb) {\n        zr.on(eventType, function (e) {\n          var dis = makeDispatchAction(api);\n          each$8(inner$d(zr).records, function (record) {\n            record && cb(record, e, dis.dispatchAction);\n          });\n          dispatchTooltipFinally(dis.pendings, api);\n        });\n      }\n    }\n\n    function dispatchTooltipFinally(pendings, api) {\n      var showLen = pendings.showTip.length;\n      var hideLen = pendings.hideTip.length;\n      var actuallyPayload;\n\n      if (showLen) {\n        actuallyPayload = pendings.showTip[showLen - 1];\n      } else if (hideLen) {\n        actuallyPayload = pendings.hideTip[hideLen - 1];\n      }\n\n      if (actuallyPayload) {\n        actuallyPayload.dispatchAction = null;\n        api.dispatchAction(actuallyPayload);\n      }\n    }\n\n    function onLeave(record, e, dispatchAction) {\n      record.handler('leave', null, dispatchAction);\n    }\n\n    function doEnter(currTrigger, record, e, dispatchAction) {\n      record.handler(currTrigger, e, dispatchAction);\n    }\n\n    function makeDispatchAction(api) {\n      var pendings = {\n        showTip: [],\n        hideTip: []\n      };\n\n      var dispatchAction = function (payload) {\n        var pendingList = pendings[payload.type];\n\n        if (pendingList) {\n          pendingList.push(payload);\n        } else {\n          payload.dispatchAction = dispatchAction;\n          api.dispatchAction(payload);\n        }\n      };\n\n      return {\n        dispatchAction: dispatchAction,\n        pendings: pendings\n      };\n    }\n\n    function unregister(key, api) {\n      if (env.node) {\n        return;\n      }\n\n      var zr = api.getZr();\n      var record = (inner$d(zr).records || {})[key];\n\n      if (record) {\n        inner$d(zr).records[key] = null;\n      }\n    }\n\n    var AxisPointerView = function (_super) {\n      __extends(AxisPointerView, _super);\n\n      function AxisPointerView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = AxisPointerView.type;\n        return _this;\n      }\n\n      AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {\n        var globalTooltipModel = ecModel.getComponent('tooltip');\n        var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click';\n        register('axisPointer', api, function (currTrigger, e, dispatchAction) {\n          if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {\n            dispatchAction({\n              type: 'updateAxisPointer',\n              currTrigger: currTrigger,\n              x: e && e.offsetX,\n              y: e && e.offsetY\n            });\n          }\n        });\n      };\n\n      AxisPointerView.prototype.remove = function (ecModel, api) {\n        unregister('axisPointer', api);\n      };\n\n      AxisPointerView.prototype.dispose = function (ecModel, api) {\n        unregister('axisPointer', api);\n      };\n\n      AxisPointerView.type = 'axisPointer';\n      return AxisPointerView;\n    }(ComponentView);\n\n    function findPointFromSeries(finder, ecModel) {\n      var point = [];\n      var seriesIndex = finder.seriesIndex;\n      var seriesModel;\n\n      if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {\n        return {\n          point: []\n        };\n      }\n\n      var data = seriesModel.getData();\n      var dataIndex = queryDataIndex(data, finder);\n\n      if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {\n        return {\n          point: []\n        };\n      }\n\n      var el = data.getItemGraphicEl(dataIndex);\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (seriesModel.getTooltipPosition) {\n        point = seriesModel.getTooltipPosition(dataIndex) || [];\n      } else if (coordSys && coordSys.dataToPoint) {\n        if (finder.isStacked) {\n          var baseAxis = coordSys.getBaseAxis();\n          var valueAxis = coordSys.getOtherAxis(baseAxis);\n          var valueAxisDim = valueAxis.dim;\n          var baseAxisDim = baseAxis.dim;\n          var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n          var baseDim = data.mapDimension(baseAxisDim);\n          var stackedData = [];\n          stackedData[baseDataOffset] = data.get(baseDim, dataIndex);\n          stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo('stackResultDimension'), dataIndex);\n          point = coordSys.dataToPoint(stackedData) || [];\n        } else {\n          point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function (dim) {\n            return data.mapDimension(dim);\n          }), dataIndex)) || [];\n        }\n      } else if (el) {\n        var rect = el.getBoundingRect().clone();\n        rect.applyTransform(el.transform);\n        point = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n      }\n\n      return {\n        point: point,\n        el: el\n      };\n    }\n\n    var inner$e = makeInner();\n    function axisTrigger(payload, ecModel, api) {\n      var currTrigger = payload.currTrigger;\n      var point = [payload.x, payload.y];\n      var finder = payload;\n      var dispatchAction = payload.dispatchAction || bind(api.dispatchAction, api);\n      var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n      if (!coordSysAxesInfo) {\n        return;\n      }\n\n      if (illegalPoint(point)) {\n        point = findPointFromSeries({\n          seriesIndex: finder.seriesIndex,\n          dataIndex: finder.dataIndex\n        }, ecModel).point;\n      }\n\n      var isIllegalPoint = illegalPoint(point);\n      var inputAxesInfo = finder.axesInfo;\n      var axesInfo = coordSysAxesInfo.axesInfo;\n      var shouldHide = currTrigger === 'leave' || illegalPoint(point);\n      var outputPayload = {};\n      var showValueMap = {};\n      var dataByCoordSys = {\n        list: [],\n        map: {}\n      };\n      var updaters = {\n        showPointer: curry(showPointer, showValueMap),\n        showTooltip: curry(showTooltip, dataByCoordSys)\n      };\n      each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {\n        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);\n        each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {\n          var axis = axisInfo.axis;\n          var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);\n\n          if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {\n            var val = inputAxisInfo && inputAxisInfo.value;\n\n            if (val == null && !isIllegalPoint) {\n              val = axis.pointToData(point);\n            }\n\n            val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);\n          }\n        });\n      });\n      var linkTriggers = {};\n      each(axesInfo, function (tarAxisInfo, tarKey) {\n        var linkGroup = tarAxisInfo.linkGroup;\n\n        if (linkGroup && !showValueMap[tarKey]) {\n          each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {\n            var srcValItem = showValueMap[srcKey];\n\n            if (srcAxisInfo !== tarAxisInfo && srcValItem) {\n              var val = srcValItem.value;\n              linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));\n              linkTriggers[tarAxisInfo.key] = val;\n            }\n          });\n        }\n      });\n      each(linkTriggers, function (val, tarKey) {\n        processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);\n      });\n      updateModelActually(showValueMap, axesInfo, outputPayload);\n      dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);\n      dispatchHighDownActually(axesInfo, dispatchAction, api);\n      return outputPayload;\n    }\n\n    function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {\n      var axis = axisInfo.axis;\n\n      if (axis.scale.isBlank() || !axis.containData(newValue)) {\n        return;\n      }\n\n      if (!axisInfo.involveSeries) {\n        updaters.showPointer(axisInfo, newValue);\n        return;\n      }\n\n      var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);\n      var payloadBatch = payloadInfo.payloadBatch;\n      var snapToValue = payloadInfo.snapToValue;\n\n      if (payloadBatch[0] && outputFinder.seriesIndex == null) {\n        extend(outputFinder, payloadBatch[0]);\n      }\n\n      if (!noSnap && axisInfo.snap) {\n        if (axis.containData(snapToValue) && snapToValue != null) {\n          newValue = snapToValue;\n        }\n      }\n\n      updaters.showPointer(axisInfo, newValue, payloadBatch);\n      updaters.showTooltip(axisInfo, payloadInfo, snapToValue);\n    }\n\n    function buildPayloadsBySeries(value, axisInfo) {\n      var axis = axisInfo.axis;\n      var dim = axis.dim;\n      var snapToValue = value;\n      var payloadBatch = [];\n      var minDist = Number.MAX_VALUE;\n      var minDiff = -1;\n      each(axisInfo.seriesModels, function (series, idx) {\n        var dataDim = series.getData().mapDimensionsAll(dim);\n        var seriesNestestValue;\n        var dataIndices;\n\n        if (series.getAxisTooltipData) {\n          var result = series.getAxisTooltipData(dataDim, value, axis);\n          dataIndices = result.dataIndices;\n          seriesNestestValue = result.nestestValue;\n        } else {\n          dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === 'category' ? 0.5 : null);\n\n          if (!dataIndices.length) {\n            return;\n          }\n\n          seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);\n        }\n\n        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {\n          return;\n        }\n\n        var diff = value - seriesNestestValue;\n        var dist = Math.abs(diff);\n\n        if (dist <= minDist) {\n          if (dist < minDist || diff >= 0 && minDiff < 0) {\n            minDist = dist;\n            minDiff = diff;\n            snapToValue = seriesNestestValue;\n            payloadBatch.length = 0;\n          }\n\n          each(dataIndices, function (dataIndex) {\n            payloadBatch.push({\n              seriesIndex: series.seriesIndex,\n              dataIndexInside: dataIndex,\n              dataIndex: series.getData().getRawIndex(dataIndex)\n            });\n          });\n        }\n      });\n      return {\n        payloadBatch: payloadBatch,\n        snapToValue: snapToValue\n      };\n    }\n\n    function showPointer(showValueMap, axisInfo, value, payloadBatch) {\n      showValueMap[axisInfo.key] = {\n        value: value,\n        payloadBatch: payloadBatch\n      };\n    }\n\n    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {\n      var payloadBatch = payloadInfo.payloadBatch;\n      var axis = axisInfo.axis;\n      var axisModel = axis.model;\n      var axisPointerModel = axisInfo.axisPointerModel;\n\n      if (!axisInfo.triggerTooltip || !payloadBatch.length) {\n        return;\n      }\n\n      var coordSysModel = axisInfo.coordSys.model;\n      var coordSysKey = makeKey(coordSysModel);\n      var coordSysItem = dataByCoordSys.map[coordSysKey];\n\n      if (!coordSysItem) {\n        coordSysItem = dataByCoordSys.map[coordSysKey] = {\n          coordSysId: coordSysModel.id,\n          coordSysIndex: coordSysModel.componentIndex,\n          coordSysType: coordSysModel.type,\n          coordSysMainType: coordSysModel.mainType,\n          dataByAxis: []\n        };\n        dataByCoordSys.list.push(coordSysItem);\n      }\n\n      coordSysItem.dataByAxis.push({\n        axisDim: axis.dim,\n        axisIndex: axisModel.componentIndex,\n        axisType: axisModel.type,\n        axisId: axisModel.id,\n        value: value,\n        valueLabelOpt: {\n          precision: axisPointerModel.get(['label', 'precision']),\n          formatter: axisPointerModel.get(['label', 'formatter'])\n        },\n        seriesDataIndices: payloadBatch.slice()\n      });\n    }\n\n    function updateModelActually(showValueMap, axesInfo, outputPayload) {\n      var outputAxesInfo = outputPayload.axesInfo = [];\n      each(axesInfo, function (axisInfo, key) {\n        var option = axisInfo.axisPointerModel.option;\n        var valItem = showValueMap[key];\n\n        if (valItem) {\n          !axisInfo.useHandle && (option.status = 'show');\n          option.value = valItem.value;\n          option.seriesDataIndices = (valItem.payloadBatch || []).slice();\n        } else {\n          !axisInfo.useHandle && (option.status = 'hide');\n        }\n\n        option.status === 'show' && outputAxesInfo.push({\n          axisDim: axisInfo.axis.dim,\n          axisIndex: axisInfo.axis.model.componentIndex,\n          value: option.value\n        });\n      });\n    }\n\n    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {\n      if (illegalPoint(point) || !dataByCoordSys.list.length) {\n        dispatchAction({\n          type: 'hideTip'\n        });\n        return;\n      }\n\n      var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};\n      dispatchAction({\n        type: 'showTip',\n        escapeConnect: true,\n        x: point[0],\n        y: point[1],\n        tooltipOption: payload.tooltipOption,\n        position: payload.position,\n        dataIndexInside: sampleItem.dataIndexInside,\n        dataIndex: sampleItem.dataIndex,\n        seriesIndex: sampleItem.seriesIndex,\n        dataByCoordSys: dataByCoordSys.list\n      });\n    }\n\n    function dispatchHighDownActually(axesInfo, dispatchAction, api) {\n      var zr = api.getZr();\n      var highDownKey = 'axisPointerLastHighlights';\n      var lastHighlights = inner$e(zr)[highDownKey] || {};\n      var newHighlights = inner$e(zr)[highDownKey] = {};\n      each(axesInfo, function (axisInfo, key) {\n        var option = axisInfo.axisPointerModel.option;\n        option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {\n          var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;\n          newHighlights[key] = batchItem;\n        });\n      });\n      var toHighlight = [];\n      var toDownplay = [];\n      each(lastHighlights, function (batchItem, key) {\n        !newHighlights[key] && toDownplay.push(batchItem);\n      });\n      each(newHighlights, function (batchItem, key) {\n        !lastHighlights[key] && toHighlight.push(batchItem);\n      });\n      toDownplay.length && api.dispatchAction({\n        type: 'downplay',\n        escapeConnect: true,\n        notBlur: true,\n        batch: toDownplay\n      });\n      toHighlight.length && api.dispatchAction({\n        type: 'highlight',\n        escapeConnect: true,\n        notBlur: true,\n        batch: toHighlight\n      });\n    }\n\n    function findInputAxisInfo(inputAxesInfo, axisInfo) {\n      for (var i = 0; i < (inputAxesInfo || []).length; i++) {\n        var inputAxisInfo = inputAxesInfo[i];\n\n        if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {\n          return inputAxisInfo;\n        }\n      }\n    }\n\n    function makeMapperParam(axisInfo) {\n      var axisModel = axisInfo.axis.model;\n      var item = {};\n      var dim = item.axisDim = axisInfo.axis.dim;\n      item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;\n      item.axisName = item[dim + 'AxisName'] = axisModel.name;\n      item.axisId = item[dim + 'AxisId'] = axisModel.id;\n      return item;\n    }\n\n    function illegalPoint(point) {\n      return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);\n    }\n\n    function install$r(registers) {\n      AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);\n      registers.registerComponentModel(AxisPointerModel);\n      registers.registerComponentView(AxisPointerView);\n      registers.registerPreprocessor(function (option) {\n        if (option) {\n          (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});\n          var link = option.axisPointer.link;\n\n          if (link && !isArray(link)) {\n            option.axisPointer.link = [link];\n          }\n        }\n      });\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {\n        ecModel.getComponent('axisPointer').coordSysAxesInfo = collect(ecModel, api);\n      });\n      registers.registerAction({\n        type: 'updateAxisPointer',\n        event: 'updateAxisPointer',\n        update: ':updateAxisPointer'\n      }, axisTrigger);\n    }\n\n    function install$s(registers) {\n      use(install$5);\n      use(install$r);\n    }\n\n    var PolarAxisPointer = function (_super) {\n      __extends(PolarAxisPointer, _super);\n\n      function PolarAxisPointer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      PolarAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n\n        if (axis.dim === 'angle') {\n          this.animationThreshold = Math.PI / 18;\n        }\n\n        var polar = axis.polar;\n        var otherAxis = polar.getOtherAxis(axis);\n        var otherExtent = otherAxis.getExtent();\n        var coordValue = axis.dataToCoord(value);\n        var axisPointerType = axisPointerModel.get('type');\n\n        if (axisPointerType && axisPointerType !== 'none') {\n          var elStyle = buildElStyle(axisPointerModel);\n          var pointerOption = pointerShapeBuilder$1[axisPointerType](axis, polar, coordValue, otherExtent);\n          pointerOption.style = elStyle;\n          elOption.graphicKey = pointerOption.type;\n          elOption.pointer = pointerOption;\n        }\n\n        var labelMargin = axisPointerModel.get(['label', 'margin']);\n        var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);\n        buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);\n      };\n\n      return PolarAxisPointer;\n    }(BaseAxisPointer);\n\n    function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {\n      var axis = axisModel.axis;\n      var coord = axis.dataToCoord(value);\n      var axisAngle = polar.getAngleAxis().getExtent()[0];\n      axisAngle = axisAngle / 180 * Math.PI;\n      var radiusExtent = polar.getRadiusAxis().getExtent();\n      var position;\n      var align;\n      var verticalAlign;\n\n      if (axis.dim === 'radius') {\n        var transform = create$1();\n        rotate(transform, transform, axisAngle);\n        translate(transform, transform, [polar.cx, polar.cy]);\n        position = applyTransform$1([coord, -labelMargin], transform);\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0;\n        var labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);\n        align = labelLayout.textAlign;\n        verticalAlign = labelLayout.textVerticalAlign;\n      } else {\n        var r = radiusExtent[1];\n        position = polar.coordToPoint([r + labelMargin, coord]);\n        var cx = polar.cx;\n        var cy = polar.cy;\n        align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right';\n        verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom';\n      }\n\n      return {\n        position: position,\n        align: align,\n        verticalAlign: verticalAlign\n      };\n    }\n\n    var pointerShapeBuilder$1 = {\n      line: function (axis, polar, coordValue, otherExtent) {\n        return axis.dim === 'angle' ? {\n          type: 'Line',\n          shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))\n        } : {\n          type: 'Circle',\n          shape: {\n            cx: polar.cx,\n            cy: polar.cy,\n            r: coordValue\n          }\n        };\n      },\n      shadow: function (axis, polar, coordValue, otherExtent) {\n        var bandWidth = Math.max(1, axis.getBandWidth());\n        var radian = Math.PI / 180;\n        return axis.dim === 'angle' ? {\n          type: 'Sector',\n          shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)\n        } : {\n          type: 'Sector',\n          shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)\n        };\n      }\n    };\n\n    var PolarModel = function (_super) {\n      __extends(PolarModel, _super);\n\n      function PolarModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PolarModel.type;\n        return _this;\n      }\n\n      PolarModel.prototype.findAxisModel = function (axisType) {\n        var foundAxisModel;\n        var ecModel = this.ecModel;\n        ecModel.eachComponent(axisType, function (axisModel) {\n          if (axisModel.getCoordSysModel() === this) {\n            foundAxisModel = axisModel;\n          }\n        }, this);\n        return foundAxisModel;\n      };\n\n      PolarModel.type = 'polar';\n      PolarModel.dependencies = ['radiusAxis', 'angleAxis'];\n      PolarModel.defaultOption = {\n        zlevel: 0,\n        z: 0,\n        center: ['50%', '50%'],\n        radius: '80%'\n      };\n      return PolarModel;\n    }(ComponentModel);\n\n    var PolarAxisModel = function (_super) {\n      __extends(PolarAxisModel, _super);\n\n      function PolarAxisModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      PolarAxisModel.prototype.getCoordSysModel = function () {\n        return this.getReferringComponents('polar', SINGLE_REFERRING).models[0];\n      };\n\n      PolarAxisModel.type = 'polarAxis';\n      return PolarAxisModel;\n    }(ComponentModel);\n\n    mixin(PolarAxisModel, AxisModelCommonMixin);\n\n    var AngleAxisModel = function (_super) {\n      __extends(AngleAxisModel, _super);\n\n      function AngleAxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = AngleAxisModel.type;\n        return _this;\n      }\n\n      AngleAxisModel.type = 'angleAxis';\n      return AngleAxisModel;\n    }(PolarAxisModel);\n\n    var RadiusAxisModel = function (_super) {\n      __extends(RadiusAxisModel, _super);\n\n      function RadiusAxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadiusAxisModel.type;\n        return _this;\n      }\n\n      RadiusAxisModel.type = 'radiusAxis';\n      return RadiusAxisModel;\n    }(PolarAxisModel);\n\n    var RadiusAxis = function (_super) {\n      __extends(RadiusAxis, _super);\n\n      function RadiusAxis(scale, radiusExtent) {\n        return _super.call(this, 'radius', scale, radiusExtent) || this;\n      }\n\n      RadiusAxis.prototype.pointToData = function (point, clamp) {\n        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n      };\n\n      return RadiusAxis;\n    }(Axis);\n\n    RadiusAxis.prototype.dataToRadius = Axis.prototype.dataToCoord;\n    RadiusAxis.prototype.radiusToData = Axis.prototype.coordToData;\n\n    var inner$f = makeInner();\n\n    var AngleAxis = function (_super) {\n      __extends(AngleAxis, _super);\n\n      function AngleAxis(scale, angleExtent) {\n        return _super.call(this, 'angle', scale, angleExtent || [0, 360]) || this;\n      }\n\n      AngleAxis.prototype.pointToData = function (point, clamp) {\n        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1];\n      };\n\n      AngleAxis.prototype.calculateCategoryInterval = function () {\n        var axis = this;\n        var labelModel = axis.getLabelModel();\n        var ordinalScale = axis.scale;\n        var ordinalExtent = ordinalScale.getExtent();\n        var tickCount = ordinalScale.count();\n\n        if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n          return 0;\n        }\n\n        var tickValue = ordinalExtent[0];\n        var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n        var unitH = Math.abs(unitSpan);\n        var rect = getBoundingRect(tickValue == null ? '' : tickValue + '', labelModel.getFont(), 'center', 'top');\n        var maxH = Math.max(rect.height, 7);\n        var dh = maxH / unitH;\n        isNaN(dh) && (dh = Infinity);\n        var interval = Math.max(0, Math.floor(dh));\n        var cache = inner$f(axis.model);\n        var lastAutoInterval = cache.lastAutoInterval;\n        var lastTickCount = cache.lastTickCount;\n\n        if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {\n          interval = lastAutoInterval;\n        } else {\n          cache.lastTickCount = tickCount;\n          cache.lastAutoInterval = interval;\n        }\n\n        return interval;\n      };\n\n      return AngleAxis;\n    }(Axis);\n\n    AngleAxis.prototype.dataToAngle = Axis.prototype.dataToCoord;\n    AngleAxis.prototype.angleToData = Axis.prototype.coordToData;\n\n    var Polar = function () {\n      function Polar(name) {\n        this.dimensions = ['radius', 'angle'];\n        this.type = 'polar';\n        this.cx = 0;\n        this.cy = 0;\n        this._radiusAxis = new RadiusAxis();\n        this._angleAxis = new AngleAxis();\n        this.axisPointerEnabled = true;\n        this.name = name || '';\n        this._radiusAxis.polar = this._angleAxis.polar = this;\n      }\n\n      Polar.prototype.containPoint = function (point) {\n        var coord = this.pointToCoord(point);\n        return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);\n      };\n\n      Polar.prototype.containData = function (data) {\n        return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);\n      };\n\n      Polar.prototype.getAxis = function (dim) {\n        var key = '_' + dim + 'Axis';\n        return this[key];\n      };\n\n      Polar.prototype.getAxes = function () {\n        return [this._radiusAxis, this._angleAxis];\n      };\n\n      Polar.prototype.getAxesByScale = function (scaleType) {\n        var axes = [];\n        var angleAxis = this._angleAxis;\n        var radiusAxis = this._radiusAxis;\n        angleAxis.scale.type === scaleType && axes.push(angleAxis);\n        radiusAxis.scale.type === scaleType && axes.push(radiusAxis);\n        return axes;\n      };\n\n      Polar.prototype.getAngleAxis = function () {\n        return this._angleAxis;\n      };\n\n      Polar.prototype.getRadiusAxis = function () {\n        return this._radiusAxis;\n      };\n\n      Polar.prototype.getOtherAxis = function (axis) {\n        var angleAxis = this._angleAxis;\n        return axis === angleAxis ? this._radiusAxis : angleAxis;\n      };\n\n      Polar.prototype.getBaseAxis = function () {\n        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();\n      };\n\n      Polar.prototype.getTooltipAxes = function (dim) {\n        var baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis();\n        return {\n          baseAxes: [baseAxis],\n          otherAxes: [this.getOtherAxis(baseAxis)]\n        };\n      };\n\n      Polar.prototype.dataToPoint = function (data, clamp) {\n        return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);\n      };\n\n      Polar.prototype.pointToData = function (point, clamp) {\n        var coord = this.pointToCoord(point);\n        return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];\n      };\n\n      Polar.prototype.pointToCoord = function (point) {\n        var dx = point[0] - this.cx;\n        var dy = point[1] - this.cy;\n        var angleAxis = this.getAngleAxis();\n        var extent = angleAxis.getExtent();\n        var minAngle = Math.min(extent[0], extent[1]);\n        var maxAngle = Math.max(extent[0], extent[1]);\n        angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        dx /= radius;\n        dy /= radius;\n        var radian = Math.atan2(-dy, dx) / Math.PI * 180;\n        var dir = radian < minAngle ? 1 : -1;\n\n        while (radian < minAngle || radian > maxAngle) {\n          radian += dir * 360;\n        }\n\n        return [radius, radian];\n      };\n\n      Polar.prototype.coordToPoint = function (coord) {\n        var radius = coord[0];\n        var radian = coord[1] / 180 * Math.PI;\n        var x = Math.cos(radian) * radius + this.cx;\n        var y = -Math.sin(radian) * radius + this.cy;\n        return [x, y];\n      };\n\n      Polar.prototype.getArea = function () {\n        var angleAxis = this.getAngleAxis();\n        var radiusAxis = this.getRadiusAxis();\n        var radiusExtent = radiusAxis.getExtent().slice();\n        radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n        var angleExtent = angleAxis.getExtent();\n        var RADIAN = Math.PI / 180;\n        return {\n          cx: this.cx,\n          cy: this.cy,\n          r0: radiusExtent[0],\n          r: radiusExtent[1],\n          startAngle: -angleExtent[0] * RADIAN,\n          endAngle: -angleExtent[1] * RADIAN,\n          clockwise: angleAxis.inverse,\n          contain: function (x, y) {\n            var dx = x - this.cx;\n            var dy = y - this.cy;\n            var d2 = dx * dx + dy * dy;\n            var r = this.r;\n            var r0 = this.r0;\n            return d2 <= r * r && d2 >= r0 * r0;\n          }\n        };\n      };\n\n      Polar.prototype.convertToPixel = function (ecModel, finder, value) {\n        var coordSys = getCoordSys$1(finder);\n        return coordSys === this ? this.dataToPoint(value) : null;\n      };\n\n      Polar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        var coordSys = getCoordSys$1(finder);\n        return coordSys === this ? this.pointToData(pixel) : null;\n      };\n\n      return Polar;\n    }();\n\n    function getCoordSys$1(finder) {\n      var seriesModel = finder.seriesModel;\n      var polarModel = finder.polarModel;\n      return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;\n    }\n\n    function resizePolar(polar, polarModel, api) {\n      var center = polarModel.get('center');\n      var width = api.getWidth();\n      var height = api.getHeight();\n      polar.cx = parsePercent$1(center[0], width);\n      polar.cy = parsePercent$1(center[1], height);\n      var radiusAxis = polar.getRadiusAxis();\n      var size = Math.min(width, height) / 2;\n      var radius = polarModel.get('radius');\n\n      if (radius == null) {\n        radius = [0, '100%'];\n      } else if (!isArray(radius)) {\n        radius = [0, radius];\n      }\n\n      var parsedRadius = [parsePercent$1(radius[0], size), parsePercent$1(radius[1], size)];\n      radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);\n    }\n\n    function updatePolarScale(ecModel, api) {\n      var polar = this;\n      var angleAxis = polar.getAngleAxis();\n      var radiusAxis = polar.getRadiusAxis();\n      angleAxis.scale.setExtent(Infinity, -Infinity);\n      radiusAxis.scale.setExtent(Infinity, -Infinity);\n      ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.coordinateSystem === polar) {\n          var data_1 = seriesModel.getData();\n          each(getDataDimensionsOnAxis(data_1, 'radius'), function (dim) {\n            radiusAxis.scale.unionExtentFromData(data_1, dim);\n          });\n          each(getDataDimensionsOnAxis(data_1, 'angle'), function (dim) {\n            angleAxis.scale.unionExtentFromData(data_1, dim);\n          });\n        }\n      });\n      niceScaleExtent(angleAxis.scale, angleAxis.model);\n      niceScaleExtent(radiusAxis.scale, radiusAxis.model);\n\n      if (angleAxis.type === 'category' && !angleAxis.onBand) {\n        var extent = angleAxis.getExtent();\n        var diff = 360 / angleAxis.scale.count();\n        angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;\n        angleAxis.setExtent(extent[0], extent[1]);\n      }\n    }\n\n    function isAngleAxisModel(axisModel) {\n      return axisModel.mainType === 'angleAxis';\n    }\n\n    function setAxis(axis, axisModel) {\n      axis.type = axisModel.get('type');\n      axis.scale = createScaleByModel(axisModel);\n      axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';\n      axis.inverse = axisModel.get('inverse');\n\n      if (isAngleAxisModel(axisModel)) {\n        axis.inverse = axis.inverse !== axisModel.get('clockwise');\n        var startAngle = axisModel.get('startAngle');\n        axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));\n      }\n\n      axisModel.axis = axis;\n      axis.model = axisModel;\n    }\n\n    var polarCreator = {\n      dimensions: Polar.prototype.dimensions,\n      create: function (ecModel, api) {\n        var polarList = [];\n        ecModel.eachComponent('polar', function (polarModel, idx) {\n          var polar = new Polar(idx + '');\n          polar.update = updatePolarScale;\n          var radiusAxis = polar.getRadiusAxis();\n          var angleAxis = polar.getAngleAxis();\n          var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n          var angleAxisModel = polarModel.findAxisModel('angleAxis');\n          setAxis(radiusAxis, radiusAxisModel);\n          setAxis(angleAxis, angleAxisModel);\n          resizePolar(polar, polarModel, api);\n          polarList.push(polar);\n          polarModel.coordinateSystem = polar;\n          polar.model = polarModel;\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          if (seriesModel.get('coordinateSystem') === 'polar') {\n            var polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0];\n\n            if (\"development\" !== 'production') {\n              if (!polarModel) {\n                throw new Error('Polar \"' + retrieve(seriesModel.get('polarIndex'), seriesModel.get('polarId'), 0) + '\" not found');\n              }\n            }\n\n            seriesModel.coordinateSystem = polarModel.coordinateSystem;\n          }\n        });\n        return polarList;\n      }\n    };\n\n    var elementList$1 = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea'];\n\n    function getAxisLineShape(polar, rExtent, angle) {\n      rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());\n      var start = polar.coordToPoint([rExtent[0], angle]);\n      var end = polar.coordToPoint([rExtent[1], angle]);\n      return {\n        x1: start[0],\n        y1: start[1],\n        x2: end[0],\n        y2: end[1]\n      };\n    }\n\n    function getRadiusIdx(polar) {\n      var radiusAxis = polar.getRadiusAxis();\n      return radiusAxis.inverse ? 0 : 1;\n    }\n\n    function fixAngleOverlap(list) {\n      var firstItem = list[0];\n      var lastItem = list[list.length - 1];\n\n      if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {\n        list.pop();\n      }\n    }\n\n    var AngleAxisView = function (_super) {\n      __extends(AngleAxisView, _super);\n\n      function AngleAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = AngleAxisView.type;\n        _this.axisPointerClass = 'PolarAxisPointer';\n        return _this;\n      }\n\n      AngleAxisView.prototype.render = function (angleAxisModel, ecModel) {\n        this.group.removeAll();\n\n        if (!angleAxisModel.get('show')) {\n          return;\n        }\n\n        var angleAxis = angleAxisModel.axis;\n        var polar = angleAxis.polar;\n        var radiusExtent = polar.getRadiusAxis().getExtent();\n        var ticksAngles = angleAxis.getTicksCoords();\n        var minorTickAngles = angleAxis.getMinorTicksCoords();\n        var labels = map(angleAxis.getViewLabels(), function (labelItem) {\n          labelItem = clone(labelItem);\n          var scale = angleAxis.scale;\n          var tickValue = scale.type === 'ordinal' ? scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;\n          labelItem.coord = angleAxis.dataToCoord(tickValue);\n          return labelItem;\n        });\n        fixAngleOverlap(labels);\n        fixAngleOverlap(ticksAngles);\n        each(elementList$1, function (name) {\n          if (angleAxisModel.get([name, 'show']) && (!angleAxis.scale.isBlank() || name === 'axisLine')) {\n            angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);\n          }\n        }, this);\n      };\n\n      AngleAxisView.type = 'angleAxis';\n      return AngleAxisView;\n    }(AxisView);\n\n    var angelAxisElementsBuilders = {\n      axisLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n        var lineStyleModel = angleAxisModel.getModel(['axisLine', 'lineStyle']);\n        var rId = getRadiusIdx(polar);\n        var r0Id = rId ? 0 : 1;\n        var shape;\n\n        if (radiusExtent[r0Id] === 0) {\n          shape = new Circle({\n            shape: {\n              cx: polar.cx,\n              cy: polar.cy,\n              r: radiusExtent[rId]\n            },\n            style: lineStyleModel.getLineStyle(),\n            z2: 1,\n            silent: true\n          });\n        } else {\n          shape = new Ring({\n            shape: {\n              cx: polar.cx,\n              cy: polar.cy,\n              r: radiusExtent[rId],\n              r0: radiusExtent[r0Id]\n            },\n            style: lineStyleModel.getLineStyle(),\n            z2: 1,\n            silent: true\n          });\n        }\n\n        shape.style.fill = null;\n        group.add(shape);\n      },\n      axisTick: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n        var tickModel = angleAxisModel.getModel('axisTick');\n        var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');\n        var radius = radiusExtent[getRadiusIdx(polar)];\n        var lines = map(ticksAngles, function (tickAngleItem) {\n          return new Line({\n            shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)\n          });\n        });\n        group.add(mergePath$1(lines, {\n          style: defaults(tickModel.getModel('lineStyle').getLineStyle(), {\n            stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n          })\n        }));\n      },\n      minorTick: function (group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {\n        if (!minorTickAngles.length) {\n          return;\n        }\n\n        var tickModel = angleAxisModel.getModel('axisTick');\n        var minorTickModel = angleAxisModel.getModel('minorTick');\n        var tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length');\n        var radius = radiusExtent[getRadiusIdx(polar)];\n        var lines = [];\n\n        for (var i = 0; i < minorTickAngles.length; i++) {\n          for (var k = 0; k < minorTickAngles[i].length; k++) {\n            lines.push(new Line({\n              shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)\n            }));\n          }\n        }\n\n        group.add(mergePath$1(lines, {\n          style: defaults(minorTickModel.getModel('lineStyle').getLineStyle(), defaults(tickModel.getLineStyle(), {\n            stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])\n          }))\n        }));\n      },\n      axisLabel: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {\n        var rawCategoryData = angleAxisModel.getCategories(true);\n        var commonLabelModel = angleAxisModel.getModel('axisLabel');\n        var labelMargin = commonLabelModel.get('margin');\n        var triggerEvent = angleAxisModel.get('triggerEvent');\n        each(labels, function (labelItem, idx) {\n          var labelModel = commonLabelModel;\n          var tickValue = labelItem.tickValue;\n          var r = radiusExtent[getRadiusIdx(polar)];\n          var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);\n          var cx = polar.cx;\n          var cy = polar.cy;\n          var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';\n          var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';\n\n          if (rawCategoryData && rawCategoryData[tickValue]) {\n            var rawCategoryItem = rawCategoryData[tickValue];\n\n            if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n              labelModel = new Model(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);\n            }\n          }\n\n          var textEl = new ZRText({\n            silent: AxisBuilder.isLabelSilent(angleAxisModel),\n            style: createTextStyle(labelModel, {\n              x: p[0],\n              y: p[1],\n              fill: labelModel.getTextColor() || angleAxisModel.get(['axisLine', 'lineStyle', 'color']),\n              text: labelItem.formattedLabel,\n              align: labelTextAlign,\n              verticalAlign: labelTextVerticalAlign\n            })\n          });\n          group.add(textEl);\n\n          if (triggerEvent) {\n            var eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);\n            eventData.targetType = 'axisLabel';\n            eventData.value = labelItem.rawLabel;\n            getECData(textEl).eventData = eventData;\n          }\n        }, this);\n      },\n      splitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n        var splitLineModel = angleAxisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        var lineCount = 0;\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n        var splitLines = [];\n\n        for (var i = 0; i < ticksAngles.length; i++) {\n          var colorIndex = lineCount++ % lineColors.length;\n          splitLines[colorIndex] = splitLines[colorIndex] || [];\n          splitLines[colorIndex].push(new Line({\n            shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)\n          }));\n        }\n\n        for (var i = 0; i < splitLines.length; i++) {\n          group.add(mergePath$1(splitLines[i], {\n            style: defaults({\n              stroke: lineColors[i % lineColors.length]\n            }, lineStyleModel.getLineStyle()),\n            silent: true,\n            z: angleAxisModel.get('z')\n          }));\n        }\n      },\n      minorSplitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n        if (!minorTickAngles.length) {\n          return;\n        }\n\n        var minorSplitLineModel = angleAxisModel.getModel('minorSplitLine');\n        var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n        var lines = [];\n\n        for (var i = 0; i < minorTickAngles.length; i++) {\n          for (var k = 0; k < minorTickAngles[i].length; k++) {\n            lines.push(new Line({\n              shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)\n            }));\n          }\n        }\n\n        group.add(mergePath$1(lines, {\n          style: lineStyleModel.getLineStyle(),\n          silent: true,\n          z: angleAxisModel.get('z')\n        }));\n      },\n      splitArea: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {\n        if (!ticksAngles.length) {\n          return;\n        }\n\n        var splitAreaModel = angleAxisModel.getModel('splitArea');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var areaColors = areaStyleModel.get('color');\n        var lineCount = 0;\n        areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n        var splitAreas = [];\n        var RADIAN = Math.PI / 180;\n        var prevAngle = -ticksAngles[0].coord * RADIAN;\n        var r0 = Math.min(radiusExtent[0], radiusExtent[1]);\n        var r1 = Math.max(radiusExtent[0], radiusExtent[1]);\n        var clockwise = angleAxisModel.get('clockwise');\n\n        for (var i = 1, len = ticksAngles.length; i <= len; i++) {\n          var coord = i === len ? ticksAngles[0].coord : ticksAngles[i].coord;\n          var colorIndex = lineCount++ % areaColors.length;\n          splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n          splitAreas[colorIndex].push(new Sector({\n            shape: {\n              cx: polar.cx,\n              cy: polar.cy,\n              r0: r0,\n              r: r1,\n              startAngle: prevAngle,\n              endAngle: -coord * RADIAN,\n              clockwise: clockwise\n            },\n            silent: true\n          }));\n          prevAngle = -coord * RADIAN;\n        }\n\n        for (var i = 0; i < splitAreas.length; i++) {\n          group.add(mergePath$1(splitAreas[i], {\n            style: defaults({\n              fill: areaColors[i % areaColors.length]\n            }, areaStyleModel.getAreaStyle()),\n            silent: true\n          }));\n        }\n      }\n    };\n\n    var axisBuilderAttrs$2 = ['axisLine', 'axisTickLabel', 'axisName'];\n    var selfBuilderAttrs$1 = ['splitLine', 'splitArea', 'minorSplitLine'];\n\n    var RadiusAxisView = function (_super) {\n      __extends(RadiusAxisView, _super);\n\n      function RadiusAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = RadiusAxisView.type;\n        _this.axisPointerClass = 'PolarAxisPointer';\n        return _this;\n      }\n\n      RadiusAxisView.prototype.render = function (radiusAxisModel, ecModel) {\n        this.group.removeAll();\n\n        if (!radiusAxisModel.get('show')) {\n          return;\n        }\n\n        var oldAxisGroup = this._axisGroup;\n        var newAxisGroup = this._axisGroup = new Group();\n        this.group.add(newAxisGroup);\n        var radiusAxis = radiusAxisModel.axis;\n        var polar = radiusAxis.polar;\n        var angleAxis = polar.getAngleAxis();\n        var ticksCoords = radiusAxis.getTicksCoords();\n        var minorTicksCoords = radiusAxis.getMinorTicksCoords();\n        var axisAngle = angleAxis.getExtent()[0];\n        var radiusExtent = radiusAxis.getExtent();\n        var layout = layoutAxis(polar, radiusAxisModel, axisAngle);\n        var axisBuilder = new AxisBuilder(radiusAxisModel, layout);\n        each(axisBuilderAttrs$2, axisBuilder.add, axisBuilder);\n        newAxisGroup.add(axisBuilder.getGroup());\n        groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);\n        each(selfBuilderAttrs$1, function (name) {\n          if (radiusAxisModel.get([name, 'show']) && !radiusAxis.scale.isBlank()) {\n            axisElementBuilders$1[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);\n          }\n        }, this);\n      };\n\n      RadiusAxisView.type = 'radiusAxis';\n      return RadiusAxisView;\n    }(AxisView);\n\n    var axisElementBuilders$1 = {\n      splitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n        var splitLineModel = radiusAxisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        var lineCount = 0;\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n        var splitLines = [];\n\n        for (var i = 0; i < ticksCoords.length; i++) {\n          var colorIndex = lineCount++ % lineColors.length;\n          splitLines[colorIndex] = splitLines[colorIndex] || [];\n          splitLines[colorIndex].push(new Circle({\n            shape: {\n              cx: polar.cx,\n              cy: polar.cy,\n              r: ticksCoords[i].coord\n            }\n          }));\n        }\n\n        for (var i = 0; i < splitLines.length; i++) {\n          group.add(mergePath$1(splitLines[i], {\n            style: defaults({\n              stroke: lineColors[i % lineColors.length],\n              fill: null\n            }, lineStyleModel.getLineStyle()),\n            silent: true\n          }));\n        }\n      },\n      minorSplitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {\n        if (!minorTicksCoords.length) {\n          return;\n        }\n\n        var minorSplitLineModel = radiusAxisModel.getModel('minorSplitLine');\n        var lineStyleModel = minorSplitLineModel.getModel('lineStyle');\n        var lines = [];\n\n        for (var i = 0; i < minorTicksCoords.length; i++) {\n          for (var k = 0; k < minorTicksCoords[i].length; k++) {\n            lines.push(new Circle({\n              shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r: minorTicksCoords[i][k].coord\n              }\n            }));\n          }\n        }\n\n        group.add(mergePath$1(lines, {\n          style: defaults({\n            fill: null\n          }, lineStyleModel.getLineStyle()),\n          silent: true\n        }));\n      },\n      splitArea: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {\n        if (!ticksCoords.length) {\n          return;\n        }\n\n        var splitAreaModel = radiusAxisModel.getModel('splitArea');\n        var areaStyleModel = splitAreaModel.getModel('areaStyle');\n        var areaColors = areaStyleModel.get('color');\n        var lineCount = 0;\n        areaColors = areaColors instanceof Array ? areaColors : [areaColors];\n        var splitAreas = [];\n        var prevRadius = ticksCoords[0].coord;\n\n        for (var i = 1; i < ticksCoords.length; i++) {\n          var colorIndex = lineCount++ % areaColors.length;\n          splitAreas[colorIndex] = splitAreas[colorIndex] || [];\n          splitAreas[colorIndex].push(new Sector({\n            shape: {\n              cx: polar.cx,\n              cy: polar.cy,\n              r0: prevRadius,\n              r: ticksCoords[i].coord,\n              startAngle: 0,\n              endAngle: Math.PI * 2\n            },\n            silent: true\n          }));\n          prevRadius = ticksCoords[i].coord;\n        }\n\n        for (var i = 0; i < splitAreas.length; i++) {\n          group.add(mergePath$1(splitAreas[i], {\n            style: defaults({\n              fill: areaColors[i % areaColors.length]\n            }, areaStyleModel.getAreaStyle()),\n            silent: true\n          }));\n        }\n      }\n    };\n\n    function layoutAxis(polar, radiusAxisModel, axisAngle) {\n      return {\n        position: [polar.cx, polar.cy],\n        rotation: axisAngle / 180 * Math.PI,\n        labelDirection: -1,\n        tickDirection: -1,\n        nameDirection: 1,\n        labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),\n        z2: 1\n      };\n    }\n\n    function getSeriesStackId$1(seriesModel) {\n      return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;\n    }\n\n    function getAxisKey$1(polar, axis) {\n      return axis.dim + polar.model.componentIndex;\n    }\n\n    function barLayoutPolar(seriesType, ecModel, api) {\n      var lastStackCoords = {};\n      var barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n        return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar';\n      }));\n      ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n        if (seriesModel.coordinateSystem.type !== 'polar') {\n          return;\n        }\n\n        var data = seriesModel.getData();\n        var polar = seriesModel.coordinateSystem;\n        var baseAxis = polar.getBaseAxis();\n        var axisKey = getAxisKey$1(polar, baseAxis);\n        var stackId = getSeriesStackId$1(seriesModel);\n        var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];\n        var columnOffset = columnLayoutInfo.offset;\n        var columnWidth = columnLayoutInfo.width;\n        var valueAxis = polar.getOtherAxis(baseAxis);\n        var cx = seriesModel.coordinateSystem.cx;\n        var cy = seriesModel.coordinateSystem.cy;\n        var barMinHeight = seriesModel.get('barMinHeight') || 0;\n        var barMinAngle = seriesModel.get('barMinAngle') || 0;\n        lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n        var valueDim = data.mapDimension(valueAxis.dim);\n        var baseDim = data.mapDimension(baseAxis.dim);\n        var stacked = isDimensionStacked(data, valueDim);\n        var clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true);\n        var valueAxisStart = valueAxis.dataToCoord(0);\n\n        for (var idx = 0, len = data.count(); idx < len; idx++) {\n          var value = data.get(valueDim, idx);\n          var baseValue = data.get(baseDim, idx);\n          var sign = value >= 0 ? 'p' : 'n';\n          var baseCoord = valueAxisStart;\n\n          if (stacked) {\n            if (!lastStackCoords[stackId][baseValue]) {\n              lastStackCoords[stackId][baseValue] = {\n                p: valueAxisStart,\n                n: valueAxisStart\n              };\n            }\n\n            baseCoord = lastStackCoords[stackId][baseValue][sign];\n          }\n\n          var r0 = void 0;\n          var r = void 0;\n          var startAngle = void 0;\n          var endAngle = void 0;\n\n          if (valueAxis.dim === 'radius') {\n            var radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart;\n            var angle = baseAxis.dataToCoord(baseValue);\n\n            if (Math.abs(radiusSpan) < barMinHeight) {\n              radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;\n            }\n\n            r0 = baseCoord;\n            r = baseCoord + radiusSpan;\n            startAngle = angle - columnOffset;\n            endAngle = startAngle - columnWidth;\n            stacked && (lastStackCoords[stackId][baseValue][sign] = r);\n          } else {\n            var angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart;\n            var radius = baseAxis.dataToCoord(baseValue);\n\n            if (Math.abs(angleSpan) < barMinAngle) {\n              angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;\n            }\n\n            r0 = radius + columnOffset;\n            r = r0 + columnWidth;\n            startAngle = baseCoord;\n            endAngle = baseCoord + angleSpan;\n            stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);\n          }\n\n          data.setItemLayout(idx, {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: -startAngle * Math.PI / 180,\n            endAngle: -endAngle * Math.PI / 180\n          });\n        }\n      });\n    }\n\n    function calRadialBar(barSeries) {\n      var columnsMap = {};\n      each(barSeries, function (seriesModel, idx) {\n        var data = seriesModel.getData();\n        var polar = seriesModel.coordinateSystem;\n        var baseAxis = polar.getBaseAxis();\n        var axisKey = getAxisKey$1(polar, baseAxis);\n        var axisExtent = baseAxis.getExtent();\n        var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n        var columnsOnAxis = columnsMap[axisKey] || {\n          bandWidth: bandWidth,\n          remainedWidth: bandWidth,\n          autoWidthCount: 0,\n          categoryGap: '20%',\n          gap: '30%',\n          stacks: {}\n        };\n        var stacks = columnsOnAxis.stacks;\n        columnsMap[axisKey] = columnsOnAxis;\n        var stackId = getSeriesStackId$1(seriesModel);\n\n        if (!stacks[stackId]) {\n          columnsOnAxis.autoWidthCount++;\n        }\n\n        stacks[stackId] = stacks[stackId] || {\n          width: 0,\n          maxWidth: 0\n        };\n        var barWidth = parsePercent$1(seriesModel.get('barWidth'), bandWidth);\n        var barMaxWidth = parsePercent$1(seriesModel.get('barMaxWidth'), bandWidth);\n        var barGap = seriesModel.get('barGap');\n        var barCategoryGap = seriesModel.get('barCategoryGap');\n\n        if (barWidth && !stacks[stackId].width) {\n          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n          stacks[stackId].width = barWidth;\n          columnsOnAxis.remainedWidth -= barWidth;\n        }\n\n        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n        barGap != null && (columnsOnAxis.gap = barGap);\n        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n      });\n      var result = {};\n      each(columnsMap, function (columnsOnAxis, coordSysName) {\n        result[coordSysName] = {};\n        var stacks = columnsOnAxis.stacks;\n        var bandWidth = columnsOnAxis.bandWidth;\n        var categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth);\n        var barGapPercent = parsePercent$1(columnsOnAxis.gap, 1);\n        var remainedWidth = columnsOnAxis.remainedWidth;\n        var autoWidthCount = columnsOnAxis.autoWidthCount;\n        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n        each(stacks, function (column, stack) {\n          var maxWidth = column.maxWidth;\n\n          if (maxWidth && maxWidth < autoWidth) {\n            maxWidth = Math.min(maxWidth, remainedWidth);\n\n            if (column.width) {\n              maxWidth = Math.min(maxWidth, column.width);\n            }\n\n            remainedWidth -= maxWidth;\n            column.width = maxWidth;\n            autoWidthCount--;\n          }\n        });\n        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n        autoWidth = Math.max(autoWidth, 0);\n        var widthSum = 0;\n        var lastColumn;\n        each(stacks, function (column, idx) {\n          if (!column.width) {\n            column.width = autoWidth;\n          }\n\n          lastColumn = column;\n          widthSum += column.width * (1 + barGapPercent);\n        });\n\n        if (lastColumn) {\n          widthSum -= lastColumn.width * barGapPercent;\n        }\n\n        var offset = -widthSum / 2;\n        each(stacks, function (column, stackId) {\n          result[coordSysName][stackId] = result[coordSysName][stackId] || {\n            offset: offset,\n            width: column.width\n          };\n          offset += column.width * (1 + barGapPercent);\n        });\n      });\n      return result;\n    }\n\n    var angleAxisExtraOption = {\n      startAngle: 90,\n      clockwise: true,\n      splitNumber: 12,\n      axisLabel: {\n        rotate: 0\n      }\n    };\n    var radiusAxisExtraOption = {\n      splitNumber: 5\n    };\n\n    var PolarView = function (_super) {\n      __extends(PolarView, _super);\n\n      function PolarView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PolarView.type;\n        return _this;\n      }\n\n      PolarView.type = 'polar';\n      return PolarView;\n    }(ComponentView);\n\n    function install$t(registers) {\n      use(install$r);\n      AxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer);\n      registers.registerCoordinateSystem('polar', polarCreator);\n      registers.registerComponentModel(PolarModel);\n      registers.registerComponentView(PolarView);\n      axisModelCreator(registers, 'angle', AngleAxisModel, angleAxisExtraOption);\n      axisModelCreator(registers, 'radius', RadiusAxisModel, radiusAxisExtraOption);\n      registers.registerComponentView(AngleAxisView);\n      registers.registerComponentView(RadiusAxisView);\n      registers.registerLayout(curry(barLayoutPolar, 'bar'));\n    }\n\n    var Geo = function (_super) {\n      __extends(Geo, _super);\n\n      function Geo(name, map, nameMap, invertLongitute) {\n        var _this = _super.call(this, name) || this;\n\n        _this.dimensions = ['lng', 'lat'];\n        _this.type = 'geo';\n        _this.map = map;\n        var source = geoSourceManager.load(map, nameMap);\n        _this._nameCoordMap = source.nameCoordMap;\n        _this._regionsMap = source.regionsMap;\n        _this._invertLongitute = invertLongitute == null ? true : invertLongitute;\n        _this.regions = source.regions;\n        _this._rect = source.boundingRect;\n        return _this;\n      }\n\n      Geo.prototype.containCoord = function (coord) {\n        var regions = this.regions;\n\n        for (var i = 0; i < regions.length; i++) {\n          if (regions[i].contain(coord)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      Geo.prototype.transformTo = function (x, y, width, height) {\n        var rect = this.getBoundingRect();\n        var invertLongitute = this._invertLongitute;\n        rect = rect.clone();\n\n        if (invertLongitute) {\n          rect.y = -rect.y - rect.height;\n        }\n\n        var rawTransformable = this._rawTransformable;\n        rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));\n        rawTransformable.decomposeTransform();\n\n        if (invertLongitute) {\n          rawTransformable.scaleY = -rawTransformable.scaleY;\n        }\n\n        rawTransformable.updateTransform();\n\n        this._updateTransform();\n      };\n\n      Geo.prototype.getRegion = function (name) {\n        return this._regionsMap.get(name);\n      };\n\n      Geo.prototype.getRegionByCoord = function (coord) {\n        var regions = this.regions;\n\n        for (var i = 0; i < regions.length; i++) {\n          if (regions[i].contain(coord)) {\n            return regions[i];\n          }\n        }\n      };\n\n      Geo.prototype.addGeoCoord = function (name, geoCoord) {\n        this._nameCoordMap.set(name, geoCoord);\n      };\n\n      Geo.prototype.getGeoCoord = function (name) {\n        return this._nameCoordMap.get(name);\n      };\n\n      Geo.prototype.getBoundingRect = function () {\n        return this._rect;\n      };\n\n      Geo.prototype.dataToPoint = function (data, noRoam, out) {\n        if (typeof data === 'string') {\n          data = this.getGeoCoord(data);\n        }\n\n        if (data) {\n          return View.prototype.dataToPoint.call(this, data, noRoam, out);\n        }\n      };\n\n      Geo.prototype.convertToPixel = function (ecModel, finder, value) {\n        var coordSys = getCoordSys$2(finder);\n        return coordSys === this ? coordSys.dataToPoint(value) : null;\n      };\n\n      Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        var coordSys = getCoordSys$2(finder);\n        return coordSys === this ? coordSys.pointToData(pixel) : null;\n      };\n\n      return Geo;\n    }(View);\n    mixin(Geo, View);\n\n    function getCoordSys$2(finder) {\n      var geoModel = finder.geoModel;\n      var seriesModel = finder.seriesModel;\n      return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;\n    }\n\n    function resizeGeo(geoModel, api) {\n      var boundingCoords = geoModel.get('boundingCoords');\n\n      if (boundingCoords != null) {\n        var leftTop = boundingCoords[0];\n        var rightBottom = boundingCoords[1];\n\n        if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {\n          if (\"development\" !== 'production') {\n            console.error('Invalid boundingCoords');\n          }\n        } else {\n          this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);\n        }\n      }\n\n      var rect = this.getBoundingRect();\n      var centerOption = geoModel.get('layoutCenter');\n      var sizeOption = geoModel.get('layoutSize');\n      var viewWidth = api.getWidth();\n      var viewHeight = api.getHeight();\n      var aspect = rect.width / rect.height * this.aspectScale;\n      var useCenterAndSize = false;\n      var center;\n      var size;\n\n      if (centerOption && sizeOption) {\n        center = [parsePercent$1(centerOption[0], viewWidth), parsePercent$1(centerOption[1], viewHeight)];\n        size = parsePercent$1(sizeOption, Math.min(viewWidth, viewHeight));\n\n        if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {\n          useCenterAndSize = true;\n        } else {\n          if (\"development\" !== 'production') {\n            console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');\n          }\n        }\n      }\n\n      var viewRect;\n\n      if (useCenterAndSize) {\n        viewRect = {};\n\n        if (aspect > 1) {\n          viewRect.width = size;\n          viewRect.height = size / aspect;\n        } else {\n          viewRect.height = size;\n          viewRect.width = size * aspect;\n        }\n\n        viewRect.y = center[1] - viewRect.height / 2;\n        viewRect.x = center[0] - viewRect.width / 2;\n      } else {\n        var boxLayoutOption = geoModel.getBoxLayoutParams();\n        boxLayoutOption.aspect = aspect;\n        viewRect = getLayoutRect(boxLayoutOption, {\n          width: viewWidth,\n          height: viewHeight\n        });\n      }\n\n      this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);\n      this.setCenter(geoModel.get('center'));\n      this.setZoom(geoModel.get('zoom'));\n    }\n\n    function setGeoCoords(geo, model) {\n      each(model.get('geoCoord'), function (geoCoord, name) {\n        geo.addGeoCoord(name, geoCoord);\n      });\n    }\n\n    var GeoCreator = function () {\n      function GeoCreator() {\n        this.dimensions = Geo.prototype.dimensions;\n      }\n\n      GeoCreator.prototype.create = function (ecModel, api) {\n        var geoList = [];\n        ecModel.eachComponent('geo', function (geoModel, idx) {\n          var name = geoModel.get('map');\n          var aspectScale = geoModel.get('aspectScale');\n          var invertLongitute = true;\n          var mapRecords = mapDataStorage.retrieveMap(name);\n\n          if (mapRecords && mapRecords[0] && mapRecords[0].type === 'svg') {\n            aspectScale == null && (aspectScale = 1);\n            invertLongitute = false;\n          } else {\n            aspectScale == null && (aspectScale = 0.75);\n          }\n\n          var geo = new Geo(name + idx, name, geoModel.get('nameMap'), invertLongitute);\n          geo.aspectScale = aspectScale;\n          geo.zoomLimit = geoModel.get('scaleLimit');\n          geoList.push(geo);\n          geoModel.coordinateSystem = geo;\n          geo.model = geoModel;\n          geo.resize = resizeGeo;\n          geo.resize(geoModel, api);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          var coordSys = seriesModel.get('coordinateSystem');\n\n          if (coordSys === 'geo') {\n            var geoIndex = seriesModel.get('geoIndex') || 0;\n            seriesModel.coordinateSystem = geoList[geoIndex];\n          }\n        });\n        var mapModelGroupBySeries = {};\n        ecModel.eachSeriesByType('map', function (seriesModel) {\n          if (!seriesModel.getHostGeoModel()) {\n            var mapType = seriesModel.getMapType();\n            mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];\n            mapModelGroupBySeries[mapType].push(seriesModel);\n          }\n        });\n        each(mapModelGroupBySeries, function (mapSeries, mapType) {\n          var nameMapList = map(mapSeries, function (singleMapSeries) {\n            return singleMapSeries.get('nameMap');\n          });\n          var geo = new Geo(mapType, mapType, mergeAll(nameMapList));\n          geo.zoomLimit = retrieve.apply(null, map(mapSeries, function (singleMapSeries) {\n            return singleMapSeries.get('scaleLimit');\n          }));\n          geoList.push(geo);\n          geo.resize = resizeGeo;\n          geo.aspectScale = mapSeries[0].get('aspectScale');\n          geo.resize(mapSeries[0], api);\n          each(mapSeries, function (singleMapSeries) {\n            singleMapSeries.coordinateSystem = geo;\n            setGeoCoords(geo, singleMapSeries);\n          });\n        });\n        return geoList;\n      };\n\n      GeoCreator.prototype.getFilledRegions = function (originRegionArr, mapName, nameMap) {\n        var regionsArr = (originRegionArr || []).slice();\n        var dataNameMap = createHashMap();\n\n        for (var i = 0; i < regionsArr.length; i++) {\n          dataNameMap.set(regionsArr[i].name, regionsArr[i]);\n        }\n\n        var source = geoSourceManager.load(mapName, nameMap);\n        each(source.regions, function (region) {\n          var name = region.name;\n          !dataNameMap.get(name) && regionsArr.push({\n            name: name\n          });\n        });\n        return regionsArr;\n      };\n\n      return GeoCreator;\n    }();\n\n    var geoCreator = new GeoCreator();\n\n    var GeoModel = function (_super) {\n      __extends(GeoModel, _super);\n\n      function GeoModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GeoModel.type;\n        return _this;\n      }\n\n      GeoModel.prototype.init = function (option, parentModel, ecModel) {\n        _super.prototype.init.call(this, option, parentModel, ecModel);\n\n        defaultEmphasis(option, 'label', ['show']);\n      };\n\n      GeoModel.prototype.optionUpdated = function () {\n        var option = this.option;\n        var self = this;\n        option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);\n        var selectedMap = {};\n        this._optionModelMap = reduce(option.regions || [], function (optionModelMap, regionOpt) {\n          var regionName = regionOpt.name;\n\n          if (regionName) {\n            optionModelMap.set(regionName, new Model(regionOpt, self));\n\n            if (regionOpt.selected) {\n              selectedMap[regionName] = true;\n            }\n          }\n\n          return optionModelMap;\n        }, createHashMap());\n\n        if (!option.selectedMap) {\n          option.selectedMap = selectedMap;\n        }\n      };\n\n      GeoModel.prototype.getRegionModel = function (name) {\n        return this._optionModelMap.get(name) || new Model(null, this, this.ecModel);\n      };\n\n      GeoModel.prototype.getFormattedLabel = function (name, status) {\n        var regionModel = this.getRegionModel(name);\n        var formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter']);\n        var params = {\n          name: name\n        };\n\n        if (typeof formatter === 'function') {\n          params.status = status;\n          return formatter(params);\n        } else if (typeof formatter === 'string') {\n          return formatter.replace('{a}', name != null ? name : '');\n        }\n      };\n\n      GeoModel.prototype.setZoom = function (zoom) {\n        this.option.zoom = zoom;\n      };\n\n      GeoModel.prototype.setCenter = function (center) {\n        this.option.center = center;\n      };\n\n      GeoModel.prototype.select = function (name) {\n        var option = this.option;\n        var selectedMode = option.selectedMode;\n\n        if (!selectedMode) {\n          return;\n        }\n\n        if (selectedMode !== 'multiple') {\n          option.selectedMap = null;\n        }\n\n        var selectedMap = option.selectedMap || (option.selectedMap = {});\n        selectedMap[name] = true;\n      };\n\n      GeoModel.prototype.unSelect = function (name) {\n        var selectedMap = this.option.selectedMap;\n\n        if (selectedMap) {\n          selectedMap[name] = false;\n        }\n      };\n\n      GeoModel.prototype.toggleSelected = function (name) {\n        this[this.isSelected(name) ? 'unSelect' : 'select'](name);\n      };\n\n      GeoModel.prototype.isSelected = function (name) {\n        var selectedMap = this.option.selectedMap;\n        return !!(selectedMap && selectedMap[name]);\n      };\n\n      GeoModel.prototype._initSelectedMapFromData = function () {};\n\n      GeoModel.type = 'geo';\n      GeoModel.layoutMode = 'box';\n      GeoModel.defaultOption = {\n        zlevel: 0,\n        z: 0,\n        show: true,\n        left: 'center',\n        top: 'center',\n        aspectScale: null,\n        silent: false,\n        map: '',\n        boundingCoords: null,\n        center: null,\n        zoom: 1,\n        scaleLimit: null,\n        label: {\n          show: false,\n          color: '#000'\n        },\n        itemStyle: {\n          borderWidth: 0.5,\n          borderColor: '#444',\n          color: '#eee'\n        },\n        emphasis: {\n          label: {\n            show: true,\n            color: 'rgb(100,0,0)'\n          },\n          itemStyle: {\n            color: 'rgba(255,215,0,0.8)'\n          }\n        },\n        select: {\n          label: {\n            show: true,\n            color: 'rgb(100,0,0)'\n          },\n          itemStyle: {\n            color: 'rgba(255,215,0,0.8)'\n          }\n        },\n        regions: []\n      };\n      return GeoModel;\n    }(ComponentModel);\n\n    var GeoView = function (_super) {\n      __extends(GeoView, _super);\n\n      function GeoView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GeoView.type;\n        return _this;\n      }\n\n      GeoView.prototype.init = function (ecModel, api) {\n        var mapDraw = new MapDraw(api);\n        this._mapDraw = mapDraw;\n        this.group.add(mapDraw.group);\n        this._api = api;\n      };\n\n      GeoView.prototype.render = function (geoModel, ecModel, api, payload) {\n        var mapDraw = this._mapDraw;\n\n        if (geoModel.get('show')) {\n          mapDraw.draw(geoModel, ecModel, api, this, payload);\n        } else {\n          this._mapDraw.group.removeAll();\n        }\n\n        mapDraw.group.on('click', this._handleRegionClick, this);\n        mapDraw.group.silent = geoModel.get('silent');\n        this._model = geoModel;\n        this.updateSelectStatus(geoModel, ecModel, api);\n      };\n\n      GeoView.prototype._handleRegionClick = function (e) {\n        var current = e.target;\n        var eventData;\n\n        while (current && (eventData = getECData(current).eventData) == null) {\n          current = current.__hostTarget || current.parent;\n        }\n\n        if (eventData) {\n          this._api.dispatchAction({\n            type: 'geoToggleSelect',\n            geoId: this._model.id,\n            name: eventData.name\n          });\n        }\n      };\n\n      GeoView.prototype.updateSelectStatus = function (model, ecModel, api) {\n        var _this = this;\n\n        this._mapDraw.group.traverse(function (node) {\n          var eventData = getECData(node).eventData;\n\n          if (eventData) {\n            _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node);\n            return true;\n          }\n        });\n      };\n\n      GeoView.prototype.dispose = function () {\n        this._mapDraw && this._mapDraw.remove();\n      };\n\n      GeoView.type = 'geo';\n      return GeoView;\n    }(ComponentView);\n\n    function install$u(registers) {\n      registers.registerCoordinateSystem('geo', geoCreator);\n      registers.registerComponentModel(GeoModel);\n      registers.registerComponentView(GeoView);\n\n      function makeAction(method, actionInfo) {\n        actionInfo.update = 'geo:updateSelectStatus';\n        registers.registerAction(actionInfo, function (payload, ecModel) {\n          var selected = {};\n          ecModel.eachComponent({\n            mainType: 'geo',\n            query: payload\n          }, function (geoModel) {\n            geoModel[method](payload.name);\n            var geo = geoModel.coordinateSystem;\n            each(geo.regions, function (region) {\n              selected[region.name] = geoModel.isSelected(region.name) || false;\n            });\n          });\n          return {\n            selected: selected,\n            name: payload.name\n          };\n        });\n      }\n\n      makeAction('toggleSelected', {\n        type: 'geoToggleSelect',\n        event: 'geoselectchanged'\n      });\n      makeAction('select', {\n        type: 'geoSelect',\n        event: 'geoselected'\n      });\n      makeAction('unSelect', {\n        type: 'geoUnSelect',\n        event: 'geounselected'\n      });\n      registers.registerAction({\n        type: 'geoRoam',\n        event: 'geoRoam',\n        update: 'updateTransform'\n      }, function (payload, ecModel) {\n        var componentType = payload.componentType || 'series';\n        ecModel.eachComponent({\n          mainType: componentType,\n          query: payload\n        }, function (componentModel) {\n          var geo = componentModel.coordinateSystem;\n\n          if (geo.type !== 'geo') {\n            return;\n          }\n\n          var res = updateCenterAndZoom(geo, payload, componentModel.get('scaleLimit'));\n          componentModel.setCenter && componentModel.setCenter(res.center);\n          componentModel.setZoom && componentModel.setZoom(res.zoom);\n\n          if (componentType === 'series') {\n            each(componentModel.seriesGroup, function (seriesModel) {\n              seriesModel.setCenter(res.center);\n              seriesModel.setZoom(res.zoom);\n            });\n          }\n        });\n      });\n    }\n\n    function layout$2(axisModel, opt) {\n      opt = opt || {};\n      var single = axisModel.coordinateSystem;\n      var axis = axisModel.axis;\n      var layout = {};\n      var axisPosition = axis.position;\n      var orient = axis.orient;\n      var rect = single.getRect();\n      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n      var positionMap = {\n        horizontal: {\n          top: rectBound[2],\n          bottom: rectBound[3]\n        },\n        vertical: {\n          left: rectBound[0],\n          right: rectBound[1]\n        }\n      };\n      layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]];\n      var r = {\n        horizontal: 0,\n        vertical: 1\n      };\n      layout.rotation = Math.PI / 2 * r[orient];\n      var directionMap = {\n        top: -1,\n        bottom: 1,\n        right: 1,\n        left: -1\n      };\n      layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition];\n\n      if (axisModel.get(['axisTick', 'inside'])) {\n        layout.tickDirection = -layout.tickDirection;\n      }\n\n      if (retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {\n        layout.labelDirection = -layout.labelDirection;\n      }\n\n      var labelRotation = opt.rotate;\n      labelRotation == null && (labelRotation = axisModel.get(['axisLabel', 'rotate']));\n      layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n      layout.z2 = 1;\n      return layout;\n    }\n\n    var axisBuilderAttrs$3 = ['axisLine', 'axisTickLabel', 'axisName'];\n    var selfBuilderAttrs$2 = ['splitArea', 'splitLine'];\n\n    var SingleAxisView = function (_super) {\n      __extends(SingleAxisView, _super);\n\n      function SingleAxisView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SingleAxisView.type;\n        _this.axisPointerClass = 'SingleAxisPointer';\n        return _this;\n      }\n\n      SingleAxisView.prototype.render = function (axisModel, ecModel, api, payload) {\n        var group = this.group;\n        group.removeAll();\n        var oldAxisGroup = this._axisGroup;\n        this._axisGroup = new Group();\n        var layout = layout$2(axisModel);\n        var axisBuilder = new AxisBuilder(axisModel, layout);\n        each(axisBuilderAttrs$3, axisBuilder.add, axisBuilder);\n        group.add(this._axisGroup);\n        group.add(axisBuilder.getGroup());\n        each(selfBuilderAttrs$2, function (name) {\n          if (axisModel.get([name, 'show'])) {\n            axisElementBuilders$2[name](this, this.group, this._axisGroup, axisModel);\n          }\n        }, this);\n        groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\n        _super.prototype.render.call(this, axisModel, ecModel, api, payload);\n      };\n\n      SingleAxisView.prototype.remove = function () {\n        rectCoordAxisHandleRemove(this);\n      };\n\n      SingleAxisView.type = 'singleAxis';\n      return SingleAxisView;\n    }(AxisView);\n\n    var axisElementBuilders$2 = {\n      splitLine: function (axisView, group, axisGroup, axisModel) {\n        var axis = axisModel.axis;\n\n        if (axis.scale.isBlank()) {\n          return;\n        }\n\n        var splitLineModel = axisModel.getModel('splitLine');\n        var lineStyleModel = splitLineModel.getModel('lineStyle');\n        var lineColors = lineStyleModel.get('color');\n        lineColors = lineColors instanceof Array ? lineColors : [lineColors];\n        var gridRect = axisModel.coordinateSystem.getRect();\n        var isHorizontal = axis.isHorizontal();\n        var splitLines = [];\n        var lineCount = 0;\n        var ticksCoords = axis.getTicksCoords({\n          tickModel: splitLineModel\n        });\n        var p1 = [];\n        var p2 = [];\n\n        for (var i = 0; i < ticksCoords.length; ++i) {\n          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n          if (isHorizontal) {\n            p1[0] = tickCoord;\n            p1[1] = gridRect.y;\n            p2[0] = tickCoord;\n            p2[1] = gridRect.y + gridRect.height;\n          } else {\n            p1[0] = gridRect.x;\n            p1[1] = tickCoord;\n            p2[0] = gridRect.x + gridRect.width;\n            p2[1] = tickCoord;\n          }\n\n          var colorIndex = lineCount++ % lineColors.length;\n          splitLines[colorIndex] = splitLines[colorIndex] || [];\n          splitLines[colorIndex].push(new Line({\n            subPixelOptimize: true,\n            shape: {\n              x1: p1[0],\n              y1: p1[1],\n              x2: p2[0],\n              y2: p2[1]\n            },\n            silent: true\n          }));\n        }\n\n        var lineStyle = lineStyleModel.getLineStyle(['color']);\n\n        for (var i = 0; i < splitLines.length; ++i) {\n          group.add(mergePath$1(splitLines[i], {\n            style: defaults({\n              stroke: lineColors[i % lineColors.length]\n            }, lineStyle),\n            silent: true\n          }));\n        }\n      },\n      splitArea: function (axisView, group, axisGroup, axisModel) {\n        rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);\n      }\n    };\n\n    var SingleAxisModel = function (_super) {\n      __extends(SingleAxisModel, _super);\n\n      function SingleAxisModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SingleAxisModel.type;\n        return _this;\n      }\n\n      SingleAxisModel.prototype.getCoordSysModel = function () {\n        return this;\n      };\n\n      SingleAxisModel.type = 'singleAxis';\n      SingleAxisModel.layoutMode = 'box';\n      SingleAxisModel.defaultOption = {\n        left: '5%',\n        top: '5%',\n        right: '5%',\n        bottom: '5%',\n        type: 'value',\n        position: 'bottom',\n        orient: 'horizontal',\n        axisLine: {\n          show: true,\n          lineStyle: {\n            width: 1,\n            type: 'solid'\n          }\n        },\n        tooltip: {\n          show: true\n        },\n        axisTick: {\n          show: true,\n          length: 6,\n          lineStyle: {\n            width: 1\n          }\n        },\n        axisLabel: {\n          show: true,\n          interval: 'auto'\n        },\n        splitLine: {\n          show: true,\n          lineStyle: {\n            type: 'dashed',\n            opacity: 0.2\n          }\n        }\n      };\n      return SingleAxisModel;\n    }(ComponentModel);\n\n    mixin(SingleAxisModel, AxisModelCommonMixin.prototype);\n\n    var SingleAxis = function (_super) {\n      __extends(SingleAxis, _super);\n\n      function SingleAxis(dim, scale, coordExtent, axisType, position) {\n        var _this = _super.call(this, dim, scale, coordExtent) || this;\n\n        _this.type = axisType || 'value';\n        _this.position = position || 'bottom';\n        return _this;\n      }\n\n      SingleAxis.prototype.isHorizontal = function () {\n        var position = this.position;\n        return position === 'top' || position === 'bottom';\n      };\n\n      SingleAxis.prototype.pointToData = function (point, clamp) {\n        return this.coordinateSystem.pointToData(point)[0];\n      };\n\n      return SingleAxis;\n    }(Axis);\n\n    var Single = function () {\n      function Single(axisModel, ecModel, api) {\n        this.type = 'single';\n        this.dimension = 'single';\n        this.dimensions = ['single'];\n        this.axisPointerEnabled = true;\n        this.model = axisModel;\n\n        this._init(axisModel, ecModel, api);\n      }\n\n      Single.prototype._init = function (axisModel, ecModel, api) {\n        var dim = this.dimension;\n        var axis = new SingleAxis(dim, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'));\n        var isCategory = axis.type === 'category';\n        axis.onBand = isCategory && axisModel.get('boundaryGap');\n        axis.inverse = axisModel.get('inverse');\n        axis.orient = axisModel.get('orient');\n        axisModel.axis = axis;\n        axis.model = axisModel;\n        axis.coordinateSystem = this;\n        this._axis = axis;\n      };\n\n      Single.prototype.update = function (ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n          if (seriesModel.coordinateSystem === this) {\n            var data_1 = seriesModel.getData();\n            each(data_1.mapDimensionsAll(this.dimension), function (dim) {\n              this._axis.scale.unionExtentFromData(data_1, dim);\n            }, this);\n            niceScaleExtent(this._axis.scale, this._axis.model);\n          }\n        }, this);\n      };\n\n      Single.prototype.resize = function (axisModel, api) {\n        this._rect = getLayoutRect({\n          left: axisModel.get('left'),\n          top: axisModel.get('top'),\n          right: axisModel.get('right'),\n          bottom: axisModel.get('bottom'),\n          width: axisModel.get('width'),\n          height: axisModel.get('height')\n        }, {\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n\n        this._adjustAxis();\n      };\n\n      Single.prototype.getRect = function () {\n        return this._rect;\n      };\n\n      Single.prototype._adjustAxis = function () {\n        var rect = this._rect;\n        var axis = this._axis;\n        var isHorizontal = axis.isHorizontal();\n        var extent = isHorizontal ? [0, rect.width] : [0, rect.height];\n        var idx = axis.reverse ? 1 : 0;\n        axis.setExtent(extent[idx], extent[1 - idx]);\n\n        this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);\n      };\n\n      Single.prototype._updateAxisTransform = function (axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var extentSum = axisExtent[0] + axisExtent[1];\n        var isHorizontal = axis.isHorizontal();\n        axis.toGlobalCoord = isHorizontal ? function (coord) {\n          return coord + coordBase;\n        } : function (coord) {\n          return extentSum - coord + coordBase;\n        };\n        axis.toLocalCoord = isHorizontal ? function (coord) {\n          return coord - coordBase;\n        } : function (coord) {\n          return extentSum - coord + coordBase;\n        };\n      };\n\n      Single.prototype.getAxis = function () {\n        return this._axis;\n      };\n\n      Single.prototype.getBaseAxis = function () {\n        return this._axis;\n      };\n\n      Single.prototype.getAxes = function () {\n        return [this._axis];\n      };\n\n      Single.prototype.getTooltipAxes = function () {\n        return {\n          baseAxes: [this.getAxis()],\n          otherAxes: []\n        };\n      };\n\n      Single.prototype.containPoint = function (point) {\n        var rect = this.getRect();\n        var axis = this.getAxis();\n        var orient = axis.orient;\n\n        if (orient === 'horizontal') {\n          return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n        } else {\n          return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;\n        }\n      };\n\n      Single.prototype.pointToData = function (point) {\n        var axis = this.getAxis();\n        return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))];\n      };\n\n      Single.prototype.dataToPoint = function (val) {\n        var axis = this.getAxis();\n        var rect = this.getRect();\n        var pt = [];\n        var idx = axis.orient === 'horizontal' ? 0 : 1;\n\n        if (val instanceof Array) {\n          val = val[0];\n        }\n\n        pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));\n        pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;\n        return pt;\n      };\n\n      Single.prototype.convertToPixel = function (ecModel, finder, value) {\n        var coordSys = getCoordSys$3(finder);\n        return coordSys === this ? this.dataToPoint(value) : null;\n      };\n\n      Single.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        var coordSys = getCoordSys$3(finder);\n        return coordSys === this ? this.pointToData(pixel) : null;\n      };\n\n      return Single;\n    }();\n\n    function getCoordSys$3(finder) {\n      var seriesModel = finder.seriesModel;\n      var singleModel = finder.singleAxisModel;\n      return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;\n    }\n\n    function create$2(ecModel, api) {\n      var singles = [];\n      ecModel.eachComponent('singleAxis', function (axisModel, idx) {\n        var single = new Single(axisModel, ecModel, api);\n        single.name = 'single_' + idx;\n        single.resize(axisModel, api);\n        axisModel.coordinateSystem = single;\n        singles.push(single);\n      });\n      ecModel.eachSeries(function (seriesModel) {\n        if (seriesModel.get('coordinateSystem') === 'singleAxis') {\n          var singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];\n          seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;\n        }\n      });\n      return singles;\n    }\n\n    var singleCreator = {\n      create: create$2,\n      dimensions: Single.prototype.dimensions\n    };\n\n    var XY = ['x', 'y'];\n    var WH = ['width', 'height'];\n\n    var SingleAxisPointer = function (_super) {\n      __extends(SingleAxisPointer, _super);\n\n      function SingleAxisPointer() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      SingleAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {\n        var axis = axisModel.axis;\n        var coordSys = axis.coordinateSystem;\n        var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));\n        var pixelValue = coordSys.dataToPoint(value)[0];\n        var axisPointerType = axisPointerModel.get('type');\n\n        if (axisPointerType && axisPointerType !== 'none') {\n          var elStyle = buildElStyle(axisPointerModel);\n          var pointerOption = pointerShapeBuilder$2[axisPointerType](axis, pixelValue, otherExtent);\n          pointerOption.style = elStyle;\n          elOption.graphicKey = pointerOption.type;\n          elOption.pointer = pointerOption;\n        }\n\n        var layoutInfo = layout$2(axisModel);\n        buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);\n      };\n\n      SingleAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {\n        var layoutInfo = layout$2(axisModel, {\n          labelInside: false\n        });\n        layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);\n        var position = getTransformedPosition(axisModel.axis, value, layoutInfo);\n        return {\n          x: position[0],\n          y: position[1],\n          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)\n        };\n      };\n\n      SingleAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {\n        var axis = axisModel.axis;\n        var coordSys = axis.coordinateSystem;\n        var dimIndex = getPointDimIndex(axis);\n        var axisExtent = getGlobalExtent(coordSys, dimIndex);\n        var currPosition = [transform.x, transform.y];\n        currPosition[dimIndex] += delta[dimIndex];\n        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);\n        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);\n        var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);\n        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;\n        var cursorPoint = [cursorOtherValue, cursorOtherValue];\n        cursorPoint[dimIndex] = currPosition[dimIndex];\n        return {\n          x: currPosition[0],\n          y: currPosition[1],\n          rotation: transform.rotation,\n          cursorPoint: cursorPoint,\n          tooltipOption: {\n            verticalAlign: 'middle'\n          }\n        };\n      };\n\n      return SingleAxisPointer;\n    }(BaseAxisPointer);\n\n    var pointerShapeBuilder$2 = {\n      line: function (axis, pixelValue, otherExtent) {\n        var targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));\n        return {\n          type: 'Line',\n          subPixelOptimize: true,\n          shape: targetShape\n        };\n      },\n      shadow: function (axis, pixelValue, otherExtent) {\n        var bandWidth = axis.getBandWidth();\n        var span = otherExtent[1] - otherExtent[0];\n        return {\n          type: 'Rect',\n          shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))\n        };\n      }\n    };\n\n    function getPointDimIndex(axis) {\n      return axis.isHorizontal() ? 0 : 1;\n    }\n\n    function getGlobalExtent(coordSys, dimIndex) {\n      var rect = coordSys.getRect();\n      return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];\n    }\n\n    var SingleView = function (_super) {\n      __extends(SingleView, _super);\n\n      function SingleView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SingleView.type;\n        return _this;\n      }\n\n      SingleView.type = 'single';\n      return SingleView;\n    }(ComponentView);\n\n    function install$v(registers) {\n      use(install$r);\n      AxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer);\n      registers.registerComponentView(SingleView);\n      registers.registerComponentView(SingleAxisView);\n      registers.registerComponentModel(SingleAxisModel);\n      axisModelCreator(registers, 'single', SingleAxisModel, SingleAxisModel.defaultOption);\n      registers.registerCoordinateSystem('single', singleCreator);\n    }\n\n    var CalendarModel = function (_super) {\n      __extends(CalendarModel, _super);\n\n      function CalendarModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CalendarModel.type;\n        return _this;\n      }\n\n      CalendarModel.prototype.init = function (option, parentModel, ecModel) {\n        var inputPositionParams = getLayoutParams(option);\n\n        _super.prototype.init.apply(this, arguments);\n\n        mergeAndNormalizeLayoutParams(option, inputPositionParams);\n      };\n\n      CalendarModel.prototype.mergeOption = function (option) {\n        _super.prototype.mergeOption.apply(this, arguments);\n\n        mergeAndNormalizeLayoutParams(this.option, option);\n      };\n\n      CalendarModel.prototype.getCellSize = function () {\n        return this.option.cellSize;\n      };\n\n      CalendarModel.type = 'calendar';\n      CalendarModel.defaultOption = {\n        zlevel: 0,\n        z: 2,\n        left: 80,\n        top: 60,\n        cellSize: 20,\n        orient: 'horizontal',\n        splitLine: {\n          show: true,\n          lineStyle: {\n            color: '#000',\n            width: 1,\n            type: 'solid'\n          }\n        },\n        itemStyle: {\n          color: '#fff',\n          borderWidth: 1,\n          borderColor: '#ccc'\n        },\n        dayLabel: {\n          show: true,\n          firstDay: 0,\n          position: 'start',\n          margin: '50%',\n          nameMap: 'en',\n          color: '#000'\n        },\n        monthLabel: {\n          show: true,\n          position: 'start',\n          margin: 5,\n          align: 'center',\n          nameMap: 'en',\n          formatter: null,\n          color: '#000'\n        },\n        yearLabel: {\n          show: true,\n          position: null,\n          margin: 30,\n          formatter: null,\n          color: '#ccc',\n          fontFamily: 'sans-serif',\n          fontWeight: 'bolder',\n          fontSize: 20\n        }\n      };\n      return CalendarModel;\n    }(ComponentModel);\n\n    function mergeAndNormalizeLayoutParams(target, raw) {\n      var cellSize = target.cellSize;\n      var cellSizeArr;\n\n      if (!isArray(cellSize)) {\n        cellSizeArr = target.cellSize = [cellSize, cellSize];\n      } else {\n        cellSizeArr = cellSize;\n      }\n\n      if (cellSizeArr.length === 1) {\n        cellSizeArr[1] = cellSizeArr[0];\n      }\n\n      var ignoreSize = map([0, 1], function (hvIdx) {\n        if (sizeCalculable(raw, hvIdx)) {\n          cellSizeArr[hvIdx] = 'auto';\n        }\n\n        return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== 'auto';\n      });\n      mergeLayoutParam(target, raw, {\n        type: 'box',\n        ignoreSize: ignoreSize\n      });\n    }\n\n    var MONTH_TEXT = {\n      EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n      CN: ['', '', '', '', '', '', '', '', '', '', '', '']\n    };\n    var WEEK_TEXT = {\n      EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n      CN: ['', '', '', '', '', '', '']\n    };\n\n    var CalendarView = function (_super) {\n      __extends(CalendarView, _super);\n\n      function CalendarView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = CalendarView.type;\n        return _this;\n      }\n\n      CalendarView.prototype.render = function (calendarModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n        var coordSys = calendarModel.coordinateSystem;\n        var rangeData = coordSys.getRangeInfo();\n        var orient = coordSys.getOrient();\n\n        this._renderDayRect(calendarModel, rangeData, group);\n\n        this._renderLines(calendarModel, rangeData, orient, group);\n\n        this._renderYearText(calendarModel, rangeData, orient, group);\n\n        this._renderMonthText(calendarModel, orient, group);\n\n        this._renderWeekText(calendarModel, rangeData, orient, group);\n      };\n\n      CalendarView.prototype._renderDayRect = function (calendarModel, rangeData, group) {\n        var coordSys = calendarModel.coordinateSystem;\n        var itemRectStyleModel = calendarModel.getModel('itemStyle').getItemStyle();\n        var sw = coordSys.getCellWidth();\n        var sh = coordSys.getCellHeight();\n\n        for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {\n          var point = coordSys.dataToRect([i], false).tl;\n          var rect = new Rect({\n            shape: {\n              x: point[0],\n              y: point[1],\n              width: sw,\n              height: sh\n            },\n            cursor: 'default',\n            style: itemRectStyleModel\n          });\n          group.add(rect);\n        }\n      };\n\n      CalendarView.prototype._renderLines = function (calendarModel, rangeData, orient, group) {\n        var self = this;\n        var coordSys = calendarModel.coordinateSystem;\n        var lineStyleModel = calendarModel.getModel(['splitLine', 'lineStyle']).getLineStyle();\n        var show = calendarModel.get(['splitLine', 'show']);\n        var lineWidth = lineStyleModel.lineWidth;\n        this._tlpoints = [];\n        this._blpoints = [];\n        this._firstDayOfMonth = [];\n        this._firstDayPoints = [];\n        var firstDay = rangeData.start;\n\n        for (var i = 0; firstDay.time <= rangeData.end.time; i++) {\n          addPoints(firstDay.formatedDate);\n\n          if (i === 0) {\n            firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m);\n          }\n\n          var date = firstDay.date;\n          date.setMonth(date.getMonth() + 1);\n          firstDay = coordSys.getDateInfo(date);\n        }\n\n        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);\n\n        function addPoints(date) {\n          self._firstDayOfMonth.push(coordSys.getDateInfo(date));\n\n          self._firstDayPoints.push(coordSys.dataToRect([date], false).tl);\n\n          var points = self._getLinePointsOfOneWeek(calendarModel, date, orient);\n\n          self._tlpoints.push(points[0]);\n\n          self._blpoints.push(points[points.length - 1]);\n\n          show && self._drawSplitline(points, lineStyleModel, group);\n        }\n\n        show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group);\n        show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group);\n      };\n\n      CalendarView.prototype._getEdgesPoints = function (points, lineWidth, orient) {\n        var rs = [points[0].slice(), points[points.length - 1].slice()];\n        var idx = orient === 'horizontal' ? 0 : 1;\n        rs[0][idx] = rs[0][idx] - lineWidth / 2;\n        rs[1][idx] = rs[1][idx] + lineWidth / 2;\n        return rs;\n      };\n\n      CalendarView.prototype._drawSplitline = function (points, lineStyle, group) {\n        var poyline = new Polyline({\n          z2: 20,\n          shape: {\n            points: points\n          },\n          style: lineStyle\n        });\n        group.add(poyline);\n      };\n\n      CalendarView.prototype._getLinePointsOfOneWeek = function (calendarModel, date, orient) {\n        var coordSys = calendarModel.coordinateSystem;\n        var parsedDate = coordSys.getDateInfo(date);\n        var points = [];\n\n        for (var i = 0; i < 7; i++) {\n          var tmpD = coordSys.getNextNDay(parsedDate.time, i);\n          var point = coordSys.dataToRect([tmpD.time], false);\n          points[2 * tmpD.day] = point.tl;\n          points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr'];\n        }\n\n        return points;\n      };\n\n      CalendarView.prototype._formatterLabel = function (formatter, params) {\n        if (typeof formatter === 'string' && formatter) {\n          return formatTplSimple(formatter, params);\n        }\n\n        if (typeof formatter === 'function') {\n          return formatter(params);\n        }\n\n        return params.nameMap;\n      };\n\n      CalendarView.prototype._yearTextPositionControl = function (textEl, point, orient, position, margin) {\n        var x = point[0];\n        var y = point[1];\n        var aligns = ['center', 'bottom'];\n\n        if (position === 'bottom') {\n          y += margin;\n          aligns = ['center', 'top'];\n        } else if (position === 'left') {\n          x -= margin;\n        } else if (position === 'right') {\n          x += margin;\n          aligns = ['center', 'top'];\n        } else {\n          y -= margin;\n        }\n\n        var rotate = 0;\n\n        if (position === 'left' || position === 'right') {\n          rotate = Math.PI / 2;\n        }\n\n        return {\n          rotation: rotate,\n          x: x,\n          y: y,\n          style: {\n            align: aligns[0],\n            verticalAlign: aligns[1]\n          }\n        };\n      };\n\n      CalendarView.prototype._renderYearText = function (calendarModel, rangeData, orient, group) {\n        var yearLabel = calendarModel.getModel('yearLabel');\n\n        if (!yearLabel.get('show')) {\n          return;\n        }\n\n        var margin = yearLabel.get('margin');\n        var pos = yearLabel.get('position');\n\n        if (!pos) {\n          pos = orient !== 'horizontal' ? 'top' : 'left';\n        }\n\n        var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];\n        var xc = (points[0][0] + points[1][0]) / 2;\n        var yc = (points[0][1] + points[1][1]) / 2;\n        var idx = orient === 'horizontal' ? 0 : 1;\n        var posPoints = {\n          top: [xc, points[idx][1]],\n          bottom: [xc, points[1 - idx][1]],\n          left: [points[1 - idx][0], yc],\n          right: [points[idx][0], yc]\n        };\n        var name = rangeData.start.y;\n\n        if (+rangeData.end.y > +rangeData.start.y) {\n          name = name + '-' + rangeData.end.y;\n        }\n\n        var formatter = yearLabel.get('formatter');\n        var params = {\n          start: rangeData.start.y,\n          end: rangeData.end.y,\n          nameMap: name\n        };\n\n        var content = this._formatterLabel(formatter, params);\n\n        var yearText = new ZRText({\n          z2: 30,\n          style: createTextStyle(yearLabel, {\n            text: content\n          })\n        });\n        yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));\n        group.add(yearText);\n      };\n\n      CalendarView.prototype._monthTextPositionControl = function (point, isCenter, orient, position, margin) {\n        var align = 'left';\n        var vAlign = 'top';\n        var x = point[0];\n        var y = point[1];\n\n        if (orient === 'horizontal') {\n          y = y + margin;\n\n          if (isCenter) {\n            align = 'center';\n          }\n\n          if (position === 'start') {\n            vAlign = 'bottom';\n          }\n        } else {\n          x = x + margin;\n\n          if (isCenter) {\n            vAlign = 'middle';\n          }\n\n          if (position === 'start') {\n            align = 'right';\n          }\n        }\n\n        return {\n          x: x,\n          y: y,\n          align: align,\n          verticalAlign: vAlign\n        };\n      };\n\n      CalendarView.prototype._renderMonthText = function (calendarModel, orient, group) {\n        var monthLabel = calendarModel.getModel('monthLabel');\n\n        if (!monthLabel.get('show')) {\n          return;\n        }\n\n        var nameMap = monthLabel.get('nameMap');\n        var margin = monthLabel.get('margin');\n        var pos = monthLabel.get('position');\n        var align = monthLabel.get('align');\n        var termPoints = [this._tlpoints, this._blpoints];\n\n        if (isString(nameMap)) {\n          nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];\n        }\n\n        var idx = pos === 'start' ? 0 : 1;\n        var axis = orient === 'horizontal' ? 0 : 1;\n        margin = pos === 'start' ? -margin : margin;\n        var isCenter = align === 'center';\n\n        for (var i = 0; i < termPoints[idx].length - 1; i++) {\n          var tmp = termPoints[idx][i].slice();\n          var firstDay = this._firstDayOfMonth[i];\n\n          if (isCenter) {\n            var firstDayPoints = this._firstDayPoints[i];\n            tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;\n          }\n\n          var formatter = monthLabel.get('formatter');\n          var name_1 = nameMap[+firstDay.m - 1];\n          var params = {\n            yyyy: firstDay.y,\n            yy: (firstDay.y + '').slice(2),\n            MM: firstDay.m,\n            M: +firstDay.m,\n            nameMap: name_1\n          };\n\n          var content = this._formatterLabel(formatter, params);\n\n          var monthText = new ZRText({\n            z2: 30,\n            style: extend(createTextStyle(monthLabel, {\n              text: content\n            }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))\n          });\n          group.add(monthText);\n        }\n      };\n\n      CalendarView.prototype._weekTextPositionControl = function (point, orient, position, margin, cellSize) {\n        var align = 'center';\n        var vAlign = 'middle';\n        var x = point[0];\n        var y = point[1];\n        var isStart = position === 'start';\n\n        if (orient === 'horizontal') {\n          x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;\n          align = isStart ? 'right' : 'left';\n        } else {\n          y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;\n          vAlign = isStart ? 'bottom' : 'top';\n        }\n\n        return {\n          x: x,\n          y: y,\n          align: align,\n          verticalAlign: vAlign\n        };\n      };\n\n      CalendarView.prototype._renderWeekText = function (calendarModel, rangeData, orient, group) {\n        var dayLabel = calendarModel.getModel('dayLabel');\n\n        if (!dayLabel.get('show')) {\n          return;\n        }\n\n        var coordSys = calendarModel.coordinateSystem;\n        var pos = dayLabel.get('position');\n        var nameMap = dayLabel.get('nameMap');\n        var margin = dayLabel.get('margin');\n        var firstDayOfWeek = coordSys.getFirstDayOfWeek();\n\n        if (isString(nameMap)) {\n          nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];\n        }\n\n        var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;\n        var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];\n        margin = parsePercent$1(margin, cellSize[orient === 'horizontal' ? 0 : 1]);\n\n        if (pos === 'start') {\n          start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;\n          margin = -margin;\n        }\n\n        for (var i = 0; i < 7; i++) {\n          var tmpD = coordSys.getNextNDay(start, i);\n          var point = coordSys.dataToRect([tmpD.time], false).center;\n          var day = i;\n          day = Math.abs((i + firstDayOfWeek) % 7);\n          var weekText = new ZRText({\n            z2: 30,\n            style: extend(createTextStyle(dayLabel, {\n              text: nameMap[day]\n            }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))\n          });\n          group.add(weekText);\n        }\n      };\n\n      CalendarView.type = 'calendar';\n      return CalendarView;\n    }(ComponentView);\n\n    var PROXIMATE_ONE_DAY = 86400000;\n\n    var Calendar = function () {\n      function Calendar(calendarModel, ecModel, api) {\n        this.type = 'calendar';\n        this.dimensions = Calendar.dimensions;\n        this.getDimensionsInfo = Calendar.getDimensionsInfo;\n        this._model = calendarModel;\n      }\n\n      Calendar.getDimensionsInfo = function () {\n        return [{\n          name: 'time',\n          type: 'time'\n        }, 'value'];\n      };\n\n      Calendar.prototype.getRangeInfo = function () {\n        return this._rangeInfo;\n      };\n\n      Calendar.prototype.getModel = function () {\n        return this._model;\n      };\n\n      Calendar.prototype.getRect = function () {\n        return this._rect;\n      };\n\n      Calendar.prototype.getCellWidth = function () {\n        return this._sw;\n      };\n\n      Calendar.prototype.getCellHeight = function () {\n        return this._sh;\n      };\n\n      Calendar.prototype.getOrient = function () {\n        return this._orient;\n      };\n\n      Calendar.prototype.getFirstDayOfWeek = function () {\n        return this._firstDayOfWeek;\n      };\n\n      Calendar.prototype.getDateInfo = function (date) {\n        date = parseDate(date);\n        var y = date.getFullYear();\n        var m = date.getMonth() + 1;\n        var mStr = m < 10 ? '0' + m : '' + m;\n        var d = date.getDate();\n        var dStr = d < 10 ? '0' + d : '' + d;\n        var day = date.getDay();\n        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);\n        return {\n          y: y + '',\n          m: mStr,\n          d: dStr,\n          day: day,\n          time: date.getTime(),\n          formatedDate: y + '-' + mStr + '-' + dStr,\n          date: date\n        };\n      };\n\n      Calendar.prototype.getNextNDay = function (date, n) {\n        n = n || 0;\n\n        if (n === 0) {\n          return this.getDateInfo(date);\n        }\n\n        date = new Date(this.getDateInfo(date).time);\n        date.setDate(date.getDate() + n);\n        return this.getDateInfo(date);\n      };\n\n      Calendar.prototype.update = function (ecModel, api) {\n        this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay');\n        this._orient = this._model.get('orient');\n        this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0;\n        this._rangeInfo = this._getRangeInfo(this._initRangeOption());\n        var weeks = this._rangeInfo.weeks || 1;\n        var whNames = ['width', 'height'];\n\n        var cellSize = this._model.getCellSize().slice();\n\n        var layoutParams = this._model.getBoxLayoutParams();\n\n        var cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks];\n        each([0, 1], function (idx) {\n          if (cellSizeSpecified(cellSize, idx)) {\n            layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];\n          }\n        });\n        var whGlobal = {\n          width: api.getWidth(),\n          height: api.getHeight()\n        };\n        var calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);\n        each([0, 1], function (idx) {\n          if (!cellSizeSpecified(cellSize, idx)) {\n            cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];\n          }\n        });\n\n        function cellSizeSpecified(cellSize, idx) {\n          return cellSize[idx] != null && cellSize[idx] !== 'auto';\n        }\n\n        this._sw = cellSize[0];\n        this._sh = cellSize[1];\n      };\n\n      Calendar.prototype.dataToPoint = function (data, clamp) {\n        isArray(data) && (data = data[0]);\n        clamp == null && (clamp = true);\n        var dayInfo = this.getDateInfo(data);\n        var range = this._rangeInfo;\n        var date = dayInfo.formatedDate;\n\n        if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {\n          return [NaN, NaN];\n        }\n\n        var week = dayInfo.day;\n\n        var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;\n\n        if (this._orient === 'vertical') {\n          return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];\n        }\n\n        return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];\n      };\n\n      Calendar.prototype.pointToData = function (point) {\n        var date = this.pointToDate(point);\n        return date && date.time;\n      };\n\n      Calendar.prototype.dataToRect = function (data, clamp) {\n        var point = this.dataToPoint(data, clamp);\n        return {\n          contentShape: {\n            x: point[0] - (this._sw - this._lineWidth) / 2,\n            y: point[1] - (this._sh - this._lineWidth) / 2,\n            width: this._sw - this._lineWidth,\n            height: this._sh - this._lineWidth\n          },\n          center: point,\n          tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],\n          tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],\n          br: [point[0] + this._sw / 2, point[1] + this._sh / 2],\n          bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]\n        };\n      };\n\n      Calendar.prototype.pointToDate = function (point) {\n        var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;\n        var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;\n        var range = this._rangeInfo.range;\n\n        if (this._orient === 'vertical') {\n          return this._getDateByWeeksAndDay(nthY, nthX - 1, range);\n        }\n\n        return this._getDateByWeeksAndDay(nthX, nthY - 1, range);\n      };\n\n      Calendar.prototype.convertToPixel = function (ecModel, finder, value) {\n        var coordSys = getCoordSys$4(finder);\n        return coordSys === this ? coordSys.dataToPoint(value) : null;\n      };\n\n      Calendar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n        var coordSys = getCoordSys$4(finder);\n        return coordSys === this ? coordSys.pointToData(pixel) : null;\n      };\n\n      Calendar.prototype.containPoint = function (point) {\n        console.warn('Not implemented.');\n        return false;\n      };\n\n      Calendar.prototype._initRangeOption = function () {\n        var range = this._model.get('range');\n\n        var normalizedRange;\n\n        if (isArray(range) && range.length === 1) {\n          range = range[0];\n        }\n\n        if (!isArray(range)) {\n          var rangeStr = range.toString();\n\n          if (/^\\d{4}$/.test(rangeStr)) {\n            normalizedRange = [rangeStr + '-01-01', rangeStr + '-12-31'];\n          }\n\n          if (/^\\d{4}[\\/|-]\\d{1,2}$/.test(rangeStr)) {\n            var start = this.getDateInfo(rangeStr);\n            var firstDay = start.date;\n            firstDay.setMonth(firstDay.getMonth() + 1);\n            var end = this.getNextNDay(firstDay, -1);\n            normalizedRange = [start.formatedDate, end.formatedDate];\n          }\n\n          if (/^\\d{4}[\\/|-]\\d{1,2}[\\/|-]\\d{1,2}$/.test(rangeStr)) {\n            normalizedRange = [rangeStr, rangeStr];\n          }\n        } else {\n          normalizedRange = range;\n        }\n\n        if (!normalizedRange) {\n          if (\"development\" !== 'production') {\n            logError('Invalid date range.');\n          }\n\n          return range;\n        }\n\n        var tmp = this._getRangeInfo(normalizedRange);\n\n        if (tmp.start.time > tmp.end.time) {\n          normalizedRange.reverse();\n        }\n\n        return normalizedRange;\n      };\n\n      Calendar.prototype._getRangeInfo = function (range) {\n        var parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];\n        var reversed;\n\n        if (parsedRange[0].time > parsedRange[1].time) {\n          reversed = true;\n          parsedRange.reverse();\n        }\n\n        var allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;\n        var date = new Date(parsedRange[0].time);\n        var startDateNum = date.getDate();\n        var endDateNum = parsedRange[1].date.getDate();\n        date.setDate(startDateNum + allDay - 1);\n        var dateNum = date.getDate();\n\n        if (dateNum !== endDateNum) {\n          var sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;\n\n          while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {\n            allDay -= sign;\n            date.setDate(dateNum - sign);\n          }\n        }\n\n        var weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);\n        var nthWeek = reversed ? -weeks + 1 : weeks - 1;\n        reversed && parsedRange.reverse();\n        return {\n          range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],\n          start: parsedRange[0],\n          end: parsedRange[1],\n          allDay: allDay,\n          weeks: weeks,\n          nthWeek: nthWeek,\n          fweek: parsedRange[0].day,\n          lweek: parsedRange[1].day\n        };\n      };\n\n      Calendar.prototype._getDateByWeeksAndDay = function (nthWeek, day, range) {\n        var rangeInfo = this._getRangeInfo(range);\n\n        if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {\n          return null;\n        }\n\n        var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;\n        var date = new Date(rangeInfo.start.time);\n        date.setDate(+rangeInfo.start.d + nthDay);\n        return this.getDateInfo(date);\n      };\n\n      Calendar.create = function (ecModel, api) {\n        var calendarList = [];\n        ecModel.eachComponent('calendar', function (calendarModel) {\n          var calendar = new Calendar(calendarModel, ecModel, api);\n          calendarList.push(calendar);\n          calendarModel.coordinateSystem = calendar;\n        });\n        ecModel.eachSeries(function (calendarSeries) {\n          if (calendarSeries.get('coordinateSystem') === 'calendar') {\n            calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0];\n          }\n        });\n        return calendarList;\n      };\n\n      Calendar.dimensions = ['time', 'value'];\n      return Calendar;\n    }();\n\n    function getCoordSys$4(finder) {\n      var calendarModel = finder.calendarModel;\n      var seriesModel = finder.seriesModel;\n      var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;\n      return coordSys;\n    }\n\n    function install$w(registers) {\n      registers.registerComponentModel(CalendarModel);\n      registers.registerComponentView(CalendarView);\n      registers.registerCoordinateSystem('calendar', Calendar);\n    }\n\n    var inner$g = makeInner();\n    var _nonShapeGraphicElements = {\n      path: null,\n      compoundPath: null,\n      group: Group,\n      image: ZRImage,\n      text: ZRText\n    };\n\n    var preprocessor = function (option) {\n      var graphicOption = option.graphic;\n\n      if (isArray(graphicOption)) {\n        if (!graphicOption[0] || !graphicOption[0].elements) {\n          option.graphic = [{\n            elements: graphicOption\n          }];\n        } else {\n          option.graphic = [option.graphic[0]];\n        }\n      } else if (graphicOption && !graphicOption.elements) {\n        option.graphic = [{\n          elements: [graphicOption]\n        }];\n      }\n    };\n\n    var GraphicComponentModel = function (_super) {\n      __extends(GraphicComponentModel, _super);\n\n      function GraphicComponentModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GraphicComponentModel.type;\n        return _this;\n      }\n\n      GraphicComponentModel.prototype.mergeOption = function (option, ecModel) {\n        var elements = this.option.elements;\n        this.option.elements = null;\n\n        _super.prototype.mergeOption.call(this, option, ecModel);\n\n        this.option.elements = elements;\n      };\n\n      GraphicComponentModel.prototype.optionUpdated = function (newOption, isInit) {\n        var thisOption = this.option;\n        var newList = (isInit ? thisOption : newOption).elements;\n        var existList = thisOption.elements = isInit ? [] : thisOption.elements;\n        var flattenedList = [];\n\n        this._flatten(newList, flattenedList, null);\n\n        var mappingResult = mappingToExists(existList, flattenedList, 'normalMerge');\n        var elOptionsToUpdate = this._elOptionsToUpdate = [];\n        each(mappingResult, function (resultItem, index) {\n          var newElOption = resultItem.newOption;\n\n          if (\"development\" !== 'production') {\n            assert(isObject(newElOption) || resultItem.existing, 'Empty graphic option definition');\n          }\n\n          if (!newElOption) {\n            return;\n          }\n\n          elOptionsToUpdate.push(newElOption);\n          setKeyInfoToNewElOption(resultItem, newElOption);\n          mergeNewElOptionToExist(existList, index, newElOption);\n          setLayoutInfoToExist(existList[index], newElOption);\n        }, this);\n\n        for (var i = existList.length - 1; i >= 0; i--) {\n          if (existList[i] == null) {\n            existList.splice(i, 1);\n          } else {\n            delete existList[i].$action;\n          }\n        }\n      };\n\n      GraphicComponentModel.prototype._flatten = function (optionList, result, parentOption) {\n        each(optionList, function (option) {\n          if (!option) {\n            return;\n          }\n\n          if (parentOption) {\n            option.parentOption = parentOption;\n          }\n\n          result.push(option);\n          var children = option.children;\n\n          if (option.type === 'group' && children) {\n            this._flatten(children, result, option);\n          }\n\n          delete option.children;\n        }, this);\n      };\n\n      GraphicComponentModel.prototype.useElOptionsToUpdate = function () {\n        var els = this._elOptionsToUpdate;\n        this._elOptionsToUpdate = null;\n        return els;\n      };\n\n      GraphicComponentModel.type = 'graphic';\n      GraphicComponentModel.defaultOption = {\n        elements: []\n      };\n      return GraphicComponentModel;\n    }(ComponentModel);\n\n    var GraphicComponentView = function (_super) {\n      __extends(GraphicComponentView, _super);\n\n      function GraphicComponentView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = GraphicComponentView.type;\n        return _this;\n      }\n\n      GraphicComponentView.prototype.init = function () {\n        this._elMap = createHashMap();\n      };\n\n      GraphicComponentView.prototype.render = function (graphicModel, ecModel, api) {\n        if (graphicModel !== this._lastGraphicModel) {\n          this._clear();\n        }\n\n        this._lastGraphicModel = graphicModel;\n\n        this._updateElements(graphicModel);\n\n        this._relocate(graphicModel, api);\n      };\n\n      GraphicComponentView.prototype._updateElements = function (graphicModel) {\n        var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();\n\n        if (!elOptionsToUpdate) {\n          return;\n        }\n\n        var elMap = this._elMap;\n        var rootGroup = this.group;\n        each(elOptionsToUpdate, function (elOption) {\n          var id = convertOptionIdName(elOption.id, null);\n          var elExisting = id != null ? elMap.get(id) : null;\n          var parentId = convertOptionIdName(elOption.parentId, null);\n          var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;\n          var elType = elOption.type;\n          var elOptionStyle = elOption.style;\n\n          if (elType === 'text' && elOptionStyle) {\n            if (elOption.hv && elOption.hv[1]) {\n              elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;\n            }\n          }\n\n          var textContentOption = elOption.textContent;\n          var textConfig = elOption.textConfig;\n\n          if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {\n            var convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);\n\n            if (!textConfig && convertResult.textConfig) {\n              textConfig = elOption.textConfig = convertResult.textConfig;\n            }\n\n            if (!textContentOption && convertResult.textContent) {\n              textContentOption = convertResult.textContent;\n            }\n          }\n\n          var elOptionCleaned = getCleanedElOption(elOption);\n\n          if (\"development\" !== 'production') {\n            elExisting && assert(targetElParent === elExisting.parent, 'Changing parent is not supported.');\n          }\n\n          var $action = elOption.$action || 'merge';\n\n          if ($action === 'merge') {\n            elExisting ? elExisting.attr(elOptionCleaned) : createEl$1(id, targetElParent, elOptionCleaned, elMap);\n          } else if ($action === 'replace') {\n            removeEl(elExisting, elMap);\n            createEl$1(id, targetElParent, elOptionCleaned, elMap);\n          } else if ($action === 'remove') {\n            removeEl(elExisting, elMap);\n          }\n\n          var el = elMap.get(id);\n\n          if (el && textContentOption) {\n            if ($action === 'merge') {\n              var textContentExisting = el.getTextContent();\n              textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new ZRText(textContentOption));\n            } else if ($action === 'replace') {\n              el.setTextContent(new ZRText(textContentOption));\n            }\n          }\n\n          if (el) {\n            var elInner = inner$g(el);\n            elInner.__ecGraphicWidthOption = elOption.width;\n            elInner.__ecGraphicHeightOption = elOption.height;\n            setEventData(el, graphicModel, elOption);\n          }\n        });\n      };\n\n      GraphicComponentView.prototype._relocate = function (graphicModel, api) {\n        var elOptions = graphicModel.option.elements;\n        var rootGroup = this.group;\n        var elMap = this._elMap;\n        var apiWidth = api.getWidth();\n        var apiHeight = api.getHeight();\n\n        for (var i = 0; i < elOptions.length; i++) {\n          var elOption = elOptions[i];\n          var id = convertOptionIdName(elOption.id, null);\n          var el = id != null ? elMap.get(id) : null;\n\n          if (!el || !el.isGroup) {\n            continue;\n          }\n\n          var parentEl = el.parent;\n          var isParentRoot = parentEl === rootGroup;\n          var elInner = inner$g(el);\n          var parentElInner = inner$g(parentEl);\n          elInner.__ecGraphicWidth = parsePercent$1(elInner.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentElInner.__ecGraphicWidth) || 0;\n          elInner.__ecGraphicHeight = parsePercent$1(elInner.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentElInner.__ecGraphicHeight) || 0;\n        }\n\n        for (var i = elOptions.length - 1; i >= 0; i--) {\n          var elOption = elOptions[i];\n          var id = convertOptionIdName(elOption.id, null);\n          var el = id != null ? elMap.get(id) : null;\n\n          if (!el) {\n            continue;\n          }\n\n          var parentEl = el.parent;\n          var parentElInner = inner$g(parentEl);\n          var containerInfo = parentEl === rootGroup ? {\n            width: apiWidth,\n            height: apiHeight\n          } : {\n            width: parentElInner.__ecGraphicWidth,\n            height: parentElInner.__ecGraphicHeight\n          };\n          positionElement(el, elOption, containerInfo, null, {\n            hv: elOption.hv,\n            boundingMode: elOption.bounding\n          });\n        }\n      };\n\n      GraphicComponentView.prototype._clear = function () {\n        var elMap = this._elMap;\n        elMap.each(function (el) {\n          removeEl(el, elMap);\n        });\n        this._elMap = createHashMap();\n      };\n\n      GraphicComponentView.prototype.dispose = function () {\n        this._clear();\n      };\n\n      GraphicComponentView.type = 'graphic';\n      return GraphicComponentView;\n    }(ComponentView);\n\n    function createEl$1(id, targetElParent, elOption, elMap) {\n      var graphicType = elOption.type;\n\n      if (\"development\" !== 'production') {\n        assert(graphicType, 'graphic type MUST be set');\n      }\n\n      var Clz = hasOwn(_nonShapeGraphicElements, graphicType) ? _nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);\n\n      if (\"development\" !== 'production') {\n        assert(Clz, 'graphic type can not be found');\n      }\n\n      var el = new Clz(elOption);\n      targetElParent.add(el);\n      elMap.set(id, el);\n      inner$g(el).__ecGraphicId = id;\n    }\n\n    function removeEl(elExisting, elMap) {\n      var existElParent = elExisting && elExisting.parent;\n\n      if (existElParent) {\n        elExisting.type === 'group' && elExisting.traverse(function (el) {\n          removeEl(el, elMap);\n        });\n        elMap.removeKey(inner$g(elExisting).__ecGraphicId);\n        existElParent.remove(elExisting);\n      }\n    }\n\n    function getCleanedElOption(elOption) {\n      elOption = extend({}, elOption);\n      each(['id', 'parentId', '$action', 'hv', 'bounding', 'textContent'].concat(LOCATION_PARAMS), function (name) {\n        delete elOption[name];\n      });\n      return elOption;\n    }\n\n    function isSetLoc(obj, props) {\n      var isSet;\n      each(props, function (prop) {\n        obj[prop] != null && obj[prop] !== 'auto' && (isSet = true);\n      });\n      return isSet;\n    }\n\n    function setKeyInfoToNewElOption(resultItem, newElOption) {\n      var existElOption = resultItem.existing;\n      newElOption.id = resultItem.keyInfo.id;\n      !newElOption.type && existElOption && (newElOption.type = existElOption.type);\n\n      if (newElOption.parentId == null) {\n        var newElParentOption = newElOption.parentOption;\n\n        if (newElParentOption) {\n          newElOption.parentId = newElParentOption.id;\n        } else if (existElOption) {\n          newElOption.parentId = existElOption.parentId;\n        }\n      }\n\n      newElOption.parentOption = null;\n    }\n\n    function mergeNewElOptionToExist(existList, index, newElOption) {\n      var newElOptCopy = extend({}, newElOption);\n      var existElOption = existList[index];\n      var $action = newElOption.$action || 'merge';\n\n      if ($action === 'merge') {\n        if (existElOption) {\n          if (\"development\" !== 'production') {\n            var newType = newElOption.type;\n            assert(!newType || existElOption.type === newType, 'Please set $action: \"replace\" to change `type`');\n          }\n\n          merge(existElOption, newElOptCopy, true);\n          mergeLayoutParam(existElOption, newElOptCopy, {\n            ignoreSize: true\n          });\n          copyLayoutParams(newElOption, existElOption);\n        } else {\n          existList[index] = newElOptCopy;\n        }\n      } else if ($action === 'replace') {\n        existList[index] = newElOptCopy;\n      } else if ($action === 'remove') {\n        existElOption && (existList[index] = null);\n      }\n    }\n\n    function setLayoutInfoToExist(existItem, newElOption) {\n      if (!existItem) {\n        return;\n      }\n\n      existItem.hv = newElOption.hv = [isSetLoc(newElOption, ['left', 'right']), isSetLoc(newElOption, ['top', 'bottom'])];\n\n      if (existItem.type === 'group') {\n        var existingGroupOpt = existItem;\n        var newGroupOpt = newElOption;\n        existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);\n        existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);\n      }\n    }\n\n    function setEventData(el, graphicModel, elOption) {\n      var eventData = getECData(el).eventData;\n\n      if (!el.silent && !el.ignore && !eventData) {\n        eventData = getECData(el).eventData = {\n          componentType: 'graphic',\n          componentIndex: graphicModel.componentIndex,\n          name: el.name\n        };\n      }\n\n      if (eventData) {\n        eventData.info = elOption.info;\n      }\n    }\n\n    function install$x(registers) {\n      registers.registerComponentModel(GraphicComponentModel);\n      registers.registerComponentView(GraphicComponentView);\n      registers.registerPreprocessor(preprocessor);\n    }\n\n    var DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single'];\n    var SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis'];\n    function isCoordSupported(seriesModel) {\n      var coordType = seriesModel.get('coordinateSystem');\n      return indexOf(SERIES_COORDS, coordType) >= 0;\n    }\n    function getAxisMainType(axisDim) {\n      if (\"development\" !== 'production') {\n        assert(axisDim);\n      }\n\n      return axisDim + 'Axis';\n    }\n    function findEffectedDataZooms(ecModel, payload) {\n      var axisRecords = createHashMap();\n      var effectedModels = [];\n      var effectedModelMap = createHashMap();\n      ecModel.eachComponent({\n        mainType: 'dataZoom',\n        query: payload\n      }, function (dataZoomModel) {\n        if (!effectedModelMap.get(dataZoomModel.uid)) {\n          addToEffected(dataZoomModel);\n        }\n      });\n      var foundNewLink;\n\n      do {\n        foundNewLink = false;\n        ecModel.eachComponent('dataZoom', processSingle);\n      } while (foundNewLink);\n\n      function processSingle(dataZoomModel) {\n        if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {\n          addToEffected(dataZoomModel);\n          foundNewLink = true;\n        }\n      }\n\n      function addToEffected(dataZoom) {\n        effectedModelMap.set(dataZoom.uid, true);\n        effectedModels.push(dataZoom);\n        markAxisControlled(dataZoom);\n      }\n\n      function isLinked(dataZoomModel) {\n        var isLink = false;\n        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n          var axisIdxArr = axisRecords.get(axisDim);\n\n          if (axisIdxArr && axisIdxArr[axisIndex]) {\n            isLink = true;\n          }\n        });\n        return isLink;\n      }\n\n      function markAxisControlled(dataZoomModel) {\n        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n          (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;\n        });\n      }\n\n      return effectedModels;\n    }\n    function collectReferCoordSysModelInfo(dataZoomModel) {\n      var ecModel = dataZoomModel.ecModel;\n      var coordSysInfoWrap = {\n        infoList: [],\n        infoMap: createHashMap()\n      };\n      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n        var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n\n        if (!axisModel) {\n          return;\n        }\n\n        var coordSysModel = axisModel.getCoordSysModel();\n\n        if (!coordSysModel) {\n          return;\n        }\n\n        var coordSysUid = coordSysModel.uid;\n        var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);\n\n        if (!coordSysInfo) {\n          coordSysInfo = {\n            model: coordSysModel,\n            axisModels: []\n          };\n          coordSysInfoWrap.infoList.push(coordSysInfo);\n          coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);\n        }\n\n        coordSysInfo.axisModels.push(axisModel);\n      });\n      return coordSysInfoWrap;\n    }\n\n    var DataZoomAxisInfo = function () {\n      function DataZoomAxisInfo() {\n        this.indexList = [];\n        this.indexMap = [];\n      }\n\n      DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {\n        if (!this.indexMap[axisCmptIdx]) {\n          this.indexList.push(axisCmptIdx);\n          this.indexMap[axisCmptIdx] = true;\n        }\n      };\n\n      return DataZoomAxisInfo;\n    }();\n\n    var DataZoomModel = function (_super) {\n      __extends(DataZoomModel, _super);\n\n      function DataZoomModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = DataZoomModel.type;\n        _this._autoThrottle = true;\n        _this._noTarget = true;\n        _this._rangePropMode = ['percent', 'percent'];\n        return _this;\n      }\n\n      DataZoomModel.prototype.init = function (option, parentModel, ecModel) {\n        var inputRawOption = retrieveRawOption(option);\n        this.settledOption = inputRawOption;\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        this._doInit(inputRawOption);\n      };\n\n      DataZoomModel.prototype.mergeOption = function (newOption) {\n        var inputRawOption = retrieveRawOption(newOption);\n        merge(this.option, newOption, true);\n        merge(this.settledOption, inputRawOption, true);\n\n        this._doInit(inputRawOption);\n      };\n\n      DataZoomModel.prototype._doInit = function (inputRawOption) {\n        var thisOption = this.option;\n\n        this._setDefaultThrottle(inputRawOption);\n\n        this._updateRangeUse(inputRawOption);\n\n        var settledOption = this.settledOption;\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n          if (this._rangePropMode[index] === 'value') {\n            thisOption[names[0]] = settledOption[names[0]] = null;\n          }\n        }, this);\n\n        this._resetTarget();\n      };\n\n      DataZoomModel.prototype._resetTarget = function () {\n        var optionOrient = this.get('orient', true);\n        var targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();\n\n        var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);\n\n        if (hasAxisSpecified) {\n          this._orient = optionOrient || this._makeAutoOrientByTargetAxis();\n        } else {\n          this._orient = optionOrient || 'horizontal';\n\n          this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);\n        }\n\n        this._noTarget = true;\n        targetAxisIndexMap.each(function (axisInfo) {\n          if (axisInfo.indexList.length) {\n            this._noTarget = false;\n          }\n        }, this);\n      };\n\n      DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {\n        var hasAxisSpecified = false;\n        each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n          var refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);\n\n          if (!refering.specified) {\n            return;\n          }\n\n          hasAxisSpecified = true;\n          var axisInfo = new DataZoomAxisInfo();\n          each(refering.models, function (axisModel) {\n            axisInfo.add(axisModel.componentIndex);\n          });\n          targetAxisIndexMap.set(axisDim, axisInfo);\n        }, this);\n        return hasAxisSpecified;\n      };\n\n      DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {\n        var ecModel = this.ecModel;\n        var needAuto = true;\n\n        if (needAuto) {\n          var axisDim = orient === 'vertical' ? 'y' : 'x';\n          var axisModels = ecModel.findComponents({\n            mainType: axisDim + 'Axis'\n          });\n          setParallelAxis(axisModels, axisDim);\n        }\n\n        if (needAuto) {\n          var axisModels = ecModel.findComponents({\n            mainType: 'singleAxis',\n            filter: function (axisModel) {\n              return axisModel.get('orient', true) === orient;\n            }\n          });\n          setParallelAxis(axisModels, 'single');\n        }\n\n        function setParallelAxis(axisModels, axisDim) {\n          var axisModel = axisModels[0];\n\n          if (!axisModel) {\n            return;\n          }\n\n          var axisInfo = new DataZoomAxisInfo();\n          axisInfo.add(axisModel.componentIndex);\n          targetAxisIndexMap.set(axisDim, axisInfo);\n          needAuto = false;\n\n          if (axisDim === 'x' || axisDim === 'y') {\n            var gridModel_1 = axisModel.getReferringComponents('grid', SINGLE_REFERRING).models[0];\n            gridModel_1 && each(axisModels, function (axModel) {\n              if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', SINGLE_REFERRING).models[0]) {\n                axisInfo.add(axModel.componentIndex);\n              }\n            });\n          }\n        }\n\n        if (needAuto) {\n          each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {\n            if (!needAuto) {\n              return;\n            }\n\n            var axisModels = ecModel.findComponents({\n              mainType: getAxisMainType(axisDim),\n              filter: function (axisModel) {\n                return axisModel.get('type', true) === 'category';\n              }\n            });\n\n            if (axisModels[0]) {\n              var axisInfo = new DataZoomAxisInfo();\n              axisInfo.add(axisModels[0].componentIndex);\n              targetAxisIndexMap.set(axisDim, axisInfo);\n              needAuto = false;\n            }\n          }, this);\n        }\n      };\n\n      DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {\n        var dim;\n        this.eachTargetAxis(function (axisDim) {\n          !dim && (dim = axisDim);\n        }, this);\n        return dim === 'y' ? 'vertical' : 'horizontal';\n      };\n\n      DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {\n        if (inputRawOption.hasOwnProperty('throttle')) {\n          this._autoThrottle = false;\n        }\n\n        if (this._autoThrottle) {\n          var globalOption = this.ecModel.option;\n          this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;\n        }\n      };\n\n      DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {\n        var rangePropMode = this._rangePropMode;\n        var rangeModeInOption = this.get('rangeMode');\n        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {\n          var percentSpecified = inputRawOption[names[0]] != null;\n          var valueSpecified = inputRawOption[names[1]] != null;\n\n          if (percentSpecified && !valueSpecified) {\n            rangePropMode[index] = 'percent';\n          } else if (!percentSpecified && valueSpecified) {\n            rangePropMode[index] = 'value';\n          } else if (rangeModeInOption) {\n            rangePropMode[index] = rangeModeInOption[index];\n          } else if (percentSpecified) {\n            rangePropMode[index] = 'percent';\n          }\n        });\n      };\n\n      DataZoomModel.prototype.noTarget = function () {\n        return this._noTarget;\n      };\n\n      DataZoomModel.prototype.getFirstTargetAxisModel = function () {\n        var firstAxisModel;\n        this.eachTargetAxis(function (axisDim, axisIndex) {\n          if (firstAxisModel == null) {\n            firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n          }\n        }, this);\n        return firstAxisModel;\n      };\n\n      DataZoomModel.prototype.eachTargetAxis = function (callback, context) {\n        this._targetAxisInfoMap.each(function (axisInfo, axisDim) {\n          each(axisInfo.indexList, function (axisIndex) {\n            callback.call(context, axisDim, axisIndex);\n          });\n        });\n      };\n\n      DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {\n        var axisModel = this.getAxisModel(axisDim, axisIndex);\n\n        if (axisModel) {\n          return axisModel.__dzAxisProxy;\n        }\n      };\n\n      DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {\n        if (\"development\" !== 'production') {\n          assert(axisDim && axisIndex != null);\n        }\n\n        var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n        if (axisInfo && axisInfo.indexMap[axisIndex]) {\n          return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n        }\n      };\n\n      DataZoomModel.prototype.setRawRange = function (opt) {\n        var thisOption = this.option;\n        var settledOption = this.settledOption;\n        each([['start', 'startValue'], ['end', 'endValue']], function (names) {\n          if (opt[names[0]] != null || opt[names[1]] != null) {\n            thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];\n            thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];\n          }\n        }, this);\n\n        this._updateRangeUse(opt);\n      };\n\n      DataZoomModel.prototype.setCalculatedRange = function (opt) {\n        var option = this.option;\n        each(['start', 'startValue', 'end', 'endValue'], function (name) {\n          option[name] = opt[name];\n        });\n      };\n\n      DataZoomModel.prototype.getPercentRange = function () {\n        var axisProxy = this.findRepresentativeAxisProxy();\n\n        if (axisProxy) {\n          return axisProxy.getDataPercentWindow();\n        }\n      };\n\n      DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {\n        if (axisDim == null && axisIndex == null) {\n          var axisProxy = this.findRepresentativeAxisProxy();\n\n          if (axisProxy) {\n            return axisProxy.getDataValueWindow();\n          }\n        } else {\n          return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();\n        }\n      };\n\n      DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {\n        if (axisModel) {\n          return axisModel.__dzAxisProxy;\n        }\n\n        var firstProxy;\n\n        var axisDimList = this._targetAxisInfoMap.keys();\n\n        for (var i = 0; i < axisDimList.length; i++) {\n          var axisDim = axisDimList[i];\n\n          var axisInfo = this._targetAxisInfoMap.get(axisDim);\n\n          for (var j = 0; j < axisInfo.indexList.length; j++) {\n            var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);\n\n            if (proxy.hostedBy(this)) {\n              return proxy;\n            }\n\n            if (!firstProxy) {\n              firstProxy = proxy;\n            }\n          }\n        }\n\n        return firstProxy;\n      };\n\n      DataZoomModel.prototype.getRangePropMode = function () {\n        return this._rangePropMode.slice();\n      };\n\n      DataZoomModel.prototype.getOrient = function () {\n        if (\"development\" !== 'production') {\n          assert(this._orient);\n        }\n\n        return this._orient;\n      };\n\n      DataZoomModel.type = 'dataZoom';\n      DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];\n      DataZoomModel.defaultOption = {\n        zlevel: 0,\n        z: 4,\n        filterMode: 'filter',\n        start: 0,\n        end: 100\n      };\n      return DataZoomModel;\n    }(ComponentModel);\n\n    function retrieveRawOption(option) {\n      var ret = {};\n      each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {\n        option.hasOwnProperty(name) && (ret[name] = option[name]);\n      });\n      return ret;\n    }\n\n    var SelectDataZoomModel = function (_super) {\n      __extends(SelectDataZoomModel, _super);\n\n      function SelectDataZoomModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SelectDataZoomModel.type;\n        return _this;\n      }\n\n      SelectDataZoomModel.type = 'dataZoom.select';\n      return SelectDataZoomModel;\n    }(DataZoomModel);\n\n    var DataZoomView = function (_super) {\n      __extends(DataZoomView, _super);\n\n      function DataZoomView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = DataZoomView.type;\n        return _this;\n      }\n\n      DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n        this.dataZoomModel = dataZoomModel;\n        this.ecModel = ecModel;\n        this.api = api;\n      };\n\n      DataZoomView.type = 'dataZoom';\n      return DataZoomView;\n    }(ComponentView);\n\n    var SelectDataZoomView = function (_super) {\n      __extends(SelectDataZoomView, _super);\n\n      function SelectDataZoomView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SelectDataZoomView.type;\n        return _this;\n      }\n\n      SelectDataZoomView.type = 'dataZoom.select';\n      return SelectDataZoomView;\n    }(DataZoomView);\n\n    var each$9 = each;\n    var asc$1 = asc;\n\n    var AxisProxy = function () {\n      function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {\n        this._dimName = dimName;\n        this._axisIndex = axisIndex;\n        this.ecModel = ecModel;\n        this._dataZoomModel = dataZoomModel;\n      }\n\n      AxisProxy.prototype.hostedBy = function (dataZoomModel) {\n        return this._dataZoomModel === dataZoomModel;\n      };\n\n      AxisProxy.prototype.getDataValueWindow = function () {\n        return this._valueWindow.slice();\n      };\n\n      AxisProxy.prototype.getDataPercentWindow = function () {\n        return this._percentWindow.slice();\n      };\n\n      AxisProxy.prototype.getTargetSeriesModels = function () {\n        var seriesModels = [];\n        this.ecModel.eachSeries(function (seriesModel) {\n          if (isCoordSupported(seriesModel)) {\n            var axisMainType = getAxisMainType(this._dimName);\n            var axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];\n\n            if (axisModel && this._axisIndex === axisModel.componentIndex) {\n              seriesModels.push(seriesModel);\n            }\n          }\n        }, this);\n        return seriesModels;\n      };\n\n      AxisProxy.prototype.getAxisModel = function () {\n        return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);\n      };\n\n      AxisProxy.prototype.getMinMaxSpan = function () {\n        return clone(this._minMaxSpan);\n      };\n\n      AxisProxy.prototype.calculateDataWindow = function (opt) {\n        var dataExtent = this._dataExtent;\n        var axisModel = this.getAxisModel();\n        var scale = axisModel.axis.scale;\n\n        var rangePropMode = this._dataZoomModel.getRangePropMode();\n\n        var percentExtent = [0, 100];\n        var percentWindow = [];\n        var valueWindow = [];\n        var hasPropModeValue;\n        each$9(['start', 'end'], function (prop, idx) {\n          var boundPercent = opt[prop];\n          var boundValue = opt[prop + 'Value'];\n\n          if (rangePropMode[idx] === 'percent') {\n            boundPercent == null && (boundPercent = percentExtent[idx]);\n            boundValue = scale.parse(linearMap(boundPercent, percentExtent, dataExtent));\n          } else {\n            hasPropModeValue = true;\n            boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);\n            boundPercent = linearMap(boundValue, dataExtent, percentExtent);\n          }\n\n          valueWindow[idx] = boundValue;\n          percentWindow[idx] = boundPercent;\n        });\n        asc$1(valueWindow);\n        asc$1(percentWindow);\n        var spans = this._minMaxSpan;\n        hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);\n\n        function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {\n          var suffix = toValue ? 'Span' : 'ValueSpan';\n          sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);\n\n          for (var i = 0; i < 2; i++) {\n            toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true);\n            toValue && (toWindow[i] = scale.parse(toWindow[i]));\n          }\n        }\n\n        return {\n          valueWindow: valueWindow,\n          percentWindow: percentWindow\n        };\n      };\n\n      AxisProxy.prototype.reset = function (dataZoomModel) {\n        if (dataZoomModel !== this._dataZoomModel) {\n          return;\n        }\n\n        var targetSeries = this.getTargetSeriesModels();\n        this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);\n\n        this._updateMinMaxSpan();\n\n        var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);\n        this._valueWindow = dataWindow.valueWindow;\n        this._percentWindow = dataWindow.percentWindow;\n\n        this._setAxisModel();\n      };\n\n      AxisProxy.prototype.filterData = function (dataZoomModel, api) {\n        if (dataZoomModel !== this._dataZoomModel) {\n          return;\n        }\n\n        var axisDim = this._dimName;\n        var seriesModels = this.getTargetSeriesModels();\n        var filterMode = dataZoomModel.get('filterMode');\n        var valueWindow = this._valueWindow;\n\n        if (filterMode === 'none') {\n          return;\n        }\n\n        each$9(seriesModels, function (seriesModel) {\n          var seriesData = seriesModel.getData();\n          var dataDims = seriesData.mapDimensionsAll(axisDim);\n\n          if (!dataDims.length) {\n            return;\n          }\n\n          if (filterMode === 'weakFilter') {\n            seriesData.filterSelf(function (dataIndex) {\n              var leftOut;\n              var rightOut;\n              var hasValue;\n\n              for (var i = 0; i < dataDims.length; i++) {\n                var value = seriesData.get(dataDims[i], dataIndex);\n                var thisHasValue = !isNaN(value);\n                var thisLeftOut = value < valueWindow[0];\n                var thisRightOut = value > valueWindow[1];\n\n                if (thisHasValue && !thisLeftOut && !thisRightOut) {\n                  return true;\n                }\n\n                thisHasValue && (hasValue = true);\n                thisLeftOut && (leftOut = true);\n                thisRightOut && (rightOut = true);\n              }\n\n              return hasValue && leftOut && rightOut;\n            });\n          } else {\n            each$9(dataDims, function (dim) {\n              if (filterMode === 'empty') {\n                seriesModel.setData(seriesData = seriesData.map(dim, function (value) {\n                  return !isInWindow(value) ? NaN : value;\n                }));\n              } else {\n                var range = {};\n                range[dim] = valueWindow;\n                seriesData.selectRange(range);\n              }\n            });\n          }\n\n          each$9(dataDims, function (dim) {\n            seriesData.setApproximateExtent(valueWindow, dim);\n          });\n        });\n\n        function isInWindow(value) {\n          return value >= valueWindow[0] && value <= valueWindow[1];\n        }\n      };\n\n      AxisProxy.prototype._updateMinMaxSpan = function () {\n        var minMaxSpan = this._minMaxSpan = {};\n        var dataZoomModel = this._dataZoomModel;\n        var dataExtent = this._dataExtent;\n        each$9(['min', 'max'], function (minMax) {\n          var percentSpan = dataZoomModel.get(minMax + 'Span');\n          var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');\n          valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));\n\n          if (valueSpan != null) {\n            percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);\n          } else if (percentSpan != null) {\n            valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];\n          }\n\n          minMaxSpan[minMax + 'Span'] = percentSpan;\n          minMaxSpan[minMax + 'ValueSpan'] = valueSpan;\n        }, this);\n      };\n\n      AxisProxy.prototype._setAxisModel = function () {\n        var axisModel = this.getAxisModel();\n        var percentWindow = this._percentWindow;\n        var valueWindow = this._valueWindow;\n\n        if (!percentWindow) {\n          return;\n        }\n\n        var precision = getPixelPrecision(valueWindow, [0, 500]);\n        precision = Math.min(precision, 20);\n        var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;\n\n        if (percentWindow[0] !== 0) {\n          rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));\n        }\n\n        if (percentWindow[1] !== 100) {\n          rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));\n        }\n\n        rawExtentInfo.freeze();\n      };\n\n      return AxisProxy;\n    }();\n\n    function calculateDataExtent(axisProxy, axisDim, seriesModels) {\n      var dataExtent = [Infinity, -Infinity];\n      each$9(seriesModels, function (seriesModel) {\n        unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);\n      });\n      var axisModel = axisProxy.getAxisModel();\n      var rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();\n      return [rawExtentResult.min, rawExtentResult.max];\n    }\n\n    var dataZoomProcessor = {\n      getTargetSeries: function (ecModel) {\n        function eachAxisModel(cb) {\n          ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n            dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n              var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);\n              cb(axisDim, axisIndex, axisModel, dataZoomModel);\n            });\n          });\n        }\n\n        eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n          axisModel.__dzAxisProxy = null;\n        });\n        var proxyList = [];\n        eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {\n          if (!axisModel.__dzAxisProxy) {\n            axisModel.__dzAxisProxy = new AxisProxy(axisDim, axisIndex, dataZoomModel, ecModel);\n            proxyList.push(axisModel.__dzAxisProxy);\n          }\n        });\n        var seriesModelMap = createHashMap();\n        each(proxyList, function (axisProxy) {\n          each(axisProxy.getTargetSeriesModels(), function (seriesModel) {\n            seriesModelMap.set(seriesModel.uid, seriesModel);\n          });\n        });\n        return seriesModelMap;\n      },\n      overallReset: function (ecModel, api) {\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n          dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n            dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);\n          });\n          dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n            dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);\n          });\n        });\n        ecModel.eachComponent('dataZoom', function (dataZoomModel) {\n          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n          if (axisProxy) {\n            var percentRange = axisProxy.getDataPercentWindow();\n            var valueRange = axisProxy.getDataValueWindow();\n            dataZoomModel.setCalculatedRange({\n              start: percentRange[0],\n              end: percentRange[1],\n              startValue: valueRange[0],\n              endValue: valueRange[1]\n            });\n          }\n        });\n      }\n    };\n\n    function installDataZoomAction(registers) {\n      registers.registerAction('dataZoom', function (payload, ecModel) {\n        var effectedModels = findEffectedDataZooms(ecModel, payload);\n        each(effectedModels, function (dataZoomModel) {\n          dataZoomModel.setRawRange({\n            start: payload.start,\n            end: payload.end,\n            startValue: payload.startValue,\n            endValue: payload.endValue\n          });\n        });\n      });\n    }\n\n    var installed = false;\n    function installCommon(registers) {\n      if (installed) {\n        return;\n      }\n\n      installed = true;\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor);\n      installDataZoomAction(registers);\n      registers.registerSubTypeDefaulter('dataZoom', function () {\n        return 'slider';\n      });\n    }\n\n    function install$y(registers) {\n      registers.registerComponentModel(SelectDataZoomModel);\n      registers.registerComponentView(SelectDataZoomView);\n      installCommon(registers);\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var ToolboxFeature = function () {\n      function ToolboxFeature() {}\n\n      return ToolboxFeature;\n    }();\n    var features = {};\n    function registerFeature(name, ctor) {\n      features[name] = ctor;\n    }\n    function getFeature(name) {\n      return features[name];\n    }\n\n    var ToolboxModel = function (_super) {\n      __extends(ToolboxModel, _super);\n\n      function ToolboxModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ToolboxModel.type;\n        return _this;\n      }\n\n      ToolboxModel.prototype.optionUpdated = function () {\n        _super.prototype.optionUpdated.apply(this, arguments);\n\n        var ecModel = this.ecModel;\n        each(this.option.feature, function (featureOpt, featureName) {\n          var Feature = getFeature(featureName);\n\n          if (Feature) {\n            if (Feature.getDefaultOption) {\n              Feature.defaultOption = Feature.getDefaultOption(ecModel);\n            }\n\n            merge(featureOpt, Feature.defaultOption);\n          }\n        });\n      };\n\n      ToolboxModel.type = 'toolbox';\n      ToolboxModel.layoutMode = {\n        type: 'box',\n        ignoreSize: true\n      };\n      ToolboxModel.defaultOption = {\n        show: true,\n        z: 6,\n        zlevel: 0,\n        orient: 'horizontal',\n        left: 'right',\n        top: 'top',\n        backgroundColor: 'transparent',\n        borderColor: '#ccc',\n        borderRadius: 0,\n        borderWidth: 0,\n        padding: 5,\n        itemSize: 15,\n        itemGap: 8,\n        showTitle: true,\n        iconStyle: {\n          borderColor: '#666',\n          color: 'none'\n        },\n        emphasis: {\n          iconStyle: {\n            borderColor: '#3E98C5'\n          }\n        },\n        tooltip: {\n          show: false\n        }\n      };\n      return ToolboxModel;\n    }(ComponentModel);\n\n    function layout$3(group, componentModel, api) {\n      var boxLayoutParams = componentModel.getBoxLayoutParams();\n      var padding = componentModel.get('padding');\n      var viewportSize = {\n        width: api.getWidth(),\n        height: api.getHeight()\n      };\n      var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);\n      box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);\n      positionElement(group, boxLayoutParams, viewportSize, padding);\n    }\n    function makeBackground(rect, componentModel) {\n      var padding = normalizeCssArray$1(componentModel.get('padding'));\n      var style = componentModel.getItemStyle(['color', 'opacity']);\n      style.fill = componentModel.get('backgroundColor');\n      rect = new Rect({\n        shape: {\n          x: rect.x - padding[3],\n          y: rect.y - padding[0],\n          width: rect.width + padding[1] + padding[3],\n          height: rect.height + padding[0] + padding[2],\n          r: componentModel.get('borderRadius')\n        },\n        style: style,\n        silent: true,\n        z2: -1\n      });\n      return rect;\n    }\n\n    var ToolboxView = function (_super) {\n      __extends(ToolboxView, _super);\n\n      function ToolboxView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      ToolboxView.prototype.render = function (toolboxModel, ecModel, api, payload) {\n        var group = this.group;\n        group.removeAll();\n\n        if (!toolboxModel.get('show')) {\n          return;\n        }\n\n        var itemSize = +toolboxModel.get('itemSize');\n        var featureOpts = toolboxModel.get('feature') || {};\n        var features = this._features || (this._features = {});\n        var featureNames = [];\n        each(featureOpts, function (opt, name) {\n          featureNames.push(name);\n        });\n        new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute();\n        this._featureNames = featureNames;\n\n        function processFeature(newIndex, oldIndex) {\n          var featureName = featureNames[newIndex];\n          var oldName = featureNames[oldIndex];\n          var featureOpt = featureOpts[featureName];\n          var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);\n          var feature;\n\n          if (payload && payload.newTitle != null && payload.featureName === featureName) {\n            featureOpt.title = payload.newTitle;\n          }\n\n          if (featureName && !oldName) {\n            if (isUserFeatureName(featureName)) {\n              feature = {\n                onclick: featureModel.option.onclick,\n                featureName: featureName\n              };\n            } else {\n              var Feature = getFeature(featureName);\n\n              if (!Feature) {\n                return;\n              }\n\n              feature = new Feature();\n            }\n\n            features[featureName] = feature;\n          } else {\n            feature = features[oldName];\n\n            if (!feature) {\n              return;\n            }\n          }\n\n          feature.uid = getUID('toolbox-feature');\n          feature.model = featureModel;\n          feature.ecModel = ecModel;\n          feature.api = api;\n\n          if (feature instanceof ToolboxFeature) {\n            if (!featureName && oldName) {\n              feature.dispose && feature.dispose(ecModel, api);\n              return;\n            }\n\n            if (!featureModel.get('show') || feature.unusable) {\n              feature.remove && feature.remove(ecModel, api);\n              return;\n            }\n          }\n\n          createIconPaths(featureModel, feature, featureName);\n\n          featureModel.setIconStatus = function (iconName, status) {\n            var option = this.option;\n            var iconPaths = this.iconPaths;\n            option.iconStatus = option.iconStatus || {};\n            option.iconStatus[iconName] = status;\n\n            if (iconPaths[iconName]) {\n              (status === 'emphasis' ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);\n            }\n          };\n\n          if (feature instanceof ToolboxFeature) {\n            if (feature.render) {\n              feature.render(featureModel, ecModel, api, payload);\n            }\n          }\n        }\n\n        function createIconPaths(featureModel, feature, featureName) {\n          var iconStyleModel = featureModel.getModel('iconStyle');\n          var iconStyleEmphasisModel = featureModel.getModel(['emphasis', 'iconStyle']);\n          var icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get('icon');\n          var titles = featureModel.get('title') || {};\n          var iconsMap;\n          var titlesMap;\n\n          if (typeof icons === 'string') {\n            iconsMap = {};\n            iconsMap[featureName] = icons;\n          } else {\n            iconsMap = icons;\n          }\n\n          if (typeof titles === 'string') {\n            titlesMap = {};\n            titlesMap[featureName] = titles;\n          } else {\n            titlesMap = titles;\n          }\n\n          var iconPaths = featureModel.iconPaths = {};\n          each(iconsMap, function (iconStr, iconName) {\n            var path = createIcon(iconStr, {}, {\n              x: -itemSize / 2,\n              y: -itemSize / 2,\n              width: itemSize,\n              height: itemSize\n            });\n            path.setStyle(iconStyleModel.getItemStyle());\n            var pathEmphasisState = path.ensureState('emphasis');\n            pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();\n            var textContent = new ZRText({\n              style: {\n                text: titlesMap[iconName],\n                align: iconStyleEmphasisModel.get('textAlign'),\n                borderRadius: iconStyleEmphasisModel.get('textBorderRadius'),\n                padding: iconStyleEmphasisModel.get('textPadding'),\n                fill: null\n              },\n              ignore: true\n            });\n            path.setTextContent(textContent);\n            var tooltipModel = toolboxModel.getModel('tooltip');\n\n            if (tooltipModel && tooltipModel.get('show')) {\n              path.tooltip = extend({\n                content: titlesMap[iconName],\n                formatter: tooltipModel.get('formatter', true) || function () {\n                  return titlesMap[iconName];\n                },\n                formatterParams: {\n                  componentType: 'toolbox',\n                  name: iconName,\n                  title: titlesMap[iconName],\n                  $vars: ['name', 'title']\n                },\n                position: tooltipModel.get('position', true) || 'bottom'\n              }, tooltipModel.option);\n            }\n\n            path.__title = titlesMap[iconName];\n            path.on('mouseover', function () {\n              var hoverStyle = iconStyleEmphasisModel.getItemStyle();\n              var defaultTextPosition = toolboxModel.get('orient') === 'vertical' ? toolboxModel.get('right') == null ? 'right' : 'left' : toolboxModel.get('bottom') == null ? 'bottom' : 'top';\n              textContent.setStyle({\n                fill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',\n                backgroundColor: iconStyleEmphasisModel.get('textBackgroundColor')\n              });\n              path.setTextConfig({\n                position: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition\n              });\n              textContent.ignore = !toolboxModel.get('showTitle');\n              enterEmphasis(this);\n            }).on('mouseout', function () {\n              if (featureModel.get(['iconStatus', iconName]) !== 'emphasis') {\n                leaveEmphasis(this);\n              }\n\n              textContent.hide();\n            });\n            (featureModel.get(['iconStatus', iconName]) === 'emphasis' ? enterEmphasis : leaveEmphasis)(path);\n            group.add(path);\n            path.on('click', bind(feature.onclick, feature, ecModel, api, iconName));\n            iconPaths[iconName] = path;\n          });\n        }\n\n        layout$3(group, toolboxModel, api);\n        group.add(makeBackground(group.getBoundingRect(), toolboxModel));\n        group.eachChild(function (icon) {\n          var titleText = icon.__title;\n          var emphasisState = icon.ensureState('emphasis');\n          var emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});\n          var textContent = icon.getTextContent();\n          var emphasisTextState = textContent && textContent.states.emphasis;\n\n          if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {\n            var emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});\n            var rect = getBoundingRect(titleText, ZRText.makeFont(emphasisTextStyle));\n            var offsetX = icon.x + group.x;\n            var offsetY = icon.y + group.y + itemSize;\n            var needPutOnTop = false;\n\n            if (offsetY + rect.height > api.getHeight()) {\n              emphasisTextConfig.position = 'top';\n              needPutOnTop = true;\n            }\n\n            var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;\n\n            if (offsetX + rect.width / 2 > api.getWidth()) {\n              emphasisTextConfig.position = ['100%', topOffset];\n              emphasisTextStyle.align = 'right';\n            } else if (offsetX - rect.width / 2 < 0) {\n              emphasisTextConfig.position = [0, topOffset];\n              emphasisTextStyle.align = 'left';\n            }\n          }\n        });\n      };\n\n      ToolboxView.prototype.updateView = function (toolboxModel, ecModel, api, payload) {\n        each(this._features, function (feature) {\n          feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload);\n        });\n      };\n\n      ToolboxView.prototype.remove = function (ecModel, api) {\n        each(this._features, function (feature) {\n          feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api);\n        });\n        this.group.removeAll();\n      };\n\n      ToolboxView.prototype.dispose = function (ecModel, api) {\n        each(this._features, function (feature) {\n          feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api);\n        });\n      };\n\n      ToolboxView.type = 'toolbox';\n      return ToolboxView;\n    }(ComponentView);\n\n    function isUserFeatureName(featureName) {\n      return featureName.indexOf('my') === 0;\n    }\n\n    var SaveAsImage = function (_super) {\n      __extends(SaveAsImage, _super);\n\n      function SaveAsImage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      SaveAsImage.prototype.onclick = function (ecModel, api) {\n        var model = this.model;\n        var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';\n        var isSvg = api.getZr().painter.getType() === 'svg';\n        var type = isSvg ? 'svg' : model.get('type', true) || 'png';\n        var url = api.getConnectedDataURL({\n          type: type,\n          backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',\n          connectedBackgroundColor: model.get('connectedBackgroundColor'),\n          excludeComponents: model.get('excludeComponents'),\n          pixelRatio: model.get('pixelRatio')\n        });\n\n        if (typeof MouseEvent === 'function' && (env.browser.newEdge || !env.browser.ie && !env.browser.edge)) {\n          var $a = document.createElement('a');\n          $a.download = title + '.' + type;\n          $a.target = '_blank';\n          $a.href = url;\n          var evt = new MouseEvent('click', {\n            view: document.defaultView,\n            bubbles: true,\n            cancelable: false\n          });\n          $a.dispatchEvent(evt);\n        } else {\n          if (window.navigator.msSaveOrOpenBlob || isSvg) {\n            var parts = url.split(',');\n            var base64Encoded = parts[0].indexOf('base64') > -1;\n            var bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];\n            base64Encoded && (bstr = atob(bstr));\n            var filename = title + '.' + type;\n\n            if (window.navigator.msSaveOrOpenBlob) {\n              var n = bstr.length;\n              var u8arr = new Uint8Array(n);\n\n              while (n--) {\n                u8arr[n] = bstr.charCodeAt(n);\n              }\n\n              var blob = new Blob([u8arr]);\n              window.navigator.msSaveOrOpenBlob(blob, filename);\n            } else {\n              var frame = document.createElement('iframe');\n              document.body.appendChild(frame);\n              var cw = frame.contentWindow;\n              var doc = cw.document;\n              doc.open('image/svg+xml', 'replace');\n              doc.write(bstr);\n              doc.close();\n              cw.focus();\n              doc.execCommand('SaveAs', true, filename);\n              document.body.removeChild(frame);\n            }\n          } else {\n            var lang = model.get('lang');\n            var html = '' + '<body style=\"margin:0;\">' + '<img src=\"' + url + '\" style=\"max-width:100%;\" title=\"' + (lang && lang[0] || '') + '\" />' + '</body>';\n            var tab = window.open();\n            tab.document.write(html);\n            tab.document.title = title;\n          }\n        }\n      };\n\n      SaveAsImage.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',\n          title: ecModel.getLocale(['toolbox', 'saveAsImage', 'title']),\n          type: 'png',\n          connectedBackgroundColor: '#fff',\n          name: '',\n          excludeComponents: ['toolbox'],\n          pixelRatio: 1,\n          lang: ecModel.getLocale(['toolbox', 'saveAsImage', 'lang'])\n        };\n        return defaultOption;\n      };\n\n      return SaveAsImage;\n    }(ToolboxFeature);\n\n    SaveAsImage.prototype.unusable = !env.canvasSupported;\n\n    var INNER_STACK_KEYWORD = '__ec_magicType_stack__';\n    var radioTypes = [['line', 'bar'], ['stack']];\n\n    var MagicType = function (_super) {\n      __extends(MagicType, _super);\n\n      function MagicType() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      MagicType.prototype.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon');\n        var icons = {};\n        each(model.get('type'), function (type) {\n          if (availableIcons[type]) {\n            icons[type] = availableIcons[type];\n          }\n        });\n        return icons;\n      };\n\n      MagicType.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          type: [],\n          icon: {\n            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',\n            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',\n            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z'\n          },\n          title: ecModel.getLocale(['toolbox', 'magicType', 'title']),\n          option: {},\n          seriesIndex: {}\n        };\n        return defaultOption;\n      };\n\n      MagicType.prototype.onclick = function (ecModel, api, type) {\n        var model = this.model;\n        var seriesIndex = model.get(['seriesIndex', type]);\n\n        if (!seriesOptGenreator[type]) {\n          return;\n        }\n\n        var newOption = {\n          series: []\n        };\n\n        var generateNewSeriesTypes = function (seriesModel) {\n          var seriesType = seriesModel.subType;\n          var seriesId = seriesModel.id;\n          var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);\n\n          if (newSeriesOpt) {\n            defaults(newSeriesOpt, seriesModel.option);\n            newOption.series.push(newSeriesOpt);\n          }\n\n          var coordSys = seriesModel.coordinateSystem;\n\n          if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n            if (categoryAxis) {\n              var axisDim = categoryAxis.dim;\n              var axisType = axisDim + 'Axis';\n              var axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];\n              var axisIndex = axisModel.componentIndex;\n              newOption[axisType] = newOption[axisType] || [];\n\n              for (var i = 0; i <= axisIndex; i++) {\n                newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};\n              }\n\n              newOption[axisType][axisIndex].boundaryGap = type === 'bar';\n            }\n          }\n        };\n\n        each(radioTypes, function (radio) {\n          if (indexOf(radio, type) >= 0) {\n            each(radio, function (item) {\n              model.setIconStatus(item, 'normal');\n            });\n          }\n        });\n        model.setIconStatus(type, 'emphasis');\n        ecModel.eachComponent({\n          mainType: 'series',\n          query: seriesIndex == null ? null : {\n            seriesIndex: seriesIndex\n          }\n        }, generateNewSeriesTypes);\n        var newTitle;\n\n        if (type === 'stack') {\n          newTitle = merge({\n            stack: model.option.title.tiled,\n            tiled: model.option.title.stack\n          }, model.option.title);\n        }\n\n        api.dispatchAction({\n          type: 'changeMagicType',\n          currentType: type,\n          newOption: newOption,\n          newTitle: newTitle,\n          featureName: 'magicType'\n        });\n      };\n\n      return MagicType;\n    }(ToolboxFeature);\n\n    var seriesOptGenreator = {\n      'line': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'bar') {\n          return merge({\n            id: seriesId,\n            type: 'line',\n            data: seriesModel.get('data'),\n            stack: seriesModel.get('stack'),\n            markPoint: seriesModel.get('markPoint'),\n            markLine: seriesModel.get('markLine')\n          }, model.get(['option', 'line']) || {}, true);\n        }\n      },\n      'bar': function (seriesType, seriesId, seriesModel, model) {\n        if (seriesType === 'line') {\n          return merge({\n            id: seriesId,\n            type: 'bar',\n            data: seriesModel.get('data'),\n            stack: seriesModel.get('stack'),\n            markPoint: seriesModel.get('markPoint'),\n            markLine: seriesModel.get('markLine')\n          }, model.get(['option', 'bar']) || {}, true);\n        }\n      },\n      'stack': function (seriesType, seriesId, seriesModel, model) {\n        var isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD;\n\n        if (seriesType === 'line' || seriesType === 'bar') {\n          model.setIconStatus('stack', isStack ? 'normal' : 'emphasis');\n          return merge({\n            id: seriesId,\n            stack: isStack ? '' : INNER_STACK_KEYWORD\n          }, model.get(['option', 'stack']) || {}, true);\n        }\n      }\n    };\n    registerAction({\n      type: 'changeMagicType',\n      event: 'magicTypeChanged',\n      update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n      ecModel.mergeOption(payload.newOption);\n    });\n\n    var BLOCK_SPLITER = new Array(60).join('-');\n    var ITEM_SPLITER = '\\t';\n\n    function groupSeries(ecModel) {\n      var seriesGroupByCategoryAxis = {};\n      var otherSeries = [];\n      var meta = [];\n      ecModel.eachRawSeries(function (seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n\n        if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {\n          var baseAxis = coordSys.getBaseAxis();\n\n          if (baseAxis.type === 'category') {\n            var key = baseAxis.dim + '_' + baseAxis.index;\n\n            if (!seriesGroupByCategoryAxis[key]) {\n              seriesGroupByCategoryAxis[key] = {\n                categoryAxis: baseAxis,\n                valueAxis: coordSys.getOtherAxis(baseAxis),\n                series: []\n              };\n              meta.push({\n                axisDim: baseAxis.dim,\n                axisIndex: baseAxis.index\n              });\n            }\n\n            seriesGroupByCategoryAxis[key].series.push(seriesModel);\n          } else {\n            otherSeries.push(seriesModel);\n          }\n        } else {\n          otherSeries.push(seriesModel);\n        }\n      });\n      return {\n        seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,\n        other: otherSeries,\n        meta: meta\n      };\n    }\n\n    function assembleSeriesWithCategoryAxis(groups) {\n      var tables = [];\n      each(groups, function (group, key) {\n        var categoryAxis = group.categoryAxis;\n        var valueAxis = group.valueAxis;\n        var valueAxisDim = valueAxis.dim;\n        var headers = [' '].concat(map(group.series, function (series) {\n          return series.name;\n        }));\n        var columns = [categoryAxis.model.getCategories()];\n        each(group.series, function (series) {\n          var rawData = series.getRawData();\n          columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {\n            return val;\n          }));\n        });\n        var lines = [headers.join(ITEM_SPLITER)];\n\n        for (var i = 0; i < columns[0].length; i++) {\n          var items = [];\n\n          for (var j = 0; j < columns.length; j++) {\n            items.push(columns[j][i]);\n          }\n\n          lines.push(items.join(ITEM_SPLITER));\n        }\n\n        tables.push(lines.join('\\n'));\n      });\n      return tables.join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    function assembleOtherSeries(series) {\n      return map(series, function (series) {\n        var data = series.getRawData();\n        var lines = [series.name];\n        var vals = [];\n        data.each(data.dimensions, function () {\n          var argLen = arguments.length;\n          var dataIndex = arguments[argLen - 1];\n          var name = data.getName(dataIndex);\n\n          for (var i = 0; i < argLen - 1; i++) {\n            vals[i] = arguments[i];\n          }\n\n          lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));\n        });\n        return lines.join('\\n');\n      }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n');\n    }\n\n    function getContentFromModel(ecModel) {\n      var result = groupSeries(ecModel);\n      return {\n        value: filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {\n          return !!str.replace(/[\\n\\t\\s]/g, '');\n        }).join('\\n\\n' + BLOCK_SPLITER + '\\n\\n'),\n        meta: result.meta\n      };\n    }\n\n    function trim$1(str) {\n      return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n    }\n\n    function isTSVFormat(block) {\n      var firstLine = block.slice(0, block.indexOf('\\n'));\n\n      if (firstLine.indexOf(ITEM_SPLITER) >= 0) {\n        return true;\n      }\n    }\n\n    var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');\n\n    function parseTSVContents(tsv) {\n      var tsvLines = tsv.split(/\\n+/g);\n      var headers = trim$1(tsvLines.shift()).split(itemSplitRegex);\n      var categories = [];\n      var series = map(headers, function (header) {\n        return {\n          name: header,\n          data: []\n        };\n      });\n\n      for (var i = 0; i < tsvLines.length; i++) {\n        var items = trim$1(tsvLines[i]).split(itemSplitRegex);\n        categories.push(items.shift());\n\n        for (var j = 0; j < items.length; j++) {\n          series[j] && (series[j].data[i] = items[j]);\n        }\n      }\n\n      return {\n        series: series,\n        categories: categories\n      };\n    }\n\n    function parseListContents(str) {\n      var lines = str.split(/\\n+/g);\n      var seriesName = trim$1(lines.shift());\n      var data = [];\n\n      for (var i = 0; i < lines.length; i++) {\n        var line = trim$1(lines[i]);\n\n        if (!line) {\n          continue;\n        }\n\n        var items = line.split(itemSplitRegex);\n        var name_1 = '';\n        var value = void 0;\n        var hasName = false;\n\n        if (isNaN(items[0])) {\n          hasName = true;\n          name_1 = items[0];\n          items = items.slice(1);\n          data[i] = {\n            name: name_1,\n            value: []\n          };\n          value = data[i].value;\n        } else {\n          value = data[i] = [];\n        }\n\n        for (var j = 0; j < items.length; j++) {\n          value.push(+items[j]);\n        }\n\n        if (value.length === 1) {\n          hasName ? data[i].value = value[0] : data[i] = value[0];\n        }\n      }\n\n      return {\n        name: seriesName,\n        data: data\n      };\n    }\n\n    function parseContents(str, blockMetaList) {\n      var blocks = str.split(new RegExp('\\n*' + BLOCK_SPLITER + '\\n*', 'g'));\n      var newOption = {\n        series: []\n      };\n      each(blocks, function (block, idx) {\n        if (isTSVFormat(block)) {\n          var result = parseTSVContents(block);\n          var blockMeta = blockMetaList[idx];\n          var axisKey = blockMeta.axisDim + 'Axis';\n\n          if (blockMeta) {\n            newOption[axisKey] = newOption[axisKey] || [];\n            newOption[axisKey][blockMeta.axisIndex] = {\n              data: result.categories\n            };\n            newOption.series = newOption.series.concat(result.series);\n          }\n        } else {\n          var result = parseListContents(block);\n          newOption.series.push(result);\n        }\n      });\n      return newOption;\n    }\n\n    var DataView = function (_super) {\n      __extends(DataView, _super);\n\n      function DataView() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      DataView.prototype.onclick = function (ecModel, api) {\n        var container = api.getDom();\n        var model = this.model;\n\n        if (this._dom) {\n          container.removeChild(this._dom);\n        }\n\n        var root = document.createElement('div');\n        root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';\n        root.style.backgroundColor = model.get('backgroundColor') || '#fff';\n        var header = document.createElement('h4');\n        var lang = model.get('lang') || [];\n        header.innerHTML = lang[0] || model.get('title');\n        header.style.cssText = 'margin: 10px 20px;';\n        header.style.color = model.get('textColor');\n        var viewMain = document.createElement('div');\n        var textarea = document.createElement('textarea');\n        viewMain.style.cssText = 'display:block;width:100%;overflow:auto;';\n        var optionToContent = model.get('optionToContent');\n        var contentToOption = model.get('contentToOption');\n        var result = getContentFromModel(ecModel);\n\n        if (typeof optionToContent === 'function') {\n          var htmlOrDom = optionToContent(api.getOption());\n\n          if (typeof htmlOrDom === 'string') {\n            viewMain.innerHTML = htmlOrDom;\n          } else if (isDom(htmlOrDom)) {\n            viewMain.appendChild(htmlOrDom);\n          }\n        } else {\n          viewMain.appendChild(textarea);\n          textarea.readOnly = model.get('readOnly');\n          textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';\n          textarea.style.color = model.get('textColor');\n          textarea.style.borderColor = model.get('textareaBorderColor');\n          textarea.style.backgroundColor = model.get('textareaColor');\n          textarea.value = result.value;\n        }\n\n        var blockMetaList = result.meta;\n        var buttonContainer = document.createElement('div');\n        buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';\n        var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';\n        var closeButton = document.createElement('div');\n        var refreshButton = document.createElement('div');\n        buttonStyle += ';background-color:' + model.get('buttonColor');\n        buttonStyle += ';color:' + model.get('buttonTextColor');\n        var self = this;\n\n        function close() {\n          container.removeChild(root);\n          self._dom = null;\n        }\n\n        addEventListener(closeButton, 'click', close);\n        addEventListener(refreshButton, 'click', function () {\n          if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {\n            if (\"development\" !== 'production') {\n              console.warn('It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.');\n            }\n\n            close();\n            return;\n          }\n\n          var newOption;\n\n          try {\n            if (typeof contentToOption === 'function') {\n              newOption = contentToOption(viewMain, api.getOption());\n            } else {\n              newOption = parseContents(textarea.value, blockMetaList);\n            }\n          } catch (e) {\n            close();\n            throw new Error('Data view format error ' + e);\n          }\n\n          if (newOption) {\n            api.dispatchAction({\n              type: 'changeDataView',\n              newOption: newOption\n            });\n          }\n\n          close();\n        });\n        closeButton.innerHTML = lang[1];\n        refreshButton.innerHTML = lang[2];\n        refreshButton.style.cssText = buttonStyle;\n        closeButton.style.cssText = buttonStyle;\n        !model.get('readOnly') && buttonContainer.appendChild(refreshButton);\n        buttonContainer.appendChild(closeButton);\n        root.appendChild(header);\n        root.appendChild(viewMain);\n        root.appendChild(buttonContainer);\n        viewMain.style.height = container.clientHeight - 80 + 'px';\n        container.appendChild(root);\n        this._dom = root;\n      };\n\n      DataView.prototype.remove = function (ecModel, api) {\n        this._dom && api.getDom().removeChild(this._dom);\n      };\n\n      DataView.prototype.dispose = function (ecModel, api) {\n        this.remove(ecModel, api);\n      };\n\n      DataView.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          readOnly: false,\n          optionToContent: null,\n          contentToOption: null,\n          icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',\n          title: ecModel.getLocale(['toolbox', 'dataView', 'title']),\n          lang: ecModel.getLocale(['toolbox', 'dataView', 'lang']),\n          backgroundColor: '#fff',\n          textColor: '#000',\n          textareaColor: '#fff',\n          textareaBorderColor: '#333',\n          buttonColor: '#c23531',\n          buttonTextColor: '#fff'\n        };\n        return defaultOption;\n      };\n\n      return DataView;\n    }(ToolboxFeature);\n\n    function tryMergeDataOption(newData, originalData) {\n      return map(newData, function (newVal, idx) {\n        var original = originalData && originalData[idx];\n\n        if (isObject(original) && !isArray(original)) {\n          var newValIsObject = isObject(newVal) && !isArray(newVal);\n\n          if (!newValIsObject) {\n            newVal = {\n              value: newVal\n            };\n          }\n\n          var shouldDeleteName = original.name != null && newVal.name == null;\n          newVal = defaults(newVal, original);\n          shouldDeleteName && delete newVal.name;\n          return newVal;\n        } else {\n          return newVal;\n        }\n      });\n    }\n\n    registerAction({\n      type: 'changeDataView',\n      event: 'dataViewChanged',\n      update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n      var newSeriesOptList = [];\n      each(payload.newOption.series, function (seriesOpt) {\n        var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];\n\n        if (!seriesModel) {\n          newSeriesOptList.push(extend({\n            type: 'scatter'\n          }, seriesOpt));\n        } else {\n          var originalData = seriesModel.get('data');\n          newSeriesOptList.push({\n            name: seriesOpt.name,\n            data: tryMergeDataOption(seriesOpt.data, originalData)\n          });\n        }\n      });\n      ecModel.mergeOption(defaults({\n        series: newSeriesOptList\n      }, payload.newOption));\n    });\n\n    var each$a = each;\n    var inner$h = makeInner();\n    function push(ecModel, newSnapshot) {\n      var storedSnapshots = getStoreSnapshots(ecModel);\n      each$a(newSnapshot, function (batchItem, dataZoomId) {\n        var i = storedSnapshots.length - 1;\n\n        for (; i >= 0; i--) {\n          var snapshot = storedSnapshots[i];\n\n          if (snapshot[dataZoomId]) {\n            break;\n          }\n        }\n\n        if (i < 0) {\n          var dataZoomModel = ecModel.queryComponents({\n            mainType: 'dataZoom',\n            subType: 'select',\n            id: dataZoomId\n          })[0];\n\n          if (dataZoomModel) {\n            var percentRange = dataZoomModel.getPercentRange();\n            storedSnapshots[0][dataZoomId] = {\n              dataZoomId: dataZoomId,\n              start: percentRange[0],\n              end: percentRange[1]\n            };\n          }\n        }\n      });\n      storedSnapshots.push(newSnapshot);\n    }\n    function pop(ecModel) {\n      var storedSnapshots = getStoreSnapshots(ecModel);\n      var head = storedSnapshots[storedSnapshots.length - 1];\n      storedSnapshots.length > 1 && storedSnapshots.pop();\n      var snapshot = {};\n      each$a(head, function (batchItem, dataZoomId) {\n        for (var i = storedSnapshots.length - 1; i >= 0; i--) {\n          batchItem = storedSnapshots[i][dataZoomId];\n\n          if (batchItem) {\n            snapshot[dataZoomId] = batchItem;\n            break;\n          }\n        }\n      });\n      return snapshot;\n    }\n    function clear$1(ecModel) {\n      inner$h(ecModel).snapshots = null;\n    }\n    function count(ecModel) {\n      return getStoreSnapshots(ecModel).length;\n    }\n\n    function getStoreSnapshots(ecModel) {\n      var store = inner$h(ecModel);\n\n      if (!store.snapshots) {\n        store.snapshots = [{}];\n      }\n\n      return store.snapshots;\n    }\n\n    var RestoreOption = function (_super) {\n      __extends(RestoreOption, _super);\n\n      function RestoreOption() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      RestoreOption.prototype.onclick = function (ecModel, api) {\n        clear$1(ecModel);\n        api.dispatchAction({\n          type: 'restore',\n          from: this.uid\n        });\n      };\n\n      RestoreOption.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',\n          title: ecModel.getLocale(['toolbox', 'restore', 'title'])\n        };\n        return defaultOption;\n      };\n\n      return RestoreOption;\n    }(ToolboxFeature);\n\n    registerAction({\n      type: 'restore',\n      event: 'restore',\n      update: 'prepareAndUpdate'\n    }, function (payload, ecModel) {\n      ecModel.resetOption('recreate');\n    });\n\n    var COORD_CONVERTS = ['dataToPoint', 'pointToData'];\n    var INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap'];\n\n    var BrushTargetManager = function () {\n      function BrushTargetManager(finder, ecModel, opt) {\n        var _this = this;\n\n        this._targetInfoList = [];\n        var foundCpts = parseFinder$1(ecModel, finder);\n        each(targetInfoBuilders, function (builder, type) {\n          if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {\n            builder(foundCpts, _this._targetInfoList);\n          }\n        });\n      }\n\n      BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {\n        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n          (area.coordRanges || (area.coordRanges = [])).push(coordRange);\n\n          if (!area.coordRange) {\n            area.coordRange = coordRange;\n            var result = coordConvert[area.brushType](0, coordSys, coordRange);\n            area.__rangeOffset = {\n              offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),\n              xyMinMax: result.xyMinMax\n            };\n          }\n        });\n        return areas;\n      };\n\n      BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {\n        each(areas, function (area) {\n          var targetInfo = this.findTargetInfo(area, ecModel);\n\n          if (targetInfo && targetInfo !== true) {\n            each(targetInfo.coordSyses, function (coordSys) {\n              var result = coordConvert[area.brushType](1, coordSys, area.range);\n              cb(area, result.values, coordSys, ecModel);\n            });\n          }\n        }, this);\n      };\n\n      BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {\n        each(areas, function (area) {\n          var targetInfo = this.findTargetInfo(area, ecModel);\n\n          if (\"development\" !== 'production') {\n            assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.');\n            assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.');\n          }\n\n          area.range = area.range || [];\n\n          if (targetInfo && targetInfo !== true) {\n            area.panelId = targetInfo.panelId;\n            var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);\n            var rangeOffset = area.__rangeOffset;\n            area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;\n          }\n        }, this);\n      };\n\n      BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {\n        return map(this._targetInfoList, function (targetInfo) {\n          var rect = targetInfo.getPanelRect();\n          return {\n            panelId: targetInfo.panelId,\n            defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,\n            clipPath: makeRectPanelClipPath(rect),\n            isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),\n            getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)\n          };\n        });\n      };\n\n      BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {\n        var targetInfo = this.findTargetInfo(area, ecModel);\n        return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;\n      };\n\n      BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {\n        var targetInfoList = this._targetInfoList;\n        var foundCpts = parseFinder$1(ecModel, area);\n\n        for (var i = 0; i < targetInfoList.length; i++) {\n          var targetInfo = targetInfoList[i];\n          var areaPanelId = area.panelId;\n\n          if (areaPanelId) {\n            if (targetInfo.panelId === areaPanelId) {\n              return targetInfo;\n            }\n          } else {\n            for (var j = 0; j < targetInfoMatchers.length; j++) {\n              if (targetInfoMatchers[j](foundCpts, targetInfo)) {\n                return targetInfo;\n              }\n            }\n          }\n        }\n\n        return true;\n      };\n\n      return BrushTargetManager;\n    }();\n\n    function formatMinMax(minMax) {\n      minMax[0] > minMax[1] && minMax.reverse();\n      return minMax;\n    }\n\n    function parseFinder$1(ecModel, finder) {\n      return parseFinder(ecModel, finder, {\n        includeMainTypes: INCLUDE_FINDER_MAIN_TYPES\n      });\n    }\n\n    var targetInfoBuilders = {\n      grid: function (foundCpts, targetInfoList) {\n        var xAxisModels = foundCpts.xAxisModels;\n        var yAxisModels = foundCpts.yAxisModels;\n        var gridModels = foundCpts.gridModels;\n        var gridModelMap = createHashMap();\n        var xAxesHas = {};\n        var yAxesHas = {};\n\n        if (!xAxisModels && !yAxisModels && !gridModels) {\n          return;\n        }\n\n        each(xAxisModels, function (axisModel) {\n          var gridModel = axisModel.axis.grid.model;\n          gridModelMap.set(gridModel.id, gridModel);\n          xAxesHas[gridModel.id] = true;\n        });\n        each(yAxisModels, function (axisModel) {\n          var gridModel = axisModel.axis.grid.model;\n          gridModelMap.set(gridModel.id, gridModel);\n          yAxesHas[gridModel.id] = true;\n        });\n        each(gridModels, function (gridModel) {\n          gridModelMap.set(gridModel.id, gridModel);\n          xAxesHas[gridModel.id] = true;\n          yAxesHas[gridModel.id] = true;\n        });\n        gridModelMap.each(function (gridModel) {\n          var grid = gridModel.coordinateSystem;\n          var cartesians = [];\n          each(grid.getCartesians(), function (cartesian, index) {\n            if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {\n              cartesians.push(cartesian);\n            }\n          });\n          targetInfoList.push({\n            panelId: 'grid--' + gridModel.id,\n            gridModel: gridModel,\n            coordSysModel: gridModel,\n            coordSys: cartesians[0],\n            coordSyses: cartesians,\n            getPanelRect: panelRectBuilders.grid,\n            xAxisDeclared: xAxesHas[gridModel.id],\n            yAxisDeclared: yAxesHas[gridModel.id]\n          });\n        });\n      },\n      geo: function (foundCpts, targetInfoList) {\n        each(foundCpts.geoModels, function (geoModel) {\n          var coordSys = geoModel.coordinateSystem;\n          targetInfoList.push({\n            panelId: 'geo--' + geoModel.id,\n            geoModel: geoModel,\n            coordSysModel: geoModel,\n            coordSys: coordSys,\n            coordSyses: [coordSys],\n            getPanelRect: panelRectBuilders.geo\n          });\n        });\n      }\n    };\n    var targetInfoMatchers = [function (foundCpts, targetInfo) {\n      var xAxisModel = foundCpts.xAxisModel;\n      var yAxisModel = foundCpts.yAxisModel;\n      var gridModel = foundCpts.gridModel;\n      !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);\n      !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);\n      return gridModel && gridModel === targetInfo.gridModel;\n    }, function (foundCpts, targetInfo) {\n      var geoModel = foundCpts.geoModel;\n      return geoModel && geoModel === targetInfo.geoModel;\n    }];\n    var panelRectBuilders = {\n      grid: function () {\n        return this.coordSys.master.getRect().clone();\n      },\n      geo: function () {\n        var coordSys = this.coordSys;\n        var rect = coordSys.getBoundingRect().clone();\n        rect.applyTransform(getTransform(coordSys));\n        return rect;\n      }\n    };\n    var coordConvert = {\n      lineX: curry(axisConvert, 0),\n      lineY: curry(axisConvert, 1),\n      rect: function (to, coordSys, rangeOrCoordRange) {\n        var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);\n        var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);\n        var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];\n        return {\n          values: values,\n          xyMinMax: values\n        };\n      },\n      polygon: function (to, coordSys, rangeOrCoordRange) {\n        var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];\n        var values = map(rangeOrCoordRange, function (item) {\n          var p = coordSys[COORD_CONVERTS[to]](item);\n          xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);\n          xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);\n          xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);\n          xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);\n          return p;\n        });\n        return {\n          values: values,\n          xyMinMax: xyMinMax\n        };\n      }\n    };\n\n    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {\n      if (\"development\" !== 'production') {\n        assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.');\n      }\n\n      var axis = coordSys.getAxis(['x', 'y'][axisNameIndex]);\n      var values = formatMinMax(map([0, 1], function (i) {\n        return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));\n      }));\n      var xyMinMax = [];\n      xyMinMax[axisNameIndex] = values;\n      xyMinMax[1 - axisNameIndex] = [NaN, NaN];\n      return {\n        values: values,\n        xyMinMax: xyMinMax\n      };\n    }\n\n    var diffProcessor = {\n      lineX: curry(axisDiffProcessor, 0),\n      lineY: curry(axisDiffProcessor, 1),\n      rect: function (values, refer, scales) {\n        return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];\n      },\n      polygon: function (values, refer, scales) {\n        return map(values, function (item, idx) {\n          return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];\n        });\n      }\n    };\n\n    function axisDiffProcessor(axisNameIndex, values, refer, scales) {\n      return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];\n    }\n\n    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {\n      var sizeCurr = getSize(xyMinMaxCurr);\n      var sizeOrigin = getSize(xyMinMaxOrigin);\n      var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];\n      isNaN(scales[0]) && (scales[0] = 1);\n      isNaN(scales[1]) && (scales[1] = 1);\n      return scales;\n    }\n\n    function getSize(xyMinMax) {\n      return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];\n    }\n\n    var each$b = each;\n    var DATA_ZOOM_ID_BASE = makeInternalComponentId('toolbox-dataZoom_');\n\n    var DataZoomFeature = function (_super) {\n      __extends(DataZoomFeature, _super);\n\n      function DataZoomFeature() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      DataZoomFeature.prototype.render = function (featureModel, ecModel, api, payload) {\n        if (!this.brushController) {\n          this.brushController = new BrushController(api.getZr());\n          this.brushController.on('brush', bind(this._onBrush, this)).mount();\n        }\n\n        updateZoomBtnStatus(featureModel, ecModel, this, payload, api);\n        updateBackBtnStatus(featureModel, ecModel);\n      };\n\n      DataZoomFeature.prototype.onclick = function (ecModel, api, type) {\n        handlers$1[type].call(this);\n      };\n\n      DataZoomFeature.prototype.remove = function (ecModel, api) {\n        this.brushController.unmount();\n      };\n\n      DataZoomFeature.prototype.dispose = function (ecModel, api) {\n        this.brushController.dispose();\n      };\n\n      DataZoomFeature.prototype._onBrush = function (eventParam) {\n        var areas = eventParam.areas;\n\n        if (!eventParam.isEnd || !areas.length) {\n          return;\n        }\n\n        var snapshot = {};\n        var ecModel = this.ecModel;\n        this.brushController.updateCovers([]);\n        var brushTargetManager = new BrushTargetManager(makeAxisFinder(this.model), ecModel, {\n          include: ['grid']\n        });\n        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {\n          if (coordSys.type !== 'cartesian2d') {\n            return;\n          }\n\n          var brushType = area.brushType;\n\n          if (brushType === 'rect') {\n            setBatch('x', coordSys, coordRange[0]);\n            setBatch('y', coordSys, coordRange[1]);\n          } else {\n            setBatch({\n              lineX: 'x',\n              lineY: 'y'\n            }[brushType], coordSys, coordRange);\n          }\n        });\n        push(ecModel, snapshot);\n\n        this._dispatchZoomAction(snapshot);\n\n        function setBatch(dimName, coordSys, minMax) {\n          var axis = coordSys.getAxis(dimName);\n          var axisModel = axis.model;\n          var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);\n          var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();\n\n          if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {\n            minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);\n          }\n\n          dataZoomModel && (snapshot[dataZoomModel.id] = {\n            dataZoomId: dataZoomModel.id,\n            startValue: minMax[0],\n            endValue: minMax[1]\n          });\n        }\n\n        function findDataZoom(dimName, axisModel, ecModel) {\n          var found;\n          ecModel.eachComponent({\n            mainType: 'dataZoom',\n            subType: 'select'\n          }, function (dzModel) {\n            var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);\n            has && (found = dzModel);\n          });\n          return found;\n        }\n      };\n\n      DataZoomFeature.prototype._dispatchZoomAction = function (snapshot) {\n        var batch = [];\n        each$b(snapshot, function (batchItem, dataZoomId) {\n          batch.push(clone(batchItem));\n        });\n        batch.length && this.api.dispatchAction({\n          type: 'dataZoom',\n          from: this.uid,\n          batch: batch\n        });\n      };\n\n      DataZoomFeature.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          filterMode: 'filter',\n          icon: {\n            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',\n            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'\n          },\n          title: ecModel.getLocale(['toolbox', 'dataZoom', 'title']),\n          brushStyle: {\n            borderWidth: 0,\n            color: 'rgba(210,219,238,0.2)'\n          }\n        };\n        return defaultOption;\n      };\n\n      return DataZoomFeature;\n    }(ToolboxFeature);\n\n    var handlers$1 = {\n      zoom: function () {\n        var nextActive = !this.isZoomActive;\n        this.api.dispatchAction({\n          type: 'takeGlobalCursor',\n          key: 'dataZoomSelect',\n          dataZoomSelectActive: nextActive\n        });\n      },\n      back: function () {\n        this._dispatchZoomAction(pop(this.ecModel));\n      }\n    };\n\n    function makeAxisFinder(dzFeatureModel) {\n      var setting = {\n        xAxisIndex: dzFeatureModel.get('xAxisIndex', true),\n        yAxisIndex: dzFeatureModel.get('yAxisIndex', true),\n        xAxisId: dzFeatureModel.get('xAxisId', true),\n        yAxisId: dzFeatureModel.get('yAxisId', true)\n      };\n\n      if (setting.xAxisIndex == null && setting.xAxisId == null) {\n        setting.xAxisIndex = 'all';\n      }\n\n      if (setting.yAxisIndex == null && setting.yAxisId == null) {\n        setting.yAxisIndex = 'all';\n      }\n\n      return setting;\n    }\n\n    function updateBackBtnStatus(featureModel, ecModel) {\n      featureModel.setIconStatus('back', count(ecModel) > 1 ? 'emphasis' : 'normal');\n    }\n\n    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {\n      var zoomActive = view.isZoomActive;\n\n      if (payload && payload.type === 'takeGlobalCursor') {\n        zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false;\n      }\n\n      view.isZoomActive = zoomActive;\n      featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal');\n      var brushTargetManager = new BrushTargetManager(makeAxisFinder(featureModel), ecModel, {\n        include: ['grid']\n      });\n      var panels = brushTargetManager.makePanelOpts(api, function (targetInfo) {\n        return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect';\n      });\n      view.brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {\n        brushType: 'auto',\n        brushStyle: featureModel.getModel('brushStyle').getItemStyle()\n      } : false);\n    }\n\n    registerInternalOptionCreator('dataZoom', function (ecModel) {\n      var toolboxModel = ecModel.getComponent('toolbox', 0);\n\n      if (!toolboxModel) {\n        return;\n      }\n\n      var dzFeatureModel = toolboxModel.getModel(['feature', 'dataZoom']);\n      var dzOptions = [];\n      var finder = makeAxisFinder(dzFeatureModel);\n      var finderResult = parseFinder(ecModel, finder);\n      each$b(finderResult.xAxisModels, function (axisModel) {\n        return buildInternalOptions(axisModel, 'xAxis', 'xAxisIndex');\n      });\n      each$b(finderResult.yAxisModels, function (axisModel) {\n        return buildInternalOptions(axisModel, 'yAxis', 'yAxisIndex');\n      });\n\n      function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {\n        var axisIndex = axisModel.componentIndex;\n        var newOpt = {\n          type: 'select',\n          $fromToolbox: true,\n          filterMode: dzFeatureModel.get('filterMode', true) || 'filter',\n          id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex\n        };\n        newOpt[axisIndexPropName] = axisIndex;\n        dzOptions.push(newOpt);\n      }\n\n      return dzOptions;\n    });\n\n    function install$z(registers) {\n      registers.registerComponentModel(ToolboxModel);\n      registers.registerComponentView(ToolboxView);\n      registerFeature('saveAsImage', SaveAsImage);\n      registerFeature('magicType', MagicType);\n      registerFeature('dataView', DataView);\n      registerFeature('dataZoom', DataZoomFeature);\n      registerFeature('restore', RestoreOption);\n      use(install$y);\n    }\n\n    var TooltipModel = function (_super) {\n      __extends(TooltipModel, _super);\n\n      function TooltipModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TooltipModel.type;\n        return _this;\n      }\n\n      TooltipModel.type = 'tooltip';\n      TooltipModel.dependencies = ['axisPointer'];\n      TooltipModel.defaultOption = {\n        zlevel: 0,\n        z: 60,\n        show: true,\n        showContent: true,\n        trigger: 'item',\n        triggerOn: 'mousemove|click',\n        alwaysShowContent: false,\n        displayMode: 'single',\n        renderMode: 'auto',\n        confine: null,\n        showDelay: 0,\n        hideDelay: 100,\n        transitionDuration: 0.4,\n        enterable: false,\n        backgroundColor: '#fff',\n        shadowBlur: 10,\n        shadowColor: 'rgba(0, 0, 0, .2)',\n        shadowOffsetX: 1,\n        shadowOffsetY: 2,\n        borderRadius: 4,\n        borderWidth: 1,\n        padding: null,\n        extraCssText: '',\n        axisPointer: {\n          type: 'line',\n          axis: 'auto',\n          animation: 'auto',\n          animationDurationUpdate: 200,\n          animationEasingUpdate: 'exponentialOut',\n          crossStyle: {\n            color: '#999',\n            width: 1,\n            type: 'dashed',\n            textStyle: {}\n          }\n        },\n        textStyle: {\n          color: '#666',\n          fontSize: 14\n        }\n      };\n      return TooltipModel;\n    }(ComponentModel);\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function shouldTooltipConfine(tooltipModel) {\n      var confineOption = tooltipModel.get('confine');\n      return confineOption != null ? !!confineOption : tooltipModel.get('renderMode') === 'richText';\n    }\n\n    var vendors = ['-ms-', '-moz-', '-o-', '-webkit-', ''];\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    function mirrorPos(pos) {\n      pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top';\n      return pos;\n    }\n\n    function assembleArrow(backgroundColor, borderColor, arrowPosition) {\n      if (!isString(arrowPosition) || arrowPosition === 'inside') {\n        return '';\n      }\n\n      borderColor = convertToColorString(borderColor);\n      var arrowPos = mirrorPos(arrowPosition);\n      var positionStyle = '';\n      var transformStyle = '';\n\n      if (indexOf(['left', 'right'], arrowPos) > -1) {\n        positionStyle = arrowPos + \":-6px;top:50%;\";\n        transformStyle = \"translateY(-50%) rotate(\" + (arrowPos === 'left' ? -225 : -45) + \"deg)\";\n      } else {\n        positionStyle = arrowPos + \":-6px;left:50%;\";\n        transformStyle = \"translateX(-50%) rotate(\" + (arrowPos === 'top' ? 225 : 45) + \"deg)\";\n      }\n\n      transformStyle = map(vendors, function (vendorPrefix) {\n        return vendorPrefix + 'transform:' + transformStyle;\n      }).join(';');\n      var styleCss = ['position:absolute;width:10px;height:10px;', \"\" + positionStyle + transformStyle + \";\", \"border-bottom: \" + borderColor + \" solid 1px;\", \"border-right: \" + borderColor + \" solid 1px;\", \"background-color: \" + backgroundColor + \";\", 'box-shadow: 8px 8px 16px -3px #000;'];\n      return \"<div style=\\\"\" + styleCss.join('') + \"\\\"></div>\";\n    }\n\n    function assembleTransition(duration, onlyFade) {\n      var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n      var transitionText = 'opacity ' + duration / 2 + 's ' + transitionCurve + ',' + 'visibility ' + duration / 2 + 's ' + transitionCurve;\n\n      if (!onlyFade) {\n        transitionText += ',left ' + duration + 's ' + transitionCurve + ',top ' + duration + 's ' + transitionCurve;\n      }\n\n      return map(vendors, function (vendorPrefix) {\n        return vendorPrefix + 'transition:' + transitionText;\n      }).join(';');\n    }\n\n    function assembleFont(textStyleModel) {\n      var cssText = [];\n      var fontSize = textStyleModel.get('fontSize');\n      var color = textStyleModel.getTextColor();\n      color && cssText.push('color:' + color);\n      cssText.push('font:' + textStyleModel.getFont());\n      fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n      var shadowColor = textStyleModel.get('textShadowColor');\n      var shadowBlur = textStyleModel.get('textShadowBlur') || 0;\n      var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;\n      var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;\n      shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);\n      each(['decoration', 'align'], function (name) {\n        var val = textStyleModel.get(name);\n        val && cssText.push('text-' + name + ':' + val);\n      });\n      return cssText.join(';');\n    }\n\n    function assembleCssText(tooltipModel, enableTransition, onlyFade) {\n      var cssText = [];\n      var transitionDuration = tooltipModel.get('transitionDuration');\n      var backgroundColor = tooltipModel.get('backgroundColor');\n      var shadowBlur = tooltipModel.get('shadowBlur');\n      var shadowColor = tooltipModel.get('shadowColor');\n      var shadowOffsetX = tooltipModel.get('shadowOffsetX');\n      var shadowOffsetY = tooltipModel.get('shadowOffsetY');\n      var textStyleModel = tooltipModel.getModel('textStyle');\n      var padding = getPaddingFromTooltipModel(tooltipModel, 'html');\n      var boxShadow = shadowOffsetX + \"px \" + shadowOffsetY + \"px \" + shadowBlur + \"px \" + shadowColor;\n      cssText.push('box-shadow:' + boxShadow);\n      enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));\n\n      if (backgroundColor) {\n        if (env.canvasSupported) {\n          cssText.push('background-Color:' + backgroundColor);\n        } else {\n          cssText.push('background-Color:#' + toHex(backgroundColor));\n          cssText.push('filter:alpha(opacity=70)');\n        }\n      }\n\n      each(['width', 'color', 'radius'], function (name) {\n        var borderName = 'border-' + name;\n        var camelCase = toCamelCase(borderName);\n        var val = tooltipModel.get(camelCase);\n        val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n      });\n      cssText.push(assembleFont(textStyleModel));\n\n      if (padding != null) {\n        cssText.push('padding:' + normalizeCssArray$1(padding).join('px ') + 'px');\n      }\n\n      return cssText.join(';') + ';';\n    }\n\n    function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {\n      var zrPainter = zr && zr.painter;\n\n      if (appendToBody) {\n        var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();\n\n        if (zrViewportRoot) {\n          transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);\n        }\n      } else {\n        out[0] = zrX;\n        out[1] = zrY;\n        var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();\n\n        if (viewportRootOffset) {\n          out[0] += viewportRootOffset.offsetLeft;\n          out[1] += viewportRootOffset.offsetTop;\n        }\n      }\n\n      out[2] = out[0] / zr.getWidth();\n      out[3] = out[1] / zr.getHeight();\n    }\n\n    var TooltipHTMLContent = function () {\n      function TooltipHTMLContent(container, api, opt) {\n        this._show = false;\n        this._styleCoord = [0, 0, 0, 0];\n        this._enterable = true;\n        this._firstShow = true;\n        this._longHide = true;\n\n        if (env.wxa) {\n          return null;\n        }\n\n        var el = document.createElement('div');\n        el.domBelongToZr = true;\n        this.el = el;\n        var zr = this._zr = api.getZr();\n        var appendToBody = this._appendToBody = opt && opt.appendToBody;\n        makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);\n\n        if (appendToBody) {\n          document.body.appendChild(el);\n        } else {\n          container.appendChild(el);\n        }\n\n        this._container = container;\n        var self = this;\n\n        el.onmouseenter = function () {\n          if (self._enterable) {\n            clearTimeout(self._hideTimeout);\n            self._show = true;\n          }\n\n          self._inContent = true;\n        };\n\n        el.onmousemove = function (e) {\n          e = e || window.event;\n\n          if (!self._enterable) {\n            var handler = zr.handler;\n            var zrViewportRoot = zr.painter.getViewportRoot();\n            normalizeEvent(zrViewportRoot, e, true);\n            handler.dispatch('mousemove', e);\n          }\n        };\n\n        el.onmouseleave = function () {\n          self._inContent = false;\n\n          if (self._enterable) {\n            if (self._show) {\n              self.hideLater(self._hideDelay);\n            }\n          }\n        };\n      }\n\n      TooltipHTMLContent.prototype.update = function (tooltipModel) {\n        var container = this._container;\n        var stl = container.currentStyle || document.defaultView.getComputedStyle(container);\n        var domStyle = container.style;\n\n        if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n          domStyle.position = 'relative';\n        }\n\n        var alwaysShowContent = tooltipModel.get('alwaysShowContent');\n        alwaysShowContent && this._moveIfResized();\n        this.el.className = tooltipModel.get('className') || '';\n      };\n\n      TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {\n        clearTimeout(this._hideTimeout);\n        clearTimeout(this._longHideTimeout);\n        var el = this.el;\n        var styleCoord = this._styleCoord;\n        var offset = el.offsetHeight / 2;\n        nearPointColor = convertToColorString(nearPointColor);\n        el.style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + ';left:' + styleCoord[0] + 'px;top:' + (styleCoord[1] - offset) + 'px;' + (\"border-color: \" + nearPointColor + \";\") + (tooltipModel.get('extraCssText') || '');\n        el.style.display = el.innerHTML ? 'block' : 'none';\n        el.style.pointerEvents = this._enterable ? 'auto' : 'none';\n        this._show = true;\n        this._firstShow = false;\n        this._longHide = false;\n      };\n\n      TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {\n        if (content == null) {\n          return;\n        }\n\n        var el = this.el;\n\n        if (isString(arrowPosition) && tooltipModel.get('trigger') === 'item' && !shouldTooltipConfine(tooltipModel)) {\n          content += assembleArrow(tooltipModel.get('backgroundColor'), borderColor, arrowPosition);\n        }\n\n        if (isString(content)) {\n          el.innerHTML = content;\n        } else if (content) {\n          el.innerHTML = '';\n\n          if (!isArray(content)) {\n            content = [content];\n          }\n\n          for (var i = 0; i < content.length; i++) {\n            if (isDom(content[i]) && content[i].parentNode !== el) {\n              el.appendChild(content[i]);\n            }\n          }\n        }\n      };\n\n      TooltipHTMLContent.prototype.setEnterable = function (enterable) {\n        this._enterable = enterable;\n      };\n\n      TooltipHTMLContent.prototype.getSize = function () {\n        var el = this.el;\n        return [el.clientWidth, el.clientHeight];\n      };\n\n      TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {\n        var styleCoord = this._styleCoord;\n        makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);\n\n        if (styleCoord[0] != null && styleCoord[1] != null) {\n          var style = this.el.style;\n          style.left = styleCoord[0].toFixed(0) + 'px';\n          style.top = styleCoord[1].toFixed(0) + 'px';\n        }\n      };\n\n      TooltipHTMLContent.prototype._moveIfResized = function () {\n        var ratioX = this._styleCoord[2];\n        var ratioY = this._styleCoord[3];\n        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());\n      };\n\n      TooltipHTMLContent.prototype.hide = function () {\n        var _this = this;\n\n        this.el.style.visibility = 'hidden';\n        this.el.style.opacity = '0';\n        this._show = false;\n        this._longHideTimeout = setTimeout(function () {\n          return _this._longHide = true;\n        }, 500);\n      };\n\n      TooltipHTMLContent.prototype.hideLater = function (time) {\n        if (this._show && !(this._inContent && this._enterable)) {\n          if (time) {\n            this._hideDelay = time;\n            this._show = false;\n            this._hideTimeout = setTimeout(bind(this.hide, this), time);\n          } else {\n            this.hide();\n          }\n        }\n      };\n\n      TooltipHTMLContent.prototype.isShow = function () {\n        return this._show;\n      };\n\n      TooltipHTMLContent.prototype.dispose = function () {\n        this.el.parentNode.removeChild(this.el);\n      };\n\n      TooltipHTMLContent.prototype.getOuterSize = function () {\n        var width = this.el.clientWidth;\n        var height = this.el.clientHeight;\n\n        if (document.defaultView && document.defaultView.getComputedStyle) {\n          var stl = document.defaultView.getComputedStyle(this.el);\n\n          if (stl) {\n            width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);\n            height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);\n          }\n        }\n\n        return {\n          width: width,\n          height: height\n        };\n      };\n\n      return TooltipHTMLContent;\n    }();\n\n    var TooltipRichContent = function () {\n      function TooltipRichContent(api) {\n        this._show = false;\n        this._styleCoord = [0, 0, 0, 0];\n        this._enterable = true;\n        this._zr = api.getZr();\n        makeStyleCoord$1(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);\n      }\n\n      TooltipRichContent.prototype.update = function (tooltipModel) {\n        var alwaysShowContent = tooltipModel.get('alwaysShowContent');\n        alwaysShowContent && this._moveIfResized();\n      };\n\n      TooltipRichContent.prototype.show = function () {\n        if (this._hideTimeout) {\n          clearTimeout(this._hideTimeout);\n        }\n\n        this.el.show();\n        this._show = true;\n      };\n\n      TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {\n        if (isObject(content)) {\n          throwError(\"development\" !== 'production' ? 'Passing DOM nodes as content is not supported in richText tooltip!' : '');\n        }\n\n        if (this.el) {\n          this._zr.remove(this.el);\n        }\n\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        this.el = new ZRText({\n          style: {\n            rich: markupStyleCreator.richTextStyles,\n            text: content,\n            lineHeight: 22,\n            backgroundColor: tooltipModel.get('backgroundColor'),\n            borderRadius: tooltipModel.get('borderRadius'),\n            borderWidth: 1,\n            borderColor: borderColor,\n            shadowColor: tooltipModel.get('shadowColor'),\n            shadowBlur: tooltipModel.get('shadowBlur'),\n            shadowOffsetX: tooltipModel.get('shadowOffsetX'),\n            shadowOffsetY: tooltipModel.get('shadowOffsetY'),\n            textShadowColor: textStyleModel.get('textShadowColor'),\n            textShadowBlur: textStyleModel.get('textShadowBlur') || 0,\n            textShadowOffsetX: textStyleModel.get('textShadowOffsetX') || 0,\n            textShadowOffsetY: textStyleModel.get('textShadowOffsetY') || 0,\n            fill: tooltipModel.get(['textStyle', 'color']),\n            padding: getPaddingFromTooltipModel(tooltipModel, 'richText'),\n            verticalAlign: 'top',\n            align: 'left'\n          },\n          z: tooltipModel.get('z')\n        });\n\n        this._zr.add(this.el);\n\n        var self = this;\n        this.el.on('mouseover', function () {\n          if (self._enterable) {\n            clearTimeout(self._hideTimeout);\n            self._show = true;\n          }\n\n          self._inContent = true;\n        });\n        this.el.on('mouseout', function () {\n          if (self._enterable) {\n            if (self._show) {\n              self.hideLater(self._hideDelay);\n            }\n          }\n\n          self._inContent = false;\n        });\n      };\n\n      TooltipRichContent.prototype.setEnterable = function (enterable) {\n        this._enterable = enterable;\n      };\n\n      TooltipRichContent.prototype.getSize = function () {\n        var el = this.el;\n        var bounding = this.el.getBoundingRect();\n        var shadowOuterSize = calcShadowOuterSize(el.style);\n        return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];\n      };\n\n      TooltipRichContent.prototype.moveTo = function (x, y) {\n        var el = this.el;\n\n        if (el) {\n          var styleCoord = this._styleCoord;\n          makeStyleCoord$1(styleCoord, this._zr, x, y);\n          x = styleCoord[0];\n          y = styleCoord[1];\n          var style = el.style;\n          var borderWidth = mathMaxWith0(style.borderWidth || 0);\n          var shadowOuterSize = calcShadowOuterSize(style);\n          el.x = x + borderWidth + shadowOuterSize.left;\n          el.y = y + borderWidth + shadowOuterSize.top;\n          el.markRedraw();\n        }\n      };\n\n      TooltipRichContent.prototype._moveIfResized = function () {\n        var ratioX = this._styleCoord[2];\n        var ratioY = this._styleCoord[3];\n        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());\n      };\n\n      TooltipRichContent.prototype.hide = function () {\n        if (this.el) {\n          this.el.hide();\n        }\n\n        this._show = false;\n      };\n\n      TooltipRichContent.prototype.hideLater = function (time) {\n        if (this._show && !(this._inContent && this._enterable)) {\n          if (time) {\n            this._hideDelay = time;\n            this._show = false;\n            this._hideTimeout = setTimeout(bind(this.hide, this), time);\n          } else {\n            this.hide();\n          }\n        }\n      };\n\n      TooltipRichContent.prototype.isShow = function () {\n        return this._show;\n      };\n\n      TooltipRichContent.prototype.getOuterSize = function () {\n        var size = this.getSize();\n        return {\n          width: size[0],\n          height: size[1]\n        };\n      };\n\n      TooltipRichContent.prototype.dispose = function () {\n        this._zr.remove(this.el);\n      };\n\n      return TooltipRichContent;\n    }();\n\n    function mathMaxWith0(val) {\n      return Math.max(0, val);\n    }\n\n    function calcShadowOuterSize(style) {\n      var shadowBlur = mathMaxWith0(style.shadowBlur || 0);\n      var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);\n      var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);\n      return {\n        left: mathMaxWith0(shadowBlur - shadowOffsetX),\n        right: mathMaxWith0(shadowBlur + shadowOffsetX),\n        top: mathMaxWith0(shadowBlur - shadowOffsetY),\n        bottom: mathMaxWith0(shadowBlur + shadowOffsetY)\n      };\n    }\n\n    function makeStyleCoord$1(out, zr, zrX, zrY) {\n      out[0] = zrX;\n      out[1] = zrY;\n      out[2] = out[0] / zr.getWidth();\n      out[3] = out[1] / zr.getHeight();\n    }\n\n    var bind$2 = bind;\n    var each$c = each;\n    var parsePercent$3 = parsePercent$1;\n    var proxyRect = new Rect({\n      shape: {\n        x: -1,\n        y: -1,\n        width: 2,\n        height: 2\n      }\n    });\n\n    var TooltipView = function (_super) {\n      __extends(TooltipView, _super);\n\n      function TooltipView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TooltipView.type;\n        return _this;\n      }\n\n      TooltipView.prototype.init = function (ecModel, api) {\n        if (env.node) {\n          return;\n        }\n\n        var tooltipModel = ecModel.getComponent('tooltip');\n        var renderMode = tooltipModel.get('renderMode');\n        this._renderMode = getTooltipRenderMode(renderMode);\n        this._tooltipContent = this._renderMode === 'richText' ? new TooltipRichContent(api) : new TooltipHTMLContent(api.getDom(), api, {\n          appendToBody: tooltipModel.get('appendToBody', true)\n        });\n      };\n\n      TooltipView.prototype.render = function (tooltipModel, ecModel, api) {\n        if (env.node) {\n          return;\n        }\n\n        this.group.removeAll();\n        this._tooltipModel = tooltipModel;\n        this._ecModel = ecModel;\n        this._api = api;\n        this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n        var tooltipContent = this._tooltipContent;\n        tooltipContent.update(tooltipModel);\n        tooltipContent.setEnterable(tooltipModel.get('enterable'));\n\n        this._initGlobalListener();\n\n        this._keepShow();\n      };\n\n      TooltipView.prototype._initGlobalListener = function () {\n        var tooltipModel = this._tooltipModel;\n        var triggerOn = tooltipModel.get('triggerOn');\n        register('itemTooltip', this._api, bind$2(function (currTrigger, e, dispatchAction) {\n          if (triggerOn !== 'none') {\n            if (triggerOn.indexOf(currTrigger) >= 0) {\n              this._tryShow(e, dispatchAction);\n            } else if (currTrigger === 'leave') {\n              this._hide(dispatchAction);\n            }\n          }\n        }, this));\n      };\n\n      TooltipView.prototype._keepShow = function () {\n        var tooltipModel = this._tooltipModel;\n        var ecModel = this._ecModel;\n        var api = this._api;\n\n        if (this._lastX != null && this._lastY != null && tooltipModel.get('triggerOn') !== 'none') {\n          var self_1 = this;\n          clearTimeout(this._refreshUpdateTimeout);\n          this._refreshUpdateTimeout = setTimeout(function () {\n            !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {\n              x: self_1._lastX,\n              y: self_1._lastY,\n              dataByCoordSys: self_1._lastDataByCoordSys\n            });\n          });\n        }\n      };\n\n      TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {\n        if (payload.from === this.uid || env.node) {\n          return;\n        }\n\n        var dispatchAction = makeDispatchAction$1(payload, api);\n        this._ticket = '';\n        var dataByCoordSys = payload.dataByCoordSys;\n\n        if (payload.tooltip && payload.x != null && payload.y != null) {\n          var el = proxyRect;\n          el.x = payload.x;\n          el.y = payload.y;\n          el.update();\n          el.tooltip = payload.tooltip;\n\n          this._tryShow({\n            offsetX: payload.x,\n            offsetY: payload.y,\n            target: el\n          }, dispatchAction);\n        } else if (dataByCoordSys) {\n          this._tryShow({\n            offsetX: payload.x,\n            offsetY: payload.y,\n            position: payload.position,\n            dataByCoordSys: dataByCoordSys,\n            tooltipOption: payload.tooltipOption\n          }, dispatchAction);\n        } else if (payload.seriesIndex != null) {\n          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n            return;\n          }\n\n          var pointInfo = findPointFromSeries(payload, ecModel);\n          var cx = pointInfo.point[0];\n          var cy = pointInfo.point[1];\n\n          if (cx != null && cy != null) {\n            this._tryShow({\n              offsetX: cx,\n              offsetY: cy,\n              position: payload.position,\n              target: pointInfo.el\n            }, dispatchAction);\n          }\n        } else if (payload.x != null && payload.y != null) {\n          api.dispatchAction({\n            type: 'updateAxisPointer',\n            x: payload.x,\n            y: payload.y\n          });\n\n          this._tryShow({\n            offsetX: payload.x,\n            offsetY: payload.y,\n            position: payload.position,\n            target: api.getZr().findHover(payload.x, payload.y).target\n          }, dispatchAction);\n        }\n      };\n\n      TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {\n        var tooltipContent = this._tooltipContent;\n\n        if (!this._alwaysShowContent && this._tooltipModel) {\n          tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n        }\n\n        this._lastX = this._lastY = this._lastDataByCoordSys = null;\n\n        if (payload.from !== this.uid) {\n          this._hide(makeDispatchAction$1(payload, api));\n        }\n      };\n\n      TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {\n        var seriesIndex = payload.seriesIndex;\n        var dataIndex = payload.dataIndex;\n        var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n\n        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n          return;\n        }\n\n        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\n        if (!seriesModel) {\n          return;\n        }\n\n        var data = seriesModel.getData();\n        var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);\n\n        if (tooltipCascadedModel.get('trigger') !== 'axis') {\n          return;\n        }\n\n        api.dispatchAction({\n          type: 'updateAxisPointer',\n          seriesIndex: seriesIndex,\n          dataIndex: dataIndex,\n          position: payload.position\n        });\n        return true;\n      };\n\n      TooltipView.prototype._tryShow = function (e, dispatchAction) {\n        var el = e.target;\n        var tooltipModel = this._tooltipModel;\n\n        if (!tooltipModel) {\n          return;\n        }\n\n        this._lastX = e.offsetX;\n        this._lastY = e.offsetY;\n        var dataByCoordSys = e.dataByCoordSys;\n\n        if (dataByCoordSys && dataByCoordSys.length) {\n          this._showAxisTooltip(dataByCoordSys, e);\n        } else if (el && findEventDispatcher(el, function (target) {\n          return getECData(target).dataIndex != null;\n        }, true)) {\n          this._lastDataByCoordSys = null;\n\n          this._showSeriesItemTooltip(e, el, dispatchAction);\n        } else if (el && el.tooltip) {\n          this._lastDataByCoordSys = null;\n\n          this._showComponentItemTooltip(e, el, dispatchAction);\n        } else {\n          this._lastDataByCoordSys = null;\n\n          this._hide(dispatchAction);\n        }\n      };\n\n      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\n        var delay = tooltipModel.get('showDelay');\n        cb = bind(cb, this);\n        clearTimeout(this._showTimout);\n        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n      };\n\n      TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {\n        var ecModel = this._ecModel;\n        var globalTooltipModel = this._tooltipModel;\n        var point = [e.offsetX, e.offsetY];\n        var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);\n        var renderMode = this._renderMode;\n        var cbParamsList = [];\n        var articleMarkup = createTooltipMarkup('section', {\n          blocks: [],\n          noHeader: true\n        });\n        var markupTextArrLegacy = [];\n        var markupStyleCreator = new TooltipMarkupStyleCreator();\n        each$c(dataByCoordSys, function (itemCoordSys) {\n          each$c(itemCoordSys.dataByAxis, function (axisItem) {\n            var axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex);\n            var axisValue = axisItem.value;\n\n            if (!axisModel || axisValue == null) {\n              return;\n            }\n\n            var axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);\n            var axisSectionMarkup = createTooltipMarkup('section', {\n              header: axisValueLabel,\n              noHeader: !trim(axisValueLabel),\n              sortBlocks: true,\n              blocks: []\n            });\n            articleMarkup.blocks.push(axisSectionMarkup);\n            each(axisItem.seriesDataIndices, function (idxItem) {\n              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n              var dataIndex = idxItem.dataIndexInside;\n              var cbParams = series.getDataParams(dataIndex);\n              cbParams.axisDim = axisItem.axisDim;\n              cbParams.axisIndex = axisItem.axisIndex;\n              cbParams.axisType = axisItem.axisType;\n              cbParams.axisId = axisItem.axisId;\n              cbParams.axisValue = getAxisRawValue(axisModel.axis, {\n                value: axisValue\n              });\n              cbParams.axisValueLabel = axisValueLabel;\n              cbParams.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(cbParams.color), renderMode);\n              var seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));\n\n              if (seriesTooltipResult.markupFragment) {\n                axisSectionMarkup.blocks.push(seriesTooltipResult.markupFragment);\n              }\n\n              if (seriesTooltipResult.markupText) {\n                markupTextArrLegacy.push(seriesTooltipResult.markupText);\n              }\n\n              cbParamsList.push(cbParams);\n            });\n          });\n        });\n        articleMarkup.blocks.reverse();\n        markupTextArrLegacy.reverse();\n        var positionExpr = e.position;\n        var orderMode = singleTooltipModel.get('order');\n        var builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), singleTooltipModel.get('textStyle'));\n        builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);\n        var blockBreak = renderMode === 'richText' ? '\\n\\n' : '<br/>';\n        var allMarkupText = markupTextArrLegacy.join(blockBreak);\n\n        this._showOrMove(singleTooltipModel, function () {\n          if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {\n            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);\n          } else {\n            this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator);\n          }\n        });\n      };\n\n      TooltipView.prototype._showSeriesItemTooltip = function (e, el, dispatchAction) {\n        var dispatcher = findEventDispatcher(el, function (target) {\n          return getECData(target).dataIndex != null;\n        }, true);\n        var ecModel = this._ecModel;\n        var ecData = getECData(dispatcher);\n        var seriesIndex = ecData.seriesIndex;\n        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n        var dataModel = ecData.dataModel || seriesModel;\n        var dataIndex = ecData.dataIndex;\n        var dataType = ecData.dataType;\n        var data = dataModel.getData(dataType);\n        var renderMode = this._renderMode;\n        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);\n        var tooltipTrigger = tooltipModel.get('trigger');\n\n        if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n          return;\n        }\n\n        var params = dataModel.getDataParams(dataIndex, dataType);\n        var markupStyleCreator = new TooltipMarkupStyleCreator();\n        params.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(params.color), renderMode);\n        var seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));\n        var orderMode = tooltipModel.get('order');\n        var markupText = seriesTooltipResult.markupFragment ? buildTooltipMarkup(seriesTooltipResult.markupFragment, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), tooltipModel.get('textStyle')) : seriesTooltipResult.markupText;\n        var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n\n        this._showOrMove(tooltipModel, function () {\n          this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator);\n        });\n\n        dispatchAction({\n          type: 'showTip',\n          dataIndexInside: dataIndex,\n          dataIndex: data.getRawIndex(dataIndex),\n          seriesIndex: seriesIndex,\n          from: this.uid\n        });\n      };\n\n      TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {\n        var tooltipOpt = el.tooltip;\n\n        if (isString(tooltipOpt)) {\n          var content = tooltipOpt;\n          tooltipOpt = {\n            content: content,\n            formatter: content\n          };\n        }\n\n        var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);\n        var defaultHtml = subTooltipModel.get('content');\n        var asyncTicket = Math.random() + '';\n        var markupStyleCreator = new TooltipMarkupStyleCreator();\n\n        this._showOrMove(subTooltipModel, function () {\n          this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator);\n        });\n\n        dispatchAction({\n          type: 'showTip',\n          from: this.uid\n        });\n      };\n\n      TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {\n        this._ticket = '';\n\n        if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n          return;\n        }\n\n        var tooltipContent = this._tooltipContent;\n        var formatter = tooltipModel.get('formatter');\n        positionExpr = positionExpr || tooltipModel.get('position');\n        var html = defaultHtml;\n\n        var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'), tooltipModel.get('borderColor'));\n\n        if (formatter && isString(formatter)) {\n          var useUTC = tooltipModel.ecModel.get('useUTC');\n          var params0 = isArray(params) ? params[0] : params;\n          var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0;\n          html = formatter;\n\n          if (isTimeAxis) {\n            html = format(params0.axisValue, html, useUTC);\n          }\n\n          html = formatTpl(html, params, true);\n        } else if (isFunction(formatter)) {\n          var callback = bind$2(function (cbTicket, html) {\n            if (cbTicket === this._ticket) {\n              tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);\n\n              this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n            }\n          }, this);\n          this._ticket = asyncTicket;\n          html = formatter(params, asyncTicket, callback);\n        }\n\n        tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);\n        tooltipContent.show(tooltipModel, nearPoint.color);\n\n        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n      };\n\n      TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger, borderColor) {\n        if (trigger === 'axis' || isArray(tooltipDataParams)) {\n          return {\n            color: borderColor || (this._renderMode === 'html' ? '#fff' : 'none')\n          };\n        }\n\n        if (!isArray(tooltipDataParams)) {\n          return {\n            color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor\n          };\n        }\n      };\n\n      TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {\n        var viewWidth = this._api.getWidth();\n\n        var viewHeight = this._api.getHeight();\n\n        positionExpr = positionExpr || tooltipModel.get('position');\n        var contentSize = content.getSize();\n        var align = tooltipModel.get('align');\n        var vAlign = tooltipModel.get('verticalAlign');\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n\n        if (isFunction(positionExpr)) {\n          positionExpr = positionExpr([x, y], params, content.el, rect, {\n            viewSize: [viewWidth, viewHeight],\n            contentSize: contentSize.slice()\n          });\n        }\n\n        if (isArray(positionExpr)) {\n          x = parsePercent$3(positionExpr[0], viewWidth);\n          y = parsePercent$3(positionExpr[1], viewHeight);\n        } else if (isObject(positionExpr)) {\n          var boxLayoutPosition = positionExpr;\n          boxLayoutPosition.width = contentSize[0];\n          boxLayoutPosition.height = contentSize[1];\n          var layoutRect = getLayoutRect(boxLayoutPosition, {\n            width: viewWidth,\n            height: viewHeight\n          });\n          x = layoutRect.x;\n          y = layoutRect.y;\n          align = null;\n          vAlign = null;\n        } else if (isString(positionExpr) && el) {\n          var pos = calcTooltipPosition(positionExpr, rect, contentSize);\n          x = pos[0];\n          y = pos[1];\n        } else {\n          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n          x = pos[0];\n          y = pos[1];\n        }\n\n        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n\n        if (shouldTooltipConfine(tooltipModel)) {\n          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);\n          x = pos[0];\n          y = pos[1];\n        }\n\n        content.moveTo(x, y);\n      };\n\n      TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys) {\n        var lastCoordSys = this._lastDataByCoordSys;\n        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n        contentNotChanged && each$c(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n          var lastDataByAxis = lastItemCoordSys.dataByAxis || [];\n          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n          contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;\n          contentNotChanged && each$c(lastDataByAxis, function (lastItem, indexAxis) {\n            var thisItem = thisDataByAxis[indexAxis] || {};\n            var lastIndices = lastItem.seriesDataIndices || [];\n            var newIndices = thisItem.seriesDataIndices || [];\n            contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n            contentNotChanged && each$c(lastIndices, function (lastIdxItem, j) {\n              var newIdxItem = newIndices[j];\n              contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n            });\n          });\n        });\n        this._lastDataByCoordSys = dataByCoordSys;\n        return !!contentNotChanged;\n      };\n\n      TooltipView.prototype._hide = function (dispatchAction) {\n        this._lastDataByCoordSys = null;\n        dispatchAction({\n          type: 'hideTip',\n          from: this.uid\n        });\n      };\n\n      TooltipView.prototype.dispose = function (ecModel, api) {\n        if (env.node) {\n          return;\n        }\n\n        this._tooltipContent.dispose();\n\n        unregister('itemTooltip', api);\n      };\n\n      TooltipView.type = 'tooltip';\n      return TooltipView;\n    }(ComponentView);\n\n    function buildTooltipModel(modelCascade) {\n      var resultModel = modelCascade.pop();\n\n      while (modelCascade.length) {\n        var tooltipOpt = modelCascade.pop();\n\n        if (tooltipOpt) {\n          if (tooltipOpt instanceof Model) {\n            tooltipOpt = tooltipOpt.get('tooltip', true);\n          }\n\n          if (isString(tooltipOpt)) {\n            tooltipOpt = {\n              formatter: tooltipOpt\n            };\n          }\n\n          resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);\n        }\n      }\n\n      return resultModel;\n    }\n\n    function makeDispatchAction$1(payload, api) {\n      return payload.dispatchAction || bind(api.dispatchAction, api);\n    }\n\n    function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {\n      var size = content.getOuterSize();\n      var width = size.width;\n      var height = size.height;\n\n      if (gapH != null) {\n        if (x + width + gapH + 2 > viewWidth) {\n          x -= width + gapH;\n        } else {\n          x += gapH;\n        }\n      }\n\n      if (gapV != null) {\n        if (y + height + gapV > viewHeight) {\n          y -= height + gapV;\n        } else {\n          y += gapV;\n        }\n      }\n\n      return [x, y];\n    }\n\n    function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {\n      var size = content.getOuterSize();\n      var width = size.width;\n      var height = size.height;\n      x = Math.min(x + width, viewWidth) - width;\n      y = Math.min(y + height, viewHeight) - height;\n      x = Math.max(x, 0);\n      y = Math.max(y, 0);\n      return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, contentSize) {\n      var domWidth = contentSize[0];\n      var domHeight = contentSize[1];\n      var gap = 10;\n      var offset = 5;\n      var x = 0;\n      var y = 0;\n      var rectWidth = rect.width;\n      var rectHeight = rect.height;\n\n      switch (position) {\n        case 'inside':\n          x = rect.x + rectWidth / 2 - domWidth / 2;\n          y = rect.y + rectHeight / 2 - domHeight / 2;\n          break;\n\n        case 'top':\n          x = rect.x + rectWidth / 2 - domWidth / 2;\n          y = rect.y - domHeight - gap;\n          break;\n\n        case 'bottom':\n          x = rect.x + rectWidth / 2 - domWidth / 2;\n          y = rect.y + rectHeight + gap;\n          break;\n\n        case 'left':\n          x = rect.x - domWidth - gap - offset;\n          y = rect.y + rectHeight / 2 - domHeight / 2;\n          break;\n\n        case 'right':\n          x = rect.x + rectWidth + gap + offset;\n          y = rect.y + rectHeight / 2 - domHeight / 2;\n      }\n\n      return [x, y];\n    }\n\n    function isCenterAlign(align) {\n      return align === 'center' || align === 'middle';\n    }\n\n    function install$A(registers) {\n      use(install$r);\n      registers.registerComponentModel(TooltipModel);\n      registers.registerComponentView(TooltipView);\n      registers.registerAction({\n        type: 'showTip',\n        event: 'showTip',\n        update: 'tooltip:manuallyShowTip'\n      }, function () {});\n      registers.registerAction({\n        type: 'hideTip',\n        event: 'hideTip',\n        update: 'tooltip:manuallyHideTip'\n      }, function () {});\n    }\n\n    var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear'];\n    function brushPreprocessor(option, isNew) {\n      var brushComponents = normalizeToArray(option ? option.brush : []);\n\n      if (!brushComponents.length) {\n        return;\n      }\n\n      var brushComponentSpecifiedBtns = [];\n      each(brushComponents, function (brushOpt) {\n        var tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : [];\n\n        if (tbs instanceof Array) {\n          brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);\n        }\n      });\n      var toolbox = option && option.toolbox;\n\n      if (isArray(toolbox)) {\n        toolbox = toolbox[0];\n      }\n\n      if (!toolbox) {\n        toolbox = {\n          feature: {}\n        };\n        option.toolbox = [toolbox];\n      }\n\n      var toolboxFeature = toolbox.feature || (toolbox.feature = {});\n      var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});\n      var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);\n      brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);\n      removeDuplicate(brushTypes);\n\n      if (isNew && !brushTypes.length) {\n        brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);\n      }\n    }\n\n    function removeDuplicate(arr) {\n      var map = {};\n      each(arr, function (val) {\n        map[val] = 1;\n      });\n      arr.length = 0;\n      each(map, function (flag, val) {\n        arr.push(val);\n      });\n    }\n\n    var each$d = each;\n\n    function hasKeys(obj) {\n      if (obj) {\n        for (var name_1 in obj) {\n          if (obj.hasOwnProperty(name_1)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    function createVisualMappings(option, stateList, supplementVisualOption) {\n      var visualMappings = {};\n      each$d(stateList, function (state) {\n        var mappings = visualMappings[state] = createMappings();\n        each$d(option[state], function (visualData, visualType) {\n          if (!VisualMapping.isValidType(visualType)) {\n            return;\n          }\n\n          var mappingOption = {\n            type: visualType,\n            visual: visualData\n          };\n          supplementVisualOption && supplementVisualOption(mappingOption, state);\n          mappings[visualType] = new VisualMapping(mappingOption);\n\n          if (visualType === 'opacity') {\n            mappingOption = clone(mappingOption);\n            mappingOption.type = 'colorAlpha';\n            mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);\n          }\n        });\n      });\n      return visualMappings;\n\n      function createMappings() {\n        var Creater = function () {};\n\n        Creater.prototype.__hidden = Creater.prototype;\n        var obj = new Creater();\n        return obj;\n      }\n    }\n    function replaceVisualOption(thisOption, newOption, keys) {\n      var has;\n      each(keys, function (key) {\n        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {\n          has = true;\n        }\n      });\n      has && each(keys, function (key) {\n        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {\n          thisOption[key] = clone(newOption[key]);\n        } else {\n          delete thisOption[key];\n        }\n      });\n    }\n    function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {\n      var visualTypesMap = {};\n      each(stateList, function (state) {\n        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);\n        visualTypesMap[state] = visualTypes;\n      });\n      var dataIndex;\n\n      function getVisual(key) {\n        return getItemVisualFromData(data, dataIndex, key);\n      }\n\n      function setVisual(key, value) {\n        setItemVisualFromData(data, dataIndex, key, value);\n      }\n\n      if (dimension == null) {\n        data.each(eachItem);\n      } else {\n        data.each([dimension], eachItem);\n      }\n\n      function eachItem(valueOrIndex, index) {\n        dataIndex = dimension == null ? valueOrIndex : index;\n        var rawDataItem = data.getRawDataItem(dataIndex);\n\n        if (rawDataItem && rawDataItem.visualMap === false) {\n          return;\n        }\n\n        var valueState = getValueState.call(scope, valueOrIndex);\n        var mappings = visualMappings[valueState];\n        var visualTypes = visualTypesMap[valueState];\n\n        for (var i = 0, len = visualTypes.length; i < len; i++) {\n          var type = visualTypes[i];\n          mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);\n        }\n      }\n    }\n    function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {\n      var visualTypesMap = {};\n      each(stateList, function (state) {\n        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);\n        visualTypesMap[state] = visualTypes;\n      });\n      return {\n        progress: function progress(params, data) {\n          var dimName;\n\n          if (dim != null) {\n            dimName = data.getDimension(dim);\n          }\n\n          function getVisual(key) {\n            return getItemVisualFromData(data, dataIndex, key);\n          }\n\n          function setVisual(key, value) {\n            setItemVisualFromData(data, dataIndex, key, value);\n          }\n\n          var dataIndex;\n\n          while ((dataIndex = params.next()) != null) {\n            var rawDataItem = data.getRawDataItem(dataIndex);\n\n            if (rawDataItem && rawDataItem.visualMap === false) {\n              continue;\n            }\n\n            var value = dim != null ? data.get(dimName, dataIndex) : dataIndex;\n            var valueState = getValueState(value);\n            var mappings = visualMappings[valueState];\n            var visualTypes = visualTypesMap[valueState];\n\n            for (var i = 0, len = visualTypes.length; i < len; i++) {\n              var type = visualTypes[i];\n              mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);\n            }\n          }\n        }\n      };\n    }\n\n    function makeBrushCommonSelectorForSeries(area) {\n      var brushType = area.brushType;\n      var selectors = {\n        point: function (itemLayout) {\n          return selector[brushType].point(itemLayout, selectors, area);\n        },\n        rect: function (itemLayout) {\n          return selector[brushType].rect(itemLayout, selectors, area);\n        }\n      };\n      return selectors;\n    }\n    var selector = {\n      lineX: getLineSelectors(0),\n      lineY: getLineSelectors(1),\n      rect: {\n        point: function (itemLayout, selectors, area) {\n          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);\n        },\n        rect: function (itemLayout, selectors, area) {\n          return itemLayout && area.boundingRect.intersect(itemLayout);\n        }\n      },\n      polygon: {\n        point: function (itemLayout, selectors, area) {\n          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain$2(area.range, itemLayout[0], itemLayout[1]);\n        },\n        rect: function (itemLayout, selectors, area) {\n          var points = area.range;\n\n          if (!itemLayout || points.length <= 1) {\n            return false;\n          }\n\n          var x = itemLayout.x;\n          var y = itemLayout.y;\n          var width = itemLayout.width;\n          var height = itemLayout.height;\n          var p = points[0];\n\n          if (contain$2(points, x, y) || contain$2(points, x + width, y) || contain$2(points, x, y + height) || contain$2(points, x + width, y + height) || BoundingRect.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points) || linePolygonIntersect(x, y, x, y + height, points) || linePolygonIntersect(x + width, y, x + width, y + height, points) || linePolygonIntersect(x, y + height, x + width, y + height, points)) {\n            return true;\n          }\n        }\n      }\n    };\n\n    function getLineSelectors(xyIndex) {\n      var xy = ['x', 'y'];\n      var wh = ['width', 'height'];\n      return {\n        point: function (itemLayout, selectors, area) {\n          if (itemLayout) {\n            var range = area.range;\n            var p = itemLayout[xyIndex];\n            return inLineRange(p, range);\n          }\n        },\n        rect: function (itemLayout, selectors, area) {\n          if (itemLayout) {\n            var range = area.range;\n            var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];\n            layoutRange[1] < layoutRange[0] && layoutRange.reverse();\n            return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);\n          }\n        }\n      };\n    }\n\n    function inLineRange(p, range) {\n      return range[0] <= p && p <= range[1];\n    }\n\n    var STATE_LIST = ['inBrush', 'outOfBrush'];\n    var DISPATCH_METHOD = '__ecBrushSelect';\n    var DISPATCH_FLAG = '__ecInBrushSelectEvent';\n    function layoutCovers(ecModel) {\n      ecModel.eachComponent({\n        mainType: 'brush'\n      }, function (brushModel) {\n        var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);\n        brushTargetManager.setInputRanges(brushModel.areas, ecModel);\n      });\n    }\n    function brushVisual(ecModel, api, payload) {\n      var brushSelected = [];\n      var throttleType;\n      var throttleDelay;\n      ecModel.eachComponent({\n        mainType: 'brush'\n      }, function (brushModel) {\n        payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush' ? payload.brushOption : {\n          brushType: false\n        });\n      });\n      layoutCovers(ecModel);\n      ecModel.eachComponent({\n        mainType: 'brush'\n      }, function (brushModel, brushIndex) {\n        var thisBrushSelected = {\n          brushId: brushModel.id,\n          brushIndex: brushIndex,\n          brushName: brushModel.name,\n          areas: clone(brushModel.areas),\n          selected: []\n        };\n        brushSelected.push(thisBrushSelected);\n        var brushOption = brushModel.option;\n        var brushLink = brushOption.brushLink;\n        var linkedSeriesMap = [];\n        var selectedDataIndexForLink = [];\n        var rangeInfoBySeries = [];\n        var hasBrushExists = false;\n\n        if (!brushIndex) {\n          throttleType = brushOption.throttleType;\n          throttleDelay = brushOption.throttleDelay;\n        }\n\n        var areas = map(brushModel.areas, function (area) {\n          var builder = boundingRectBuilders[area.brushType];\n          var selectableArea = defaults({\n            boundingRect: builder ? builder(area) : void 0\n          }, area);\n          selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);\n          return selectableArea;\n        });\n        var visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function (mappingOption) {\n          mappingOption.mappingMethod = 'fixed';\n        });\n        isArray(brushLink) && each(brushLink, function (seriesIndex) {\n          linkedSeriesMap[seriesIndex] = 1;\n        });\n\n        function linkOthers(seriesIndex) {\n          return brushLink === 'all' || !!linkedSeriesMap[seriesIndex];\n        }\n\n        function brushed(rangeInfoList) {\n          return !!rangeInfoList.length;\n        }\n\n        ecModel.eachSeries(function (seriesModel, seriesIndex) {\n          var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];\n          seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);\n        });\n\n        function stepAParallel(seriesModel, seriesIndex) {\n          var coordSys = seriesModel.coordinateSystem;\n          hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();\n          linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function (activeState, dataIndex) {\n            activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1);\n          });\n        }\n\n        function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {\n          if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {\n            return;\n          }\n\n          each(areas, function (area) {\n            if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {\n              rangeInfoList.push(area);\n            }\n\n            hasBrushExists = hasBrushExists || brushed(rangeInfoList);\n          });\n\n          if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {\n            var data_1 = seriesModel.getData();\n            data_1.each(function (dataIndex) {\n              if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {\n                selectedDataIndexForLink[dataIndex] = 1;\n              }\n            });\n          }\n        }\n\n        ecModel.eachSeries(function (seriesModel, seriesIndex) {\n          var seriesBrushSelected = {\n            seriesId: seriesModel.id,\n            seriesIndex: seriesIndex,\n            seriesName: seriesModel.name,\n            dataIndex: []\n          };\n          thisBrushSelected.selected.push(seriesBrushSelected);\n          var rangeInfoList = rangeInfoBySeries[seriesIndex];\n          var data = seriesModel.getData();\n          var getValueState = linkOthers(seriesIndex) ? function (dataIndex) {\n            return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';\n          } : function (dataIndex) {\n            return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush';\n          };\n          (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);\n        });\n      });\n      dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);\n    }\n\n    function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {\n      if (!payload) {\n        return;\n      }\n\n      var zr = api.getZr();\n\n      if (zr[DISPATCH_FLAG]) {\n        return;\n      }\n\n      if (!zr[DISPATCH_METHOD]) {\n        zr[DISPATCH_METHOD] = doDispatch;\n      }\n\n      var fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);\n      fn(api, brushSelected);\n    }\n\n    function doDispatch(api, brushSelected) {\n      if (!api.isDisposed()) {\n        var zr = api.getZr();\n        zr[DISPATCH_FLAG] = true;\n        api.dispatchAction({\n          type: 'brushSelect',\n          batch: brushSelected\n        });\n        zr[DISPATCH_FLAG] = false;\n      }\n    }\n\n    function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {\n      for (var i = 0, len = rangeInfoList.length; i < len; i++) {\n        var area = rangeInfoList[i];\n\n        if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {\n          return true;\n        }\n      }\n    }\n\n    function brushModelNotControll(brushModel, seriesIndex) {\n      var seriesIndices = brushModel.option.seriesIndex;\n      return seriesIndices != null && seriesIndices !== 'all' && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);\n    }\n\n    var boundingRectBuilders = {\n      rect: function (area) {\n        return getBoundingRectFromMinMax(area.range);\n      },\n      polygon: function (area) {\n        var minMax;\n        var range = area.range;\n\n        for (var i = 0, len = range.length; i < len; i++) {\n          minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];\n          var rg = range[i];\n          rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);\n          rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);\n          rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);\n          rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);\n        }\n\n        return minMax && getBoundingRectFromMinMax(minMax);\n      }\n    };\n\n    function getBoundingRectFromMinMax(minMax) {\n      return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);\n    }\n\n    var BrushView = function (_super) {\n      __extends(BrushView, _super);\n\n      function BrushView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BrushView.type;\n        return _this;\n      }\n\n      BrushView.prototype.init = function (ecModel, api) {\n        this.ecModel = ecModel;\n        this.api = api;\n        this.model;\n        (this._brushController = new BrushController(api.getZr())).on('brush', bind(this._onBrush, this)).mount();\n      };\n\n      BrushView.prototype.render = function (brushModel, ecModel, api, payload) {\n        this.model = brushModel;\n\n        this._updateController(brushModel, ecModel, api, payload);\n      };\n\n      BrushView.prototype.updateTransform = function (brushModel, ecModel, api, payload) {\n        layoutCovers(ecModel);\n\n        this._updateController(brushModel, ecModel, api, payload);\n      };\n\n      BrushView.prototype.updateVisual = function (brushModel, ecModel, api, payload) {\n        this.updateTransform(brushModel, ecModel, api, payload);\n      };\n\n      BrushView.prototype.updateView = function (brushModel, ecModel, api, payload) {\n        this._updateController(brushModel, ecModel, api, payload);\n      };\n\n      BrushView.prototype._updateController = function (brushModel, ecModel, api, payload) {\n        (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());\n      };\n\n      BrushView.prototype.dispose = function () {\n        this._brushController.dispose();\n      };\n\n      BrushView.prototype._onBrush = function (eventParam) {\n        var modelId = this.model.id;\n        var areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);\n        (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({\n          type: 'brush',\n          brushId: modelId,\n          areas: clone(areas),\n          $from: modelId\n        });\n        eventParam.isEnd && this.api.dispatchAction({\n          type: 'brushEnd',\n          brushId: modelId,\n          areas: clone(areas),\n          $from: modelId\n        });\n      };\n\n      BrushView.type = 'brush';\n      return BrushView;\n    }(ComponentView);\n\n    var DEFAULT_OUT_OF_BRUSH_COLOR = '#ddd';\n\n    var BrushModel = function (_super) {\n      __extends(BrushModel, _super);\n\n      function BrushModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = BrushModel.type;\n        _this.areas = [];\n        _this.brushOption = {};\n        return _this;\n      }\n\n      BrushModel.prototype.optionUpdated = function (newOption, isInit) {\n        var thisOption = this.option;\n        !isInit && replaceVisualOption(thisOption, newOption, ['inBrush', 'outOfBrush']);\n        var inBrush = thisOption.inBrush = thisOption.inBrush || {};\n        thisOption.outOfBrush = thisOption.outOfBrush || {\n          color: DEFAULT_OUT_OF_BRUSH_COLOR\n        };\n\n        if (!inBrush.hasOwnProperty('liftZ')) {\n          inBrush.liftZ = 5;\n        }\n      };\n\n      BrushModel.prototype.setAreas = function (areas) {\n        if (\"development\" !== 'production') {\n          assert(isArray(areas));\n          each(areas, function (area) {\n            assert(area.brushType, 'Illegal areas');\n          });\n        }\n\n        if (!areas) {\n          return;\n        }\n\n        this.areas = map(areas, function (area) {\n          return generateBrushOption(this.option, area);\n        }, this);\n      };\n\n      BrushModel.prototype.setBrushOption = function (brushOption) {\n        this.brushOption = generateBrushOption(this.option, brushOption);\n        this.brushType = this.brushOption.brushType;\n      };\n\n      BrushModel.type = 'brush';\n      BrushModel.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series'];\n      BrushModel.defaultOption = {\n        seriesIndex: 'all',\n        brushType: 'rect',\n        brushMode: 'single',\n        transformable: true,\n        brushStyle: {\n          borderWidth: 1,\n          color: 'rgba(210,219,238,0.3)',\n          borderColor: '#D2DBEE'\n        },\n        throttleType: 'fixRate',\n        throttleDelay: 0,\n        removeOnClick: true,\n        z: 10000\n      };\n      return BrushModel;\n    }(ComponentModel);\n\n    function generateBrushOption(option, brushOption) {\n      return merge({\n        brushType: option.brushType,\n        brushMode: option.brushMode,\n        transformable: option.transformable,\n        brushStyle: new Model(option.brushStyle).getItemStyle(),\n        removeOnClick: option.removeOnClick,\n        z: option.z\n      }, brushOption, true);\n    }\n\n    var ICON_TYPES = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'];\n\n    var BrushFeature = function (_super) {\n      __extends(BrushFeature, _super);\n\n      function BrushFeature() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      BrushFeature.prototype.render = function (featureModel, ecModel, api) {\n        var brushType;\n        var brushMode;\n        var isBrushed;\n        ecModel.eachComponent({\n          mainType: 'brush'\n        }, function (brushModel) {\n          brushType = brushModel.brushType;\n          brushMode = brushModel.brushOption.brushMode || 'single';\n          isBrushed = isBrushed || !!brushModel.areas.length;\n        });\n        this._brushType = brushType;\n        this._brushMode = brushMode;\n        each(featureModel.get('type', true), function (type) {\n          featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal');\n        });\n      };\n\n      BrushFeature.prototype.updateView = function (featureModel, ecModel, api) {\n        this.render(featureModel, ecModel, api);\n      };\n\n      BrushFeature.prototype.getIcons = function () {\n        var model = this.model;\n        var availableIcons = model.get('icon', true);\n        var icons = {};\n        each(model.get('type', true), function (type) {\n          if (availableIcons[type]) {\n            icons[type] = availableIcons[type];\n          }\n        });\n        return icons;\n      };\n\n      BrushFeature.prototype.onclick = function (ecModel, api, type) {\n        var brushType = this._brushType;\n        var brushMode = this._brushMode;\n\n        if (type === 'clear') {\n          api.dispatchAction({\n            type: 'axisAreaSelect',\n            intervals: []\n          });\n          api.dispatchAction({\n            type: 'brush',\n            command: 'clear',\n            areas: []\n          });\n        } else {\n          api.dispatchAction({\n            type: 'takeGlobalCursor',\n            key: 'brush',\n            brushOption: {\n              brushType: type === 'keep' ? brushType : brushType === type ? false : type,\n              brushMode: type === 'keep' ? brushMode === 'multiple' ? 'single' : 'multiple' : brushMode\n            }\n          });\n        }\n      };\n\n      BrushFeature.getDefaultOption = function (ecModel) {\n        var defaultOption = {\n          show: true,\n          type: ICON_TYPES.slice(),\n          icon: {\n            rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',\n            polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',\n            lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',\n            lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',\n            keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',\n            clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2'\n          },\n          title: ecModel.getLocale(['toolbox', 'brush', 'title'])\n        };\n        return defaultOption;\n      };\n\n      return BrushFeature;\n    }(ToolboxFeature);\n\n    function install$B(registers) {\n      registers.registerComponentView(BrushView);\n      registers.registerComponentModel(BrushModel);\n      registers.registerPreprocessor(brushPreprocessor);\n      registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);\n      registers.registerAction({\n        type: 'brush',\n        event: 'brush',\n        update: 'updateVisual'\n      }, function (payload, ecModel) {\n        ecModel.eachComponent({\n          mainType: 'brush',\n          query: payload\n        }, function (brushModel) {\n          brushModel.setAreas(payload.areas);\n        });\n      });\n      registers.registerAction({\n        type: 'brushSelect',\n        event: 'brushSelected',\n        update: 'none'\n      }, function () {});\n      registers.registerAction({\n        type: 'brushEnd',\n        event: 'brushEnd',\n        update: 'none'\n      }, function () {});\n      registerFeature('brush', BrushFeature);\n    }\n\n    var TitleModel = function (_super) {\n      __extends(TitleModel, _super);\n\n      function TitleModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TitleModel.type;\n        _this.layoutMode = {\n          type: 'box',\n          ignoreSize: true\n        };\n        return _this;\n      }\n\n      TitleModel.type = 'title';\n      TitleModel.defaultOption = {\n        zlevel: 0,\n        z: 6,\n        show: true,\n        text: '',\n        target: 'blank',\n        subtext: '',\n        subtarget: 'blank',\n        left: 0,\n        top: 0,\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',\n        borderWidth: 0,\n        padding: 5,\n        itemGap: 10,\n        textStyle: {\n          fontSize: 18,\n          fontWeight: 'bold',\n          color: '#464646'\n        },\n        subtextStyle: {\n          fontSize: 12,\n          color: '#6E7079'\n        }\n      };\n      return TitleModel;\n    }(ComponentModel);\n\n    var TitleView = function (_super) {\n      __extends(TitleView, _super);\n\n      function TitleView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TitleView.type;\n        return _this;\n      }\n\n      TitleView.prototype.render = function (titleModel, ecModel, api) {\n        this.group.removeAll();\n\n        if (!titleModel.get('show')) {\n          return;\n        }\n\n        var group = this.group;\n        var textStyleModel = titleModel.getModel('textStyle');\n        var subtextStyleModel = titleModel.getModel('subtextStyle');\n        var textAlign = titleModel.get('textAlign');\n        var textVerticalAlign = retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));\n        var textEl = new ZRText({\n          style: createTextStyle(textStyleModel, {\n            text: titleModel.get('text'),\n            fill: textStyleModel.getTextColor()\n          }, {\n            disableBox: true\n          }),\n          z2: 10\n        });\n        var textRect = textEl.getBoundingRect();\n        var subText = titleModel.get('subtext');\n        var subTextEl = new ZRText({\n          style: createTextStyle(subtextStyleModel, {\n            text: subText,\n            fill: subtextStyleModel.getTextColor(),\n            y: textRect.height + titleModel.get('itemGap'),\n            verticalAlign: 'top'\n          }, {\n            disableBox: true\n          }),\n          z2: 10\n        });\n        var link = titleModel.get('link');\n        var sublink = titleModel.get('sublink');\n        var triggerEvent = titleModel.get('triggerEvent', true);\n        textEl.silent = !link && !triggerEvent;\n        subTextEl.silent = !sublink && !triggerEvent;\n\n        if (link) {\n          textEl.on('click', function () {\n            windowOpen(link, '_' + titleModel.get('target'));\n          });\n        }\n\n        if (sublink) {\n          subTextEl.on('click', function () {\n            windowOpen(sublink, '_' + titleModel.get('subtarget'));\n          });\n        }\n\n        getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {\n          componentType: 'title',\n          componentIndex: titleModel.componentIndex\n        } : null;\n        group.add(textEl);\n        subText && group.add(subTextEl);\n        var groupRect = group.getBoundingRect();\n        var layoutOption = titleModel.getBoxLayoutParams();\n        layoutOption.width = groupRect.width;\n        layoutOption.height = groupRect.height;\n        var layoutRect = getLayoutRect(layoutOption, {\n          width: api.getWidth(),\n          height: api.getHeight()\n        }, titleModel.get('padding'));\n\n        if (!textAlign) {\n          textAlign = titleModel.get('left') || titleModel.get('right');\n\n          if (textAlign === 'middle') {\n            textAlign = 'center';\n          }\n\n          if (textAlign === 'right') {\n            layoutRect.x += layoutRect.width;\n          } else if (textAlign === 'center') {\n            layoutRect.x += layoutRect.width / 2;\n          }\n        }\n\n        if (!textVerticalAlign) {\n          textVerticalAlign = titleModel.get('top') || titleModel.get('bottom');\n\n          if (textVerticalAlign === 'center') {\n            textVerticalAlign = 'middle';\n          }\n\n          if (textVerticalAlign === 'bottom') {\n            layoutRect.y += layoutRect.height;\n          } else if (textVerticalAlign === 'middle') {\n            layoutRect.y += layoutRect.height / 2;\n          }\n\n          textVerticalAlign = textVerticalAlign || 'top';\n        }\n\n        group.x = layoutRect.x;\n        group.y = layoutRect.y;\n        group.markRedraw();\n        var alignStyle = {\n          align: textAlign,\n          verticalAlign: textVerticalAlign\n        };\n        textEl.setStyle(alignStyle);\n        subTextEl.setStyle(alignStyle);\n        groupRect = group.getBoundingRect();\n        var padding = layoutRect.margin;\n        var style = titleModel.getItemStyle(['color', 'opacity']);\n        style.fill = titleModel.get('backgroundColor');\n        var rect = new Rect({\n          shape: {\n            x: groupRect.x - padding[3],\n            y: groupRect.y - padding[0],\n            width: groupRect.width + padding[1] + padding[3],\n            height: groupRect.height + padding[0] + padding[2],\n            r: titleModel.get('borderRadius')\n          },\n          style: style,\n          subPixelOptimize: true,\n          silent: true\n        });\n        group.add(rect);\n      };\n\n      TitleView.type = 'title';\n      return TitleView;\n    }(ComponentView);\n\n    function install$C(registers) {\n      registers.registerComponentModel(TitleModel);\n      registers.registerComponentView(TitleView);\n    }\n\n    var TimelineModel = function (_super) {\n      __extends(TimelineModel, _super);\n\n      function TimelineModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TimelineModel.type;\n        _this.layoutMode = 'box';\n        return _this;\n      }\n\n      TimelineModel.prototype.init = function (option, parentModel, ecModel) {\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        this._initData();\n      };\n\n      TimelineModel.prototype.mergeOption = function (option) {\n        _super.prototype.mergeOption.apply(this, arguments);\n\n        this._initData();\n      };\n\n      TimelineModel.prototype.setCurrentIndex = function (currentIndex) {\n        if (currentIndex == null) {\n          currentIndex = this.option.currentIndex;\n        }\n\n        var count = this._data.count();\n\n        if (this.option.loop) {\n          currentIndex = (currentIndex % count + count) % count;\n        } else {\n          currentIndex >= count && (currentIndex = count - 1);\n          currentIndex < 0 && (currentIndex = 0);\n        }\n\n        this.option.currentIndex = currentIndex;\n      };\n\n      TimelineModel.prototype.getCurrentIndex = function () {\n        return this.option.currentIndex;\n      };\n\n      TimelineModel.prototype.isIndexMax = function () {\n        return this.getCurrentIndex() >= this._data.count() - 1;\n      };\n\n      TimelineModel.prototype.setPlayState = function (state) {\n        this.option.autoPlay = !!state;\n      };\n\n      TimelineModel.prototype.getPlayState = function () {\n        return !!this.option.autoPlay;\n      };\n\n      TimelineModel.prototype._initData = function () {\n        var thisOption = this.option;\n        var dataArr = thisOption.data || [];\n        var axisType = thisOption.axisType;\n        var names = this._names = [];\n        var processedDataArr;\n\n        if (axisType === 'category') {\n          processedDataArr = [];\n          each(dataArr, function (item, index) {\n            var value = convertOptionIdName(getDataItemValue(item), '');\n            var newItem;\n\n            if (isObject(item)) {\n              newItem = clone(item);\n              newItem.value = index;\n            } else {\n              newItem = index;\n            }\n\n            processedDataArr.push(newItem);\n            names.push(value);\n          });\n        } else {\n          processedDataArr = dataArr;\n        }\n\n        var dimType = {\n          category: 'ordinal',\n          time: 'time',\n          value: 'number'\n        }[axisType] || 'number';\n        var data = this._data = new List([{\n          name: 'value',\n          type: dimType\n        }], this);\n        data.initData(processedDataArr, names);\n      };\n\n      TimelineModel.prototype.getData = function () {\n        return this._data;\n      };\n\n      TimelineModel.prototype.getCategories = function () {\n        if (this.get('axisType') === 'category') {\n          return this._names.slice();\n        }\n      };\n\n      TimelineModel.type = 'timeline';\n      TimelineModel.defaultOption = {\n        zlevel: 0,\n        z: 4,\n        show: true,\n        axisType: 'time',\n        realtime: true,\n        left: '20%',\n        top: null,\n        right: '20%',\n        bottom: 0,\n        width: null,\n        height: 40,\n        padding: 5,\n        controlPosition: 'left',\n        autoPlay: false,\n        rewind: false,\n        loop: true,\n        playInterval: 2000,\n        currentIndex: 0,\n        itemStyle: {},\n        label: {\n          color: '#000'\n        },\n        data: []\n      };\n      return TimelineModel;\n    }(ComponentModel);\n\n    var SliderTimelineModel = function (_super) {\n      __extends(SliderTimelineModel, _super);\n\n      function SliderTimelineModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SliderTimelineModel.type;\n        return _this;\n      }\n\n      SliderTimelineModel.type = 'timeline.slider';\n      SliderTimelineModel.defaultOption = inheritDefaultOption(TimelineModel.defaultOption, {\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',\n        borderWidth: 0,\n        orient: 'horizontal',\n        inverse: false,\n        tooltip: {\n          trigger: 'item'\n        },\n        symbol: 'circle',\n        symbolSize: 12,\n        lineStyle: {\n          show: true,\n          width: 2,\n          color: '#DAE1F5'\n        },\n        label: {\n          position: 'auto',\n          show: true,\n          interval: 'auto',\n          rotate: 0,\n          color: '#A4B1D7'\n        },\n        itemStyle: {\n          color: '#A4B1D7',\n          borderWidth: 1\n        },\n        checkpointStyle: {\n          symbol: 'circle',\n          symbolSize: 15,\n          color: '#316bf3',\n          borderColor: '#fff',\n          borderWidth: 2,\n          shadowBlur: 2,\n          shadowOffsetX: 1,\n          shadowOffsetY: 1,\n          shadowColor: 'rgba(0, 0, 0, 0.3)',\n          animation: true,\n          animationDuration: 300,\n          animationEasing: 'quinticInOut'\n        },\n        controlStyle: {\n          show: true,\n          showPlayBtn: true,\n          showPrevBtn: true,\n          showNextBtn: true,\n          itemSize: 24,\n          itemGap: 12,\n          position: 'left',\n          playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',\n          stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',\n          nextIcon: 'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',\n          prevIcon: 'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',\n          prevBtnSize: 18,\n          nextBtnSize: 18,\n          color: '#A4B1D7',\n          borderColor: '#A4B1D7',\n          borderWidth: 1\n        },\n        emphasis: {\n          label: {\n            show: true,\n            color: '#6f778d'\n          },\n          itemStyle: {\n            color: '#316BF3'\n          },\n          controlStyle: {\n            color: '#316BF3',\n            borderColor: '#316BF3',\n            borderWidth: 2\n          }\n        },\n        progress: {\n          lineStyle: {\n            color: '#316BF3'\n          },\n          itemStyle: {\n            color: '#316BF3'\n          },\n          label: {\n            color: '#6f778d'\n          }\n        },\n        data: []\n      });\n      return SliderTimelineModel;\n    }(TimelineModel);\n\n    mixin(SliderTimelineModel, DataFormatMixin.prototype);\n\n    var TimelineView = function (_super) {\n      __extends(TimelineView, _super);\n\n      function TimelineView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = TimelineView.type;\n        return _this;\n      }\n\n      TimelineView.type = 'timeline';\n      return TimelineView;\n    }(ComponentView);\n\n    var TimelineAxis = function (_super) {\n      __extends(TimelineAxis, _super);\n\n      function TimelineAxis(dim, scale, coordExtent, axisType) {\n        var _this = _super.call(this, dim, scale, coordExtent) || this;\n\n        _this.type = axisType || 'value';\n        return _this;\n      }\n\n      TimelineAxis.prototype.getLabelModel = function () {\n        return this.model.getModel('label');\n      };\n\n      TimelineAxis.prototype.isHorizontal = function () {\n        return this.model.get('orient') === 'horizontal';\n      };\n\n      return TimelineAxis;\n    }(Axis);\n\n    var PI$8 = Math.PI;\n    var labelDataIndexStore = makeInner();\n\n    var SliderTimelineView = function (_super) {\n      __extends(SliderTimelineView, _super);\n\n      function SliderTimelineView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SliderTimelineView.type;\n        return _this;\n      }\n\n      SliderTimelineView.prototype.init = function (ecModel, api) {\n        this.api = api;\n      };\n\n      SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {\n        this.model = timelineModel;\n        this.api = api;\n        this.ecModel = ecModel;\n        this.group.removeAll();\n\n        if (timelineModel.get('show', true)) {\n          var layoutInfo_1 = this._layout(timelineModel, api);\n\n          var mainGroup_1 = this._createGroup('_mainGroup');\n\n          var labelGroup = this._createGroup('_labelGroup');\n\n          var axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel);\n\n          timelineModel.formatTooltip = function (dataIndex) {\n            var name = axis_1.scale.getLabel({\n              value: dataIndex\n            });\n            return createTooltipMarkup('nameValue', {\n              noName: true,\n              value: name\n            });\n          };\n\n          each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {\n            this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel);\n          }, this);\n\n          this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel);\n\n          this._position(layoutInfo_1, timelineModel);\n        }\n\n        this._doPlayStop();\n\n        this._updateTicksStatus();\n      };\n\n      SliderTimelineView.prototype.remove = function () {\n        this._clearTimer();\n\n        this.group.removeAll();\n      };\n\n      SliderTimelineView.prototype.dispose = function () {\n        this._clearTimer();\n      };\n\n      SliderTimelineView.prototype._layout = function (timelineModel, api) {\n        var labelPosOpt = timelineModel.get(['label', 'position']);\n        var orient = timelineModel.get('orient');\n        var viewRect = getViewRect$5(timelineModel, api);\n        var parsedLabelPos;\n\n        if (labelPosOpt == null || labelPosOpt === 'auto') {\n          parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';\n        } else if (isString(labelPosOpt)) {\n          parsedLabelPos = {\n            horizontal: {\n              top: '-',\n              bottom: '+'\n            },\n            vertical: {\n              left: '-',\n              right: '+'\n            }\n          }[orient][labelPosOpt];\n        } else {\n          parsedLabelPos = labelPosOpt;\n        }\n\n        var labelAlignMap = {\n          horizontal: 'center',\n          vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'\n        };\n        var labelBaselineMap = {\n          horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',\n          vertical: 'middle'\n        };\n        var rotationMap = {\n          horizontal: 0,\n          vertical: PI$8 / 2\n        };\n        var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;\n        var controlModel = timelineModel.getModel('controlStyle');\n        var showControl = controlModel.get('show', true);\n        var controlSize = showControl ? controlModel.get('itemSize') : 0;\n        var controlGap = showControl ? controlModel.get('itemGap') : 0;\n        var sizePlusGap = controlSize + controlGap;\n        var labelRotation = timelineModel.get(['label', 'rotate']) || 0;\n        labelRotation = labelRotation * PI$8 / 180;\n        var playPosition;\n        var prevBtnPosition;\n        var nextBtnPosition;\n        var controlPosition = controlModel.get('position', true);\n        var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);\n        var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);\n        var showNextBtn = showControl && controlModel.get('showNextBtn', true);\n        var xLeft = 0;\n        var xRight = mainLength;\n\n        if (controlPosition === 'left' || controlPosition === 'bottom') {\n          showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);\n          showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);\n          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n        } else {\n          showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n          showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);\n          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);\n        }\n\n        var axisExtent = [xLeft, xRight];\n\n        if (timelineModel.get('inverse')) {\n          axisExtent.reverse();\n        }\n\n        return {\n          viewRect: viewRect,\n          mainLength: mainLength,\n          orient: orient,\n          rotation: rotationMap[orient],\n          labelRotation: labelRotation,\n          labelPosOpt: parsedLabelPos,\n          labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],\n          labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],\n          playPosition: playPosition,\n          prevBtnPosition: prevBtnPosition,\n          nextBtnPosition: nextBtnPosition,\n          axisExtent: axisExtent,\n          controlSize: controlSize,\n          controlGap: controlGap\n        };\n      };\n\n      SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {\n        var mainGroup = this._mainGroup;\n        var labelGroup = this._labelGroup;\n        var viewRect = layoutInfo.viewRect;\n\n        if (layoutInfo.orient === 'vertical') {\n          var m = create$1();\n          var rotateOriginX = viewRect.x;\n          var rotateOriginY = viewRect.y + viewRect.height;\n          translate(m, m, [-rotateOriginX, -rotateOriginY]);\n          rotate(m, m, -PI$8 / 2);\n          translate(m, m, [rotateOriginX, rotateOriginY]);\n          viewRect = viewRect.clone();\n          viewRect.applyTransform(m);\n        }\n\n        var viewBound = getBound(viewRect);\n        var mainBound = getBound(mainGroup.getBoundingRect());\n        var labelBound = getBound(labelGroup.getBoundingRect());\n        var mainPosition = [mainGroup.x, mainGroup.y];\n        var labelsPosition = [labelGroup.x, labelGroup.y];\n        labelsPosition[0] = mainPosition[0] = viewBound[0][0];\n        var labelPosOpt = layoutInfo.labelPosOpt;\n\n        if (labelPosOpt == null || isString(labelPosOpt)) {\n          var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;\n          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n          toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);\n        } else {\n          var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;\n          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);\n          labelsPosition[1] = mainPosition[1] + labelPosOpt;\n        }\n\n        mainGroup.setPosition(mainPosition);\n        labelGroup.setPosition(labelsPosition);\n        mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;\n        setOrigin(mainGroup);\n        setOrigin(labelGroup);\n\n        function setOrigin(targetGroup) {\n          targetGroup.originX = viewBound[0][0] - targetGroup.x;\n          targetGroup.originY = viewBound[1][0] - targetGroup.y;\n        }\n\n        function getBound(rect) {\n          return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];\n        }\n\n        function toBound(fromPos, from, to, dimIdx, boundIdx) {\n          fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];\n        }\n      };\n\n      SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {\n        var data = timelineModel.getData();\n        var axisType = timelineModel.get('axisType');\n        var scale = createScaleByModel$1(timelineModel, axisType);\n\n        scale.getTicks = function () {\n          return data.mapArray(['value'], function (value) {\n            return {\n              value: value\n            };\n          });\n        };\n\n        var dataExtent = data.getDataExtent('value');\n        scale.setExtent(dataExtent[0], dataExtent[1]);\n        scale.niceTicks();\n        var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);\n        axis.model = timelineModel;\n        return axis;\n      };\n\n      SliderTimelineView.prototype._createGroup = function (key) {\n        var newGroup = this[key] = new Group();\n        this.group.add(newGroup);\n        return newGroup;\n      };\n\n      SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {\n        var axisExtent = axis.getExtent();\n\n        if (!timelineModel.get(['lineStyle', 'show'])) {\n          return;\n        }\n\n        var line = new Line({\n          shape: {\n            x1: axisExtent[0],\n            y1: 0,\n            x2: axisExtent[1],\n            y2: 0\n          },\n          style: extend({\n            lineCap: 'round'\n          }, timelineModel.getModel('lineStyle').getLineStyle()),\n          silent: true,\n          z2: 1\n        });\n        group.add(line);\n        var progressLine = this._progressLine = new Line({\n          shape: {\n            x1: axisExtent[0],\n            x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],\n            y1: 0,\n            y2: 0\n          },\n          style: defaults({\n            lineCap: 'round',\n            lineWidth: line.style.lineWidth\n          }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),\n          silent: true,\n          z2: 1\n        });\n        group.add(progressLine);\n      };\n\n      SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {\n        var _this = this;\n\n        var data = timelineModel.getData();\n        var ticks = axis.scale.getTicks();\n        this._tickSymbols = [];\n        each(ticks, function (tick) {\n          var tickCoord = axis.dataToCoord(tick.value);\n          var itemModel = data.getItemModel(tick.value);\n          var itemStyleModel = itemModel.getModel('itemStyle');\n          var hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle']);\n          var progressStyleModel = itemModel.getModel(['progress', 'itemStyle']);\n          var symbolOpt = {\n            x: tickCoord,\n            y: 0,\n            onclick: bind(_this._changeTimeline, _this, tick.value)\n          };\n          var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);\n          el.ensureState('emphasis').style = hoverStyleModel.getItemStyle();\n          el.ensureState('progress').style = progressStyleModel.getItemStyle();\n          enableHoverEmphasis(el);\n          var ecData = getECData(el);\n\n          if (itemModel.get('tooltip')) {\n            ecData.dataIndex = tick.value;\n            ecData.dataModel = timelineModel;\n          } else {\n            ecData.dataIndex = ecData.dataModel = null;\n          }\n\n          _this._tickSymbols.push(el);\n        });\n      };\n\n      SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {\n        var _this = this;\n\n        var labelModel = axis.getLabelModel();\n\n        if (!labelModel.get('show')) {\n          return;\n        }\n\n        var data = timelineModel.getData();\n        var labels = axis.getViewLabels();\n        this._tickLabels = [];\n        each(labels, function (labelItem) {\n          var dataIndex = labelItem.tickValue;\n          var itemModel = data.getItemModel(dataIndex);\n          var normalLabelModel = itemModel.getModel('label');\n          var hoverLabelModel = itemModel.getModel(['emphasis', 'label']);\n          var progressLabelModel = itemModel.getModel(['progress', 'label']);\n          var tickCoord = axis.dataToCoord(labelItem.tickValue);\n          var textEl = new ZRText({\n            x: tickCoord,\n            y: 0,\n            rotation: layoutInfo.labelRotation - layoutInfo.rotation,\n            onclick: bind(_this._changeTimeline, _this, dataIndex),\n            silent: false,\n            style: createTextStyle(normalLabelModel, {\n              text: labelItem.formattedLabel,\n              align: layoutInfo.labelAlign,\n              verticalAlign: layoutInfo.labelBaseline\n            })\n          });\n          textEl.ensureState('emphasis').style = createTextStyle(hoverLabelModel);\n          textEl.ensureState('progress').style = createTextStyle(progressLabelModel);\n          group.add(textEl);\n          enableHoverEmphasis(textEl);\n          labelDataIndexStore(textEl).dataIndex = dataIndex;\n\n          _this._tickLabels.push(textEl);\n        });\n      };\n\n      SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {\n        var controlSize = layoutInfo.controlSize;\n        var rotation = layoutInfo.rotation;\n        var itemStyle = timelineModel.getModel('controlStyle').getItemStyle();\n        var hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle();\n        var playState = timelineModel.getPlayState();\n        var inverse = timelineModel.get('inverse', true);\n        makeBtn(layoutInfo.nextBtnPosition, 'next', bind(this._changeTimeline, this, inverse ? '-' : '+'));\n        makeBtn(layoutInfo.prevBtnPosition, 'prev', bind(this._changeTimeline, this, inverse ? '+' : '-'));\n        makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', bind(this._handlePlayClick, this, !playState), true);\n\n        function makeBtn(position, iconName, onclick, willRotate) {\n          if (!position) {\n            return;\n          }\n\n          var iconSize = parsePercent(retrieve2(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize);\n          var rect = [0, -iconSize / 2, iconSize, iconSize];\n          var opt = {\n            position: position,\n            origin: [controlSize / 2, 0],\n            rotation: willRotate ? -rotation : 0,\n            rectHover: true,\n            style: itemStyle,\n            onclick: onclick\n          };\n          var btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, opt);\n          btn.ensureState('emphasis').style = hoverStyle;\n          group.add(btn);\n          enableHoverEmphasis(btn);\n        }\n      };\n\n      SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {\n        var data = timelineModel.getData();\n        var currentIndex = timelineModel.getCurrentIndex();\n        var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');\n        var me = this;\n        var callback = {\n          onCreate: function (pointer) {\n            pointer.draggable = true;\n            pointer.drift = bind(me._handlePointerDrag, me);\n            pointer.ondragend = bind(me._handlePointerDragend, me);\n            pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);\n          },\n          onUpdate: function (pointer) {\n            pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);\n          }\n        };\n        this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);\n      };\n\n      SliderTimelineView.prototype._handlePlayClick = function (nextState) {\n        this._clearTimer();\n\n        this.api.dispatchAction({\n          type: 'timelinePlayChange',\n          playState: nextState,\n          from: this.uid\n        });\n      };\n\n      SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {\n        this._clearTimer();\n\n        this._pointerChangeTimeline([e.offsetX, e.offsetY]);\n      };\n\n      SliderTimelineView.prototype._handlePointerDragend = function (e) {\n        this._pointerChangeTimeline([e.offsetX, e.offsetY], true);\n      };\n\n      SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {\n        var toCoord = this._toAxisCoord(mousePos)[0];\n\n        var axis = this._axis;\n        var axisExtent = asc(axis.getExtent().slice());\n        toCoord > axisExtent[1] && (toCoord = axisExtent[1]);\n        toCoord < axisExtent[0] && (toCoord = axisExtent[0]);\n        this._currentPointer.x = toCoord;\n\n        this._currentPointer.markRedraw();\n\n        this._progressLine.shape.x2 = toCoord;\n\n        this._progressLine.dirty();\n\n        var targetDataIndex = this._findNearestTick(toCoord);\n\n        var timelineModel = this.model;\n\n        if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {\n          this._changeTimeline(targetDataIndex);\n        }\n      };\n\n      SliderTimelineView.prototype._doPlayStop = function () {\n        var _this = this;\n\n        this._clearTimer();\n\n        if (this.model.getPlayState()) {\n          this._timer = setTimeout(function () {\n            var timelineModel = _this.model;\n\n            _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));\n          }, this.model.get('playInterval'));\n        }\n      };\n\n      SliderTimelineView.prototype._toAxisCoord = function (vertex) {\n        var trans = this._mainGroup.getLocalTransform();\n\n        return applyTransform$1(vertex, trans, true);\n      };\n\n      SliderTimelineView.prototype._findNearestTick = function (axisCoord) {\n        var data = this.model.getData();\n        var dist = Infinity;\n        var targetDataIndex;\n        var axis = this._axis;\n        data.each(['value'], function (value, dataIndex) {\n          var coord = axis.dataToCoord(value);\n          var d = Math.abs(coord - axisCoord);\n\n          if (d < dist) {\n            dist = d;\n            targetDataIndex = dataIndex;\n          }\n        });\n        return targetDataIndex;\n      };\n\n      SliderTimelineView.prototype._clearTimer = function () {\n        if (this._timer) {\n          clearTimeout(this._timer);\n          this._timer = null;\n        }\n      };\n\n      SliderTimelineView.prototype._changeTimeline = function (nextIndex) {\n        var currentIndex = this.model.getCurrentIndex();\n\n        if (nextIndex === '+') {\n          nextIndex = currentIndex + 1;\n        } else if (nextIndex === '-') {\n          nextIndex = currentIndex - 1;\n        }\n\n        this.api.dispatchAction({\n          type: 'timelineChange',\n          currentIndex: nextIndex,\n          from: this.uid\n        });\n      };\n\n      SliderTimelineView.prototype._updateTicksStatus = function () {\n        var currentIndex = this.model.getCurrentIndex();\n        var tickSymbols = this._tickSymbols;\n        var tickLabels = this._tickLabels;\n\n        if (tickSymbols) {\n          for (var i = 0; i < tickSymbols.length; i++) {\n            tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex);\n          }\n        }\n\n        if (tickLabels) {\n          for (var i = 0; i < tickLabels.length; i++) {\n            tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);\n          }\n        }\n      };\n\n      SliderTimelineView.type = 'timeline.slider';\n      return SliderTimelineView;\n    }(TimelineView);\n\n    function createScaleByModel$1(model, axisType) {\n      axisType = axisType || model.get('type');\n\n      if (axisType) {\n        switch (axisType) {\n          case 'category':\n            return new OrdinalScale({\n              ordinalMeta: model.getCategories(),\n              extent: [Infinity, -Infinity]\n            });\n\n          case 'time':\n            return new TimeScale({\n              locale: model.ecModel.getLocaleModel(),\n              useUTC: model.ecModel.get('useUTC')\n            });\n\n          default:\n            return new IntervalScale();\n        }\n      }\n    }\n\n    function getViewRect$5(model, api) {\n      return getLayoutRect(model.getBoxLayoutParams(), {\n        width: api.getWidth(),\n        height: api.getHeight()\n      }, model.get('padding'));\n    }\n\n    function makeControlIcon(timelineModel, objPath, rect, opts) {\n      var style = opts.style;\n      var icon = createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3]));\n\n      if (style) {\n        icon.setStyle(style);\n      }\n\n      return icon;\n    }\n\n    function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {\n      var color = itemStyleModel.get('color');\n\n      if (!symbol) {\n        var symbolType = hostModel.get('symbol');\n        symbol = createSymbol(symbolType, -1, -1, 2, 2, color);\n        symbol.setStyle('strokeNoScale', true);\n        group.add(symbol);\n        callback && callback.onCreate(symbol);\n      } else {\n        symbol.setColor(color);\n        group.add(symbol);\n        callback && callback.onUpdate(symbol);\n      }\n\n      var itemStyle = itemStyleModel.getItemStyle(['color']);\n      symbol.setStyle(itemStyle);\n      opt = merge({\n        rectHover: true,\n        z2: 100\n      }, opt, true);\n      var symbolSize = hostModel.get('symbolSize');\n      symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n      opt.scaleX = symbolSize[0] / 2;\n      opt.scaleY = symbolSize[1] / 2;\n      var symbolOffset = hostModel.get('symbolOffset');\n\n      if (symbolOffset) {\n        opt.x = opt.x || 0;\n        opt.y = opt.y || 0;\n        opt.x += parsePercent$1(symbolOffset[0], symbolSize[0]);\n        opt.y += parsePercent$1(symbolOffset[1], symbolSize[1]);\n      }\n\n      var symbolRotate = hostModel.get('symbolRotate');\n      opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;\n      symbol.attr(opt);\n      symbol.updateTransform();\n      return symbol;\n    }\n\n    function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {\n      if (pointer.dragging) {\n        return;\n      }\n\n      var pointerModel = timelineModel.getModel('checkpointStyle');\n      var toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex));\n\n      if (noAnimation || !pointerModel.get('animation', true)) {\n        pointer.attr({\n          x: toCoord,\n          y: 0\n        });\n        progressLine && progressLine.attr({\n          shape: {\n            x2: toCoord\n          }\n        });\n      } else {\n        var animationCfg = {\n          duration: pointerModel.get('animationDuration', true),\n          easing: pointerModel.get('animationEasing', true)\n        };\n        pointer.stopAnimation(null, true);\n        pointer.animateTo({\n          x: toCoord,\n          y: 0\n        }, animationCfg);\n        progressLine && progressLine.animateTo({\n          shape: {\n            x2: toCoord\n          }\n        }, animationCfg);\n      }\n    }\n\n    function installTimelineAction(registers) {\n      registers.registerAction({\n        type: 'timelineChange',\n        event: 'timelineChanged',\n        update: 'prepareAndUpdate'\n      }, function (payload, ecModel) {\n        var timelineModel = ecModel.getComponent('timeline');\n\n        if (timelineModel && payload.currentIndex != null) {\n          timelineModel.setCurrentIndex(payload.currentIndex);\n\n          if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {\n            timelineModel.setPlayState(false);\n          }\n        }\n\n        ecModel.resetOption('timeline', {\n          replaceMerge: timelineModel.get('replaceMerge', true)\n        });\n        return defaults({\n          currentIndex: timelineModel.option.currentIndex\n        }, payload);\n      });\n      registers.registerAction({\n        type: 'timelinePlayChange',\n        event: 'timelinePlayChanged',\n        update: 'update'\n      }, function (payload, ecModel) {\n        var timelineModel = ecModel.getComponent('timeline');\n\n        if (timelineModel && payload.playState != null) {\n          timelineModel.setPlayState(payload.playState);\n        }\n      });\n    }\n\n    function timelinePreprocessor(option) {\n      var timelineOpt = option && option.timeline;\n\n      if (!isArray(timelineOpt)) {\n        timelineOpt = timelineOpt ? [timelineOpt] : [];\n      }\n\n      each(timelineOpt, function (opt) {\n        if (!opt) {\n          return;\n        }\n\n        compatibleEC2(opt);\n      });\n    }\n\n    function compatibleEC2(opt) {\n      var type = opt.type;\n      var ec2Types = {\n        'number': 'value',\n        'time': 'time'\n      };\n\n      if (ec2Types[type]) {\n        opt.axisType = ec2Types[type];\n        delete opt.type;\n      }\n\n      transferItem(opt);\n\n      if (has(opt, 'controlPosition')) {\n        var controlStyle = opt.controlStyle || (opt.controlStyle = {});\n\n        if (!has(controlStyle, 'position')) {\n          controlStyle.position = opt.controlPosition;\n        }\n\n        if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {\n          controlStyle.show = false;\n          delete controlStyle.position;\n        }\n\n        delete opt.controlPosition;\n      }\n\n      each(opt.data || [], function (dataItem) {\n        if (isObject(dataItem) && !isArray(dataItem)) {\n          if (!has(dataItem, 'value') && has(dataItem, 'name')) {\n            dataItem.value = dataItem.name;\n          }\n\n          transferItem(dataItem);\n        }\n      });\n    }\n\n    function transferItem(opt) {\n      var itemStyle = opt.itemStyle || (opt.itemStyle = {});\n      var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});\n      var label = opt.label || opt.label || {};\n      var labelNormal = label.normal || (label.normal = {});\n      var excludeLabelAttr = {\n        normal: 1,\n        emphasis: 1\n      };\n      each(label, function (value, name) {\n        if (!excludeLabelAttr[name] && !has(labelNormal, name)) {\n          labelNormal[name] = value;\n        }\n      });\n\n      if (itemStyleEmphasis.label && !has(label, 'emphasis')) {\n        label.emphasis = itemStyleEmphasis.label;\n        delete itemStyleEmphasis.label;\n      }\n    }\n\n    function has(obj, attr) {\n      return obj.hasOwnProperty(attr);\n    }\n\n    function install$D(registers) {\n      registers.registerComponentModel(SliderTimelineModel);\n      registers.registerComponentView(SliderTimelineView);\n      registers.registerSubTypeDefaulter('timeline', function () {\n        return 'slider';\n      });\n      installTimelineAction(registers);\n      registers.registerPreprocessor(timelinePreprocessor);\n    }\n\n    function fillLabel(opt) {\n      defaultEmphasis(opt, 'label', ['show']);\n    }\n\n    var inner$i = makeInner();\n\n    var MarkerModel = function (_super) {\n      __extends(MarkerModel, _super);\n\n      function MarkerModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkerModel.type;\n        _this.createdBySelf = false;\n        return _this;\n      }\n\n      MarkerModel.prototype.init = function (option, parentModel, ecModel) {\n        if (\"development\" !== 'production') {\n          if (this.type === 'marker') {\n            throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');\n          }\n        }\n\n        this.mergeDefaultAndTheme(option, ecModel);\n\n        this._mergeOption(option, ecModel, false, true);\n      };\n\n      MarkerModel.prototype.isAnimationEnabled = function () {\n        if (env.node) {\n          return false;\n        }\n\n        var hostSeries = this.__hostSeries;\n        return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();\n      };\n\n      MarkerModel.prototype.mergeOption = function (newOpt, ecModel) {\n        this._mergeOption(newOpt, ecModel, false, false);\n      };\n\n      MarkerModel.prototype._mergeOption = function (newOpt, ecModel, createdBySelf, isInit) {\n        var componentType = this.mainType;\n\n        if (!createdBySelf) {\n          ecModel.eachSeries(function (seriesModel) {\n            var markerOpt = seriesModel.get(this.mainType, true);\n            var markerModel = inner$i(seriesModel)[componentType];\n\n            if (!markerOpt || !markerOpt.data) {\n              inner$i(seriesModel)[componentType] = null;\n              return;\n            }\n\n            if (!markerModel) {\n              if (isInit) {\n                fillLabel(markerOpt);\n              }\n\n              each(markerOpt.data, function (item) {\n                if (item instanceof Array) {\n                  fillLabel(item[0]);\n                  fillLabel(item[1]);\n                } else {\n                  fillLabel(item);\n                }\n              });\n              markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);\n              extend(markerModel, {\n                mainType: this.mainType,\n                seriesIndex: seriesModel.seriesIndex,\n                name: seriesModel.name,\n                createdBySelf: true\n              });\n              markerModel.__hostSeries = seriesModel;\n            } else {\n              markerModel._mergeOption(markerOpt, ecModel, true);\n            }\n\n            inner$i(seriesModel)[componentType] = markerModel;\n          }, this);\n        }\n      };\n\n      MarkerModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {\n        var data = this.getData();\n        var value = this.getRawValue(dataIndex);\n        var itemName = data.getName(dataIndex);\n        return createTooltipMarkup('section', {\n          header: this.name,\n          blocks: [createTooltipMarkup('nameValue', {\n            name: itemName,\n            value: value,\n            noName: !itemName,\n            noValue: value == null\n          })]\n        });\n      };\n\n      MarkerModel.prototype.getData = function () {\n        return this._data;\n      };\n\n      MarkerModel.prototype.setData = function (data) {\n        this._data = data;\n      };\n\n      MarkerModel.getMarkerModelFromSeries = function (seriesModel, componentType) {\n        return inner$i(seriesModel)[componentType];\n      };\n\n      MarkerModel.type = 'marker';\n      MarkerModel.dependencies = ['series', 'grid', 'polar', 'geo'];\n      return MarkerModel;\n    }(ComponentModel);\n\n    mixin(MarkerModel, DataFormatMixin.prototype);\n\n    var MarkPointModel = function (_super) {\n      __extends(MarkPointModel, _super);\n\n      function MarkPointModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkPointModel.type;\n        return _this;\n      }\n\n      MarkPointModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n        return new MarkPointModel(markerOpt, masterMarkerModel, ecModel);\n      };\n\n      MarkPointModel.type = 'markPoint';\n      MarkPointModel.defaultOption = {\n        zlevel: 0,\n        z: 5,\n        symbol: 'pin',\n        symbolSize: 50,\n        tooltip: {\n          trigger: 'item'\n        },\n        label: {\n          show: true,\n          position: 'inside'\n        },\n        itemStyle: {\n          borderWidth: 2\n        },\n        emphasis: {\n          label: {\n            show: true\n          }\n        }\n      };\n      return MarkPointModel;\n    }(MarkerModel);\n\n    function hasXOrY(item) {\n      return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));\n    }\n\n    function hasXAndY(item) {\n      return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));\n    }\n\n    function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {\n      var coordArr = [];\n      var stacked = isDimensionStacked(data, targetDataDim);\n      var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;\n      var value = numCalculate(data, calcDataDim, markerType);\n      var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];\n      coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);\n      coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);\n      var coordArrValue = data.get(targetDataDim, dataIndex);\n      var precision = getPrecision(data.get(targetDataDim, dataIndex));\n      precision = Math.min(precision, 20);\n\n      if (precision >= 0) {\n        coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);\n      }\n\n      return [coordArr, coordArrValue];\n    }\n\n    var markerTypeCalculator = {\n      min: curry(markerTypeCalculatorWithExtent, 'min'),\n      max: curry(markerTypeCalculatorWithExtent, 'max'),\n      average: curry(markerTypeCalculatorWithExtent, 'average'),\n      median: curry(markerTypeCalculatorWithExtent, 'median')\n    };\n    function dataTransform(seriesModel, item) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n\n      if (item && !hasXAndY(item) && !isArray(item.coord) && coordSys) {\n        var dims = coordSys.dimensions;\n        var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel);\n        item = clone(item);\n\n        if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {\n          var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);\n          var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);\n          var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);\n          item.coord = coordInfo[0];\n          item.value = coordInfo[1];\n        } else {\n          var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];\n\n          for (var i = 0; i < 2; i++) {\n            if (markerTypeCalculator[coord[i]]) {\n              coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);\n            }\n          }\n\n          item.coord = coord;\n        }\n      }\n\n      return item;\n    }\n    function getAxisInfo$1(item, data, coordSys, seriesModel) {\n      var ret = {};\n\n      if (item.valueIndex != null || item.valueDim != null) {\n        ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;\n        ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));\n        ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);\n        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n      } else {\n        ret.baseAxis = seriesModel.getBaseAxis();\n        ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);\n        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);\n        ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);\n      }\n\n      return ret;\n    }\n\n    function dataDimToCoordDim(seriesModel, dataDim) {\n      var data = seriesModel.getData();\n      var dimensions = data.dimensions;\n      dataDim = data.getDimension(dataDim);\n\n      for (var i = 0; i < dimensions.length; i++) {\n        var dimItem = data.getDimensionInfo(dimensions[i]);\n\n        if (dimItem.name === dataDim) {\n          return dimItem.coordDim;\n        }\n      }\n    }\n\n    function dataFilter$1(coordSys, item) {\n      return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;\n    }\n    function dimValueGetter(item, dimName, dataIndex, dimIndex) {\n      if (dimIndex < 2) {\n        return item.coord && item.coord[dimIndex];\n      }\n\n      return item.value;\n    }\n    function numCalculate(data, valueDataDim, type) {\n      if (type === 'average') {\n        var sum_1 = 0;\n        var count_1 = 0;\n        data.each(valueDataDim, function (val, idx) {\n          if (!isNaN(val)) {\n            sum_1 += val;\n            count_1++;\n          }\n        });\n        return sum_1 / count_1;\n      } else if (type === 'median') {\n        return data.getMedian(valueDataDim);\n      } else {\n        return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];\n      }\n    }\n\n    var inner$j = makeInner();\n\n    var MarkerView = function (_super) {\n      __extends(MarkerView, _super);\n\n      function MarkerView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkerView.type;\n        return _this;\n      }\n\n      MarkerView.prototype.init = function () {\n        this.markerGroupMap = createHashMap();\n      };\n\n      MarkerView.prototype.render = function (markerModel, ecModel, api) {\n        var _this = this;\n\n        var markerGroupMap = this.markerGroupMap;\n        markerGroupMap.each(function (item) {\n          inner$j(item).keep = false;\n        });\n        ecModel.eachSeries(function (seriesModel) {\n          var markerModel = MarkerModel.getMarkerModelFromSeries(seriesModel, _this.type);\n          markerModel && _this.renderSeries(seriesModel, markerModel, ecModel, api);\n        });\n        markerGroupMap.each(function (item) {\n          !inner$j(item).keep && _this.group.remove(item.group);\n        });\n      };\n\n      MarkerView.prototype.markKeep = function (drawGroup) {\n        inner$j(drawGroup).keep = true;\n      };\n\n      MarkerView.prototype.blurSeries = function (seriesModelList) {\n        var _this = this;\n\n        each(seriesModelList, function (seriesModel) {\n          var markerModel = MarkerModel.getMarkerModelFromSeries(seriesModel, _this.type);\n\n          if (markerModel) {\n            var data = markerModel.getData();\n            data.eachItemGraphicEl(function (el) {\n              if (el) {\n                enterBlur(el);\n              }\n            });\n          }\n        });\n      };\n\n      MarkerView.type = 'marker';\n      return MarkerView;\n    }(ComponentView);\n\n    function updateMarkerLayout(mpData, seriesModel, api) {\n      var coordSys = seriesModel.coordinateSystem;\n      mpData.each(function (idx) {\n        var itemModel = mpData.getItemModel(idx);\n        var point;\n        var xPx = parsePercent$1(itemModel.get('x'), api.getWidth());\n        var yPx = parsePercent$1(itemModel.get('y'), api.getHeight());\n\n        if (!isNaN(xPx) && !isNaN(yPx)) {\n          point = [xPx, yPx];\n        } else if (seriesModel.getMarkerPosition) {\n          point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));\n        } else if (coordSys) {\n          var x = mpData.get(coordSys.dimensions[0], idx);\n          var y = mpData.get(coordSys.dimensions[1], idx);\n          point = coordSys.dataToPoint([x, y]);\n        }\n\n        if (!isNaN(xPx)) {\n          point[0] = xPx;\n        }\n\n        if (!isNaN(yPx)) {\n          point[1] = yPx;\n        }\n\n        mpData.setItemLayout(idx, point);\n      });\n    }\n\n    var MarkPointView = function (_super) {\n      __extends(MarkPointView, _super);\n\n      function MarkPointView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkPointView.type;\n        return _this;\n      }\n\n      MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n          var mpModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markPoint');\n\n          if (mpModel) {\n            updateMarkerLayout(mpModel.getData(), seriesModel, api);\n            this.markerGroupMap.get(seriesModel.id).updateLayout();\n          }\n        }, this);\n      };\n\n      MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesId = seriesModel.id;\n        var seriesData = seriesModel.getData();\n        var symbolDrawMap = this.markerGroupMap;\n        var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());\n        var mpData = createList$1(coordSys, seriesModel, mpModel);\n        mpModel.setData(mpData);\n        updateMarkerLayout(mpModel.getData(), seriesModel, api);\n        mpData.each(function (idx) {\n          var itemModel = mpData.getItemModel(idx);\n          var symbol = itemModel.getShallow('symbol');\n          var symbolSize = itemModel.getShallow('symbolSize');\n          var symbolRotate = itemModel.getShallow('symbolRotate');\n\n          if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate)) {\n            var rawIdx = mpModel.getRawValue(idx);\n            var dataParams = mpModel.getDataParams(idx);\n\n            if (isFunction(symbol)) {\n              symbol = symbol(rawIdx, dataParams);\n            }\n\n            if (isFunction(symbolSize)) {\n              symbolSize = symbolSize(rawIdx, dataParams);\n            }\n\n            if (isFunction(symbolRotate)) {\n              symbolRotate = symbolRotate(rawIdx, dataParams);\n            }\n          }\n\n          var style = itemModel.getModel('itemStyle').getItemStyle();\n          var color = getVisualFromData(seriesData, 'color');\n\n          if (!style.fill) {\n            style.fill = color;\n          }\n\n          mpData.setItemVisual(idx, {\n            symbol: symbol,\n            symbolSize: symbolSize,\n            symbolRotate: symbolRotate,\n            style: style\n          });\n        });\n        symbolDraw.updateData(mpData);\n        this.group.add(symbolDraw.group);\n        mpData.eachItemGraphicEl(function (el) {\n          el.traverse(function (child) {\n            getECData(child).dataModel = mpModel;\n          });\n        });\n        this.markKeep(symbolDraw);\n        symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent');\n      };\n\n      MarkPointView.type = 'markPoint';\n      return MarkPointView;\n    }(MarkerView);\n\n    function createList$1(coordSys, seriesModel, mpModel) {\n      var coordDimsInfos;\n\n      if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};\n          return defaults({\n            name: coordDim\n          }, info);\n        });\n      } else {\n        coordDimsInfos = [{\n          name: 'value',\n          type: 'float'\n        }];\n      }\n\n      var mpData = new List(coordDimsInfos, mpModel);\n      var dataOpt = map(mpModel.get('data'), curry(dataTransform, seriesModel));\n\n      if (coordSys) {\n        dataOpt = filter(dataOpt, curry(dataFilter$1, coordSys));\n      }\n\n      mpData.initData(dataOpt, null, coordSys ? dimValueGetter : function (item) {\n        return item.value;\n      });\n      return mpData;\n    }\n\n    function install$E(registers) {\n      registers.registerComponentModel(MarkPointModel);\n      registers.registerComponentView(MarkPointView);\n      registers.registerPreprocessor(function (opt) {\n        opt.markPoint = opt.markPoint || {};\n      });\n    }\n\n    var MarkLineModel = function (_super) {\n      __extends(MarkLineModel, _super);\n\n      function MarkLineModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkLineModel.type;\n        return _this;\n      }\n\n      MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n        return new MarkLineModel(markerOpt, masterMarkerModel, ecModel);\n      };\n\n      MarkLineModel.type = 'markLine';\n      MarkLineModel.defaultOption = {\n        zlevel: 0,\n        z: 5,\n        symbol: ['circle', 'arrow'],\n        symbolSize: [8, 16],\n        precision: 2,\n        tooltip: {\n          trigger: 'item'\n        },\n        label: {\n          show: true,\n          position: 'end',\n          distance: 5\n        },\n        lineStyle: {\n          type: 'dashed'\n        },\n        emphasis: {\n          label: {\n            show: true\n          },\n          lineStyle: {\n            width: 3\n          }\n        },\n        animationEasing: 'linear'\n      };\n      return MarkLineModel;\n    }(MarkerModel);\n\n    var inner$k = makeInner();\n\n    var markLineTransform = function (seriesModel, coordSys, mlModel, item) {\n      var data = seriesModel.getData();\n      var itemArray;\n\n      if (!isArray(item)) {\n        var mlType = item.type;\n\n        if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' || item.xAxis != null || item.yAxis != null) {\n          var valueAxis = void 0;\n          var value = void 0;\n\n          if (item.yAxis != null || item.xAxis != null) {\n            valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');\n            value = retrieve(item.yAxis, item.xAxis);\n          } else {\n            var axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel);\n            valueAxis = axisInfo.valueAxis;\n            var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);\n            value = numCalculate(data, valueDataDim, mlType);\n          }\n\n          var valueIndex = valueAxis.dim === 'x' ? 0 : 1;\n          var baseIndex = 1 - valueIndex;\n          var mlFrom = clone(item);\n          var mlTo = {\n            coord: []\n          };\n          mlFrom.type = null;\n          mlFrom.coord = [];\n          mlFrom.coord[baseIndex] = -Infinity;\n          mlTo.coord[baseIndex] = Infinity;\n          var precision = mlModel.get('precision');\n\n          if (precision >= 0 && typeof value === 'number') {\n            value = +value.toFixed(Math.min(precision, 20));\n          }\n\n          mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;\n          itemArray = [mlFrom, mlTo, {\n            type: mlType,\n            valueIndex: item.valueIndex,\n            value: value\n          }];\n        } else {\n          if (\"development\" !== 'production') {\n            logError('Invalid markLine data.');\n          }\n\n          itemArray = [];\n        }\n      } else {\n        itemArray = item;\n      }\n\n      var normalizedItem = [dataTransform(seriesModel, itemArray[0]), dataTransform(seriesModel, itemArray[1]), extend({}, itemArray[2])];\n      normalizedItem[2].type = normalizedItem[2].type || null;\n      merge(normalizedItem[2], normalizedItem[0]);\n      merge(normalizedItem[2], normalizedItem[1]);\n      return normalizedItem;\n    };\n\n    function isInifinity(val) {\n      return !isNaN(val) && !isFinite(val);\n    }\n\n    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n      var otherDimIndex = 1 - dimIndex;\n      var dimName = coordSys.dimensions[dimIndex];\n      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);\n    }\n\n    function markLineFilter(coordSys, item) {\n      if (coordSys.type === 'cartesian2d') {\n        var fromCoord = item[0].coord;\n        var toCoord = item[1].coord;\n\n        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {\n          return true;\n        }\n      }\n\n      return dataFilter$1(coordSys, item[0]) && dataFilter$1(coordSys, item[1]);\n    }\n\n    function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {\n      var coordSys = seriesModel.coordinateSystem;\n      var itemModel = data.getItemModel(idx);\n      var point;\n      var xPx = parsePercent$1(itemModel.get('x'), api.getWidth());\n      var yPx = parsePercent$1(itemModel.get('y'), api.getHeight());\n\n      if (!isNaN(xPx) && !isNaN(yPx)) {\n        point = [xPx, yPx];\n      } else {\n        if (seriesModel.getMarkerPosition) {\n          point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));\n        } else {\n          var dims = coordSys.dimensions;\n          var x = data.get(dims[0], idx);\n          var y = data.get(dims[1], idx);\n          point = coordSys.dataToPoint([x, y]);\n        }\n\n        if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n          var xAxis = coordSys.getAxis('x');\n          var yAxis = coordSys.getAxis('y');\n          var dims = coordSys.dimensions;\n\n          if (isInifinity(data.get(dims[0], idx))) {\n            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);\n          } else if (isInifinity(data.get(dims[1], idx))) {\n            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);\n          }\n        }\n\n        if (!isNaN(xPx)) {\n          point[0] = xPx;\n        }\n\n        if (!isNaN(yPx)) {\n          point[1] = yPx;\n        }\n      }\n\n      data.setItemLayout(idx, point);\n    }\n\n    var MarkLineView = function (_super) {\n      __extends(MarkLineView, _super);\n\n      function MarkLineView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkLineView.type;\n        return _this;\n      }\n\n      MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n          var mlModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markLine');\n\n          if (mlModel) {\n            var mlData_1 = mlModel.getData();\n            var fromData_1 = inner$k(mlModel).from;\n            var toData_1 = inner$k(mlModel).to;\n            fromData_1.each(function (idx) {\n              updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);\n              updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);\n            });\n            mlData_1.each(function (idx) {\n              mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);\n            });\n            this.markerGroupMap.get(seriesModel.id).updateLayout();\n          }\n        }, this);\n      };\n\n      MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesId = seriesModel.id;\n        var seriesData = seriesModel.getData();\n        var lineDrawMap = this.markerGroupMap;\n        var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());\n        this.group.add(lineDraw.group);\n        var mlData = createList$2(coordSys, seriesModel, mlModel);\n        var fromData = mlData.from;\n        var toData = mlData.to;\n        var lineData = mlData.line;\n        inner$k(mlModel).from = fromData;\n        inner$k(mlModel).to = toData;\n        mlModel.setData(lineData);\n        var symbolType = mlModel.get('symbol');\n        var symbolSize = mlModel.get('symbolSize');\n\n        if (!isArray(symbolType)) {\n          symbolType = [symbolType, symbolType];\n        }\n\n        if (!isArray(symbolSize)) {\n          symbolSize = [symbolSize, symbolSize];\n        }\n\n        mlData.from.each(function (idx) {\n          updateDataVisualAndLayout(fromData, idx, true);\n          updateDataVisualAndLayout(toData, idx, false);\n        });\n        lineData.each(function (idx) {\n          var lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle();\n          lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);\n\n          if (lineStyle.stroke == null) {\n            lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill;\n          }\n\n          lineData.setItemVisual(idx, {\n            fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),\n            fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),\n            fromSymbol: fromData.getItemVisual(idx, 'symbol'),\n            toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),\n            toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),\n            toSymbol: toData.getItemVisual(idx, 'symbol'),\n            style: lineStyle\n          });\n        });\n        lineDraw.updateData(lineData);\n        mlData.line.eachItemGraphicEl(function (el, idx) {\n          el.traverse(function (child) {\n            getECData(child).dataModel = mlModel;\n          });\n        });\n\n        function updateDataVisualAndLayout(data, idx, isFrom) {\n          var itemModel = data.getItemModel(idx);\n          updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);\n          var style = itemModel.getModel('itemStyle').getItemStyle();\n\n          if (style.fill == null) {\n            style.fill = getVisualFromData(seriesData, 'color');\n          }\n\n          data.setItemVisual(idx, {\n            symbolRotate: itemModel.get('symbolRotate'),\n            symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],\n            symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],\n            style: style\n          });\n        }\n\n        this.markKeep(lineDraw);\n        lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');\n      };\n\n      MarkLineView.type = 'markLine';\n      return MarkLineView;\n    }(MarkerView);\n\n    function createList$2(coordSys, seriesModel, mlModel) {\n      var coordDimsInfos;\n\n      if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};\n          return defaults({\n            name: coordDim\n          }, info);\n        });\n      } else {\n        coordDimsInfos = [{\n          name: 'value',\n          type: 'float'\n        }];\n      }\n\n      var fromData = new List(coordDimsInfos, mlModel);\n      var toData = new List(coordDimsInfos, mlModel);\n      var lineData = new List([], mlModel);\n      var optData = map(mlModel.get('data'), curry(markLineTransform, seriesModel, coordSys, mlModel));\n\n      if (coordSys) {\n        optData = filter(optData, curry(markLineFilter, coordSys));\n      }\n\n      var dimValueGetter$1 = coordSys ? dimValueGetter : function (item) {\n        return item.value;\n      };\n      fromData.initData(map(optData, function (item) {\n        return item[0];\n      }), null, dimValueGetter$1);\n      toData.initData(map(optData, function (item) {\n        return item[1];\n      }), null, dimValueGetter$1);\n      lineData.initData(map(optData, function (item) {\n        return item[2];\n      }));\n      lineData.hasItemOption = true;\n      return {\n        from: fromData,\n        to: toData,\n        line: lineData\n      };\n    }\n\n    function install$F(registers) {\n      registers.registerComponentModel(MarkLineModel);\n      registers.registerComponentView(MarkLineView);\n      registers.registerPreprocessor(function (opt) {\n        opt.markLine = opt.markLine || {};\n      });\n    }\n\n    var MarkAreaModel = function (_super) {\n      __extends(MarkAreaModel, _super);\n\n      function MarkAreaModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkAreaModel.type;\n        return _this;\n      }\n\n      MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {\n        return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel);\n      };\n\n      MarkAreaModel.type = 'markArea';\n      MarkAreaModel.defaultOption = {\n        zlevel: 0,\n        z: 1,\n        tooltip: {\n          trigger: 'item'\n        },\n        animation: false,\n        label: {\n          show: true,\n          position: 'top'\n        },\n        itemStyle: {\n          borderWidth: 0\n        },\n        emphasis: {\n          label: {\n            show: true,\n            position: 'top'\n          }\n        }\n      };\n      return MarkAreaModel;\n    }(MarkerModel);\n\n    var inner$l = makeInner();\n\n    var markAreaTransform = function (seriesModel, coordSys, maModel, item) {\n      var lt = dataTransform(seriesModel, item[0]);\n      var rb = dataTransform(seriesModel, item[1]);\n      var ltCoord = lt.coord;\n      var rbCoord = rb.coord;\n      ltCoord[0] = retrieve(ltCoord[0], -Infinity);\n      ltCoord[1] = retrieve(ltCoord[1], -Infinity);\n      rbCoord[0] = retrieve(rbCoord[0], Infinity);\n      rbCoord[1] = retrieve(rbCoord[1], Infinity);\n      var result = mergeAll([{}, lt, rb]);\n      result.coord = [lt.coord, rb.coord];\n      result.x0 = lt.x;\n      result.y0 = lt.y;\n      result.x1 = rb.x;\n      result.y1 = rb.y;\n      return result;\n    };\n\n    function isInifinity$1(val) {\n      return !isNaN(val) && !isFinite(val);\n    }\n\n    function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {\n      var otherDimIndex = 1 - dimIndex;\n      return isInifinity$1(fromCoord[otherDimIndex]) && isInifinity$1(toCoord[otherDimIndex]);\n    }\n\n    function markAreaFilter(coordSys, item) {\n      var fromCoord = item.coord[0];\n      var toCoord = item.coord[1];\n\n      if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n        if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord))) {\n          return true;\n        }\n      }\n\n      return dataFilter$1(coordSys, {\n        coord: fromCoord,\n        x: item.x0,\n        y: item.y0\n      }) || dataFilter$1(coordSys, {\n        coord: toCoord,\n        x: item.x1,\n        y: item.y1\n      });\n    }\n\n    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {\n      var coordSys = seriesModel.coordinateSystem;\n      var itemModel = data.getItemModel(idx);\n      var point;\n      var xPx = parsePercent$1(itemModel.get(dims[0]), api.getWidth());\n      var yPx = parsePercent$1(itemModel.get(dims[1]), api.getHeight());\n\n      if (!isNaN(xPx) && !isNaN(yPx)) {\n        point = [xPx, yPx];\n      } else {\n        if (seriesModel.getMarkerPosition) {\n          point = seriesModel.getMarkerPosition(data.getValues(dims, idx));\n        } else {\n          var x = data.get(dims[0], idx);\n          var y = data.get(dims[1], idx);\n          var pt = [x, y];\n          coordSys.clampData && coordSys.clampData(pt, pt);\n          point = coordSys.dataToPoint(pt, true);\n        }\n\n        if (isCoordinateSystemType(coordSys, 'cartesian2d')) {\n          var xAxis = coordSys.getAxis('x');\n          var yAxis = coordSys.getAxis('y');\n          var x = data.get(dims[0], idx);\n          var y = data.get(dims[1], idx);\n\n          if (isInifinity$1(x)) {\n            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1]);\n          } else if (isInifinity$1(y)) {\n            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1]);\n          }\n        }\n\n        if (!isNaN(xPx)) {\n          point[0] = xPx;\n        }\n\n        if (!isNaN(yPx)) {\n          point[1] = yPx;\n        }\n      }\n\n      return point;\n    }\n\n    var dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']];\n\n    var MarkAreaView = function (_super) {\n      __extends(MarkAreaView, _super);\n\n      function MarkAreaView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = MarkAreaView.type;\n        return _this;\n      }\n\n      MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {\n        ecModel.eachSeries(function (seriesModel) {\n          var maModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markArea');\n\n          if (maModel) {\n            var areaData_1 = maModel.getData();\n            areaData_1.each(function (idx) {\n              var points = map(dimPermutations, function (dim) {\n                return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api);\n              });\n              areaData_1.setItemLayout(idx, points);\n              var el = areaData_1.getItemGraphicEl(idx);\n              el.setShape('points', points);\n            });\n          }\n        }, this);\n      };\n\n      MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {\n        var coordSys = seriesModel.coordinateSystem;\n        var seriesId = seriesModel.id;\n        var seriesData = seriesModel.getData();\n        var areaGroupMap = this.markerGroupMap;\n        var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {\n          group: new Group()\n        });\n        this.group.add(polygonGroup.group);\n        this.markKeep(polygonGroup);\n        var areaData = createList$3(coordSys, seriesModel, maModel);\n        maModel.setData(areaData);\n        areaData.each(function (idx) {\n          var points = map(dimPermutations, function (dim) {\n            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);\n          });\n          var allClipped = true;\n          each(dimPermutations, function (dim) {\n            if (!allClipped) {\n              return;\n            }\n\n            var xValue = areaData.get(dim[0], idx);\n            var yValue = areaData.get(dim[1], idx);\n\n            if ((isInifinity$1(xValue) || coordSys.getAxis('x').containData(xValue)) && (isInifinity$1(yValue) || coordSys.getAxis('y').containData(yValue))) {\n              allClipped = false;\n            }\n          });\n          areaData.setItemLayout(idx, {\n            points: points,\n            allClipped: allClipped\n          });\n          var style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle();\n          var color$1 = getVisualFromData(seriesData, 'color');\n\n          if (!style.fill) {\n            style.fill = color$1;\n\n            if (typeof style.fill === 'string') {\n              style.fill = modifyAlpha(style.fill, 0.4);\n            }\n          }\n\n          if (!style.stroke) {\n            style.stroke = color$1;\n          }\n\n          areaData.setItemVisual(idx, 'style', style);\n        });\n        areaData.diff(inner$l(polygonGroup).data).add(function (idx) {\n          var layout = areaData.getItemLayout(idx);\n\n          if (!layout.allClipped) {\n            var polygon = new Polygon({\n              shape: {\n                points: layout.points\n              }\n            });\n            areaData.setItemGraphicEl(idx, polygon);\n            polygonGroup.group.add(polygon);\n          }\n        }).update(function (newIdx, oldIdx) {\n          var polygon = inner$l(polygonGroup).data.getItemGraphicEl(oldIdx);\n          var layout = areaData.getItemLayout(newIdx);\n\n          if (!layout.allClipped) {\n            if (polygon) {\n              updateProps(polygon, {\n                shape: {\n                  points: layout.points\n                }\n              }, maModel, newIdx);\n            } else {\n              polygon = new Polygon({\n                shape: {\n                  points: layout.points\n                }\n              });\n            }\n\n            areaData.setItemGraphicEl(newIdx, polygon);\n            polygonGroup.group.add(polygon);\n          } else if (polygon) {\n            polygonGroup.group.remove(polygon);\n          }\n        }).remove(function (idx) {\n          var polygon = inner$l(polygonGroup).data.getItemGraphicEl(idx);\n          polygonGroup.group.remove(polygon);\n        }).execute();\n        areaData.eachItemGraphicEl(function (polygon, idx) {\n          var itemModel = areaData.getItemModel(idx);\n          var style = areaData.getItemVisual(idx, 'style');\n          polygon.useStyle(areaData.getItemVisual(idx, 'style'));\n          setLabelStyle(polygon, getLabelStatesModels(itemModel), {\n            labelFetcher: maModel,\n            labelDataIndex: idx,\n            defaultText: areaData.getName(idx) || '',\n            inheritColor: typeof style.fill === 'string' ? modifyAlpha(style.fill, 1) : '#000'\n          });\n          setStatesStylesFromModel(polygon, itemModel);\n          enableHoverEmphasis(polygon);\n          getECData(polygon).dataModel = maModel;\n        });\n        inner$l(polygonGroup).data = areaData;\n        polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent');\n      };\n\n      MarkAreaView.type = 'markArea';\n      return MarkAreaView;\n    }(MarkerView);\n\n    function createList$3(coordSys, seriesModel, maModel) {\n      var coordDimsInfos;\n      var areaData;\n      var dims = ['x0', 'y0', 'x1', 'y1'];\n\n      if (coordSys) {\n        coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {\n          var data = seriesModel.getData();\n          var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};\n          return defaults({\n            name: coordDim\n          }, info);\n        });\n        areaData = new List(map(dims, function (dim, idx) {\n          return {\n            name: dim,\n            type: coordDimsInfos[idx % 2].type\n          };\n        }), maModel);\n      } else {\n        coordDimsInfos = [{\n          name: 'value',\n          type: 'float'\n        }];\n        areaData = new List(coordDimsInfos, maModel);\n      }\n\n      var optData = map(maModel.get('data'), curry(markAreaTransform, seriesModel, coordSys, maModel));\n\n      if (coordSys) {\n        optData = filter(optData, curry(markAreaFilter, coordSys));\n      }\n\n      var dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {\n        return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];\n      } : function (item) {\n        return item.value;\n      };\n      areaData.initData(optData, null, dimValueGetter);\n      areaData.hasItemOption = true;\n      return areaData;\n    }\n\n    function install$G(registers) {\n      registers.registerComponentModel(MarkAreaModel);\n      registers.registerComponentView(MarkAreaView);\n      registers.registerPreprocessor(function (opt) {\n        opt.markArea = opt.markArea || {};\n      });\n    }\n\n    var getDefaultSelectorOptions = function (ecModel, type) {\n      if (type === 'all') {\n        return {\n          type: 'all',\n          title: ecModel.getLocale(['legend', 'selector', 'all'])\n        };\n      } else if (type === 'inverse') {\n        return {\n          type: 'inverse',\n          title: ecModel.getLocale(['legend', 'selector', 'inverse'])\n        };\n      }\n    };\n\n    var LegendModel = function (_super) {\n      __extends(LegendModel, _super);\n\n      function LegendModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = LegendModel.type;\n        _this.layoutMode = {\n          type: 'box',\n          ignoreSize: true\n        };\n        return _this;\n      }\n\n      LegendModel.prototype.init = function (option, parentModel, ecModel) {\n        this.mergeDefaultAndTheme(option, ecModel);\n        option.selected = option.selected || {};\n\n        this._updateSelector(option);\n      };\n\n      LegendModel.prototype.mergeOption = function (option, ecModel) {\n        _super.prototype.mergeOption.call(this, option, ecModel);\n\n        this._updateSelector(option);\n      };\n\n      LegendModel.prototype._updateSelector = function (option) {\n        var selector = option.selector;\n        var ecModel = this.ecModel;\n\n        if (selector === true) {\n          selector = option.selector = ['all', 'inverse'];\n        }\n\n        if (isArray(selector)) {\n          each(selector, function (item, index) {\n            isString(item) && (item = {\n              type: item\n            });\n            selector[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));\n          });\n        }\n      };\n\n      LegendModel.prototype.optionUpdated = function () {\n        this._updateData(this.ecModel);\n\n        var legendData = this._data;\n\n        if (legendData[0] && this.get('selectedMode') === 'single') {\n          var hasSelected = false;\n\n          for (var i = 0; i < legendData.length; i++) {\n            var name_1 = legendData[i].get('name');\n\n            if (this.isSelected(name_1)) {\n              this.select(name_1);\n              hasSelected = true;\n              break;\n            }\n          }\n\n          !hasSelected && this.select(legendData[0].get('name'));\n        }\n      };\n\n      LegendModel.prototype._updateData = function (ecModel) {\n        var potentialData = [];\n        var availableNames = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n          var seriesName = seriesModel.name;\n          availableNames.push(seriesName);\n          var isPotential;\n\n          if (seriesModel.legendVisualProvider) {\n            var provider = seriesModel.legendVisualProvider;\n            var names = provider.getAllNames();\n\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n              availableNames = availableNames.concat(names);\n            }\n\n            if (names.length) {\n              potentialData = potentialData.concat(names);\n            } else {\n              isPotential = true;\n            }\n          } else {\n            isPotential = true;\n          }\n\n          if (isPotential && isNameSpecified(seriesModel)) {\n            potentialData.push(seriesModel.name);\n          }\n        });\n        this._availableNames = availableNames;\n        var rawData = this.get('data') || potentialData;\n        var legendData = map(rawData, function (dataItem) {\n          if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n            dataItem = {\n              name: dataItem\n            };\n          }\n\n          return new Model(dataItem, this, this.ecModel);\n        }, this);\n        this._data = legendData;\n      };\n\n      LegendModel.prototype.getData = function () {\n        return this._data;\n      };\n\n      LegendModel.prototype.select = function (name) {\n        var selected = this.option.selected;\n        var selectedMode = this.get('selectedMode');\n\n        if (selectedMode === 'single') {\n          var data = this._data;\n          each(data, function (dataItem) {\n            selected[dataItem.get('name')] = false;\n          });\n        }\n\n        selected[name] = true;\n      };\n\n      LegendModel.prototype.unSelect = function (name) {\n        if (this.get('selectedMode') !== 'single') {\n          this.option.selected[name] = false;\n        }\n      };\n\n      LegendModel.prototype.toggleSelected = function (name) {\n        var selected = this.option.selected;\n\n        if (!selected.hasOwnProperty(name)) {\n          selected[name] = true;\n        }\n\n        this[selected[name] ? 'unSelect' : 'select'](name);\n      };\n\n      LegendModel.prototype.allSelect = function () {\n        var data = this._data;\n        var selected = this.option.selected;\n        each(data, function (dataItem) {\n          selected[dataItem.get('name', true)] = true;\n        });\n      };\n\n      LegendModel.prototype.inverseSelect = function () {\n        var data = this._data;\n        var selected = this.option.selected;\n        each(data, function (dataItem) {\n          var name = dataItem.get('name', true);\n\n          if (!selected.hasOwnProperty(name)) {\n            selected[name] = true;\n          }\n\n          selected[name] = !selected[name];\n        });\n      };\n\n      LegendModel.prototype.isSelected = function (name) {\n        var selected = this.option.selected;\n        return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;\n      };\n\n      LegendModel.prototype.getOrient = function () {\n        return this.get('orient') === 'vertical' ? {\n          index: 1,\n          name: 'vertical'\n        } : {\n          index: 0,\n          name: 'horizontal'\n        };\n      };\n\n      LegendModel.type = 'legend.plain';\n      LegendModel.dependencies = ['series'];\n      LegendModel.defaultOption = {\n        zlevel: 0,\n        z: 4,\n        show: true,\n        orient: 'horizontal',\n        left: 'center',\n        top: 0,\n        align: 'auto',\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',\n        borderRadius: 0,\n        borderWidth: 0,\n        padding: 5,\n        itemGap: 10,\n        itemWidth: 25,\n        itemHeight: 14,\n        inactiveColor: '#ccc',\n        inactiveBorderColor: '#ccc',\n        itemStyle: {\n          borderWidth: 0\n        },\n        textStyle: {\n          color: '#333'\n        },\n        selectedMode: true,\n        selector: false,\n        selectorLabel: {\n          show: true,\n          borderRadius: 10,\n          padding: [3, 5, 3, 5],\n          fontSize: 12,\n          fontFamily: ' sans-serif',\n          color: '#666',\n          borderWidth: 1,\n          borderColor: '#666'\n        },\n        emphasis: {\n          selectorLabel: {\n            show: true,\n            color: '#eee',\n            backgroundColor: '#666'\n          }\n        },\n        selectorPosition: 'auto',\n        selectorItemGap: 7,\n        selectorButtonGap: 10,\n        tooltip: {\n          show: false\n        }\n      };\n      return LegendModel;\n    }(ComponentModel);\n\n    var curry$1 = curry;\n    var each$e = each;\n    var Group$2 = Group;\n\n    var LegendView = function (_super) {\n      __extends(LegendView, _super);\n\n      function LegendView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = LegendView.type;\n        _this.newlineDisabled = false;\n        return _this;\n      }\n\n      LegendView.prototype.init = function () {\n        this.group.add(this._contentGroup = new Group$2());\n        this.group.add(this._selectorGroup = new Group$2());\n        this._isFirstRender = true;\n      };\n\n      LegendView.prototype.getContentGroup = function () {\n        return this._contentGroup;\n      };\n\n      LegendView.prototype.getSelectorGroup = function () {\n        return this._selectorGroup;\n      };\n\n      LegendView.prototype.render = function (legendModel, ecModel, api) {\n        var isFirstRender = this._isFirstRender;\n        this._isFirstRender = false;\n        this.resetInner();\n\n        if (!legendModel.get('show', true)) {\n          return;\n        }\n\n        var itemAlign = legendModel.get('align');\n        var orient = legendModel.get('orient');\n\n        if (!itemAlign || itemAlign === 'auto') {\n          itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';\n        }\n\n        var selector = legendModel.get('selector', true);\n        var selectorPosition = legendModel.get('selectorPosition', true);\n\n        if (selector && (!selectorPosition || selectorPosition === 'auto')) {\n          selectorPosition = orient === 'horizontal' ? 'end' : 'start';\n        }\n\n        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n        var positionInfo = legendModel.getBoxLayoutParams();\n        var viewportSize = {\n          width: api.getWidth(),\n          height: api.getHeight()\n        };\n        var padding = legendModel.get('padding');\n        var maxSize = getLayoutRect(positionInfo, viewportSize, padding);\n        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);\n        var layoutRect = getLayoutRect(defaults({\n          width: mainRect.width,\n          height: mainRect.height\n        }, positionInfo), viewportSize, padding);\n        this.group.x = layoutRect.x - mainRect.x;\n        this.group.y = layoutRect.y - mainRect.y;\n        this.group.markRedraw();\n        this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));\n      };\n\n      LegendView.prototype.resetInner = function () {\n        this.getContentGroup().removeAll();\n        this._backgroundEl && this.group.remove(this._backgroundEl);\n        this.getSelectorGroup().removeAll();\n      };\n\n      LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n        var contentGroup = this.getContentGroup();\n        var legendDrawnMap = createHashMap();\n        var selectMode = legendModel.get('selectedMode');\n        var excludeSeriesId = [];\n        ecModel.eachRawSeries(function (seriesModel) {\n          !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);\n        });\n        each$e(legendModel.getData(), function (itemModel, dataIndex) {\n          var name = itemModel.get('name');\n\n          if (!this.newlineDisabled && (name === '' || name === '\\n')) {\n            var g = new Group$2();\n            g.newline = true;\n            contentGroup.add(g);\n            return;\n          }\n\n          var seriesModel = ecModel.getSeriesByName(name)[0];\n\n          if (legendDrawnMap.get(name)) {\n            return;\n          }\n\n          if (seriesModel) {\n            var data = seriesModel.getData();\n            var style = data.getVisual('style');\n            var color = style[data.getVisual('drawType')] || style.fill;\n            var borderColor = style.stroke;\n            var decal = style.decal;\n            var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n            var symbolType = data.getVisual('symbol');\n\n            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode);\n\n            itemGroup.on('click', curry$1(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry$1(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry$1(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));\n            legendDrawnMap.set(name, true);\n          } else {\n            ecModel.eachRawSeries(function (seriesModel) {\n              if (legendDrawnMap.get(name)) {\n                return;\n              }\n\n              if (seriesModel.legendVisualProvider) {\n                var provider = seriesModel.legendVisualProvider;\n\n                if (!provider.containName(name)) {\n                  return;\n                }\n\n                var idx = provider.indexOfName(name);\n                var style = provider.getItemVisual(idx, 'style');\n                var borderColor = style.stroke;\n                var decal = style.decal;\n                var color = style.fill;\n                var colorArr = parse(style.fill);\n\n                if (colorArr && colorArr[3] === 0) {\n                  colorArr[3] = 0.2;\n                  color = stringify(colorArr, 'rgba');\n                }\n\n                var legendSymbolType = 'roundRect';\n\n                var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, decal, selectMode);\n\n                itemGroup.on('click', curry$1(dispatchSelectAction, null, name, api, excludeSeriesId)).on('mouseover', curry$1(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry$1(dispatchDownplayAction, null, name, api, excludeSeriesId));\n                legendDrawnMap.set(name, true);\n              }\n            }, this);\n          }\n\n          if (\"development\" !== 'production') {\n            if (!legendDrawnMap.get(name)) {\n              console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n            }\n          }\n        }, this);\n\n        if (selector) {\n          this._createSelector(selector, legendModel, api, orient, selectorPosition);\n        }\n      };\n\n      LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {\n        var selectorGroup = this.getSelectorGroup();\n        each$e(selector, function createSelectorButton(selectorItem) {\n          var type = selectorItem.type;\n          var labelText = new ZRText({\n            style: {\n              x: 0,\n              y: 0,\n              align: 'center',\n              verticalAlign: 'middle'\n            },\n            onclick: function () {\n              api.dispatchAction({\n                type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'\n              });\n            }\n          });\n          selectorGroup.add(labelText);\n          var labelModel = legendModel.getModel('selectorLabel');\n          var emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel']);\n          setLabelStyle(labelText, {\n            normal: labelModel,\n            emphasis: emphasisLabelModel\n          }, {\n            defaultText: selectorItem.title\n          });\n          enableHoverEmphasis(labelText);\n        });\n      };\n\n      LegendView.prototype._createItem = function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode) {\n        var itemWidth = legendModel.get('itemWidth');\n        var itemHeight = legendModel.get('itemHeight');\n        var inactiveColor = legendModel.get('inactiveColor');\n        var inactiveBorderColor = legendModel.get('inactiveBorderColor');\n        var symbolKeepAspect = legendModel.get('symbolKeepAspect');\n        var legendModelItemStyle = legendModel.getModel('itemStyle');\n        var isSelected = legendModel.isSelected(name);\n        var itemGroup = new Group$2();\n        var textStyleModel = itemModel.getModel('textStyle');\n        var itemIcon = itemModel.get('icon');\n        var tooltipModel = itemModel.getModel('tooltip');\n        var legendGlobalTooltipModel = tooltipModel.parentModel;\n        legendSymbolType = itemIcon || legendSymbolType;\n        var legendSymbol = createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, symbolKeepAspect == null ? true : symbolKeepAspect);\n        itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected));\n\n        if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType === 'none')) {\n          var size = itemHeight * 0.8;\n\n          if (symbolType === 'none') {\n            symbolType = 'circle';\n          }\n\n          var legendSymbolCenter = createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, symbolKeepAspect == null ? true : symbolKeepAspect);\n          itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected));\n        }\n\n        var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n        var textAlign = itemAlign;\n        var formatter = legendModel.get('formatter');\n        var content = name;\n\n        if (typeof formatter === 'string' && formatter) {\n          content = formatter.replace('{name}', name != null ? name : '');\n        } else if (typeof formatter === 'function') {\n          content = formatter(name);\n        }\n\n        itemGroup.add(new ZRText({\n          style: createTextStyle(textStyleModel, {\n            text: content,\n            x: textX,\n            y: itemHeight / 2,\n            fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n            align: textAlign,\n            verticalAlign: 'middle'\n          })\n        }));\n        var hitRect = new Rect({\n          shape: itemGroup.getBoundingRect(),\n          invisible: true\n        });\n\n        if (tooltipModel.get('show')) {\n          var formatterParams = {\n            componentType: 'legend',\n            legendIndex: legendModel.componentIndex,\n            name: name,\n            $vars: ['name']\n          };\n          hitRect.tooltip = extend({\n            content: name,\n            formatter: legendGlobalTooltipModel.get('formatter', true) || function (params) {\n              return params.name;\n            },\n            formatterParams: formatterParams\n          }, tooltipModel.option);\n        }\n\n        itemGroup.add(hitRect);\n        itemGroup.eachChild(function (child) {\n          child.silent = true;\n        });\n        hitRect.silent = !selectMode;\n        this.getContentGroup().add(itemGroup);\n        enableHoverEmphasis(itemGroup);\n        itemGroup.__legendDataIndex = dataIndex;\n        return itemGroup;\n      };\n\n      LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n        var contentGroup = this.getContentGroup();\n        var selectorGroup = this.getSelectorGroup();\n        box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);\n        var contentRect = contentGroup.getBoundingRect();\n        var contentPos = [-contentRect.x, -contentRect.y];\n        selectorGroup.markRedraw();\n        contentGroup.markRedraw();\n\n        if (selector) {\n          box('horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n          var selectorRect = selectorGroup.getBoundingRect();\n          var selectorPos = [-selectorRect.x, -selectorRect.y];\n          var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n          var orientIdx = legendModel.getOrient().index;\n          var wh = orientIdx === 0 ? 'width' : 'height';\n          var hw = orientIdx === 0 ? 'height' : 'width';\n          var yx = orientIdx === 0 ? 'y' : 'x';\n\n          if (selectorPosition === 'end') {\n            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;\n          } else {\n            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;\n          }\n\n          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;\n          selectorGroup.x = selectorPos[0];\n          selectorGroup.y = selectorPos[1];\n          contentGroup.x = contentPos[0];\n          contentGroup.y = contentPos[1];\n          var mainRect = {\n            x: 0,\n            y: 0\n          };\n          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];\n          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);\n          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);\n          return mainRect;\n        } else {\n          contentGroup.x = contentPos[0];\n          contentGroup.y = contentPos[1];\n          return this.group.getBoundingRect();\n        }\n      };\n\n      LegendView.prototype.remove = function () {\n        this.getContentGroup().removeAll();\n        this._isFirstRender = true;\n      };\n\n      LegendView.type = 'legend.plain';\n      return LegendView;\n    }(ComponentView);\n\n    function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected) {\n      var itemStyle;\n\n      if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {\n        itemStyle = legendModelItemStyle.getItemStyle();\n        symbol.style.stroke = borderColor;\n        symbol.style.decal = decal;\n\n        if (!isSelected) {\n          itemStyle.stroke = inactiveBorderColor;\n        }\n      } else {\n        itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);\n      }\n\n      symbol.setStyle(itemStyle);\n      return symbol;\n    }\n\n    function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {\n      dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);\n      api.dispatchAction({\n        type: 'legendToggleSelect',\n        name: seriesName != null ? seriesName : dataName\n      });\n      dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);\n    }\n\n    function isUseHoverLayer(api) {\n      var list = api.getZr().storage.getDisplayList();\n      var emphasisState;\n      var i = 0;\n      var len = list.length;\n\n      while (i < len && !(emphasisState = list[i].states.emphasis)) {\n        i++;\n      }\n\n      return emphasisState && emphasisState.hoverLayer;\n    }\n\n    function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {\n      if (!isUseHoverLayer(api)) {\n        api.dispatchAction({\n          type: 'highlight',\n          seriesName: seriesName,\n          name: dataName,\n          excludeSeriesId: excludeSeriesId\n        });\n      }\n    }\n\n    function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {\n      if (!isUseHoverLayer(api)) {\n        api.dispatchAction({\n          type: 'downplay',\n          seriesName: seriesName,\n          name: dataName,\n          excludeSeriesId: excludeSeriesId\n        });\n      }\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function legendFilter(ecModel) {\n      var legendModels = ecModel.findComponents({\n        mainType: 'legend'\n      });\n\n      if (legendModels && legendModels.length) {\n        ecModel.filterSeries(function (series) {\n          for (var i = 0; i < legendModels.length; i++) {\n            if (!legendModels[i].isSelected(series.name)) {\n              return false;\n            }\n          }\n\n          return true;\n        });\n      }\n    }\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n      var selectedMap = {};\n      var isToggleSelect = methodName === 'toggleSelected';\n      var isSelected;\n      ecModel.eachComponent('legend', function (legendModel) {\n        if (isToggleSelect && isSelected != null) {\n          legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n        } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {\n          legendModel[methodName]();\n        } else {\n          legendModel[methodName](payload.name);\n          isSelected = legendModel.isSelected(payload.name);\n        }\n\n        var legendData = legendModel.getData();\n        each(legendData, function (model) {\n          var name = model.get('name');\n\n          if (name === '\\n' || name === '') {\n            return;\n          }\n\n          var isItemSelected = legendModel.isSelected(name);\n\n          if (selectedMap.hasOwnProperty(name)) {\n            selectedMap[name] = selectedMap[name] && isItemSelected;\n          } else {\n            selectedMap[name] = isItemSelected;\n          }\n        });\n      });\n      return methodName === 'allSelect' || methodName === 'inverseSelect' ? {\n        selected: selectedMap\n      } : {\n        name: payload.name,\n        selected: selectedMap\n      };\n    }\n\n    function installLegendAction(registers) {\n      registers.registerAction('legendToggleSelect', 'legendselectchanged', curry(legendSelectActionHandler, 'toggleSelected'));\n      registers.registerAction('legendAllSelect', 'legendselectall', curry(legendSelectActionHandler, 'allSelect'));\n      registers.registerAction('legendInverseSelect', 'legendinverseselect', curry(legendSelectActionHandler, 'inverseSelect'));\n      registers.registerAction('legendSelect', 'legendselected', curry(legendSelectActionHandler, 'select'));\n      registers.registerAction('legendUnSelect', 'legendunselected', curry(legendSelectActionHandler, 'unSelect'));\n    }\n\n    function install$H(registers) {\n      registers.registerComponentModel(LegendModel);\n      registers.registerComponentView(LegendView);\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);\n      registers.registerSubTypeDefaulter('legend', function () {\n        return 'plain';\n      });\n      installLegendAction(registers);\n    }\n\n    var ScrollableLegendModel = function (_super) {\n      __extends(ScrollableLegendModel, _super);\n\n      function ScrollableLegendModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ScrollableLegendModel.type;\n        return _this;\n      }\n\n      ScrollableLegendModel.prototype.setScrollDataIndex = function (scrollDataIndex) {\n        this.option.scrollDataIndex = scrollDataIndex;\n      };\n\n      ScrollableLegendModel.prototype.init = function (option, parentModel, ecModel) {\n        var inputPositionParams = getLayoutParams(option);\n\n        _super.prototype.init.call(this, option, parentModel, ecModel);\n\n        mergeAndNormalizeLayoutParams$1(this, option, inputPositionParams);\n      };\n\n      ScrollableLegendModel.prototype.mergeOption = function (option, ecModel) {\n        _super.prototype.mergeOption.call(this, option, ecModel);\n\n        mergeAndNormalizeLayoutParams$1(this, this.option, option);\n      };\n\n      ScrollableLegendModel.type = 'legend.scroll';\n      ScrollableLegendModel.defaultOption = inheritDefaultOption(LegendModel.defaultOption, {\n        scrollDataIndex: 0,\n        pageButtonItemGap: 5,\n        pageButtonGap: null,\n        pageButtonPosition: 'end',\n        pageFormatter: '{current}/{total}',\n        pageIcons: {\n          horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],\n          vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']\n        },\n        pageIconColor: '#2f4554',\n        pageIconInactiveColor: '#aaa',\n        pageIconSize: 15,\n        pageTextStyle: {\n          color: '#333'\n        },\n        animationDurationUpdate: 800\n      });\n      return ScrollableLegendModel;\n    }(LegendModel);\n\n    function mergeAndNormalizeLayoutParams$1(legendModel, target, raw) {\n      var orient = legendModel.getOrient();\n      var ignoreSize = [1, 1];\n      ignoreSize[orient.index] = 0;\n      mergeLayoutParam(target, raw, {\n        type: 'box',\n        ignoreSize: !!ignoreSize\n      });\n    }\n\n    var Group$3 = Group;\n    var WH$1 = ['width', 'height'];\n    var XY$1 = ['x', 'y'];\n\n    var ScrollableLegendView = function (_super) {\n      __extends(ScrollableLegendView, _super);\n\n      function ScrollableLegendView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ScrollableLegendView.type;\n        _this.newlineDisabled = true;\n        _this._currentIndex = 0;\n        return _this;\n      }\n\n      ScrollableLegendView.prototype.init = function () {\n        _super.prototype.init.call(this);\n\n        this.group.add(this._containerGroup = new Group$3());\n\n        this._containerGroup.add(this.getContentGroup());\n\n        this.group.add(this._controllerGroup = new Group$3());\n      };\n\n      ScrollableLegendView.prototype.resetInner = function () {\n        _super.prototype.resetInner.call(this);\n\n        this._controllerGroup.removeAll();\n\n        this._containerGroup.removeClipPath();\n\n        this._containerGroup.__rectSize = null;\n      };\n\n      ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {\n        var self = this;\n\n        _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);\n\n        var controllerGroup = this._controllerGroup;\n        var pageIconSize = legendModel.get('pageIconSize', true);\n        var pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];\n        createPageButton('pagePrev', 0);\n        var pageTextStyleModel = legendModel.getModel('pageTextStyle');\n        controllerGroup.add(new ZRText({\n          name: 'pageText',\n          style: {\n            text: 'xx/xx',\n            fill: pageTextStyleModel.getTextColor(),\n            font: pageTextStyleModel.getFont(),\n            verticalAlign: 'middle',\n            align: 'center'\n          },\n          silent: true\n        }));\n        createPageButton('pageNext', 1);\n\n        function createPageButton(name, iconIdx) {\n          var pageDataIndexName = name + 'DataIndex';\n          var icon = createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {\n            onclick: bind(self._pageGo, self, pageDataIndexName, legendModel, api)\n          }, {\n            x: -pageIconSizeArr[0] / 2,\n            y: -pageIconSizeArr[1] / 2,\n            width: pageIconSizeArr[0],\n            height: pageIconSizeArr[1]\n          });\n          icon.name = name;\n          controllerGroup.add(icon);\n        }\n      };\n\n      ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {\n        var selectorGroup = this.getSelectorGroup();\n        var orientIdx = legendModel.getOrient().index;\n        var wh = WH$1[orientIdx];\n        var xy = XY$1[orientIdx];\n        var hw = WH$1[1 - orientIdx];\n        var yx = XY$1[1 - orientIdx];\n        selector && box('horizontal', selectorGroup, legendModel.get('selectorItemGap', true));\n        var selectorButtonGap = legendModel.get('selectorButtonGap', true);\n        var selectorRect = selectorGroup.getBoundingRect();\n        var selectorPos = [-selectorRect.x, -selectorRect.y];\n        var processMaxSize = clone(maxSize);\n        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);\n\n        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);\n\n        if (selector) {\n          if (selectorPosition === 'end') {\n            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;\n          } else {\n            var offset = selectorRect[wh] + selectorButtonGap;\n            selectorPos[orientIdx] -= offset;\n            mainRect[xy] -= offset;\n          }\n\n          mainRect[wh] += selectorRect[wh] + selectorButtonGap;\n          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;\n          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);\n          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);\n          selectorGroup.x = selectorPos[0];\n          selectorGroup.y = selectorPos[1];\n          selectorGroup.markRedraw();\n        }\n\n        return mainRect;\n      };\n\n      ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {\n        var contentGroup = this.getContentGroup();\n        var containerGroup = this._containerGroup;\n        var controllerGroup = this._controllerGroup;\n        box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);\n        box('horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true));\n        var contentRect = contentGroup.getBoundingRect();\n        var controllerRect = controllerGroup.getBoundingRect();\n        var showController = this._showController = contentRect[wh] > maxSize[wh];\n        var contentPos = [-contentRect.x, -contentRect.y];\n\n        if (!isFirstRender) {\n          contentPos[orientIdx] = contentGroup[xy];\n        }\n\n        var containerPos = [0, 0];\n        var controllerPos = [-controllerRect.x, -controllerRect.y];\n        var pageButtonGap = retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true));\n\n        if (showController) {\n          var pageButtonPosition = legendModel.get('pageButtonPosition', true);\n\n          if (pageButtonPosition === 'end') {\n            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];\n          } else {\n            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;\n          }\n        }\n\n        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;\n        contentGroup.setPosition(contentPos);\n        containerGroup.setPosition(containerPos);\n        controllerGroup.setPosition(controllerPos);\n        var mainRect = {\n          x: 0,\n          y: 0\n        };\n        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];\n        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);\n        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);\n        containerGroup.__rectSize = maxSize[wh];\n\n        if (showController) {\n          var clipShape = {\n            x: 0,\n            y: 0\n          };\n          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);\n          clipShape[hw] = mainRect[hw];\n          containerGroup.setClipPath(new Rect({\n            shape: clipShape\n          }));\n          containerGroup.__rectSize = clipShape[wh];\n        } else {\n          controllerGroup.eachChild(function (child) {\n            child.attr({\n              invisible: true,\n              silent: true\n            });\n          });\n        }\n\n        var pageInfo = this._getPageInfo(legendModel);\n\n        pageInfo.pageIndex != null && updateProps(contentGroup, {\n          x: pageInfo.contentPosition[0],\n          y: pageInfo.contentPosition[1]\n        }, showController ? legendModel : null);\n\n        this._updatePageInfoView(legendModel, pageInfo);\n\n        return mainRect;\n      };\n\n      ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {\n        var scrollDataIndex = this._getPageInfo(legendModel)[to];\n\n        scrollDataIndex != null && api.dispatchAction({\n          type: 'legendScroll',\n          scrollDataIndex: scrollDataIndex,\n          legendId: legendModel.id\n        });\n      };\n\n      ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {\n        var controllerGroup = this._controllerGroup;\n        each(['pagePrev', 'pageNext'], function (name) {\n          var key = name + 'DataIndex';\n          var canJump = pageInfo[key] != null;\n          var icon = controllerGroup.childOfName(name);\n\n          if (icon) {\n            icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true));\n            icon.cursor = canJump ? 'pointer' : 'default';\n          }\n        });\n        var pageText = controllerGroup.childOfName('pageText');\n        var pageFormatter = legendModel.get('pageFormatter');\n        var pageIndex = pageInfo.pageIndex;\n        var current = pageIndex != null ? pageIndex + 1 : 0;\n        var total = pageInfo.pageCount;\n        pageText && pageFormatter && pageText.setStyle('text', isString(pageFormatter) ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '') : pageFormatter({\n          current: current,\n          total: total\n        }));\n      };\n\n      ScrollableLegendView.prototype._getPageInfo = function (legendModel) {\n        var scrollDataIndex = legendModel.get('scrollDataIndex', true);\n        var contentGroup = this.getContentGroup();\n        var containerRectSize = this._containerGroup.__rectSize;\n        var orientIdx = legendModel.getOrient().index;\n        var wh = WH$1[orientIdx];\n        var xy = XY$1[orientIdx];\n\n        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);\n\n        var children = contentGroup.children();\n        var targetItem = children[targetItemIndex];\n        var itemCount = children.length;\n        var pCount = !itemCount ? 0 : 1;\n        var result = {\n          contentPosition: [contentGroup.x, contentGroup.y],\n          pageCount: pCount,\n          pageIndex: pCount - 1,\n          pagePrevDataIndex: null,\n          pageNextDataIndex: null\n        };\n\n        if (!targetItem) {\n          return result;\n        }\n\n        var targetItemInfo = getItemInfo(targetItem);\n        result.contentPosition[orientIdx] = -targetItemInfo.s;\n\n        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {\n          currItemInfo = getItemInfo(children[i]);\n\n          if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {\n            if (winEndItemInfo.i > winStartItemInfo.i) {\n              winStartItemInfo = winEndItemInfo;\n            } else {\n              winStartItemInfo = currItemInfo;\n            }\n\n            if (winStartItemInfo) {\n              if (result.pageNextDataIndex == null) {\n                result.pageNextDataIndex = winStartItemInfo.i;\n              }\n\n              ++result.pageCount;\n            }\n          }\n\n          winEndItemInfo = currItemInfo;\n        }\n\n        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {\n          currItemInfo = getItemInfo(children[i]);\n\n          if ((!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {\n            winEndItemInfo = winStartItemInfo;\n\n            if (result.pagePrevDataIndex == null) {\n              result.pagePrevDataIndex = winStartItemInfo.i;\n            }\n\n            ++result.pageCount;\n            ++result.pageIndex;\n          }\n\n          winStartItemInfo = currItemInfo;\n        }\n\n        return result;\n\n        function getItemInfo(el) {\n          if (el) {\n            var itemRect = el.getBoundingRect();\n            var start = itemRect[xy] + el[xy];\n            return {\n              s: start,\n              e: start + itemRect[wh],\n              i: el.__legendDataIndex\n            };\n          }\n        }\n\n        function intersect(itemInfo, winStart) {\n          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;\n        }\n      };\n\n      ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {\n        if (!this._showController) {\n          return 0;\n        }\n\n        var index;\n        var contentGroup = this.getContentGroup();\n        var defaultIndex;\n        contentGroup.eachChild(function (child, idx) {\n          var legendDataIdx = child.__legendDataIndex;\n\n          if (defaultIndex == null && legendDataIdx != null) {\n            defaultIndex = idx;\n          }\n\n          if (legendDataIdx === targetDataIndex) {\n            index = idx;\n          }\n        });\n        return index != null ? index : defaultIndex;\n      };\n\n      ScrollableLegendView.type = 'legend.scroll';\n      return ScrollableLegendView;\n    }(LegendView);\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    function installScrollableLegendAction(registers) {\n      registers.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {\n        var scrollDataIndex = payload.scrollDataIndex;\n        scrollDataIndex != null && ecModel.eachComponent({\n          mainType: 'legend',\n          subType: 'scroll',\n          query: payload\n        }, function (legendModel) {\n          legendModel.setScrollDataIndex(scrollDataIndex);\n        });\n      });\n    }\n\n    function install$I(registers) {\n      use(install$H);\n      registers.registerComponentModel(ScrollableLegendModel);\n      registers.registerComponentView(ScrollableLegendView);\n      installScrollableLegendAction(registers);\n    }\n\n    function install$J(registers) {\n      use(install$H);\n      use(install$I);\n    }\n\n    var InsideZoomModel = function (_super) {\n      __extends(InsideZoomModel, _super);\n\n      function InsideZoomModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = InsideZoomModel.type;\n        return _this;\n      }\n\n      InsideZoomModel.type = 'dataZoom.inside';\n      InsideZoomModel.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {\n        disabled: false,\n        zoomLock: false,\n        zoomOnMouseWheel: true,\n        moveOnMouseMove: true,\n        moveOnMouseWheel: false,\n        preventDefaultMouseMove: true\n      });\n      return InsideZoomModel;\n    }(DataZoomModel);\n\n    var inner$m = makeInner();\n    function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {\n      inner$m(api).coordSysRecordMap.each(function (coordSysRecord) {\n        var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);\n\n        if (dzInfo) {\n          dzInfo.getRange = getRange;\n        }\n      });\n    }\n    function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {\n      var coordSysRecordMap = inner$m(api).coordSysRecordMap;\n      var coordSysKeyArr = coordSysRecordMap.keys();\n\n      for (var i = 0; i < coordSysKeyArr.length; i++) {\n        var coordSysKey = coordSysKeyArr[i];\n        var coordSysRecord = coordSysRecordMap.get(coordSysKey);\n        var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n\n        if (dataZoomInfoMap) {\n          var dzUid = dataZoomModel.uid;\n          var dzInfo = dataZoomInfoMap.get(dzUid);\n\n          if (dzInfo) {\n            dataZoomInfoMap.removeKey(dzUid);\n\n            if (!dataZoomInfoMap.keys().length) {\n              disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n            }\n          }\n        }\n      }\n    }\n\n    function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {\n      if (coordSysRecord) {\n        coordSysRecordMap.removeKey(coordSysRecord.model.uid);\n        var controller = coordSysRecord.controller;\n        controller && controller.dispose();\n      }\n    }\n\n    function createCoordSysRecord(api, coordSysModel) {\n      var coordSysRecord = {\n        model: coordSysModel,\n        containsPoint: curry(containsPoint, coordSysModel),\n        dispatchAction: curry(dispatchAction$1, api),\n        dataZoomInfoMap: null,\n        controller: null\n      };\n      var controller = coordSysRecord.controller = new RoamController(api.getZr());\n      each(['pan', 'zoom', 'scrollMove'], function (eventName) {\n        controller.on(eventName, function (event) {\n          var batch = [];\n          coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {\n            if (!event.isAvailableBehavior(dzInfo.model.option)) {\n              return;\n            }\n\n            var method = (dzInfo.getRange || {})[eventName];\n            var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);\n            !dzInfo.model.get('disabled', true) && range && batch.push({\n              dataZoomId: dzInfo.model.id,\n              start: range[0],\n              end: range[1]\n            });\n          });\n          batch.length && coordSysRecord.dispatchAction(batch);\n        });\n      });\n      return coordSysRecord;\n    }\n\n    function dispatchAction$1(api, batch) {\n      api.dispatchAction({\n        type: 'dataZoom',\n        animation: {\n          easing: 'cubicOut',\n          duration: 100\n        },\n        batch: batch\n      });\n    }\n\n    function containsPoint(coordSysModel, e, x, y) {\n      return coordSysModel.coordinateSystem.containPoint([x, y]);\n    }\n\n    function mergeControllerParams(dataZoomInfoMap) {\n      var controlType;\n      var prefix = 'type_';\n      var typePriority = {\n        'type_true': 2,\n        'type_move': 1,\n        'type_false': 0,\n        'type_undefined': -1\n      };\n      var preventDefaultMouseMove = true;\n      dataZoomInfoMap.each(function (dataZoomInfo) {\n        var dataZoomModel = dataZoomInfo.model;\n        var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;\n\n        if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {\n          controlType = oneType;\n        }\n\n        preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true);\n      });\n      return {\n        controlType: controlType,\n        opt: {\n          zoomOnMouseWheel: true,\n          moveOnMouseMove: true,\n          moveOnMouseWheel: true,\n          preventDefaultMouseMove: !!preventDefaultMouseMove\n        }\n      };\n    }\n\n    function installDataZoomRoamProcessor(registers) {\n      registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {\n        var apiInner = inner$m(api);\n        var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());\n        coordSysRecordMap.each(function (coordSysRecord) {\n          coordSysRecord.dataZoomInfoMap = null;\n        });\n        ecModel.eachComponent({\n          mainType: 'dataZoom',\n          subType: 'inside'\n        }, function (dataZoomModel) {\n          var dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);\n          each(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {\n            var coordSysUid = dzCoordSysInfo.model.uid;\n            var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));\n            var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());\n            dataZoomInfoMap.set(dataZoomModel.uid, {\n              dzReferCoordSysInfo: dzCoordSysInfo,\n              model: dataZoomModel,\n              getRange: null\n            });\n          });\n        });\n        coordSysRecordMap.each(function (coordSysRecord) {\n          var controller = coordSysRecord.controller;\n          var firstDzInfo;\n          var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;\n\n          if (dataZoomInfoMap) {\n            var firstDzKey = dataZoomInfoMap.keys()[0];\n\n            if (firstDzKey != null) {\n              firstDzInfo = dataZoomInfoMap.get(firstDzKey);\n            }\n          }\n\n          if (!firstDzInfo) {\n            disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);\n            return;\n          }\n\n          var controllerParams = mergeControllerParams(dataZoomInfoMap);\n          controller.enable(controllerParams.controlType, controllerParams.opt);\n          controller.setPointerChecker(coordSysRecord.containsPoint);\n          createOrUpdate(coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate');\n        });\n      });\n    }\n\n    var InsideZoomView = function (_super) {\n      __extends(InsideZoomView, _super);\n\n      function InsideZoomView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'dataZoom.inside';\n        return _this;\n      }\n\n      InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {\n        _super.prototype.render.apply(this, arguments);\n\n        if (dataZoomModel.noTarget()) {\n          this._clear();\n\n          return;\n        }\n\n        this.range = dataZoomModel.getPercentRange();\n        setViewInfoToCoordSysRecord(api, dataZoomModel, {\n          pan: bind(getRangeHandlers.pan, this),\n          zoom: bind(getRangeHandlers.zoom, this),\n          scrollMove: bind(getRangeHandlers.scrollMove, this)\n        });\n      };\n\n      InsideZoomView.prototype.dispose = function () {\n        this._clear();\n\n        _super.prototype.dispose.apply(this, arguments);\n      };\n\n      InsideZoomView.prototype._clear = function () {\n        disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);\n        this.range = null;\n      };\n\n      InsideZoomView.type = 'dataZoom.inside';\n      return InsideZoomView;\n    }(DataZoomView);\n\n    var getRangeHandlers = {\n      zoom: function (coordSysInfo, coordSysMainType, controller, e) {\n        var lastRange = this.range;\n        var range = lastRange.slice();\n        var axisModel = coordSysInfo.axisModels[0];\n\n        if (!axisModel) {\n          return;\n        }\n\n        var directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo);\n        var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];\n        var scale = Math.max(1 / e.scale, 0);\n        range[0] = (range[0] - percentPoint) * scale + percentPoint;\n        range[1] = (range[1] - percentPoint) * scale + percentPoint;\n        var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n        sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);\n        this.range = range;\n\n        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n          return range;\n        }\n      },\n      pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n        var directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo);\n        return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;\n      }),\n      scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {\n        var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo);\n        return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;\n      })\n    };\n\n    function makeMover(getPercentDelta) {\n      return function (coordSysInfo, coordSysMainType, controller, e) {\n        var lastRange = this.range;\n        var range = lastRange.slice();\n        var axisModel = coordSysInfo.axisModels[0];\n\n        if (!axisModel) {\n          return;\n        }\n\n        var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e);\n        sliderMove(percentDelta, range, [0, 100], 'all');\n        this.range = range;\n\n        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {\n          return range;\n        }\n      };\n    }\n\n    var getDirectionInfo = {\n      grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n        var axis = axisModel.axis;\n        var ret = {};\n        var rect = coordSysInfo.model.coordinateSystem.getRect();\n        oldPoint = oldPoint || [0, 0];\n\n        if (axis.dim === 'x') {\n          ret.pixel = newPoint[0] - oldPoint[0];\n          ret.pixelLength = rect.width;\n          ret.pixelStart = rect.x;\n          ret.signal = axis.inverse ? 1 : -1;\n        } else {\n          ret.pixel = newPoint[1] - oldPoint[1];\n          ret.pixelLength = rect.height;\n          ret.pixelStart = rect.y;\n          ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n      },\n      polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n        var axis = axisModel.axis;\n        var ret = {};\n        var polar = coordSysInfo.model.coordinateSystem;\n        var radiusExtent = polar.getRadiusAxis().getExtent();\n        var angleExtent = polar.getAngleAxis().getExtent();\n        oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];\n        newPoint = polar.pointToCoord(newPoint);\n\n        if (axisModel.mainType === 'radiusAxis') {\n          ret.pixel = newPoint[0] - oldPoint[0];\n          ret.pixelLength = radiusExtent[1] - radiusExtent[0];\n          ret.pixelStart = radiusExtent[0];\n          ret.signal = axis.inverse ? 1 : -1;\n        } else {\n          ret.pixel = newPoint[1] - oldPoint[1];\n          ret.pixelLength = angleExtent[1] - angleExtent[0];\n          ret.pixelStart = angleExtent[0];\n          ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n      },\n      singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {\n        var axis = axisModel.axis;\n        var rect = coordSysInfo.model.coordinateSystem.getRect();\n        var ret = {};\n        oldPoint = oldPoint || [0, 0];\n\n        if (axis.orient === 'horizontal') {\n          ret.pixel = newPoint[0] - oldPoint[0];\n          ret.pixelLength = rect.width;\n          ret.pixelStart = rect.x;\n          ret.signal = axis.inverse ? 1 : -1;\n        } else {\n          ret.pixel = newPoint[1] - oldPoint[1];\n          ret.pixelLength = rect.height;\n          ret.pixelStart = rect.y;\n          ret.signal = axis.inverse ? -1 : 1;\n        }\n\n        return ret;\n      }\n    };\n\n    function install$K(registers) {\n      installCommon(registers);\n      registers.registerComponentModel(InsideZoomModel);\n      registers.registerComponentView(InsideZoomView);\n      installDataZoomRoamProcessor(registers);\n    }\n\n    var SliderZoomModel = function (_super) {\n      __extends(SliderZoomModel, _super);\n\n      function SliderZoomModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SliderZoomModel.type;\n        return _this;\n      }\n\n      SliderZoomModel.type = 'dataZoom.slider';\n      SliderZoomModel.layoutMode = 'box';\n      SliderZoomModel.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {\n        show: true,\n        right: 'ph',\n        top: 'ph',\n        width: 'ph',\n        height: 'ph',\n        left: null,\n        bottom: null,\n        borderColor: '#d2dbee',\n        borderRadius: 3,\n        backgroundColor: 'rgba(47,69,84,0)',\n        dataBackground: {\n          lineStyle: {\n            color: '#d2dbee',\n            width: 0.5\n          },\n          areaStyle: {\n            color: '#d2dbee',\n            opacity: 0.2\n          }\n        },\n        selectedDataBackground: {\n          lineStyle: {\n            color: '#8fb0f7',\n            width: 0.5\n          },\n          areaStyle: {\n            color: '#8fb0f7',\n            opacity: 0.2\n          }\n        },\n        fillerColor: 'rgba(135,175,274,0.2)',\n        handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',\n        handleSize: '100%',\n        handleStyle: {\n          color: '#fff',\n          borderColor: '#ACB8D1'\n        },\n        moveHandleSize: 7,\n        moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',\n        moveHandleStyle: {\n          color: '#D2DBEE',\n          opacity: 0.7\n        },\n        showDetail: true,\n        showDataShadow: 'auto',\n        realtime: true,\n        zoomLock: false,\n        textStyle: {\n          color: '#6E7079'\n        },\n        brushSelect: true,\n        brushStyle: {\n          color: 'rgba(135,175,274,0.15)'\n        },\n        emphasis: {\n          handleStyle: {\n            borderColor: '#8FB0F7'\n          },\n          moveHandleStyle: {\n            color: '#8FB0F7'\n          }\n        }\n      });\n      return SliderZoomModel;\n    }(DataZoomModel);\n\n    var Rect$2 = Rect;\n    var DEFAULT_LOCATION_EDGE_GAP = 7;\n    var DEFAULT_FRAME_BORDER_WIDTH = 1;\n    var DEFAULT_FILLER_SIZE = 30;\n    var DEFAULT_MOVE_HANDLE_SIZE = 7;\n    var HORIZONTAL = 'horizontal';\n    var VERTICAL = 'vertical';\n    var LABEL_GAP = 5;\n    var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];\n    var REALTIME_ANIMATION_CONFIG = {\n      easing: 'cubicOut',\n      duration: 100\n    };\n\n    var SliderZoomView = function (_super) {\n      __extends(SliderZoomView, _super);\n\n      function SliderZoomView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = SliderZoomView.type;\n        _this._displayables = {};\n        return _this;\n      }\n\n      SliderZoomView.prototype.init = function (ecModel, api) {\n        this.api = api;\n        this._onBrush = bind(this._onBrush, this);\n        this._onBrushEnd = bind(this._onBrushEnd, this);\n      };\n\n      SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {\n        _super.prototype.render.apply(this, arguments);\n\n        createOrUpdate(this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate');\n        this._orient = dataZoomModel.getOrient();\n\n        if (dataZoomModel.get('show') === false) {\n          this.group.removeAll();\n          return;\n        }\n\n        if (dataZoomModel.noTarget()) {\n          this._clear();\n\n          this.group.removeAll();\n          return;\n        }\n\n        if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {\n          this._buildView();\n        }\n\n        this._updateView();\n      };\n\n      SliderZoomView.prototype.dispose = function () {\n        this._clear();\n\n        _super.prototype.dispose.apply(this, arguments);\n      };\n\n      SliderZoomView.prototype._clear = function () {\n        clear(this, '_dispatchZoomAction');\n        var zr = this.api.getZr();\n        zr.off('mousemove', this._onBrush);\n        zr.off('mouseup', this._onBrushEnd);\n      };\n\n      SliderZoomView.prototype._buildView = function () {\n        var thisGroup = this.group;\n        thisGroup.removeAll();\n        this._brushing = false;\n        this._displayables.brushRect = null;\n\n        this._resetLocation();\n\n        this._resetInterval();\n\n        var barGroup = this._displayables.sliderGroup = new Group();\n\n        this._renderBackground();\n\n        this._renderHandle();\n\n        this._renderDataShadow();\n\n        thisGroup.add(barGroup);\n\n        this._positionGroup();\n      };\n\n      SliderZoomView.prototype._resetLocation = function () {\n        var dataZoomModel = this.dataZoomModel;\n        var api = this.api;\n        var showMoveHandle = dataZoomModel.get('brushSelect');\n        var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;\n\n        var coordRect = this._findCoordRect();\n\n        var ecSize = {\n          width: api.getWidth(),\n          height: api.getHeight()\n        };\n        var positionInfo = this._orient === HORIZONTAL ? {\n          right: ecSize.width - coordRect.x - coordRect.width,\n          top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,\n          width: coordRect.width,\n          height: DEFAULT_FILLER_SIZE\n        } : {\n          right: DEFAULT_LOCATION_EDGE_GAP,\n          top: coordRect.y,\n          width: DEFAULT_FILLER_SIZE,\n          height: coordRect.height\n        };\n        var layoutParams = getLayoutParams(dataZoomModel.option);\n        each(['right', 'top', 'width', 'height'], function (name) {\n          if (layoutParams[name] === 'ph') {\n            layoutParams[name] = positionInfo[name];\n          }\n        });\n        var layoutRect = getLayoutRect(layoutParams, ecSize);\n        this._location = {\n          x: layoutRect.x,\n          y: layoutRect.y\n        };\n        this._size = [layoutRect.width, layoutRect.height];\n        this._orient === VERTICAL && this._size.reverse();\n      };\n\n      SliderZoomView.prototype._positionGroup = function () {\n        var thisGroup = this.group;\n        var location = this._location;\n        var orient = this._orient;\n        var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();\n        var inverse = targetAxisModel && targetAxisModel.get('inverse');\n        var sliderGroup = this._displayables.sliderGroup;\n        var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;\n        sliderGroup.attr(orient === HORIZONTAL && !inverse ? {\n          scaleY: otherAxisInverse ? 1 : -1,\n          scaleX: 1\n        } : orient === HORIZONTAL && inverse ? {\n          scaleY: otherAxisInverse ? 1 : -1,\n          scaleX: -1\n        } : orient === VERTICAL && !inverse ? {\n          scaleY: otherAxisInverse ? -1 : 1,\n          scaleX: 1,\n          rotation: Math.PI / 2\n        } : {\n          scaleY: otherAxisInverse ? -1 : 1,\n          scaleX: -1,\n          rotation: Math.PI / 2\n        });\n        var rect = thisGroup.getBoundingRect([sliderGroup]);\n        thisGroup.x = location.x - rect.x;\n        thisGroup.y = location.y - rect.y;\n        thisGroup.markRedraw();\n      };\n\n      SliderZoomView.prototype._getViewExtent = function () {\n        return [0, this._size[0]];\n      };\n\n      SliderZoomView.prototype._renderBackground = function () {\n        var dataZoomModel = this.dataZoomModel;\n        var size = this._size;\n        var barGroup = this._displayables.sliderGroup;\n        var brushSelect = dataZoomModel.get('brushSelect');\n        barGroup.add(new Rect$2({\n          silent: true,\n          shape: {\n            x: 0,\n            y: 0,\n            width: size[0],\n            height: size[1]\n          },\n          style: {\n            fill: dataZoomModel.get('backgroundColor')\n          },\n          z2: -40\n        }));\n        var clickPanel = new Rect$2({\n          shape: {\n            x: 0,\n            y: 0,\n            width: size[0],\n            height: size[1]\n          },\n          style: {\n            fill: 'transparent'\n          },\n          z2: 0,\n          onclick: bind(this._onClickPanel, this)\n        });\n        var zr = this.api.getZr();\n\n        if (brushSelect) {\n          clickPanel.on('mousedown', this._onBrushStart, this);\n          clickPanel.cursor = 'crosshair';\n          zr.on('mousemove', this._onBrush);\n          zr.on('mouseup', this._onBrushEnd);\n        } else {\n          zr.off('mousemove', this._onBrush);\n          zr.off('mouseup', this._onBrushEnd);\n        }\n\n        barGroup.add(clickPanel);\n      };\n\n      SliderZoomView.prototype._renderDataShadow = function () {\n        var info = this._dataShadowInfo = this._prepareDataShadowInfo();\n\n        this._displayables.dataShadowSegs = [];\n\n        if (!info) {\n          return;\n        }\n\n        var size = this._size;\n        var seriesModel = info.series;\n        var data = seriesModel.getRawData();\n        var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;\n\n        if (otherDim == null) {\n          return;\n        }\n\n        var otherDataExtent = data.getDataExtent(otherDim);\n        var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;\n        otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];\n        var otherShadowExtent = [0, size[1]];\n        var thisShadowExtent = [0, size[0]];\n        var areaPoints = [[size[0], 0], [0, 0]];\n        var linePoints = [];\n        var step = thisShadowExtent[1] / (data.count() - 1);\n        var thisCoord = 0;\n        var stride = Math.round(data.count() / size[0]);\n        var lastIsEmpty;\n        data.each([otherDim], function (value, index) {\n          if (stride > 0 && index % stride) {\n            thisCoord += step;\n            return;\n          }\n\n          var isEmpty = value == null || isNaN(value) || value === '';\n          var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);\n\n          if (isEmpty && !lastIsEmpty && index) {\n            areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);\n            linePoints.push([linePoints[linePoints.length - 1][0], 0]);\n          } else if (!isEmpty && lastIsEmpty) {\n            areaPoints.push([thisCoord, 0]);\n            linePoints.push([thisCoord, 0]);\n          }\n\n          areaPoints.push([thisCoord, otherCoord]);\n          linePoints.push([thisCoord, otherCoord]);\n          thisCoord += step;\n          lastIsEmpty = isEmpty;\n        });\n        var dataZoomModel = this.dataZoomModel;\n\n        function createDataShadowGroup(isSelectedArea) {\n          var model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground');\n          var group = new Group();\n          var polygon = new Polygon({\n            shape: {\n              points: areaPoints\n            },\n            segmentIgnoreThreshold: 1,\n            style: model.getModel('areaStyle').getAreaStyle(),\n            silent: true,\n            z2: -20\n          });\n          var polyline = new Polyline({\n            shape: {\n              points: linePoints\n            },\n            segmentIgnoreThreshold: 1,\n            style: model.getModel('lineStyle').getLineStyle(),\n            silent: true,\n            z2: -19\n          });\n          group.add(polygon);\n          group.add(polyline);\n          return group;\n        }\n\n        for (var i = 0; i < 3; i++) {\n          var group = createDataShadowGroup(i === 1);\n\n          this._displayables.sliderGroup.add(group);\n\n          this._displayables.dataShadowSegs.push(group);\n        }\n      };\n\n      SliderZoomView.prototype._prepareDataShadowInfo = function () {\n        var dataZoomModel = this.dataZoomModel;\n        var showDataShadow = dataZoomModel.get('showDataShadow');\n\n        if (showDataShadow === false) {\n          return;\n        }\n\n        var result;\n        var ecModel = this.ecModel;\n        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {\n          var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();\n          each(seriesModels, function (seriesModel) {\n            if (result) {\n              return;\n            }\n\n            if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {\n              return;\n            }\n\n            var thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;\n            var otherDim = getOtherDim(axisDim);\n            var otherAxisInverse;\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (otherDim != null && coordSys.getOtherAxis) {\n              otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;\n            }\n\n            otherDim = seriesModel.getData().mapDimension(otherDim);\n            result = {\n              thisAxis: thisAxis,\n              series: seriesModel,\n              thisDim: axisDim,\n              otherDim: otherDim,\n              otherAxisInverse: otherAxisInverse\n            };\n          }, this);\n        }, this);\n        return result;\n      };\n\n      SliderZoomView.prototype._renderHandle = function () {\n        var thisGroup = this.group;\n        var displayables = this._displayables;\n        var handles = displayables.handles = [null, null];\n        var handleLabels = displayables.handleLabels = [null, null];\n        var sliderGroup = this._displayables.sliderGroup;\n        var size = this._size;\n        var dataZoomModel = this.dataZoomModel;\n        var api = this.api;\n        var borderRadius = dataZoomModel.get('borderRadius') || 0;\n        var brushSelect = dataZoomModel.get('brushSelect');\n        var filler = displayables.filler = new Rect$2({\n          silent: brushSelect,\n          style: {\n            fill: dataZoomModel.get('fillerColor')\n          },\n          textConfig: {\n            position: 'inside'\n          }\n        });\n        sliderGroup.add(filler);\n        sliderGroup.add(new Rect$2({\n          silent: true,\n          subPixelOptimize: true,\n          shape: {\n            x: 0,\n            y: 0,\n            width: size[0],\n            height: size[1],\n            r: borderRadius\n          },\n          style: {\n            stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),\n            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,\n            fill: 'rgba(0,0,0,0)'\n          }\n        }));\n        each([0, 1], function (handleIndex) {\n          var iconStr = dataZoomModel.get('handleIcon');\n\n          if (!symbolBuildProxies[iconStr] && iconStr.indexOf('path://') < 0) {\n            iconStr = 'path://' + iconStr;\n\n            if (\"development\" !== 'production') {\n              deprecateLog('handleIcon now needs \\'path://\\' prefix when using a path string');\n            }\n          }\n\n          var path = createSymbol(iconStr, -1, 0, 2, 2, null, true);\n          path.attr({\n            cursor: getCursor(this._orient),\n            draggable: true,\n            drift: bind(this._onDragMove, this, handleIndex),\n            ondragend: bind(this._onDragEnd, this),\n            onmouseover: bind(this._showDataInfo, this, true),\n            onmouseout: bind(this._showDataInfo, this, false),\n            z2: 5\n          });\n          var bRect = path.getBoundingRect();\n          var handleSize = dataZoomModel.get('handleSize');\n          this._handleHeight = parsePercent$1(handleSize, this._size[1]);\n          this._handleWidth = bRect.width / bRect.height * this._handleHeight;\n          path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());\n          path.style.strokeNoScale = true;\n          path.rectHover = true;\n          path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle();\n          enableHoverEmphasis(path);\n          var handleColor = dataZoomModel.get('handleColor');\n\n          if (handleColor != null) {\n            path.style.fill = handleColor;\n          }\n\n          sliderGroup.add(handles[handleIndex] = path);\n          var textStyleModel = dataZoomModel.getModel('textStyle');\n          thisGroup.add(handleLabels[handleIndex] = new ZRText({\n            silent: true,\n            invisible: true,\n            style: {\n              x: 0,\n              y: 0,\n              text: '',\n              verticalAlign: 'middle',\n              align: 'center',\n              fill: textStyleModel.getTextColor(),\n              font: textStyleModel.getFont()\n            },\n            z2: 10\n          }));\n        }, this);\n        var actualMoveZone = filler;\n\n        if (brushSelect) {\n          var moveHandleHeight = parsePercent$1(dataZoomModel.get('moveHandleSize'), size[1]);\n          var moveHandle_1 = displayables.moveHandle = new Rect({\n            style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),\n            silent: true,\n            shape: {\n              r: [0, 0, 2, 2],\n              y: size[1] - 0.5,\n              height: moveHandleHeight\n            }\n          });\n          var iconSize = moveHandleHeight * 0.8;\n          var moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true);\n          moveHandleIcon.silent = true;\n          moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;\n          moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle();\n          var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));\n          actualMoveZone = displayables.moveZone = new Rect({\n            invisible: true,\n            shape: {\n              y: size[1] - moveZoneExpandSize,\n              height: moveHandleHeight + moveZoneExpandSize\n            }\n          });\n          actualMoveZone.on('mouseover', function () {\n            api.enterEmphasis(moveHandle_1);\n          }).on('mouseout', function () {\n            api.leaveEmphasis(moveHandle_1);\n          });\n          sliderGroup.add(moveHandle_1);\n          sliderGroup.add(moveHandleIcon);\n          sliderGroup.add(actualMoveZone);\n        }\n\n        actualMoveZone.attr({\n          draggable: true,\n          cursor: getCursor(this._orient),\n          drift: bind(this._onDragMove, this, 'all'),\n          ondragstart: bind(this._showDataInfo, this, true),\n          ondragend: bind(this._onDragEnd, this),\n          onmouseover: bind(this._showDataInfo, this, true),\n          onmouseout: bind(this._showDataInfo, this, false)\n        });\n      };\n\n      SliderZoomView.prototype._resetInterval = function () {\n        var range = this._range = this.dataZoomModel.getPercentRange();\n\n        var viewExtent = this._getViewExtent();\n\n        this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];\n      };\n\n      SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {\n        var dataZoomModel = this.dataZoomModel;\n        var handleEnds = this._handleEnds;\n\n        var viewExtend = this._getViewExtent();\n\n        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();\n        var percentExtent = [0, 100];\n        sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);\n        var lastRange = this._range;\n        var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);\n        return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];\n      };\n\n      SliderZoomView.prototype._updateView = function (nonRealtime) {\n        var displaybles = this._displayables;\n        var handleEnds = this._handleEnds;\n        var handleInterval = asc(handleEnds.slice());\n        var size = this._size;\n        each([0, 1], function (handleIndex) {\n          var handle = displaybles.handles[handleIndex];\n          var handleHeight = this._handleHeight;\n          handle.attr({\n            scaleX: handleHeight / 2,\n            scaleY: handleHeight / 2,\n            x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),\n            y: size[1] / 2 - handleHeight / 2\n          });\n        }, this);\n        displaybles.filler.setShape({\n          x: handleInterval[0],\n          y: 0,\n          width: handleInterval[1] - handleInterval[0],\n          height: size[1]\n        });\n        var viewExtent = {\n          x: handleInterval[0],\n          width: handleInterval[1] - handleInterval[0]\n        };\n\n        if (displaybles.moveHandle) {\n          displaybles.moveHandle.setShape(viewExtent);\n          displaybles.moveZone.setShape(viewExtent);\n          displaybles.moveZone.getBoundingRect();\n          displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2);\n        }\n\n        var dataShadowSegs = displaybles.dataShadowSegs;\n        var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];\n\n        for (var i = 0; i < dataShadowSegs.length; i++) {\n          var segGroup = dataShadowSegs[i];\n          var clipPath = segGroup.getClipPath();\n\n          if (!clipPath) {\n            clipPath = new Rect();\n            segGroup.setClipPath(clipPath);\n          }\n\n          clipPath.setShape({\n            x: segIntervals[i],\n            y: 0,\n            width: segIntervals[i + 1] - segIntervals[i],\n            height: size[1]\n          });\n        }\n\n        this._updateDataInfo(nonRealtime);\n      };\n\n      SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {\n        var dataZoomModel = this.dataZoomModel;\n        var displaybles = this._displayables;\n        var handleLabels = displaybles.handleLabels;\n        var orient = this._orient;\n        var labelTexts = ['', ''];\n\n        if (dataZoomModel.get('showDetail')) {\n          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();\n\n          if (axisProxy) {\n            var axis = axisProxy.getAxisModel().axis;\n            var range = this._range;\n            var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({\n              start: range[0],\n              end: range[1]\n            }).valueWindow : axisProxy.getDataValueWindow();\n            labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];\n          }\n        }\n\n        var orderedHandleEnds = asc(this._handleEnds.slice());\n        setLabel.call(this, 0);\n        setLabel.call(this, 1);\n\n        function setLabel(handleIndex) {\n          var barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);\n          var direction = transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);\n          var offset = this._handleWidth / 2 + LABEL_GAP;\n          var textPoint = applyTransform$1([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);\n          handleLabels[handleIndex].setStyle({\n            x: textPoint[0],\n            y: textPoint[1],\n            verticalAlign: orient === HORIZONTAL ? 'middle' : direction,\n            align: orient === HORIZONTAL ? direction : 'center',\n            text: labelTexts[handleIndex]\n          });\n        }\n      };\n\n      SliderZoomView.prototype._formatLabel = function (value, axis) {\n        var dataZoomModel = this.dataZoomModel;\n        var labelFormatter = dataZoomModel.get('labelFormatter');\n        var labelPrecision = dataZoomModel.get('labelPrecision');\n\n        if (labelPrecision == null || labelPrecision === 'auto') {\n          labelPrecision = axis.getPixelPrecision();\n        }\n\n        var valueStr = value == null || isNaN(value) ? '' : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({\n          value: Math.round(value)\n        }) : value.toFixed(Math.min(labelPrecision, 20));\n        return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;\n      };\n\n      SliderZoomView.prototype._showDataInfo = function (showOrHide) {\n        showOrHide = this._dragging || showOrHide;\n        var displayables = this._displayables;\n        var handleLabels = displayables.handleLabels;\n        handleLabels[0].attr('invisible', !showOrHide);\n        handleLabels[1].attr('invisible', !showOrHide);\n        displayables.moveHandle && this.api[showOrHide ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1);\n      };\n\n      SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {\n        this._dragging = true;\n        stop(event.event);\n\n        var barTransform = this._displayables.sliderGroup.getLocalTransform();\n\n        var vertex = applyTransform$1([dx, dy], barTransform, true);\n\n        var changed = this._updateInterval(handleIndex, vertex[0]);\n\n        var realtime = this.dataZoomModel.get('realtime');\n\n        this._updateView(!realtime);\n\n        changed && realtime && this._dispatchZoomAction(true);\n      };\n\n      SliderZoomView.prototype._onDragEnd = function () {\n        this._dragging = false;\n\n        this._showDataInfo(false);\n\n        var realtime = this.dataZoomModel.get('realtime');\n        !realtime && this._dispatchZoomAction(false);\n      };\n\n      SliderZoomView.prototype._onClickPanel = function (e) {\n        var size = this._size;\n\n        var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);\n\n        if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {\n          return;\n        }\n\n        var handleEnds = this._handleEnds;\n        var center = (handleEnds[0] + handleEnds[1]) / 2;\n\n        var changed = this._updateInterval('all', localPoint[0] - center);\n\n        this._updateView();\n\n        changed && this._dispatchZoomAction(false);\n      };\n\n      SliderZoomView.prototype._onBrushStart = function (e) {\n        var x = e.offsetX;\n        var y = e.offsetY;\n        this._brushStart = new Point(x, y);\n        this._brushing = true;\n        this._brushStartTime = +new Date();\n      };\n\n      SliderZoomView.prototype._onBrushEnd = function (e) {\n        if (!this._brushing) {\n          return;\n        }\n\n        var brushRect = this._displayables.brushRect;\n        this._brushing = false;\n\n        if (!brushRect) {\n          return;\n        }\n\n        brushRect.attr('ignore', true);\n        var brushShape = brushRect.shape;\n        var brushEndTime = +new Date();\n\n        if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {\n          return;\n        }\n\n        var viewExtend = this._getViewExtent();\n\n        var percentExtent = [0, 100];\n        this._range = asc([linearMap(brushShape.x, viewExtend, percentExtent, true), linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);\n        this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];\n\n        this._updateView();\n\n        this._dispatchZoomAction(false);\n      };\n\n      SliderZoomView.prototype._onBrush = function (e) {\n        if (this._brushing) {\n          stop(e.event);\n\n          this._updateBrushRect(e.offsetX, e.offsetY);\n        }\n      };\n\n      SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {\n        var displayables = this._displayables;\n        var dataZoomModel = this.dataZoomModel;\n        var brushRect = displayables.brushRect;\n\n        if (!brushRect) {\n          brushRect = displayables.brushRect = new Rect$2({\n            silent: true,\n            style: dataZoomModel.getModel('brushStyle').getItemStyle()\n          });\n          displayables.sliderGroup.add(brushRect);\n        }\n\n        brushRect.attr('ignore', false);\n        var brushStart = this._brushStart;\n        var sliderGroup = this._displayables.sliderGroup;\n        var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);\n        var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);\n        var size = this._size;\n        endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);\n        brushRect.setShape({\n          x: startPoint[0],\n          y: 0,\n          width: endPoint[0] - startPoint[0],\n          height: size[1]\n        });\n      };\n\n      SliderZoomView.prototype._dispatchZoomAction = function (realtime) {\n        var range = this._range;\n        this.api.dispatchAction({\n          type: 'dataZoom',\n          from: this.uid,\n          dataZoomId: this.dataZoomModel.id,\n          animation: realtime ? REALTIME_ANIMATION_CONFIG : null,\n          start: range[0],\n          end: range[1]\n        });\n      };\n\n      SliderZoomView.prototype._findCoordRect = function () {\n        var rect;\n        var coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;\n\n        if (!rect && coordSysInfoList.length) {\n          var coordSys = coordSysInfoList[0].model.coordinateSystem;\n          rect = coordSys.getRect && coordSys.getRect();\n        }\n\n        if (!rect) {\n          var width = this.api.getWidth();\n          var height = this.api.getHeight();\n          rect = {\n            x: width * 0.2,\n            y: height * 0.2,\n            width: width * 0.6,\n            height: height * 0.6\n          };\n        }\n\n        return rect;\n      };\n\n      SliderZoomView.type = 'dataZoom.slider';\n      return SliderZoomView;\n    }(DataZoomView);\n\n    function getOtherDim(thisDim) {\n      var map = {\n        x: 'y',\n        y: 'x',\n        radius: 'angle',\n        angle: 'radius'\n      };\n      return map[thisDim];\n    }\n\n    function getCursor(orient) {\n      return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n    }\n\n    function install$L(registers) {\n      registers.registerComponentModel(SliderZoomModel);\n      registers.registerComponentView(SliderZoomView);\n      installCommon(registers);\n    }\n\n    function install$M(registers) {\n      use(install$K);\n      use(install$L);\n    }\n\n    var visualDefault = {\n      get: function (visualType, key, isCategory) {\n        var value = clone((defaultOption$1[visualType] || {})[key]);\n        return isCategory ? isArray(value) ? value[value.length - 1] : value : value;\n      }\n    };\n    var defaultOption$1 = {\n      color: {\n        active: ['#006edd', '#e0ffff'],\n        inactive: ['rgba(0,0,0,0)']\n      },\n      colorHue: {\n        active: [0, 360],\n        inactive: [0, 0]\n      },\n      colorSaturation: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n      },\n      colorLightness: {\n        active: [0.9, 0.5],\n        inactive: [0, 0]\n      },\n      colorAlpha: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n      },\n      opacity: {\n        active: [0.3, 1],\n        inactive: [0, 0]\n      },\n      symbol: {\n        active: ['circle', 'roundRect', 'diamond'],\n        inactive: ['none']\n      },\n      symbolSize: {\n        active: [10, 50],\n        inactive: [0, 0]\n      }\n    };\n\n    var mapVisual$1 = VisualMapping.mapVisual;\n    var eachVisual = VisualMapping.eachVisual;\n    var isArray$1 = isArray;\n    var each$f = each;\n    var asc$2 = asc;\n    var linearMap$1 = linearMap;\n\n    var VisualMapModel = function (_super) {\n      __extends(VisualMapModel, _super);\n\n      function VisualMapModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = VisualMapModel.type;\n        _this.stateList = ['inRange', 'outOfRange'];\n        _this.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color'];\n        _this.layoutMode = {\n          type: 'box',\n          ignoreSize: true\n        };\n        _this.dataBound = [-Infinity, Infinity];\n        _this.targetVisuals = {};\n        _this.controllerVisuals = {};\n        return _this;\n      }\n\n      VisualMapModel.prototype.init = function (option, parentModel, ecModel) {\n        this.mergeDefaultAndTheme(option, ecModel);\n      };\n\n      VisualMapModel.prototype.optionUpdated = function (newOption, isInit) {\n        var thisOption = this.option;\n\n        if (!env.canvasSupported) {\n          thisOption.realtime = false;\n        }\n\n        !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);\n        this.textStyleModel = this.getModel('textStyle');\n        this.resetItemSize();\n        this.completeVisualOption();\n      };\n\n      VisualMapModel.prototype.resetVisual = function (supplementVisualOption) {\n        var stateList = this.stateList;\n        supplementVisualOption = bind(supplementVisualOption, this);\n        this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);\n        this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);\n      };\n\n      VisualMapModel.prototype.getTargetSeriesIndices = function () {\n        var optionSeriesIndex = this.option.seriesIndex;\n        var seriesIndices = [];\n\n        if (optionSeriesIndex == null || optionSeriesIndex === 'all') {\n          this.ecModel.eachSeries(function (seriesModel, index) {\n            seriesIndices.push(index);\n          });\n        } else {\n          seriesIndices = normalizeToArray(optionSeriesIndex);\n        }\n\n        return seriesIndices;\n      };\n\n      VisualMapModel.prototype.eachTargetSeries = function (callback, context) {\n        each(this.getTargetSeriesIndices(), function (seriesIndex) {\n          var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);\n\n          if (seriesModel) {\n            callback.call(context, seriesModel);\n          }\n        }, this);\n      };\n\n      VisualMapModel.prototype.isTargetSeries = function (seriesModel) {\n        var is = false;\n        this.eachTargetSeries(function (model) {\n          model === seriesModel && (is = true);\n        });\n        return is;\n      };\n\n      VisualMapModel.prototype.formatValueText = function (value, isCategory, edgeSymbols) {\n        var option = this.option;\n        var precision = option.precision;\n        var dataBound = this.dataBound;\n        var formatter = option.formatter;\n        var isMinMax;\n        edgeSymbols = edgeSymbols || ['<', '>'];\n\n        if (isArray(value)) {\n          value = value.slice();\n          isMinMax = true;\n        }\n\n        var textValue = isCategory ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);\n\n        if (isString(formatter)) {\n          return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);\n        } else if (isFunction(formatter)) {\n          return isMinMax ? formatter(value[0], value[1]) : formatter(value);\n        }\n\n        if (isMinMax) {\n          if (value[0] === dataBound[0]) {\n            return edgeSymbols[0] + ' ' + textValue[1];\n          } else if (value[1] === dataBound[1]) {\n            return edgeSymbols[1] + ' ' + textValue[0];\n          } else {\n            return textValue[0] + ' - ' + textValue[1];\n          }\n        } else {\n          return textValue;\n        }\n\n        function toFixed(val) {\n          return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20));\n        }\n      };\n\n      VisualMapModel.prototype.resetExtent = function () {\n        var thisOption = this.option;\n        var extent = asc$2([thisOption.min, thisOption.max]);\n        this._dataExtent = extent;\n      };\n\n      VisualMapModel.prototype.getDataDimension = function (list) {\n        var optDim = this.option.dimension;\n        var listDimensions = list.dimensions;\n\n        if (optDim == null && !listDimensions.length) {\n          return;\n        }\n\n        if (optDim != null) {\n          return list.getDimension(optDim);\n        }\n\n        var dimNames = list.dimensions;\n\n        for (var i = dimNames.length - 1; i >= 0; i--) {\n          var dimName = dimNames[i];\n          var dimInfo = list.getDimensionInfo(dimName);\n\n          if (!dimInfo.isCalculationCoord) {\n            return dimName;\n          }\n        }\n      };\n\n      VisualMapModel.prototype.getExtent = function () {\n        return this._dataExtent.slice();\n      };\n\n      VisualMapModel.prototype.completeVisualOption = function () {\n        var ecModel = this.ecModel;\n        var thisOption = this.option;\n        var base = {\n          inRange: thisOption.inRange,\n          outOfRange: thisOption.outOfRange\n        };\n        var target = thisOption.target || (thisOption.target = {});\n        var controller = thisOption.controller || (thisOption.controller = {});\n        merge(target, base);\n        merge(controller, base);\n        var isCategory = this.isCategory();\n        completeSingle.call(this, target);\n        completeSingle.call(this, controller);\n        completeInactive.call(this, target, 'inRange', 'outOfRange');\n        completeController.call(this, controller);\n\n        function completeSingle(base) {\n          if (isArray$1(thisOption.color) && !base.inRange) {\n            base.inRange = {\n              color: thisOption.color.slice().reverse()\n            };\n          }\n\n          base.inRange = base.inRange || {\n            color: ecModel.get('gradientColor')\n          };\n        }\n\n        function completeInactive(base, stateExist, stateAbsent) {\n          var optExist = base[stateExist];\n          var optAbsent = base[stateAbsent];\n\n          if (optExist && !optAbsent) {\n            optAbsent = base[stateAbsent] = {};\n            each$f(optExist, function (visualData, visualType) {\n              if (!VisualMapping.isValidType(visualType)) {\n                return;\n              }\n\n              var defa = visualDefault.get(visualType, 'inactive', isCategory);\n\n              if (defa != null) {\n                optAbsent[visualType] = defa;\n\n                if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {\n                  optAbsent.opacity = [0, 0];\n                }\n              }\n            });\n          }\n        }\n\n        function completeController(controller) {\n          var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;\n          var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;\n          var inactiveColor = this.get('inactiveColor');\n          each$f(this.stateList, function (state) {\n            var itemSize = this.itemSize;\n            var visuals = controller[state];\n\n            if (!visuals) {\n              visuals = controller[state] = {\n                color: isCategory ? inactiveColor : [inactiveColor]\n              };\n            }\n\n            if (visuals.symbol == null) {\n              visuals.symbol = symbolExists && clone(symbolExists) || (isCategory ? 'roundRect' : ['roundRect']);\n            }\n\n            if (visuals.symbolSize == null) {\n              visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);\n            }\n\n            visuals.symbol = mapVisual$1(visuals.symbol, function (symbol) {\n              return symbol === 'none' || symbol === 'square' ? 'roundRect' : symbol;\n            });\n            var symbolSize = visuals.symbolSize;\n\n            if (symbolSize != null) {\n              var max_1 = -Infinity;\n              eachVisual(symbolSize, function (value) {\n                value > max_1 && (max_1 = value);\n              });\n              visuals.symbolSize = mapVisual$1(symbolSize, function (value) {\n                return linearMap$1(value, [0, max_1], [0, itemSize[0]], true);\n              });\n            }\n          }, this);\n        }\n      };\n\n      VisualMapModel.prototype.resetItemSize = function () {\n        this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];\n      };\n\n      VisualMapModel.prototype.isCategory = function () {\n        return !!this.option.categories;\n      };\n\n      VisualMapModel.prototype.setSelected = function (selected) {};\n\n      VisualMapModel.prototype.getSelected = function () {\n        return null;\n      };\n\n      VisualMapModel.prototype.getValueState = function (value) {\n        return null;\n      };\n\n      VisualMapModel.prototype.getVisualMeta = function (getColorVisual) {\n        return null;\n      };\n\n      VisualMapModel.type = 'visualMap';\n      VisualMapModel.dependencies = ['series'];\n      VisualMapModel.defaultOption = {\n        show: true,\n        zlevel: 0,\n        z: 4,\n        seriesIndex: 'all',\n        min: 0,\n        max: 200,\n        left: 0,\n        right: null,\n        top: null,\n        bottom: 0,\n        itemWidth: null,\n        itemHeight: null,\n        inverse: false,\n        orient: 'vertical',\n        backgroundColor: 'rgba(0,0,0,0)',\n        borderColor: '#ccc',\n        contentColor: '#5793f3',\n        inactiveColor: '#aaa',\n        borderWidth: 0,\n        padding: 5,\n        textGap: 10,\n        precision: 0,\n        textStyle: {\n          color: '#333'\n        }\n      };\n      return VisualMapModel;\n    }(ComponentModel);\n\n    var DEFAULT_BAR_BOUND = [20, 140];\n\n    var ContinuousModel = function (_super) {\n      __extends(ContinuousModel, _super);\n\n      function ContinuousModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ContinuousModel.type;\n        return _this;\n      }\n\n      ContinuousModel.prototype.optionUpdated = function (newOption, isInit) {\n        _super.prototype.optionUpdated.apply(this, arguments);\n\n        this.resetExtent();\n        this.resetVisual(function (mappingOption) {\n          mappingOption.mappingMethod = 'linear';\n          mappingOption.dataExtent = this.getExtent();\n        });\n\n        this._resetRange();\n      };\n\n      ContinuousModel.prototype.resetItemSize = function () {\n        _super.prototype.resetItemSize.apply(this, arguments);\n\n        var itemSize = this.itemSize;\n        (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);\n        (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);\n      };\n\n      ContinuousModel.prototype._resetRange = function () {\n        var dataExtent = this.getExtent();\n        var range = this.option.range;\n\n        if (!range || range.auto) {\n          dataExtent.auto = 1;\n          this.option.range = dataExtent;\n        } else if (isArray(range)) {\n          if (range[0] > range[1]) {\n            range.reverse();\n          }\n\n          range[0] = Math.max(range[0], dataExtent[0]);\n          range[1] = Math.min(range[1], dataExtent[1]);\n        }\n      };\n\n      ContinuousModel.prototype.completeVisualOption = function () {\n        _super.prototype.completeVisualOption.apply(this, arguments);\n\n        each(this.stateList, function (state) {\n          var symbolSize = this.option.controller[state].symbolSize;\n\n          if (symbolSize && symbolSize[0] !== symbolSize[1]) {\n            symbolSize[0] = symbolSize[1] / 3;\n          }\n        }, this);\n      };\n\n      ContinuousModel.prototype.setSelected = function (selected) {\n        this.option.range = selected.slice();\n\n        this._resetRange();\n      };\n\n      ContinuousModel.prototype.getSelected = function () {\n        var dataExtent = this.getExtent();\n        var dataInterval = asc((this.get('range') || []).slice());\n        dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);\n        dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);\n        dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);\n        dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);\n        return dataInterval;\n      };\n\n      ContinuousModel.prototype.getValueState = function (value) {\n        var range = this.option.range;\n        var dataExtent = this.getExtent();\n        return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';\n      };\n\n      ContinuousModel.prototype.findTargetDataIndices = function (range) {\n        var result = [];\n        this.eachTargetSeries(function (seriesModel) {\n          var dataIndices = [];\n          var data = seriesModel.getData();\n          data.each(this.getDataDimension(data), function (value, dataIndex) {\n            range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);\n          }, this);\n          result.push({\n            seriesId: seriesModel.id,\n            dataIndex: dataIndices\n          });\n        }, this);\n        return result;\n      };\n\n      ContinuousModel.prototype.getVisualMeta = function (getColorVisual) {\n        var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());\n        var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());\n        var stops = [];\n\n        function setStop(value, valueState) {\n          stops.push({\n            value: value,\n            color: getColorVisual(value, valueState)\n          });\n        }\n\n        var iIdx = 0;\n        var oIdx = 0;\n        var iLen = iVals.length;\n        var oLen = oVals.length;\n\n        for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {\n          if (oVals[oIdx] < iVals[iIdx]) {\n            setStop(oVals[oIdx], 'outOfRange');\n          }\n        }\n\n        for (var first = 1; iIdx < iLen; iIdx++, first = 0) {\n          first && stops.length && setStop(iVals[iIdx], 'outOfRange');\n          setStop(iVals[iIdx], 'inRange');\n        }\n\n        for (var first = 1; oIdx < oLen; oIdx++) {\n          if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {\n            if (first) {\n              stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');\n              first = 0;\n            }\n\n            setStop(oVals[oIdx], 'outOfRange');\n          }\n        }\n\n        var stopsLen = stops.length;\n        return {\n          stops: stops,\n          outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']\n        };\n      };\n\n      ContinuousModel.type = 'visualMap.continuous';\n      ContinuousModel.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {\n        align: 'auto',\n        calculable: false,\n        hoverLink: true,\n        realtime: true,\n        handleIcon: 'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',\n        handleSize: '120%',\n        handleStyle: {\n          borderColor: '#fff',\n          borderWidth: 1\n        },\n        indicatorIcon: 'circle',\n        indicatorSize: '50%',\n        indicatorStyle: {\n          borderColor: '#fff',\n          borderWidth: 2,\n          shadowBlur: 2,\n          shadowOffsetX: 1,\n          shadowOffsetY: 1,\n          shadowColor: 'rgba(0,0,0,0.2)'\n        }\n      });\n      return ContinuousModel;\n    }(VisualMapModel);\n\n    function getColorStopValues(visualMapModel, valueState, dataExtent) {\n      if (dataExtent[0] === dataExtent[1]) {\n        return dataExtent.slice();\n      }\n\n      var count = 200;\n      var step = (dataExtent[1] - dataExtent[0]) / count;\n      var value = dataExtent[0];\n      var stopValues = [];\n\n      for (var i = 0; i <= count && value < dataExtent[1]; i++) {\n        stopValues.push(value);\n        value += step;\n      }\n\n      stopValues.push(dataExtent[1]);\n      return stopValues;\n    }\n\n    var VisualMapView = function (_super) {\n      __extends(VisualMapView, _super);\n\n      function VisualMapView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = VisualMapView.type;\n        _this.autoPositionValues = {\n          left: 1,\n          right: 1,\n          top: 1,\n          bottom: 1\n        };\n        return _this;\n      }\n\n      VisualMapView.prototype.init = function (ecModel, api) {\n        this.ecModel = ecModel;\n        this.api = api;\n      };\n\n      VisualMapView.prototype.render = function (visualMapModel, ecModel, api, payload) {\n        this.visualMapModel = visualMapModel;\n\n        if (visualMapModel.get('show') === false) {\n          this.group.removeAll();\n          return;\n        }\n\n        this.doRender(visualMapModel, ecModel, api, payload);\n      };\n\n      VisualMapView.prototype.renderBackground = function (group) {\n        var visualMapModel = this.visualMapModel;\n        var padding = normalizeCssArray$1(visualMapModel.get('padding') || 0);\n        var rect = group.getBoundingRect();\n        group.add(new Rect({\n          z2: -1,\n          silent: true,\n          shape: {\n            x: rect.x - padding[3],\n            y: rect.y - padding[0],\n            width: rect.width + padding[3] + padding[1],\n            height: rect.height + padding[0] + padding[2]\n          },\n          style: {\n            fill: visualMapModel.get('backgroundColor'),\n            stroke: visualMapModel.get('borderColor'),\n            lineWidth: visualMapModel.get('borderWidth')\n          }\n        }));\n      };\n\n      VisualMapView.prototype.getControllerVisual = function (targetValue, visualCluster, opts) {\n        opts = opts || {};\n        var forceState = opts.forceState;\n        var visualMapModel = this.visualMapModel;\n        var visualObj = {};\n\n        if (visualCluster === 'symbol') {\n          visualObj.symbol = visualMapModel.get('itemSymbol');\n        }\n\n        if (visualCluster === 'color') {\n          var defaultColor = visualMapModel.get('contentColor');\n          visualObj.color = defaultColor;\n        }\n\n        function getter(key) {\n          return visualObj[key];\n        }\n\n        function setter(key, value) {\n          visualObj[key] = value;\n        }\n\n        var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];\n        var visualTypes = VisualMapping.prepareVisualTypes(mappings);\n        each(visualTypes, function (type) {\n          var visualMapping = mappings[type];\n\n          if (opts.convertOpacityToAlpha && type === 'opacity') {\n            type = 'colorAlpha';\n            visualMapping = mappings.__alphaForOpacity;\n          }\n\n          if (VisualMapping.dependsOn(type, visualCluster)) {\n            visualMapping && visualMapping.applyVisual(targetValue, getter, setter);\n          }\n        });\n        return visualObj[visualCluster];\n      };\n\n      VisualMapView.prototype.positionGroup = function (group) {\n        var model = this.visualMapModel;\n        var api = this.api;\n        positionElement(group, model.getBoxLayoutParams(), {\n          width: api.getWidth(),\n          height: api.getHeight()\n        });\n      };\n\n      VisualMapView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {};\n\n      VisualMapView.type = 'visualMap';\n      return VisualMapView;\n    }(ComponentView);\n\n    var paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];\n    function getItemAlign(visualMapModel, api, itemSize) {\n      var modelOption = visualMapModel.option;\n      var itemAlign = modelOption.align;\n\n      if (itemAlign != null && itemAlign !== 'auto') {\n        return itemAlign;\n      }\n\n      var ecSize = {\n        width: api.getWidth(),\n        height: api.getHeight()\n      };\n      var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;\n      var reals = paramsSet[realIndex];\n      var fakeValue = [0, null, 10];\n      var layoutInput = {};\n\n      for (var i = 0; i < 3; i++) {\n        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];\n        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];\n      }\n\n      var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];\n      var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);\n      return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];\n    }\n    function makeHighDownBatch(batch, visualMapModel) {\n      each(batch || [], function (batchItem) {\n        if (batchItem.dataIndex != null) {\n          batchItem.dataIndexInside = batchItem.dataIndex;\n          batchItem.dataIndex = null;\n        }\n\n        batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '');\n      });\n      return batch;\n    }\n\n    var linearMap$2 = linearMap;\n    var each$g = each;\n    var mathMin$a = Math.min;\n    var mathMax$a = Math.max;\n    var HOVER_LINK_SIZE = 12;\n    var HOVER_LINK_OUT = 6;\n\n    var ContinuousView = function (_super) {\n      __extends(ContinuousView, _super);\n\n      function ContinuousView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = ContinuousView.type;\n        _this._shapes = {};\n        _this._dataInterval = [];\n        _this._handleEnds = [];\n        _this._hoverLinkDataIndices = [];\n        return _this;\n      }\n\n      ContinuousView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {\n        this._api = api;\n\n        if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {\n          this._buildView();\n        }\n      };\n\n      ContinuousView.prototype._buildView = function () {\n        this.group.removeAll();\n        var visualMapModel = this.visualMapModel;\n        var thisGroup = this.group;\n        this._orient = visualMapModel.get('orient');\n        this._useHandle = visualMapModel.get('calculable');\n\n        this._resetInterval();\n\n        this._renderBar(thisGroup);\n\n        var dataRangeText = visualMapModel.get('text');\n\n        this._renderEndsText(thisGroup, dataRangeText, 0);\n\n        this._renderEndsText(thisGroup, dataRangeText, 1);\n\n        this._updateView(true);\n\n        this.renderBackground(thisGroup);\n\n        this._updateView();\n\n        this._enableHoverLinkToSeries();\n\n        this._enableHoverLinkFromSeries();\n\n        this.positionGroup(thisGroup);\n      };\n\n      ContinuousView.prototype._renderEndsText = function (group, dataRangeText, endsIndex) {\n        if (!dataRangeText) {\n          return;\n        }\n\n        var text = dataRangeText[1 - endsIndex];\n        text = text != null ? text + '' : '';\n        var visualMapModel = this.visualMapModel;\n        var textGap = visualMapModel.get('textGap');\n        var itemSize = visualMapModel.itemSize;\n        var barGroup = this._shapes.mainGroup;\n\n        var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);\n\n        var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);\n\n        var orient = this._orient;\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        this.group.add(new ZRText({\n          style: {\n            x: position[0],\n            y: position[1],\n            verticalAlign: orient === 'horizontal' ? 'middle' : align,\n            align: orient === 'horizontal' ? align : 'center',\n            text: text,\n            font: textStyleModel.getFont(),\n            fill: textStyleModel.getTextColor()\n          }\n        }));\n      };\n\n      ContinuousView.prototype._renderBar = function (targetGroup) {\n        var visualMapModel = this.visualMapModel;\n        var shapes = this._shapes;\n        var itemSize = visualMapModel.itemSize;\n        var orient = this._orient;\n        var useHandle = this._useHandle;\n        var itemAlign = getItemAlign(visualMapModel, this.api, itemSize);\n\n        var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);\n\n        var gradientBarGroup = new Group();\n        mainGroup.add(gradientBarGroup);\n        gradientBarGroup.add(shapes.outOfRange = createPolygon());\n        gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor$1(this._orient) : null, bind(this._dragHandle, this, 'all', false), bind(this._dragHandle, this, 'all', true)));\n        gradientBarGroup.setClipPath(new Rect({\n          shape: {\n            x: 0,\n            y: 0,\n            width: itemSize[0],\n            height: itemSize[1],\n            r: 3\n          }\n        }));\n        var textRect = visualMapModel.textStyleModel.getTextRect('');\n        var textSize = mathMax$a(textRect.width, textRect.height);\n\n        if (useHandle) {\n          shapes.handleThumbs = [];\n          shapes.handleLabels = [];\n          shapes.handleLabelPoints = [];\n\n          this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);\n\n          this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);\n        }\n\n        this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);\n\n        targetGroup.add(mainGroup);\n      };\n\n      ContinuousView.prototype._createHandle = function (visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {\n        var onDrift = bind(this._dragHandle, this, handleIndex, false);\n        var onDragEnd = bind(this._dragHandle, this, handleIndex, true);\n        var handleSize = parsePercent(visualMapModel.get('handleSize'), itemSize[0]);\n        var handleThumb = createSymbol(visualMapModel.get('handleIcon'), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);\n        var cursor = getCursor$1(this._orient);\n        handleThumb.attr({\n          cursor: cursor,\n          draggable: true,\n          drift: onDrift,\n          ondragend: onDragEnd,\n          onmousemove: function (e) {\n            stop(e.event);\n          }\n        });\n        handleThumb.x = itemSize[0] / 2;\n        handleThumb.useStyle(visualMapModel.getModel('handleStyle').getItemStyle());\n        handleThumb.setStyle({\n          strokeNoScale: true,\n          strokeFirst: true\n        });\n        handleThumb.style.lineWidth *= 2;\n        handleThumb.ensureState('emphasis').style = visualMapModel.getModel(['emphasis', 'handleStyle']).getItemStyle();\n        setAsHighDownDispatcher(handleThumb, true);\n        mainGroup.add(handleThumb);\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        var handleLabel = new ZRText({\n          cursor: cursor,\n          draggable: true,\n          drift: onDrift,\n          onmousemove: function (e) {\n            stop(e.event);\n          },\n          ondragend: onDragEnd,\n          style: {\n            x: 0,\n            y: 0,\n            text: '',\n            font: textStyleModel.getFont(),\n            fill: textStyleModel.getTextColor()\n          }\n        });\n        handleLabel.ensureState('blur').style = {\n          opacity: 0.1\n        };\n        handleLabel.stateTransition = {\n          duration: 200\n        };\n        this.group.add(handleLabel);\n        var handleLabelPoint = [handleSize, 0];\n        var shapes = this._shapes;\n        shapes.handleThumbs[handleIndex] = handleThumb;\n        shapes.handleLabelPoints[handleIndex] = handleLabelPoint;\n        shapes.handleLabels[handleIndex] = handleLabel;\n      };\n\n      ContinuousView.prototype._createIndicator = function (visualMapModel, mainGroup, itemSize, textSize, orient) {\n        var scale = parsePercent(visualMapModel.get('indicatorSize'), itemSize[0]);\n        var indicator = createSymbol(visualMapModel.get('indicatorIcon'), -scale / 2, -scale / 2, scale, scale, null, true);\n        indicator.attr({\n          cursor: 'move',\n          invisible: true,\n          silent: true,\n          x: itemSize[0] / 2\n        });\n        var indicatorStyle = visualMapModel.getModel('indicatorStyle').getItemStyle();\n\n        if (indicator instanceof ZRImage) {\n          var pathStyle = indicator.style;\n          indicator.useStyle(extend({\n            image: pathStyle.image,\n            x: pathStyle.x,\n            y: pathStyle.y,\n            width: pathStyle.width,\n            height: pathStyle.height\n          }, indicatorStyle));\n        } else {\n          indicator.useStyle(indicatorStyle);\n        }\n\n        mainGroup.add(indicator);\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        var indicatorLabel = new ZRText({\n          silent: true,\n          invisible: true,\n          style: {\n            x: 0,\n            y: 0,\n            text: '',\n            font: textStyleModel.getFont(),\n            fill: textStyleModel.getTextColor()\n          }\n        });\n        this.group.add(indicatorLabel);\n        var indicatorLabelPoint = [(orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];\n        var shapes = this._shapes;\n        shapes.indicator = indicator;\n        shapes.indicatorLabel = indicatorLabel;\n        shapes.indicatorLabelPoint = indicatorLabelPoint;\n        this._firstShowIndicator = true;\n      };\n\n      ContinuousView.prototype._dragHandle = function (handleIndex, isEnd, dx, dy) {\n        if (!this._useHandle) {\n          return;\n        }\n\n        this._dragging = !isEnd;\n\n        if (!isEnd) {\n          var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);\n\n          this._updateInterval(handleIndex, vertex[1]);\n\n          this._hideIndicator();\n\n          this._updateView();\n        }\n\n        if (isEnd === !this.visualMapModel.get('realtime')) {\n          this.api.dispatchAction({\n            type: 'selectDataRange',\n            from: this.uid,\n            visualMapId: this.visualMapModel.id,\n            selected: this._dataInterval.slice()\n          });\n        }\n\n        if (isEnd) {\n          !this._hovering && this._clearHoverLinkToSeries();\n        } else if (useHoverLinkOnHandle(this.visualMapModel)) {\n          this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);\n        }\n      };\n\n      ContinuousView.prototype._resetInterval = function () {\n        var visualMapModel = this.visualMapModel;\n        var dataInterval = this._dataInterval = visualMapModel.getSelected();\n        var dataExtent = visualMapModel.getExtent();\n        var sizeExtent = [0, visualMapModel.itemSize[1]];\n        this._handleEnds = [linearMap$2(dataInterval[0], dataExtent, sizeExtent, true), linearMap$2(dataInterval[1], dataExtent, sizeExtent, true)];\n      };\n\n      ContinuousView.prototype._updateInterval = function (handleIndex, delta) {\n        delta = delta || 0;\n        var visualMapModel = this.visualMapModel;\n        var handleEnds = this._handleEnds;\n        var sizeExtent = [0, visualMapModel.itemSize[1]];\n        sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);\n        var dataExtent = visualMapModel.getExtent();\n        this._dataInterval = [linearMap$2(handleEnds[0], sizeExtent, dataExtent, true), linearMap$2(handleEnds[1], sizeExtent, dataExtent, true)];\n      };\n\n      ContinuousView.prototype._updateView = function (forSketch) {\n        var visualMapModel = this.visualMapModel;\n        var dataExtent = visualMapModel.getExtent();\n        var shapes = this._shapes;\n        var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];\n        var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;\n\n        var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');\n\n        var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');\n\n        shapes.inRange.setStyle({\n          fill: visualInRange.barColor\n        }).setShape('points', visualInRange.barPoints);\n        shapes.outOfRange.setStyle({\n          fill: visualOutOfRange.barColor\n        }).setShape('points', visualOutOfRange.barPoints);\n\n        this._updateHandle(inRangeHandleEnds, visualInRange);\n      };\n\n      ContinuousView.prototype._createBarVisual = function (dataInterval, dataExtent, handleEnds, forceState) {\n        var opts = {\n          forceState: forceState,\n          convertOpacityToAlpha: true\n        };\n\n        var colorStops = this._makeColorGradient(dataInterval, opts);\n\n        var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];\n\n        var barPoints = this._createBarPoints(handleEnds, symbolSizes);\n\n        return {\n          barColor: new LinearGradient(0, 0, 0, 1, colorStops),\n          barPoints: barPoints,\n          handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]\n        };\n      };\n\n      ContinuousView.prototype._makeColorGradient = function (dataInterval, opts) {\n        var sampleNumber = 100;\n        var colorStops = [];\n        var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;\n        colorStops.push({\n          color: this.getControllerVisual(dataInterval[0], 'color', opts),\n          offset: 0\n        });\n\n        for (var i = 1; i < sampleNumber; i++) {\n          var currValue = dataInterval[0] + step * i;\n\n          if (currValue > dataInterval[1]) {\n            break;\n          }\n\n          colorStops.push({\n            color: this.getControllerVisual(currValue, 'color', opts),\n            offset: i / sampleNumber\n          });\n        }\n\n        colorStops.push({\n          color: this.getControllerVisual(dataInterval[1], 'color', opts),\n          offset: 1\n        });\n        return colorStops;\n      };\n\n      ContinuousView.prototype._createBarPoints = function (handleEnds, symbolSizes) {\n        var itemSize = this.visualMapModel.itemSize;\n        return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];\n      };\n\n      ContinuousView.prototype._createBarGroup = function (itemAlign) {\n        var orient = this._orient;\n        var inverse = this.visualMapModel.get('inverse');\n        return new Group(orient === 'horizontal' && !inverse ? {\n          scaleX: itemAlign === 'bottom' ? 1 : -1,\n          rotation: Math.PI / 2\n        } : orient === 'horizontal' && inverse ? {\n          scaleX: itemAlign === 'bottom' ? -1 : 1,\n          rotation: -Math.PI / 2\n        } : orient === 'vertical' && !inverse ? {\n          scaleX: itemAlign === 'left' ? 1 : -1,\n          scaleY: -1\n        } : {\n          scaleX: itemAlign === 'left' ? 1 : -1\n        });\n      };\n\n      ContinuousView.prototype._updateHandle = function (handleEnds, visualInRange) {\n        if (!this._useHandle) {\n          return;\n        }\n\n        var shapes = this._shapes;\n        var visualMapModel = this.visualMapModel;\n        var handleThumbs = shapes.handleThumbs;\n        var handleLabels = shapes.handleLabels;\n        var itemSize = visualMapModel.itemSize;\n        var dataExtent = visualMapModel.getExtent();\n        each$g([0, 1], function (handleIndex) {\n          var handleThumb = handleThumbs[handleIndex];\n          handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);\n          handleThumb.y = handleEnds[handleIndex];\n          var val = linearMap$2(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);\n          var symbolSize = this.getControllerVisual(val, 'symbolSize');\n          handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];\n          handleThumb.x = itemSize[0] - symbolSize / 2;\n          var textPoint = applyTransform$1(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group));\n          handleLabels[handleIndex].setStyle({\n            x: textPoint[0],\n            y: textPoint[1],\n            text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),\n            verticalAlign: 'middle',\n            align: this._orient === 'vertical' ? this._applyTransform('left', shapes.mainGroup) : 'center'\n          });\n        }, this);\n      };\n\n      ContinuousView.prototype._showIndicator = function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {\n        var visualMapModel = this.visualMapModel;\n        var dataExtent = visualMapModel.getExtent();\n        var itemSize = visualMapModel.itemSize;\n        var sizeExtent = [0, itemSize[1]];\n        var shapes = this._shapes;\n        var indicator = shapes.indicator;\n\n        if (!indicator) {\n          return;\n        }\n\n        indicator.attr('invisible', false);\n        var opts = {\n          convertOpacityToAlpha: true\n        };\n        var color = this.getControllerVisual(cursorValue, 'color', opts);\n        var symbolSize = this.getControllerVisual(cursorValue, 'symbolSize');\n        var y = linearMap$2(cursorValue, dataExtent, sizeExtent, true);\n        var x = itemSize[0] - symbolSize / 2;\n        var oldIndicatorPos = {\n          x: indicator.x,\n          y: indicator.y\n        };\n        indicator.y = y;\n        indicator.x = x;\n        var textPoint = applyTransform$1(shapes.indicatorLabelPoint, getTransform(indicator, this.group));\n        var indicatorLabel = shapes.indicatorLabel;\n        indicatorLabel.attr('invisible', false);\n\n        var align = this._applyTransform('left', shapes.mainGroup);\n\n        var orient = this._orient;\n        var isHorizontal = orient === 'horizontal';\n        indicatorLabel.setStyle({\n          text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),\n          verticalAlign: isHorizontal ? align : 'middle',\n          align: isHorizontal ? 'center' : align\n        });\n        var indicatorNewProps = {\n          x: x,\n          y: y,\n          style: {\n            fill: color\n          }\n        };\n        var labelNewProps = {\n          style: {\n            x: textPoint[0],\n            y: textPoint[1]\n          }\n        };\n\n        if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {\n          var animationCfg = {\n            duration: 100,\n            easing: 'cubicInOut',\n            additive: true\n          };\n          indicator.x = oldIndicatorPos.x;\n          indicator.y = oldIndicatorPos.y;\n          indicator.animateTo(indicatorNewProps, animationCfg);\n          indicatorLabel.animateTo(labelNewProps, animationCfg);\n        } else {\n          indicator.attr(indicatorNewProps);\n          indicatorLabel.attr(labelNewProps);\n        }\n\n        this._firstShowIndicator = false;\n        var handleLabels = this._shapes.handleLabels;\n\n        if (handleLabels) {\n          for (var i = 0; i < handleLabels.length; i++) {\n            this._api.enterBlur(handleLabels[i]);\n          }\n        }\n      };\n\n      ContinuousView.prototype._enableHoverLinkToSeries = function () {\n        var self = this;\n\n        this._shapes.mainGroup.on('mousemove', function (e) {\n          self._hovering = true;\n\n          if (!self._dragging) {\n            var itemSize = self.visualMapModel.itemSize;\n\n            var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.mainGroup, true, true);\n\n            pos[1] = mathMin$a(mathMax$a(0, pos[1]), itemSize[1]);\n\n            self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);\n          }\n        }).on('mouseout', function () {\n          self._hovering = false;\n          !self._dragging && self._clearHoverLinkToSeries();\n        });\n      };\n\n      ContinuousView.prototype._enableHoverLinkFromSeries = function () {\n        var zr = this.api.getZr();\n\n        if (this.visualMapModel.option.hoverLink) {\n          zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);\n          zr.on('mouseout', this._hideIndicator, this);\n        } else {\n          this._clearHoverLinkFromSeries();\n        }\n      };\n\n      ContinuousView.prototype._doHoverLinkToSeries = function (cursorPos, hoverOnBar) {\n        var visualMapModel = this.visualMapModel;\n        var itemSize = visualMapModel.itemSize;\n\n        if (!visualMapModel.option.hoverLink) {\n          return;\n        }\n\n        var sizeExtent = [0, itemSize[1]];\n        var dataExtent = visualMapModel.getExtent();\n        cursorPos = mathMin$a(mathMax$a(sizeExtent[0], cursorPos), sizeExtent[1]);\n        var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);\n        var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];\n        var cursorValue = linearMap$2(cursorPos, sizeExtent, dataExtent, true);\n        var valueRange = [linearMap$2(hoverRange[0], sizeExtent, dataExtent, true), linearMap$2(hoverRange[1], sizeExtent, dataExtent, true)];\n        hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);\n        hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);\n\n        if (hoverOnBar) {\n          if (valueRange[0] === -Infinity) {\n            this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);\n          } else if (valueRange[1] === Infinity) {\n            this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);\n          } else {\n            this._showIndicator(cursorValue, cursorValue, ' ', halfHoverLinkSize);\n          }\n        }\n\n        var oldBatch = this._hoverLinkDataIndices;\n        var newBatch = [];\n\n        if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {\n          newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);\n        }\n\n        var resultBatches = compressBatches(oldBatch, newBatch);\n\n        this._dispatchHighDown('downplay', makeHighDownBatch(resultBatches[0], visualMapModel));\n\n        this._dispatchHighDown('highlight', makeHighDownBatch(resultBatches[1], visualMapModel));\n      };\n\n      ContinuousView.prototype._hoverLinkFromSeriesMouseOver = function (e) {\n        var el = e.target;\n        var visualMapModel = this.visualMapModel;\n\n        if (!el || getECData(el).dataIndex == null) {\n          return;\n        }\n\n        var ecData = getECData(el);\n        var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);\n\n        if (!visualMapModel.isTargetSeries(dataModel)) {\n          return;\n        }\n\n        var data = dataModel.getData(ecData.dataType);\n        var value = data.get(visualMapModel.getDataDimension(data), ecData.dataIndex);\n\n        if (!isNaN(value)) {\n          this._showIndicator(value, value);\n        }\n      };\n\n      ContinuousView.prototype._hideIndicator = function () {\n        var shapes = this._shapes;\n        shapes.indicator && shapes.indicator.attr('invisible', true);\n        shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);\n        var handleLabels = this._shapes.handleLabels;\n\n        if (handleLabels) {\n          for (var i = 0; i < handleLabels.length; i++) {\n            this._api.leaveBlur(handleLabels[i]);\n          }\n        }\n      };\n\n      ContinuousView.prototype._clearHoverLinkToSeries = function () {\n        this._hideIndicator();\n\n        var indices = this._hoverLinkDataIndices;\n\n        this._dispatchHighDown('downplay', makeHighDownBatch(indices, this.visualMapModel));\n\n        indices.length = 0;\n      };\n\n      ContinuousView.prototype._clearHoverLinkFromSeries = function () {\n        this._hideIndicator();\n\n        var zr = this.api.getZr();\n        zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);\n        zr.off('mouseout', this._hideIndicator);\n      };\n\n      ContinuousView.prototype._applyTransform = function (vertex, element, inverse, global) {\n        var transform = getTransform(element, global ? null : this.group);\n        return isArray(vertex) ? applyTransform$1(vertex, transform, inverse) : transformDirection(vertex, transform, inverse);\n      };\n\n      ContinuousView.prototype._dispatchHighDown = function (type, batch) {\n        batch && batch.length && this.api.dispatchAction({\n          type: type,\n          batch: batch\n        });\n      };\n\n      ContinuousView.prototype.dispose = function () {\n        this._clearHoverLinkFromSeries();\n\n        this._clearHoverLinkToSeries();\n      };\n\n      ContinuousView.prototype.remove = function () {\n        this._clearHoverLinkFromSeries();\n\n        this._clearHoverLinkToSeries();\n      };\n\n      ContinuousView.type = 'visualMap.continuous';\n      return ContinuousView;\n    }(VisualMapView);\n\n    function createPolygon(points, cursor, onDrift, onDragEnd) {\n      return new Polygon({\n        shape: {\n          points: points\n        },\n        draggable: !!onDrift,\n        cursor: cursor,\n        drift: onDrift,\n        onmousemove: function (e) {\n          stop(e.event);\n        },\n        ondragend: onDragEnd\n      });\n    }\n\n    function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {\n      var halfHoverLinkSize = HOVER_LINK_SIZE / 2;\n      var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');\n\n      if (hoverLinkDataSize) {\n        halfHoverLinkSize = linearMap$2(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;\n      }\n\n      return halfHoverLinkSize;\n    }\n\n    function useHoverLinkOnHandle(visualMapModel) {\n      var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');\n      return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);\n    }\n\n    function getCursor$1(orient) {\n      return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n    }\n\n    /*\n    * Licensed to the Apache Software Foundation (ASF) under one\n    * or more contributor license agreements.  See the NOTICE file\n    * distributed with this work for additional information\n    * regarding copyright ownership.  The ASF licenses this file\n    * to you under the Apache License, Version 2.0 (the\n    * \"License\"); you may not use this file except in compliance\n    * with the License.  You may obtain a copy of the License at\n    *\n    *   http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing,\n    * software distributed under the License is distributed on an\n    * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    * KIND, either express or implied.  See the License for the\n    * specific language governing permissions and limitations\n    * under the License.\n    */\n\n\n    /**\n     * AUTO-GENERATED FILE. DO NOT MODIFY.\n     */\n\n    var visualMapActionInfo = {\n      type: 'selectDataRange',\n      event: 'dataRangeSelected',\n      update: 'update'\n    };\n    var visualMapActionHander = function (payload, ecModel) {\n      ecModel.eachComponent({\n        mainType: 'visualMap',\n        query: payload\n      }, function (model) {\n        model.setSelected(payload.selected);\n      });\n    };\n\n    var visualMapEncodingHandlers = [{\n      createOnAllSeries: true,\n      reset: function (seriesModel, ecModel) {\n        var resetDefines = [];\n        ecModel.eachComponent('visualMap', function (visualMapModel) {\n          var pipelineContext = seriesModel.pipelineContext;\n\n          if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {\n            return;\n          }\n\n          resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));\n        });\n        return resetDefines;\n      }\n    }, {\n      createOnAllSeries: true,\n      reset: function (seriesModel, ecModel) {\n        var data = seriesModel.getData();\n        var visualMetaList = [];\n        ecModel.eachComponent('visualMap', function (visualMapModel) {\n          if (visualMapModel.isTargetSeries(seriesModel)) {\n            var visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {\n              stops: [],\n              outerColors: []\n            };\n            var concreteDim = visualMapModel.getDataDimension(data);\n            var dimInfo = data.getDimensionInfo(concreteDim);\n\n            if (dimInfo != null) {\n              visualMeta.dimension = dimInfo.index;\n              visualMetaList.push(visualMeta);\n            }\n          }\n        });\n        seriesModel.getData().setVisual('visualMeta', visualMetaList);\n      }\n    }];\n\n    function getColorVisual(seriesModel, visualMapModel, value, valueState) {\n      var mappings = visualMapModel.targetVisuals[valueState];\n      var visualTypes = VisualMapping.prepareVisualTypes(mappings);\n      var resultVisual = {\n        color: getVisualFromData(seriesModel.getData(), 'color')\n      };\n\n      for (var i = 0, len = visualTypes.length; i < len; i++) {\n        var type = visualTypes[i];\n        var mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type];\n        mapping && mapping.applyVisual(value, getVisual, setVisual);\n      }\n\n      return resultVisual.color;\n\n      function getVisual(key) {\n        return resultVisual[key];\n      }\n\n      function setVisual(key, value) {\n        resultVisual[key] = value;\n      }\n    }\n\n    var each$h = each;\n    function visualMapPreprocessor(option) {\n      var visualMap = option && option.visualMap;\n\n      if (!isArray(visualMap)) {\n        visualMap = visualMap ? [visualMap] : [];\n      }\n\n      each$h(visualMap, function (opt) {\n        if (!opt) {\n          return;\n        }\n\n        if (has$1(opt, 'splitList') && !has$1(opt, 'pieces')) {\n          opt.pieces = opt.splitList;\n          delete opt.splitList;\n        }\n\n        var pieces = opt.pieces;\n\n        if (pieces && isArray(pieces)) {\n          each$h(pieces, function (piece) {\n            if (isObject(piece)) {\n              if (has$1(piece, 'start') && !has$1(piece, 'min')) {\n                piece.min = piece.start;\n              }\n\n              if (has$1(piece, 'end') && !has$1(piece, 'max')) {\n                piece.max = piece.end;\n              }\n            }\n          });\n        }\n      });\n    }\n\n    function has$1(obj, name) {\n      return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);\n    }\n\n    var installed$1 = false;\n    function installCommon$1(registers) {\n      if (installed$1) {\n        return;\n      }\n\n      installed$1 = true;\n      registers.registerSubTypeDefaulter('visualMap', function (option) {\n        return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';\n      });\n      registers.registerAction(visualMapActionInfo, visualMapActionHander);\n      each(visualMapEncodingHandlers, function (handler) {\n        registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);\n      });\n      registers.registerPreprocessor(visualMapPreprocessor);\n    }\n\n    function install$N(registers) {\n      registers.registerComponentModel(ContinuousModel);\n      registers.registerComponentView(ContinuousView);\n      installCommon$1(registers);\n    }\n\n    var PiecewiseModel = function (_super) {\n      __extends(PiecewiseModel, _super);\n\n      function PiecewiseModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PiecewiseModel.type;\n        _this._pieceList = [];\n        return _this;\n      }\n\n      PiecewiseModel.prototype.optionUpdated = function (newOption, isInit) {\n        _super.prototype.optionUpdated.apply(this, arguments);\n\n        this.resetExtent();\n\n        var mode = this._mode = this._determineMode();\n\n        this._pieceList = [];\n\n        resetMethods[this._mode].call(this, this._pieceList);\n\n        this._resetSelected(newOption, isInit);\n\n        var categories = this.option.categories;\n        this.resetVisual(function (mappingOption, state) {\n          if (mode === 'categories') {\n            mappingOption.mappingMethod = 'category';\n            mappingOption.categories = clone(categories);\n          } else {\n            mappingOption.dataExtent = this.getExtent();\n            mappingOption.mappingMethod = 'piecewise';\n            mappingOption.pieceList = map(this._pieceList, function (piece) {\n              piece = clone(piece);\n\n              if (state !== 'inRange') {\n                piece.visual = null;\n              }\n\n              return piece;\n            });\n          }\n        });\n      };\n\n      PiecewiseModel.prototype.completeVisualOption = function () {\n        var option = this.option;\n        var visualTypesInPieces = {};\n        var visualTypes = VisualMapping.listVisualTypes();\n        var isCategory = this.isCategory();\n        each(option.pieces, function (piece) {\n          each(visualTypes, function (visualType) {\n            if (piece.hasOwnProperty(visualType)) {\n              visualTypesInPieces[visualType] = 1;\n            }\n          });\n        });\n        each(visualTypesInPieces, function (v, visualType) {\n          var exists = false;\n          each(this.stateList, function (state) {\n            exists = exists || has(option, state, visualType) || has(option.target, state, visualType);\n          }, this);\n          !exists && each(this.stateList, function (state) {\n            (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);\n          });\n        }, this);\n\n        function has(obj, state, visualType) {\n          return obj && obj[state] && obj[state].hasOwnProperty(visualType);\n        }\n\n        _super.prototype.completeVisualOption.apply(this, arguments);\n      };\n\n      PiecewiseModel.prototype._resetSelected = function (newOption, isInit) {\n        var thisOption = this.option;\n        var pieceList = this._pieceList;\n        var selected = (isInit ? thisOption : newOption).selected || {};\n        thisOption.selected = selected;\n        each(pieceList, function (piece, index) {\n          var key = this.getSelectedMapKey(piece);\n\n          if (!selected.hasOwnProperty(key)) {\n            selected[key] = true;\n          }\n        }, this);\n\n        if (thisOption.selectedMode === 'single') {\n          var hasSel_1 = false;\n          each(pieceList, function (piece, index) {\n            var key = this.getSelectedMapKey(piece);\n\n            if (selected[key]) {\n              hasSel_1 ? selected[key] = false : hasSel_1 = true;\n            }\n          }, this);\n        }\n      };\n\n      PiecewiseModel.prototype.getSelectedMapKey = function (piece) {\n        return this._mode === 'categories' ? piece.value + '' : piece.index + '';\n      };\n\n      PiecewiseModel.prototype.getPieceList = function () {\n        return this._pieceList;\n      };\n\n      PiecewiseModel.prototype._determineMode = function () {\n        var option = this.option;\n        return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';\n      };\n\n      PiecewiseModel.prototype.setSelected = function (selected) {\n        this.option.selected = clone(selected);\n      };\n\n      PiecewiseModel.prototype.getValueState = function (value) {\n        var index = VisualMapping.findPieceIndex(value, this._pieceList);\n        return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';\n      };\n\n      PiecewiseModel.prototype.findTargetDataIndices = function (pieceIndex) {\n        var result = [];\n        var pieceList = this._pieceList;\n        this.eachTargetSeries(function (seriesModel) {\n          var dataIndices = [];\n          var data = seriesModel.getData();\n          data.each(this.getDataDimension(data), function (value, dataIndex) {\n            var pIdx = VisualMapping.findPieceIndex(value, pieceList);\n            pIdx === pieceIndex && dataIndices.push(dataIndex);\n          }, this);\n          result.push({\n            seriesId: seriesModel.id,\n            dataIndex: dataIndices\n          });\n        }, this);\n        return result;\n      };\n\n      PiecewiseModel.prototype.getRepresentValue = function (piece) {\n        var representValue;\n\n        if (this.isCategory()) {\n          representValue = piece.value;\n        } else {\n          if (piece.value != null) {\n            representValue = piece.value;\n          } else {\n            var pieceInterval = piece.interval || [];\n            representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;\n          }\n        }\n\n        return representValue;\n      };\n\n      PiecewiseModel.prototype.getVisualMeta = function (getColorVisual) {\n        if (this.isCategory()) {\n          return;\n        }\n\n        var stops = [];\n        var outerColors = ['', ''];\n        var visualMapModel = this;\n\n        function setStop(interval, valueState) {\n          var representValue = visualMapModel.getRepresentValue({\n            interval: interval\n          });\n\n          if (!valueState) {\n            valueState = visualMapModel.getValueState(representValue);\n          }\n\n          var color = getColorVisual(representValue, valueState);\n\n          if (interval[0] === -Infinity) {\n            outerColors[0] = color;\n          } else if (interval[1] === Infinity) {\n            outerColors[1] = color;\n          } else {\n            stops.push({\n              value: interval[0],\n              color: color\n            }, {\n              value: interval[1],\n              color: color\n            });\n          }\n        }\n\n        var pieceList = this._pieceList.slice();\n\n        if (!pieceList.length) {\n          pieceList.push({\n            interval: [-Infinity, Infinity]\n          });\n        } else {\n          var edge = pieceList[0].interval[0];\n          edge !== -Infinity && pieceList.unshift({\n            interval: [-Infinity, edge]\n          });\n          edge = pieceList[pieceList.length - 1].interval[1];\n          edge !== Infinity && pieceList.push({\n            interval: [edge, Infinity]\n          });\n        }\n\n        var curr = -Infinity;\n        each(pieceList, function (piece) {\n          var interval = piece.interval;\n\n          if (interval) {\n            interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');\n            setStop(interval.slice());\n            curr = interval[1];\n          }\n        }, this);\n        return {\n          stops: stops,\n          outerColors: outerColors\n        };\n      };\n\n      PiecewiseModel.type = 'visualMap.piecewise';\n      PiecewiseModel.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {\n        selected: null,\n        minOpen: false,\n        maxOpen: false,\n        align: 'auto',\n        itemWidth: 20,\n        itemHeight: 14,\n        itemSymbol: 'roundRect',\n        pieces: null,\n        categories: null,\n        splitNumber: 5,\n        selectedMode: 'multiple',\n        itemGap: 10,\n        hoverLink: true\n      });\n      return PiecewiseModel;\n    }(VisualMapModel);\n    var resetMethods = {\n      splitNumber: function (outPieceList) {\n        var thisOption = this.option;\n        var precision = Math.min(thisOption.precision, 20);\n        var dataExtent = this.getExtent();\n        var splitNumber = thisOption.splitNumber;\n        splitNumber = Math.max(parseInt(splitNumber, 10), 1);\n        thisOption.splitNumber = splitNumber;\n        var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;\n\n        while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {\n          precision++;\n        }\n\n        thisOption.precision = precision;\n        splitStep = +splitStep.toFixed(precision);\n\n        if (thisOption.minOpen) {\n          outPieceList.push({\n            interval: [-Infinity, dataExtent[0]],\n            close: [0, 0]\n          });\n        }\n\n        for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {\n          var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;\n          outPieceList.push({\n            interval: [curr, max],\n            close: [1, 1]\n          });\n        }\n\n        if (thisOption.maxOpen) {\n          outPieceList.push({\n            interval: [dataExtent[1], Infinity],\n            close: [0, 0]\n          });\n        }\n\n        reformIntervals(outPieceList);\n        each(outPieceList, function (piece, index) {\n          piece.index = index;\n          piece.text = this.formatValueText(piece.interval);\n        }, this);\n      },\n      categories: function (outPieceList) {\n        var thisOption = this.option;\n        each(thisOption.categories, function (cate) {\n          outPieceList.push({\n            text: this.formatValueText(cate, true),\n            value: cate\n          });\n        }, this);\n        normalizeReverse(thisOption, outPieceList);\n      },\n      pieces: function (outPieceList) {\n        var thisOption = this.option;\n        each(thisOption.pieces, function (pieceListItem, index) {\n          if (!isObject(pieceListItem)) {\n            pieceListItem = {\n              value: pieceListItem\n            };\n          }\n\n          var item = {\n            text: '',\n            index: index\n          };\n\n          if (pieceListItem.label != null) {\n            item.text = pieceListItem.label;\n          }\n\n          if (pieceListItem.hasOwnProperty('value')) {\n            var value = item.value = pieceListItem.value;\n            item.interval = [value, value];\n            item.close = [1, 1];\n          } else {\n            var interval = item.interval = [];\n            var close_1 = item.close = [0, 0];\n            var closeList = [1, 0, 1];\n            var infinityList = [-Infinity, Infinity];\n            var useMinMax = [];\n\n            for (var lg = 0; lg < 2; lg++) {\n              var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];\n\n              for (var i = 0; i < 3 && interval[lg] == null; i++) {\n                interval[lg] = pieceListItem[names[i]];\n                close_1[lg] = closeList[i];\n                useMinMax[lg] = i === 2;\n              }\n\n              interval[lg] == null && (interval[lg] = infinityList[lg]);\n            }\n\n            useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);\n            useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);\n\n            if (\"development\" !== 'production') {\n              if (interval[0] > interval[1]) {\n                console.warn('Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.');\n              }\n            }\n\n            if (interval[0] === interval[1] && close_1[0] && close_1[1]) {\n              item.value = interval[0];\n            }\n          }\n\n          item.visual = VisualMapping.retrieveVisuals(pieceListItem);\n          outPieceList.push(item);\n        }, this);\n        normalizeReverse(thisOption, outPieceList);\n        reformIntervals(outPieceList);\n        each(outPieceList, function (piece) {\n          var close = piece.close;\n          var edgeSymbols = [['<', ''][close[1]], ['>', ''][close[0]]];\n          piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);\n        }, this);\n      }\n    };\n\n    function normalizeReverse(thisOption, pieceList) {\n      var inverse = thisOption.inverse;\n\n      if (thisOption.orient === 'vertical' ? !inverse : inverse) {\n        pieceList.reverse();\n      }\n    }\n\n    var PiecewiseVisualMapView = function (_super) {\n      __extends(PiecewiseVisualMapView, _super);\n\n      function PiecewiseVisualMapView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = PiecewiseVisualMapView.type;\n        return _this;\n      }\n\n      PiecewiseVisualMapView.prototype.doRender = function () {\n        var thisGroup = this.group;\n        thisGroup.removeAll();\n        var visualMapModel = this.visualMapModel;\n        var textGap = visualMapModel.get('textGap');\n        var textStyleModel = visualMapModel.textStyleModel;\n        var textFont = textStyleModel.getFont();\n        var textFill = textStyleModel.getTextColor();\n\n        var itemAlign = this._getItemAlign();\n\n        var itemSize = visualMapModel.itemSize;\n\n        var viewData = this._getViewData();\n\n        var endsText = viewData.endsText;\n        var showLabel = retrieve(visualMapModel.get('showLabel', true), !endsText);\n        endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);\n        each(viewData.viewPieceList, function (item) {\n          var piece = item.piece;\n          var itemGroup = new Group();\n          itemGroup.onclick = bind(this._onItemClick, this, piece);\n\n          this._enableHoverLink(itemGroup, item.indexInModelPieceList);\n\n          var representValue = visualMapModel.getRepresentValue(piece);\n\n          this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);\n\n          if (showLabel) {\n            var visualState = this.visualMapModel.getValueState(representValue);\n            itemGroup.add(new ZRText({\n              style: {\n                x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,\n                y: itemSize[1] / 2,\n                text: piece.text,\n                verticalAlign: 'middle',\n                align: itemAlign,\n                font: textFont,\n                fill: textFill,\n                opacity: visualState === 'outOfRange' ? 0.5 : 1\n              }\n            }));\n          }\n\n          thisGroup.add(itemGroup);\n        }, this);\n        endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);\n        box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));\n        this.renderBackground(thisGroup);\n        this.positionGroup(thisGroup);\n      };\n\n      PiecewiseVisualMapView.prototype._enableHoverLink = function (itemGroup, pieceIndex) {\n        var _this = this;\n\n        itemGroup.on('mouseover', function () {\n          return onHoverLink('highlight');\n        }).on('mouseout', function () {\n          return onHoverLink('downplay');\n        });\n\n        var onHoverLink = function (method) {\n          var visualMapModel = _this.visualMapModel;\n          visualMapModel.option.hoverLink && _this.api.dispatchAction({\n            type: method,\n            batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)\n          });\n        };\n      };\n\n      PiecewiseVisualMapView.prototype._getItemAlign = function () {\n        var visualMapModel = this.visualMapModel;\n        var modelOption = visualMapModel.option;\n\n        if (modelOption.orient === 'vertical') {\n          return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);\n        } else {\n          var align = modelOption.align;\n\n          if (!align || align === 'auto') {\n            align = 'left';\n          }\n\n          return align;\n        }\n      };\n\n      PiecewiseVisualMapView.prototype._renderEndsText = function (group, text, itemSize, showLabel, itemAlign) {\n        if (!text) {\n          return;\n        }\n\n        var itemGroup = new Group();\n        var textStyleModel = this.visualMapModel.textStyleModel;\n        itemGroup.add(new ZRText({\n          style: {\n            x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,\n            y: itemSize[1] / 2,\n            verticalAlign: 'middle',\n            align: showLabel ? itemAlign : 'center',\n            text: text,\n            font: textStyleModel.getFont(),\n            fill: textStyleModel.getTextColor()\n          }\n        }));\n        group.add(itemGroup);\n      };\n\n      PiecewiseVisualMapView.prototype._getViewData = function () {\n        var visualMapModel = this.visualMapModel;\n        var viewPieceList = map(visualMapModel.getPieceList(), function (piece, index) {\n          return {\n            piece: piece,\n            indexInModelPieceList: index\n          };\n        });\n        var endsText = visualMapModel.get('text');\n        var orient = visualMapModel.get('orient');\n        var inverse = visualMapModel.get('inverse');\n\n        if (orient === 'horizontal' ? inverse : !inverse) {\n          viewPieceList.reverse();\n        } else if (endsText) {\n          endsText = endsText.slice().reverse();\n        }\n\n        return {\n          viewPieceList: viewPieceList,\n          endsText: endsText\n        };\n      };\n\n      PiecewiseVisualMapView.prototype._createItemSymbol = function (group, representValue, shapeParam) {\n        group.add(createSymbol(this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, 'color')));\n      };\n\n      PiecewiseVisualMapView.prototype._onItemClick = function (piece) {\n        var visualMapModel = this.visualMapModel;\n        var option = visualMapModel.option;\n        var selected = clone(option.selected);\n        var newKey = visualMapModel.getSelectedMapKey(piece);\n\n        if (option.selectedMode === 'single') {\n          selected[newKey] = true;\n          each(selected, function (o, key) {\n            selected[key] = key === newKey;\n          });\n        } else {\n          selected[newKey] = !selected[newKey];\n        }\n\n        this.api.dispatchAction({\n          type: 'selectDataRange',\n          from: this.uid,\n          visualMapId: this.visualMapModel.id,\n          selected: selected\n        });\n      };\n\n      PiecewiseVisualMapView.type = 'visualMap.piecewise';\n      return PiecewiseVisualMapView;\n    }(VisualMapView);\n\n    function install$O(registers) {\n      registers.registerComponentModel(PiecewiseModel);\n      registers.registerComponentView(PiecewiseVisualMapView);\n      installCommon$1(registers);\n    }\n\n    function install$P(registers) {\n      use(install$N);\n      use(install$O);\n    }\n\n    var DEFAULT_OPTION = {\n      label: {\n        enabled: true\n      },\n      decal: {\n        show: false\n      }\n    };\n    var inner$n = makeInner();\n    var decalPaletteScope = {};\n    function ariaVisual(ecModel, api) {\n      var ariaModel = ecModel.getModel('aria');\n\n      if (!ariaModel.get('enabled')) {\n        return;\n      }\n\n      var defaultOption = clone(DEFAULT_OPTION);\n      merge(defaultOption.label, ecModel.getLocaleModel().get('aria'), false);\n      merge(ariaModel.option, defaultOption, false);\n      setDecal();\n      setLabel();\n\n      function setDecal() {\n        var decalModel = ariaModel.getModel('decal');\n        var useDecal = decalModel.get('show');\n\n        if (useDecal) {\n          var paletteScopeGroupByType_1 = createHashMap();\n          ecModel.eachSeries(function (seriesModel) {\n            if (!seriesModel.useColorPaletteOnData) {\n              return;\n            }\n\n            var decalScope = paletteScopeGroupByType_1.get(seriesModel.type);\n\n            if (!decalScope) {\n              decalScope = {};\n              paletteScopeGroupByType_1.set(seriesModel.type, decalScope);\n            }\n\n            inner$n(seriesModel).scope = decalScope;\n          });\n          ecModel.eachRawSeries(function (seriesModel) {\n            if (ecModel.isSeriesFiltered(seriesModel)) {\n              return;\n            }\n\n            if (typeof seriesModel.enableAriaDecal === 'function') {\n              seriesModel.enableAriaDecal();\n              return;\n            }\n\n            var data = seriesModel.getData();\n\n            if (seriesModel.useColorPaletteOnData) {\n              var dataAll_1 = seriesModel.getRawData();\n              var idxMap_1 = {};\n              var decalScope_1 = inner$n(seriesModel).scope;\n              data.each(function (idx) {\n                var rawIdx = data.getRawIndex(idx);\n                idxMap_1[rawIdx] = idx;\n              });\n              var dataCount_1 = dataAll_1.count();\n              dataAll_1.each(function (rawIdx) {\n                var idx = idxMap_1[rawIdx];\n                var name = dataAll_1.getName(rawIdx) || rawIdx + '';\n                var paletteDecal = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1);\n                var specifiedDecal = data.getItemVisual(idx, 'decal');\n                data.setItemVisual(idx, 'decal', mergeDecal(specifiedDecal, paletteDecal));\n              });\n            } else {\n              var paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());\n              var specifiedDecal = data.getVisual('decal');\n              data.setVisual('decal', mergeDecal(specifiedDecal, paletteDecal));\n            }\n\n            function mergeDecal(specifiedDecal, paletteDecal) {\n              var resultDecal = specifiedDecal ? extend(extend({}, paletteDecal), specifiedDecal) : paletteDecal;\n              resultDecal.dirty = true;\n              return resultDecal;\n            }\n          });\n        }\n      }\n\n      function setLabel() {\n        var labelLocale = ecModel.getLocaleModel().get('aria');\n        var labelModel = ariaModel.getModel('label');\n        labelModel.option = defaults(labelModel.option, labelLocale);\n\n        if (!labelModel.get('enabled')) {\n          return;\n        }\n\n        var dom = api.getZr().dom;\n\n        if (labelModel.get('description')) {\n          dom.setAttribute('aria-label', labelModel.get('description'));\n          return;\n        }\n\n        var seriesCnt = ecModel.getSeriesCount();\n        var maxDataCnt = labelModel.get(['data', 'maxCount']) || 10;\n        var maxSeriesCnt = labelModel.get(['series', 'maxCount']) || 10;\n        var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);\n        var ariaLabel;\n\n        if (seriesCnt < 1) {\n          return;\n        } else {\n          var title = getTitle();\n\n          if (title) {\n            var withTitle = labelModel.get(['general', 'withTitle']);\n            ariaLabel = replace(withTitle, {\n              title: title\n            });\n          } else {\n            ariaLabel = labelModel.get(['general', 'withoutTitle']);\n          }\n\n          var seriesLabels_1 = [];\n          var prefix = seriesCnt > 1 ? labelModel.get(['series', 'multiple', 'prefix']) : labelModel.get(['series', 'single', 'prefix']);\n          ariaLabel += replace(prefix, {\n            seriesCount: seriesCnt\n          });\n          ecModel.eachSeries(function (seriesModel, idx) {\n            if (idx < displaySeriesCnt) {\n              var seriesLabel = void 0;\n              var seriesName = seriesModel.get('name');\n              var withName = seriesName ? 'withName' : 'withoutName';\n              seriesLabel = seriesCnt > 1 ? labelModel.get(['series', 'multiple', withName]) : labelModel.get(['series', 'single', withName]);\n              seriesLabel = replace(seriesLabel, {\n                seriesId: seriesModel.seriesIndex,\n                seriesName: seriesModel.get('name'),\n                seriesType: getSeriesTypeName(seriesModel.subType)\n              });\n              var data = seriesModel.getData();\n\n              if (data.count() > maxDataCnt) {\n                var partialLabel = labelModel.get(['data', 'partialData']);\n                seriesLabel += replace(partialLabel, {\n                  displayCnt: maxDataCnt\n                });\n              } else {\n                seriesLabel += labelModel.get(['data', 'allData']);\n              }\n\n              var dataLabels = [];\n\n              for (var i = 0; i < data.count(); i++) {\n                if (i < maxDataCnt) {\n                  var name_1 = data.getName(i);\n                  var value = retrieveRawValue(data, i);\n                  var dataLabel = labelModel.get(['data', name_1 ? 'withName' : 'withoutName']);\n                  dataLabels.push(replace(dataLabel, {\n                    name: name_1,\n                    value: value\n                  }));\n                }\n              }\n\n              var middleSeparator_1 = labelModel.get(['data', 'separator', 'middle']);\n              var endSeparator_1 = labelModel.get(['data', 'separator', 'end']);\n              seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1;\n              seriesLabels_1.push(seriesLabel);\n            }\n          });\n          var separatorModel = labelModel.getModel(['series', 'multiple', 'separator']);\n          var middleSeparator = separatorModel.get('middle');\n          var endSeparator = separatorModel.get('end');\n          ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator;\n          dom.setAttribute('aria-label', ariaLabel);\n        }\n      }\n\n      function replace(str, keyValues) {\n        if (typeof str !== 'string') {\n          return str;\n        }\n\n        var result = str;\n        each(keyValues, function (value, key) {\n          result = result.replace(new RegExp('\\\\{\\\\s*' + key + '\\\\s*\\\\}', 'g'), value);\n        });\n        return result;\n      }\n\n      function getTitle() {\n        var title = ecModel.get('title');\n\n        if (title && title.length) {\n          title = title[0];\n        }\n\n        return title && title.text;\n      }\n\n      function getSeriesTypeName(type) {\n        return ecModel.getLocaleModel().get(['series', 'typeNames'])[type] || '';\n      }\n    }\n\n    function ariaPreprocessor(option) {\n      if (!option || !option.aria) {\n        return;\n      }\n\n      var aria = option.aria;\n\n      if (aria.show != null) {\n        aria.enabled = aria.show;\n      }\n\n      aria.label = aria.label || {};\n      each(['description', 'general', 'series', 'data'], function (name) {\n        if (aria[name] != null) {\n          aria.label[name] = aria[name];\n        }\n      });\n    }\n\n    function install$Q(registers) {\n      registers.registerPreprocessor(ariaPreprocessor);\n      registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);\n    }\n\n    var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {\n      value: 'eq',\n      '<': 'lt',\n      '<=': 'lte',\n      '>': 'gt',\n      '>=': 'gte',\n      '=': 'eq',\n      '!=': 'ne',\n      '<>': 'ne'\n    };\n\n    var RegExpEvaluator = function () {\n      function RegExpEvaluator(rVal) {\n        var condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;\n\n        if (condValue == null) {\n          var errMsg = '';\n\n          if (\"development\" !== 'production') {\n            errMsg = makePrintable('Illegal regexp', rVal, 'in');\n          }\n\n          throwError(errMsg);\n        }\n      }\n\n      RegExpEvaluator.prototype.evaluate = function (lVal) {\n        var type = typeof lVal;\n        return type === 'string' ? this._condVal.test(lVal) : type === 'number' ? this._condVal.test(lVal + '') : false;\n      };\n\n      return RegExpEvaluator;\n    }();\n\n    var ConstConditionInternal = function () {\n      function ConstConditionInternal() {}\n\n      ConstConditionInternal.prototype.evaluate = function () {\n        return this.value;\n      };\n\n      return ConstConditionInternal;\n    }();\n\n    var AndConditionInternal = function () {\n      function AndConditionInternal() {}\n\n      AndConditionInternal.prototype.evaluate = function () {\n        var children = this.children;\n\n        for (var i = 0; i < children.length; i++) {\n          if (!children[i].evaluate()) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      return AndConditionInternal;\n    }();\n\n    var OrConditionInternal = function () {\n      function OrConditionInternal() {}\n\n      OrConditionInternal.prototype.evaluate = function () {\n        var children = this.children;\n\n        for (var i = 0; i < children.length; i++) {\n          if (children[i].evaluate()) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      return OrConditionInternal;\n    }();\n\n    var NotConditionInternal = function () {\n      function NotConditionInternal() {}\n\n      NotConditionInternal.prototype.evaluate = function () {\n        return !this.child.evaluate();\n      };\n\n      return NotConditionInternal;\n    }();\n\n    var RelationalConditionInternal = function () {\n      function RelationalConditionInternal() {}\n\n      RelationalConditionInternal.prototype.evaluate = function () {\n        var needParse = !!this.valueParser;\n        var getValue = this.getValue;\n        var tarValRaw = getValue(this.valueGetterParam);\n        var tarValParsed = needParse ? this.valueParser(tarValRaw) : null;\n\n        for (var i = 0; i < this.subCondList.length; i++) {\n          if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      return RelationalConditionInternal;\n    }();\n\n    function parseOption(exprOption, getters) {\n      if (exprOption === true || exprOption === false) {\n        var cond = new ConstConditionInternal();\n        cond.value = exprOption;\n        return cond;\n      }\n\n      var errMsg = '';\n\n      if (!isObjectNotArray(exprOption)) {\n        if (\"development\" !== 'production') {\n          errMsg = makePrintable('Illegal config. Expect a plain object but actually', exprOption);\n        }\n\n        throwError(errMsg);\n      }\n\n      if (exprOption.and) {\n        return parseAndOrOption('and', exprOption, getters);\n      } else if (exprOption.or) {\n        return parseAndOrOption('or', exprOption, getters);\n      } else if (exprOption.not) {\n        return parseNotOption(exprOption, getters);\n      }\n\n      return parseRelationalOption(exprOption, getters);\n    }\n\n    function parseAndOrOption(op, exprOption, getters) {\n      var subOptionArr = exprOption[op];\n      var errMsg = '';\n\n      if (\"development\" !== 'production') {\n        errMsg = makePrintable('\"and\"/\"or\" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption);\n      }\n\n      if (!isArray(subOptionArr)) {\n        throwError(errMsg);\n      }\n\n      if (!subOptionArr.length) {\n        throwError(errMsg);\n      }\n\n      var cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal();\n      cond.children = map(subOptionArr, function (subOption) {\n        return parseOption(subOption, getters);\n      });\n\n      if (!cond.children.length) {\n        throwError(errMsg);\n      }\n\n      return cond;\n    }\n\n    function parseNotOption(exprOption, getters) {\n      var subOption = exprOption.not;\n      var errMsg = '';\n\n      if (\"development\" !== 'production') {\n        errMsg = makePrintable('\"not\" condition should only be `not: {}`.', 'Illegal condition:', exprOption);\n      }\n\n      if (!isObjectNotArray(subOption)) {\n        throwError(errMsg);\n      }\n\n      var cond = new NotConditionInternal();\n      cond.child = parseOption(subOption, getters);\n\n      if (!cond.child) {\n        throwError(errMsg);\n      }\n\n      return cond;\n    }\n\n    function parseRelationalOption(exprOption, getters) {\n      var errMsg = '';\n      var valueGetterParam = getters.prepareGetValue(exprOption);\n      var subCondList = [];\n      var exprKeys = keys(exprOption);\n      var parserName = exprOption.parser;\n      var valueParser = parserName ? getRawValueParser(parserName) : null;\n\n      for (var i = 0; i < exprKeys.length; i++) {\n        var keyRaw = exprKeys[i];\n\n        if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {\n          continue;\n        }\n\n        var op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;\n        var condValueRaw = exprOption[keyRaw];\n        var condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;\n        var evaluator = createFilterComparator(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed);\n\n        if (!evaluator) {\n          if (\"development\" !== 'production') {\n            errMsg = makePrintable('Illegal relational operation: \"' + keyRaw + '\" in condition:', exprOption);\n          }\n\n          throwError(errMsg);\n        }\n\n        subCondList.push(evaluator);\n      }\n\n      if (!subCondList.length) {\n        if (\"development\" !== 'production') {\n          errMsg = makePrintable('Relational condition must have at least one operator.', 'Illegal condition:', exprOption);\n        }\n\n        throwError(errMsg);\n      }\n\n      var cond = new RelationalConditionInternal();\n      cond.valueGetterParam = valueGetterParam;\n      cond.valueParser = valueParser;\n      cond.getValue = getters.getValue;\n      cond.subCondList = subCondList;\n      return cond;\n    }\n\n    function isObjectNotArray(val) {\n      return isObject(val) && !isArrayLike(val);\n    }\n\n    var ConditionalExpressionParsed = function () {\n      function ConditionalExpressionParsed(exprOption, getters) {\n        this._cond = parseOption(exprOption, getters);\n      }\n\n      ConditionalExpressionParsed.prototype.evaluate = function () {\n        return this._cond.evaluate();\n      };\n\n      return ConditionalExpressionParsed;\n    }();\n    function parseConditionalExpression(exprOption, getters) {\n      return new ConditionalExpressionParsed(exprOption, getters);\n    }\n\n    var filterTransform = {\n      type: 'echarts:filter',\n      transform: function (params) {\n        var upstream = params.upstream;\n        var rawItem;\n        var condition = parseConditionalExpression(params.config, {\n          valueGetterAttrMap: createHashMap({\n            dimension: true\n          }),\n          prepareGetValue: function (exprOption) {\n            var errMsg = '';\n            var dimLoose = exprOption.dimension;\n\n            if (!hasOwn(exprOption, 'dimension')) {\n              if (\"development\" !== 'production') {\n                errMsg = makePrintable('Relation condition must has prop \"dimension\" specified.', 'Illegal condition:', exprOption);\n              }\n\n              throwError(errMsg);\n            }\n\n            var dimInfo = upstream.getDimensionInfo(dimLoose);\n\n            if (!dimInfo) {\n              if (\"development\" !== 'production') {\n                errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\\n', 'Illegal condition:', exprOption, '.\\n');\n              }\n\n              throwError(errMsg);\n            }\n\n            return {\n              dimIdx: dimInfo.index\n            };\n          },\n          getValue: function (param) {\n            return upstream.retrieveValueFromItem(rawItem, param.dimIdx);\n          }\n        });\n        var resultData = [];\n\n        for (var i = 0, len = upstream.count(); i < len; i++) {\n          rawItem = upstream.getRawDataItem(i);\n\n          if (condition.evaluate()) {\n            resultData.push(rawItem);\n          }\n        }\n\n        return {\n          data: resultData\n        };\n      }\n    };\n\n    var sampleLog = '';\n\n    if (\"development\" !== 'production') {\n      sampleLog = ['Valid config is like:', '{ dimension: \"age\", order: \"asc\" }', 'or [{ dimension: \"age\", order: \"asc\"], { dimension: \"date\", order: \"desc\" }]'].join(' ');\n    }\n\n    var sortTransform = {\n      type: 'echarts:sort',\n      transform: function (params) {\n        var upstream = params.upstream;\n        var config = params.config;\n        var errMsg = '';\n        var orderExprList = normalizeToArray(config);\n\n        if (!orderExprList.length) {\n          if (\"development\" !== 'production') {\n            errMsg = 'Empty `config` in sort transform.';\n          }\n\n          throwError(errMsg);\n        }\n\n        var orderDefList = [];\n        each(orderExprList, function (orderExpr) {\n          var dimLoose = orderExpr.dimension;\n          var order = orderExpr.order;\n          var parserName = orderExpr.parser;\n          var incomparable = orderExpr.incomparable;\n\n          if (dimLoose == null) {\n            if (\"development\" !== 'production') {\n              errMsg = 'Sort transform config must has \"dimension\" specified.' + sampleLog;\n            }\n\n            throwError(errMsg);\n          }\n\n          if (order !== 'asc' && order !== 'desc') {\n            if (\"development\" !== 'production') {\n              errMsg = 'Sort transform config must has \"order\" specified.' + sampleLog;\n            }\n\n            throwError(errMsg);\n          }\n\n          if (incomparable && incomparable !== 'min' && incomparable !== 'max') {\n            var errMsg_1 = '';\n\n            if (\"development\" !== 'production') {\n              errMsg_1 = 'incomparable must be \"min\" or \"max\" rather than \"' + incomparable + '\".';\n            }\n\n            throwError(errMsg_1);\n          }\n\n          if (order !== 'asc' && order !== 'desc') {\n            var errMsg_2 = '';\n\n            if (\"development\" !== 'production') {\n              errMsg_2 = 'order must be \"asc\" or \"desc\" rather than \"' + order + '\".';\n            }\n\n            throwError(errMsg_2);\n          }\n\n          var dimInfo = upstream.getDimensionInfo(dimLoose);\n\n          if (!dimInfo) {\n            if (\"development\" !== 'production') {\n              errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\\n', 'Illegal config:', orderExpr, '.\\n');\n            }\n\n            throwError(errMsg);\n          }\n\n          var parser = parserName ? getRawValueParser(parserName) : null;\n\n          if (parserName && !parser) {\n            if (\"development\" !== 'production') {\n              errMsg = makePrintable('Invalid parser name ' + parserName + '.\\n', 'Illegal config:', orderExpr, '.\\n');\n            }\n\n            throwError(errMsg);\n          }\n\n          orderDefList.push({\n            dimIdx: dimInfo.index,\n            parser: parser,\n            comparator: new SortOrderComparator(order, incomparable)\n          });\n        });\n        var sourceFormat = upstream.sourceFormat;\n\n        if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {\n          if (\"development\" !== 'production') {\n            errMsg = 'sourceFormat \"' + sourceFormat + '\" is not supported yet';\n          }\n\n          throwError(errMsg);\n        }\n\n        var resultData = [];\n\n        for (var i = 0, len = upstream.count(); i < len; i++) {\n          resultData.push(upstream.getRawDataItem(i));\n        }\n\n        resultData.sort(function (item0, item1) {\n          for (var i = 0; i < orderDefList.length; i++) {\n            var orderDef = orderDefList[i];\n            var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);\n            var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);\n\n            if (orderDef.parser) {\n              val0 = orderDef.parser(val0);\n              val1 = orderDef.parser(val1);\n            }\n\n            var result = orderDef.comparator.evaluate(val0, val1);\n\n            if (result !== 0) {\n              return result;\n            }\n          }\n\n          return 0;\n        });\n        return {\n          data: resultData\n        };\n      }\n    };\n\n    function install$R(registers) {\n      registers.registerTransform(filterTransform);\n      registers.registerTransform(sortTransform);\n    }\n\n    var DatasetModel = function (_super) {\n      __extends(DatasetModel, _super);\n\n      function DatasetModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'dataset';\n        return _this;\n      }\n\n      DatasetModel.prototype.init = function (option, parentModel, ecModel) {\n        _super.prototype.init.call(this, option, parentModel, ecModel);\n\n        this._sourceManager = new SourceManager(this);\n        disableTransformOptionMerge(this);\n      };\n\n      DatasetModel.prototype.mergeOption = function (newOption, ecModel) {\n        _super.prototype.mergeOption.call(this, newOption, ecModel);\n\n        disableTransformOptionMerge(this);\n      };\n\n      DatasetModel.prototype.optionUpdated = function () {\n        this._sourceManager.dirty();\n      };\n\n      DatasetModel.prototype.getSourceManager = function () {\n        return this._sourceManager;\n      };\n\n      DatasetModel.type = 'dataset';\n      DatasetModel.defaultOption = {\n        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN\n      };\n      return DatasetModel;\n    }(ComponentModel);\n\n    var DatasetView = function (_super) {\n      __extends(DatasetView, _super);\n\n      function DatasetView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n\n        _this.type = 'dataset';\n        return _this;\n      }\n\n      DatasetView.type = 'dataset';\n      return DatasetView;\n    }(ComponentView);\n\n    function install$S(registers) {\n      registers.registerComponentModel(DatasetModel);\n      registers.registerComponentView(DatasetView);\n    }\n\n    use([install$1]);\n    use([install]);\n    use([install$2, install$3, install$4, install$6, install$8, install$9, install$a, install$b, install$c, install$d, install$e, install$g, install$h, install$i, install$j, install$k, install$l, install$m, install$n, install$o, install$p, install$q]);\n    use(install$s);\n    use(install$t);\n    use(install$u);\n    use(install$v);\n    use(install$f);\n    use(install$w);\n    use(install$x);\n    use(install$z);\n    use(install$A);\n    use(install$r);\n    use(install$B);\n    use(install$C);\n    use(install$D);\n    use(install$E);\n    use(install$F);\n    use(install$G);\n    use(install$J);\n    use(install$M);\n    use(install$K);\n    use(install$L);\n    use(install$P);\n    use(install$N);\n    use(install$O);\n    use(install$Q);\n    use(install$R);\n    use(install$S);\n\n    exports.Axis = Axis;\n    exports.ChartView = ChartView;\n    exports.ComponentModel = ComponentModel;\n    exports.ComponentView = ComponentView;\n    exports.List = List;\n    exports.Model = Model;\n    exports.PRIORITY = PRIORITY;\n    exports.SeriesModel = SeriesModel;\n    exports.color = color;\n    exports.connect = connect;\n    exports.dataTool = dataTool;\n    exports.dependencies = dependencies;\n    exports.disConnect = disConnect;\n    exports.disconnect = disconnect;\n    exports.dispose = dispose$1;\n    exports.env = env;\n    exports.extendChartView = extendChartView;\n    exports.extendComponentModel = extendComponentModel;\n    exports.extendComponentView = extendComponentView;\n    exports.extendSeriesModel = extendSeriesModel;\n    exports.format = format$1;\n    exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;\n    exports.getInstanceByDom = getInstanceByDom;\n    exports.getInstanceById = getInstanceById;\n    exports.getMap = getMap;\n    exports.graphic = graphic$1;\n    exports.helper = helper;\n    exports.init = init$1;\n    exports.innerDrawElementOnCanvas = brushSingle;\n    exports.matrix = matrix;\n    exports.number = number;\n    exports.parseGeoJSON = parseGeoJSON;\n    exports.parseGeoJson = parseGeoJSON;\n    exports.registerAction = registerAction;\n    exports.registerCoordinateSystem = registerCoordinateSystem;\n    exports.registerLayout = registerLayout;\n    exports.registerLoading = registerLoading;\n    exports.registerLocale = registerLocale;\n    exports.registerMap = registerMap;\n    exports.registerPostInit = registerPostInit;\n    exports.registerPostUpdate = registerPostUpdate;\n    exports.registerPreprocessor = registerPreprocessor;\n    exports.registerProcessor = registerProcessor;\n    exports.registerTheme = registerTheme;\n    exports.registerTransform = registerTransform;\n    exports.registerVisual = registerVisual;\n    exports.setCanvasCreator = setCanvasCreator;\n    exports.throttle = throttle;\n    exports.time = time;\n    exports.use = use;\n    exports.util = util$1;\n    exports.vector = vector;\n    exports.version = version$1;\n    exports.zrUtil = util;\n    exports.zrender = zrender;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=echarts.js.map\n"],"sourceRoot":"webpack:///"}